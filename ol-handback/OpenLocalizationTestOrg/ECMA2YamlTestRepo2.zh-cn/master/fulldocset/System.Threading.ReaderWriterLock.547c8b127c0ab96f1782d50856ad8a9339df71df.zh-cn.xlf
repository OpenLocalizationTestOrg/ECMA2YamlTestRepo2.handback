<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ec4eb6abc1cdf4de3aec918a6749eb637feb389</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.ReaderWriterLock.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa260b1ec5f3c114c5ac5367d66c001eda77b1ee</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc33aa4e80118dfe4cd1a4cad4ba16b2cf1248f7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines a lock that supports single writers and multiple readers.</source>
          <target state="translated">定义支持单个写线程和多个读取器的锁。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The <ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph> has two reader-writer locks, &lt;xref:System.Threading.ReaderWriterLockSlim&gt; and ReaderWriterLock.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>1&gt;<ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph>具有两个读取器 / 编写器锁，&lt;xref:System.Threading.ReaderWriterLockSlim&gt;和 ReaderWriterLock。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is recommended for all new development.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;建议对于所有新的开发。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;类似于 ReaderWriterLock，但它已简化为递归以及升级或降级锁定状态的规则。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; avoids many cases of potential deadlock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;可避免潜在的死锁的很多情况。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In addition, the performance of &lt;xref:System.Threading.ReaderWriterLockSlim&gt; is significantly better than ReaderWriterLock.</source>
          <target state="translated">此外的性能&lt;xref:System.Threading.ReaderWriterLockSlim&gt;明显优于 ReaderWriterLock。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ReaderWriterLock is used to synchronize access to a resource.</source>
          <target state="translated">ReaderWriterLock 用于对资源的访问进行同步。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</source>
          <target state="translated">在任何给定时间，它允许多个线程的并发读访问权限，或者单个线程的写访问权限。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In a situation where a resource is changed infrequently, a <ph id="ph1">`ReaderWriterLock`</ph> provides better throughput than a simple one-at-a-time lock, such as &lt;xref:System.Threading.Monitor&gt;.</source>
          <target state="translated">在资源中，很少更改的情况下<ph id="ph1">`ReaderWriterLock`</ph>提供比简单的一个每次锁定，例如&lt;xref:System.Threading.Monitor&gt;.&lt;/xref:System.Threading.Monitor&gt;更佳的吞吐量</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ReaderWriterLock`</ph> works best where most accesses are reads, while writes are infrequent and of short duration.</source>
          <target state="translated"><ph id="ph1">`ReaderWriterLock`</ph>最适用于大多数访问的读取，而写很少和短的持续时间。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</source>
          <target state="translated">多个读取器备用与单个编写器，以便读取器和编写器都不会阻止很长一段。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Holding reader locks or writer locks for long periods will starve other threads.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 为很长一段将阻止其他线程持有读取器锁或编写器锁。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For best performance, consider restructuring your application to minimize the duration of writes.</source>
          <target state="translated">为获得最佳性能，请考虑重新构建应用程序以最大程度减少写入的持续时间。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>A thread can hold a reader lock or a writer lock, but not both at the same time.</source>
          <target state="translated">锁定或编写器锁，但不是能同时在同一时间，线程可以持有一个读取器。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Instead of releasing a reader lock in order to acquire the writer lock, you can use &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;.</source>
          <target state="translated">而不是为了获取写线程锁释放读线程锁，你可以使用&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;和&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Recursive lock requests increase the lock count on a lock.</source>
          <target state="translated">递归锁请求增加锁的锁计数。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Readers and writers are queued separately.</source>
          <target state="translated">单独排队读取器和编写器。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</source>
          <target state="translated">当一个线程释放写线程锁时，队列中等待的读取器在该时刻的所有线程会都授予读取器锁;当所有这些读取器锁已发布，正在编写器中的线程等待下一个队列，如果任何，被授予写线程锁，等等。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In other words, <ph id="ph1">`ReaderWriterLock`</ph> alternates between a collection of readers, and one writer.</source>
          <target state="translated">换而言之，<ph id="ph1">`ReaderWriterLock`</ph>之间的读取器、 集合和一个编写器的替代项。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</source>
          <target state="translated">时编写器队列中的线程正在等待活动的读取者锁释放，请求新的读取器锁的线程会累积读取器队列中。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</source>
          <target state="translated">未授予他们的请求，即使它们无法与现有读线程锁拥有者; 共享的并发访问这可帮助保护对读取器的无限期阻滞进度的编写器。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Most methods for acquiring locks on a <ph id="ph1">`ReaderWriterLock`</ph> accept time-out values.</source>
          <target state="translated">上获取锁的大多数方法<ph id="ph1">`ReaderWriterLock`</ph>接受超时值。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Use time-outs to avoid deadlocks in your application.</source>
          <target state="translated">使用超时值以避免在你的应用程序的死锁。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</source>
          <target state="translated">例如，线程可能会获取对一个资源的编写器锁定，然后请求上第二个资源，则将读线程锁同时，另一个线程可能会获取写线程锁上第二个资源，并请求在第一天的读取器锁定。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Unless time-outs are used, the threads deadlock.</source>
          <target state="translated">如果不使用超时，线程死锁。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">如果在超时间隔过期，并且尚未授予锁请求，该方法通过引发&lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;给调用线程返回控件</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A thread can catch this exception and determine what action to take next.</source>
          <target state="translated">线程可以捕获此异常，并确定接下来要采取的操作。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Time-outs are expressed in milliseconds.</source>
          <target state="translated">超时以毫秒为单位表示。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you use a &lt;xref:System.TimeSpan?displayProperty=fullName&gt; to specify the time-out, the value used is the total number of whole milliseconds represented by the &lt;xref:System.TimeSpan&gt;.</source>
          <target state="translated">如果你使用的&lt;xref:System.TimeSpan?displayProperty=fullName&gt;指定超时，使用的值是表示&lt;xref:System.TimeSpan&gt;.&lt;/xref:System.TimeSpan&gt;的整毫秒的总数&lt;/xref:System.TimeSpan?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following table shows the valid time-out values in milliseconds.</source>
          <target state="translated">下表显示了有效的超时值以毫秒为单位。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>|Value|Description|   |-----------|-----------------|   |-1|The thread waits until the lock is acquired, regardless of how long it takes.</source>
          <target state="translated">|值 |说明 |  |-----------|-----------------|  | 为-1 |线程等待，直到已获取锁，而不考虑了多长时间。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For methods that specify integer time-outs, the constant &lt;xref:System.Threading.Timeout.Infinite&gt; can be used.|   |0|The thread does not wait to acquire the lock.</source>
          <target state="translated">对于指定整数超时的方法，可以使用常量&lt;xref:System.Threading.Timeout.Infinite&gt;。 |  |&amp;0; |线程不会等待获取锁。&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If the lock cannot be acquired immediately, the method returns.|   |&gt;0|The number of milliseconds to wait.|       With the exception of -1, negative time-out values are not allowed.</source>
          <target state="translated">如果不能立即获取锁，该方法返回。 |  |&amp;1;&gt;&amp;0; |等待的毫秒数。 |      除了-1，不允许负的超时值。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you specify a negative integer other than -1, a time-out value of zero is used instead.</source>
          <target state="translated">如果指定负整数而-1，则改用超时值为零。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a &lt;xref:System.TimeSpan&gt; that represents a negative number of milliseconds other than -1, &lt;xref:System.ArgumentOutOfRangeException&gt; is thrown.</source>
          <target state="translated">（也就是说，该方法返回而不等待，如果不能立即获取锁。）如果指定&lt;xref:System.TimeSpan&gt;表示负数，而-1 毫秒&lt;xref:System.ArgumentOutOfRangeException&gt;引发。&lt;/xref:System.ArgumentOutOfRangeException&gt; &lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>类。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">获取读线程锁定，请使用&lt;xref:System.Int32&gt;超时值。&lt;/xref:System.Int32&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>AcquireReaderLock blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">AcquireReaderLock 阻塞，如果另一个线程持有写线程锁，或如果至少一个线程正在等待编写器锁。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 如果当前线程已将写线程锁，没有读线程锁。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">相反，写线程锁上的锁计数即会递增。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">这会阻止线程阻止在其自己的编写器锁。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">结果应完全相同调用&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;，和对的其他调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;释放该编写器锁时需要。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>支持递归读线程锁请求。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">也就是说，线程可以调用 AcquireReaderLock 多次，递增每个时间的锁计数。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">必须调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;对于您每次调用一次<ph id="ph1">`AcquireReaderLock`</ph>。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">或者，可以调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;以减少锁计数为零立即。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">递归锁请求始终立即授予而无需将读取器队列中的请求的线程。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">使用递归锁时要格外小心，以避免阻止很长一段的编写器锁的请求。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有关有效的超时值，请参阅&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">以毫秒为单位的超时。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>在授予锁请求之前过期。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">获取读线程锁定，请使用&lt;xref:System.TimeSpan&gt;超时值。&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt; blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;如果另一个线程持有写线程锁，或至少一个线程正在等待编写器锁块。&lt;/xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 如果当前线程已将写线程锁，没有读线程锁。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">相反，写线程锁上的锁计数即会递增。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">这会阻止线程阻止在其自己的编写器锁。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">结果应完全相同调用&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;，和对的其他调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;释放该编写器锁时需要。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>支持递归读线程锁请求。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">也就是说，线程可以调用 AcquireReaderLock 多次，递增每个时间的锁计数。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">必须调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;对于您每次调用一次<ph id="ph1">`AcquireReaderLock`</ph>。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">或者，可以调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;以减少锁计数为零立即。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">递归锁请求始终立即授予而无需将读取器队列中的请求的线程。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">使用递归锁时要格外小心，以避免阻止很长一段的编写器锁的请求。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有关有效的超时值，请参阅&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated">A <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>指定超时时间。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>在授予锁请求之前过期。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>指定-1 毫秒以外的值为负。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">获取写线程锁定，请使用&lt;xref:System.Int32&gt;超时值。&lt;/xref:System.Int32&gt;</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">此方法将一直阻塞如果另一个线程具有读线程锁或写线程锁。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">方法的描述编写器锁备用项具有多个并发的读取器锁，请参阅&lt;xref:System.Threading.ReaderWriterLock&gt;类。&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">已将读线程锁的线程可以获取写线程锁在两种方式之一︰ 通过调用 AcquireWriterLock 之前, 释放读线程锁或通过调用&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">1&gt; <ph id="ph1">[!CAUTION]</ph>&amp;1;&gt; 如果线程调用<ph id="ph2">`AcquireWriterLock`</ph>虽然它仍有读线程锁，它将在其自己的读取器锁块; 如果指定无限期超时，则线程将发生死锁。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">若要避免这类死锁，使用&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;以确定当前线程是否已具有读线程锁。&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>支持递归写线程锁请求。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">也就是说，调用线程可以<ph id="ph1">`AcquireWriterLock`</ph>多次，该锁计数递增&amp;1; 每次。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">必须调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;对于您每次调用一次<ph id="ph1">`AcquireWriterLock`</ph>。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">或者，可以调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;以减少锁计数为零立即。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">递归锁请求始终立即授予而无需编写器队列中将请求的线程。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有关有效的超时值，请参阅&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">以毫秒为单位的超时。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>在授予锁请求之前过期。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">获取写线程锁定，请使用&lt;xref:System.TimeSpan&gt;超时值。&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">此方法将一直阻塞如果另一个线程具有读线程锁或写线程锁。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">方法的描述编写器锁备用项具有多个并发的读取器锁，请参阅&lt;xref:System.Threading.ReaderWriterLock&gt;类。&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">已将读线程锁的线程可以获取写线程锁在两种方式之一︰ 释放之前调用的读取器锁来&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;，或通过调用&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">1&gt; <ph id="ph1">[!CAUTION]</ph>&amp;1;&gt; 如果线程调用<ph id="ph2">`AcquireWriterLock`</ph>虽然它仍有读线程锁，它将在其自己的读取器锁块; 如果指定无限期超时，则线程将发生死锁。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">若要避免这类死锁，使用&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;以确定当前线程是否已具有读线程锁。&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>支持递归写线程锁请求。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">也就是说，调用线程可以<ph id="ph1">`AcquireWriterLock`</ph>多次，该锁计数递增&amp;1; 每次。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">必须调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;对于您每次调用一次<ph id="ph1">`AcquireWriterLock`</ph>。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">或者，可以调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;以减少锁计数为零立即。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">递归锁请求始终立即授予而无需编写器队列中将请求的线程。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有关有效的超时值，请参阅&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>指定超时时间。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>在授予锁请求之前过期。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>指定-1 毫秒以外的值为负。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</source>
          <target state="translated">指示由于获取序列号是否具有已将写线程锁授予某一线程。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You can use &lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt; and <ph id="ph1">`AnyWritersSince`</ph> to improve application performance.</source>
          <target state="translated">你可以使用&lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;和<ph id="ph1">`AnyWritersSince`</ph>改进应用程序性能。&lt;/xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">例如，一个线程可能缓存持有的读取器锁时，它获取的信息。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>After releasing and later reacquiring the lock, the thread can use <ph id="ph1">`AnyWritersSince`</ph> to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</source>
          <target state="translated">释放并在先锁之后, 该线程可以使用<ph id="ph1">`AnyWritersSince`</ph>以决定是否其他有线程写入资源在此期间; 如果没有，可以使用缓存的信息。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">此方法很有用，读取由锁保护的信息将占用大量资源;例如，运行数据库查询。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">调用方必须顺序的序列号，才能将读线程锁或编写器锁持有。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The sequence number.</source>
          <target state="translated">序列号中。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果将写线程锁授予某一线程由于获取序列号;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt; was called.</source>
          <target state="translated">将线程的锁状态还原到之前&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;曾。&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>DowngradeFromWriterLock releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</source>
          <target state="translated">DowngradeFromWriterLock 释放写线程锁，而不考虑递归锁计数，并还原才能升级到编写器锁线程持有读线程锁。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The lock count on the reader lock is restored.</source>
          <target state="translated">将还原读线程锁上的锁计数。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph><ph id="ph2"> &gt;  </ph><ph id="ph3">`DowngradeFromWriterLock`</ph> accepts a &lt;xref:System.Threading.LockCookie&gt; obtained by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph> <ph id="ph2"> &gt;  </ph> <ph id="ph3">`DowngradeFromWriterLock`</ph>接受&lt;xref:System.Threading.LockCookie&gt;通过调用&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;获取&lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Do not use a <ph id="ph1">`LockCookie`</ph> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">不要使用<ph id="ph1">`LockCookie`</ph>返回&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</source>
          <target state="translated">线程不会阻止从写线程锁，降级时，即使其他线程在等待写线程锁，因为所有的读取器锁请求被授予权限时编写器锁被释放。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>返回&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">该线程没有写线程锁。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">地址<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept>是 null 指针。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">确保释放资源并在垃圾回收器回收时，并执行其他清理操作<bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The garbage collector calls Finalize when the current &lt;xref:System.Threading.ReaderWriterLock&gt; object is ready to be finalized.</source>
          <target state="translated">垃圾回收器调用完成时当前&lt;xref:System.Threading.ReaderWriterLock&gt;对象已准备好完成。&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds a reader lock.</source>
          <target state="translated">获取一个值，该值指示当前线程是否持有读线程锁。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds a reader lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果当前线程持有读线程锁;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds the writer lock.</source>
          <target state="translated">获取一个值，该值指示当前线程是否持有写线程锁。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds the writer lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果当前线程持有写线程锁;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Releases the lock, regardless of the number of times the thread acquired the lock.</source>
          <target state="translated">释放锁，不管线程获取锁的次数。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count.</source>
          <target state="translated">ReleaseLock 释放读线程锁或写线程锁，而不考虑递归锁计数。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>To restore the state of the lock, including the lock count, pass the &lt;xref:System.Threading.LockCookie&gt; to &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">要还原的锁，包括锁计数，状态将传递&lt;xref:System.Threading.LockCookie&gt;到&lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt; &lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value representing the released lock.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>值，该值表示释放的锁。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Decrements the lock count.</source>
          <target state="translated">减少锁计数。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>ReleaseReaderLock decrements the lock count.</source>
          <target state="translated">ReleaseReaderLock 减少锁计数。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>When the count reaches zero, the lock is released.</source>
          <target state="translated">在计数变为零时，被释放锁。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has the writer lock, calling <ph id="ph2">`ReleaseReaderLock`</ph> has the same effect as calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 如果线程持有写线程锁，则调用<ph id="ph2">`ReleaseReaderLock`</ph>具有与调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;相同的效果</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If a thread has no locks, calling <ph id="ph1">`ReleaseReaderLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">如果线程已无锁，则调用<ph id="ph1">`ReleaseReaderLock`</ph>引发&lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The thread does not have any reader or writer locks.</source>
          <target state="translated">线程不具有任何读取器或编写器锁。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Decrements the lock count on the writer lock.</source>
          <target state="translated">减少写线程锁上的锁计数。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>ReleaseWriterLock decrements the writer lock count.</source>
          <target state="translated">ReleaseWriterLock 减少写线程锁计数。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When the count reaches zero, the writer lock is released.</source>
          <target state="translated">当计数达到零时，将写线程锁被释放。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has a reader lock, or no locks, calling <ph id="ph2">`ReleaseWriterLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 如果线程持有读线程锁或没有锁，则调用<ph id="ph2">`ReleaseWriterLock`</ph>引发&lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">该线程没有写线程锁。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">将线程的锁状态还原到之前调用&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The state restored by <ph id="ph1">`RestoreLock`</ph> includes the recursive lock count.</source>
          <target state="translated">还原的状态<ph id="ph1">`RestoreLock`</ph>包括递归锁计数。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</source>
          <target state="translated">如果它尝试还原读线程锁，另一个线程获取写线程锁之后, 或如果它尝试还原将写线程锁后获取另一个线程的读取器锁或编写器锁线程将阻止。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`RestoreLock`</ph> does not accept a time-out, you should take care to avoid possible deadlocks.</source>
          <target state="translated">因为<ph id="ph1">`RestoreLock`</ph>不接受超时，您需要采取措施以避免可能出现死锁。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Before calling <ph id="ph2">`RestoreLock`</ph>, make sure you have released all locks acquired since the call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">1&gt; <ph id="ph1">[!CAUTION]</ph>&amp;1;&gt; 之前调用<ph id="ph2">`RestoreLock`</ph>，请确保已发布到&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;在调用中获取的所有锁</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</source>
          <target state="translated">例如，线程死锁，就获取读线程锁，，然后尝试还原的更早版本的编写器锁。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; to detect such additional locks.</source>
          <target state="translated">使用&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;和&lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt;来检测此类额外的锁。&lt;/xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Do not use a &lt;xref:System.Threading.LockCookie&gt; returned from &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">不要使用&lt;xref:System.Threading.LockCookie&gt;从&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;返回&lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>返回&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">地址<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept>是 null 指针。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using an <bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">将读取器锁升级到编写器锁，使用<bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>超时值。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">当线程调用<ph id="ph1">`UpgradeToWriterLock`</ph>释放读线程锁，而不考虑的锁计数，和线程将转到编写器锁队列的末尾。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">因此，其他线程可能会写入之前请求升级被授予写线程锁的线程资源。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock.</source>
          <target state="translated">1&gt; <ph id="ph1">[!IMPORTANT]</ph>&amp;1;&gt; 直到调用 UpgradeToWriterLock 方法的线程可以重新获取读线程锁，不会引发超时异常。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">如果没有其他线程等待编写器锁，这将立即发生。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>However, if another thread is queued for the writer lock, the thread that called the UpgradeToWriterLock method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">但是，如果另一个线程将排队，等待将写线程锁，调用 UpgradeToWriterLock 方法的线程不能重新获取读线程锁之前所有的当前读取器已释放其持有的锁，和一个线程已获取并释放写线程锁。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the UpgradeToWriterLock method.</source>
          <target state="translated">即使另一个线程请求的编写器锁请求它在当前线程调用 UpgradeToWriterLock 方法后也是如此。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">若要还原的锁定状态，调用&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;使用&lt;xref:System.Threading.LockCookie&gt;返回<ph id="ph1">`UpgradeToWriterLock`</ph>。&lt;/xref:System.Threading.LockCookie&gt; &lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">不使用此<ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">当线程必须没有读线程锁时，不要使用<ph id="ph1">`UpgradeToWriterLock`</ph>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">使用&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;相反。&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有关有效的超时值，请参阅&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">以毫秒为单位的超时。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>在授予锁请求之前过期。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using a <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">将读取器锁升级到编写器锁，使用<bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>超时值。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">当线程调用<ph id="ph1">`UpgradeToWriterLock`</ph>释放读线程锁，而不考虑的锁计数，和线程将转到编写器锁队列的末尾。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">因此，其他线程可能会写入之前请求升级被授予写线程锁的线程资源。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method can reacquire the reader lock.</source>
          <target state="translated">1&gt; <ph id="ph1">[!IMPORTANT]</ph>&amp;1;&gt; 之前调用的线程不会引发超时异常&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;方法可以重新获取读线程锁。&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">如果没有其他线程等待编写器锁，这将立即发生。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>However, if another thread is queued for the writer lock, the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">但是，如果另一个线程将排队，等待将写线程锁，该线程调用的函数&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;直到所有当前读取器已释放其持有的锁，和一个线程已获取并释放写线程锁，方法不能重新获取读线程锁。&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method.</source>
          <target state="translated">这是 true，即使另一个线程请求的编写器锁请求它后与当前线程调用&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;方法。&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">若要还原的锁定状态，调用&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;使用&lt;xref:System.Threading.LockCookie&gt;返回<ph id="ph1">`UpgradeToWriterLock`</ph>。&lt;/xref:System.Threading.LockCookie&gt; &lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">不使用此<ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">当线程必须没有读线程锁时，不要使用<ph id="ph1">`UpgradeToWriterLock`</ph>。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">使用&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;相反。&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有关有效的超时值，请参阅&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>指定超时时间。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>在授予锁请求之前过期。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>指定-1 毫秒以外的值为负。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Gets the current sequence number.</source>
          <target state="translated">获取当前序列号。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The sequence number increases whenever a thread acquires the writer lock.</source>
          <target state="translated">序列数目增加时线程获取写线程锁。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>You can save the sequence number and pass it to &lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt; at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</source>
          <target state="translated">你可以保存的序列号，并将其传递到&lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;在更高版本时，如果你想要确定其他线程是否已在此期间获取写线程锁。&lt;/xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`WriterSeqNum`</ph> to improve application performance.</source>
          <target state="translated">你可以使用<ph id="ph1">`WriterSeqNum`</ph>改进应用程序性能。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">例如，一个线程可能缓存持有的读取器锁时，它获取的信息。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling <ph id="ph1">`AnyWritersSince`</ph>; if not, the cached information can be used.</source>
          <target state="translated">在先锁再释放之后，线程可以确定其他线程具有对资源通过调用编写<ph id="ph1">`AnyWritersSince`</ph>; 如果没有，可以使用缓存的信息。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">此方法很有用，当读取由锁保护的信息将占用大量资源;例如，运行数据库查询。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">调用方必须顺序的序列号，才能将读线程锁或编写器锁持有。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The current sequence number.</source>
          <target state="translated">当前的序列号。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>