<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">875b4c44898cae512f08f519a38456c5814427a0</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.StackOverflowException.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">72d4a7c67673254490d2f2380c36fc92950871cf</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a2a773c3505724e59b782c1b78a9bea12abec17</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>The exception that is thrown when the execution stack overflows because it contains too many nested method calls.</source>
          <target state="translated">因为它包含嵌套的方法调用过多而导致执行堆栈溢出时引发的异常。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This class cannot be inherited.</source>
          <target state="translated">此类不能被继承。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>StackOverflowException is thrown for execution stack overflow errors, typically in case of a very deep or unbounded recursion.</source>
          <target state="translated">StackOverflowException 执行堆栈溢出发生错误时引发，通常发生非常深度或无限递归。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>StackOverflowException uses the HRESULT COR_E_STACKOVERFLOW, which has the value 0x800703E9.</source>
          <target state="translated">StackOverflowException 使用 HRESULT COR_E_STACKOVERFLOW，其值 0x800703E9。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Reflection.Emit.OpCodes.Localloc&gt; intermediate language (IL) instruction throws StackOverflowException.</source>
          <target state="translated">&lt;xref:System.Reflection.Emit.OpCodes.Localloc&gt;中间语言 (IL) 指令将引发 StackOverflowException。&lt;/xref:System.Reflection.Emit.OpCodes.Localloc&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For a list of initial property values for a StackOverflowException object, see the &lt;xref:System.StackOverflowException.%23ctor%2A&gt; constructors.</source>
          <target state="translated">StackOverflowException 对象的初始属性值的列表，请参阅&lt;xref:System.StackOverflowException.%23ctor%2A&gt;构造函数。&lt;/xref:System.StackOverflowException.%23ctor%2A&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Version Considerations    In the .NET Framework 1.0 and 1.1, you could catch a StackOverflowException object (for example, to recover from unbounded recursion).</source>
          <target state="translated">.NET Framework 1.0 和 1.1 版中的版本注意事项，你无法捕获 StackOverflowException 对象 （例如，若要从此不受限制的递归）。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Starting with the .NET Framework 2.0, you can’t catch a StackOverflowException object with a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block, and the corresponding process is terminated by default.</source>
          <target state="translated">从.NET Framework 2.0 开始，你无法捕获具有的 StackOverflowException 对象<ph id="ph1">`try`</ph> <ph id="ph2">/</ph> <ph id="ph3">`catch`</ph>块，并且相应的进程默认情况下将会终止。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Consequently, you should write your code to detect and prevent a stack overflow.</source>
          <target state="translated">因此，应编写代码来检测和防止堆栈溢出。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For example, if your app depends on recursion, use a counter or a state condition to terminate the recursive loop.</source>
          <target state="translated">例如，如果你的应用程序依赖于递归，用于计数器或状态条件终止递归循环。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The following example uses a counter to ensure that the number of recursive calls to the <ph id="ph1">`Execute`</ph> method do not exceed a maximum defined by the MAX_RECURSIVE_CALLS constant.</source>
          <target state="translated">下面的示例使用计数器以确保递归数调用<ph id="ph1">`Execute`</ph>方法不能超过最多由 MAX_RECURSIVE_CALLS 常量定义。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.StackOverflowException.Class#1<ept id="p2">](~/add/codesnippet/visualbasic/t-system.stackoverflowex_1.vb)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>System.StackOverflowException.Class#1<ept id="p4">](~/add/codesnippet/csharp/t-system.stackoverflowex_1.cs)</ept><ept id="p3">]</ept><ph id="ph1">      &gt; </ph><ph id="ph2">[!NOTE]</ph> &gt;  Applying the &lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt; attribute to a method that throws a StackOverflowException has no effect.</source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.StackOverflowException.Class#1<ept id="p2">](~/add/codesnippet/visualbasic/t-system.stackoverflowex_1.vb)</ept><ept id="p1">]</ept><bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>System.StackOverflowException.Class#1<ept id="p4">](~/add/codesnippet/csharp/t-system.stackoverflowex_1.cs)</ept> <ept id="p3">]</ept> <ph id="ph1">      &gt; </ph> <ph id="ph2">[!NOTE]</ph>&amp;1;&gt; 应用&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;引发 StackOverflowException 的方法的特性没有任何影响。&lt;/xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;  </target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You still cannot handle the exception from user code.</source>
          <target state="translated">仍然无法处理从用户代码的异常。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If your app hosts the common language runtime (CLR), it can specify that the CLR should unload the application domain where the stack overflow exception occurs and let the corresponding process continue.</source>
          <target state="translated">如果你的应用程序承载公共语言运行时 (CLR)，它可以指定 CLR 应卸载应用程序域，堆栈溢出异常时发生，并让相应的进程继续。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>ICLRPolicyManager Interface<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>ICLRPolicyManager 接口<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.StackOverflowException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, setting the &lt;xref:System.Exception.Message*&gt; property of the new instance to a system-supplied message that describes the error, such as "The requested operation caused a stack overflow."</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.StackOverflowException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>类，设置&lt;xref:System.Exception.Message*&gt;为系统提供的消息描述该错误，如"请求的操作导致堆栈溢出。"的新实例的属性&lt;/xref:System.Exception.Message*&gt;</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This message takes into account the current system culture.</source>
          <target state="translated">此消息将当前系统区域性考虑在内。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following table shows the initial property values for an instance of &lt;xref:System.StackOverflowException&gt;.</source>
          <target state="translated">下表显示&lt;xref:System.StackOverflowException&gt;.&lt;/xref:System.StackOverflowException&gt;实例的初始属性的值</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>|Property|Value|   |--------------|-----------|   |&lt;xref:System.Exception.InnerException%2A&gt;|<ph id="ph1">`null`</ph>.|   |&lt;xref:System.Exception.Message%2A&gt;|The localized error message string.|</source>
          <target state="translated">|属性 |值 |  |--------------|-----------|  |&lt;xref:System.Exception.InnerException%2A&gt;|<ph id="ph1">`null`</ph>.|  |&lt;xref:System.Exception.Message%2A&gt;|本地化的错误消息字符串。 |&lt;/xref:System.Exception.Message%2A&gt; &lt;/xref:System.Exception.InnerException%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.StackOverflowException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified error message.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.StackOverflowException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>与指定的错误消息的类。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following table shows the initial property values for an instance of &lt;xref:System.StackOverflowException&gt;.</source>
          <target state="translated">下表显示&lt;xref:System.StackOverflowException&gt;.&lt;/xref:System.StackOverflowException&gt;实例的初始属性的值</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>|Property|Value|   |--------------|-----------|   |&lt;xref:System.Exception.InnerException%2A&gt;|A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).|   |&lt;xref:System.Exception.Message%2A&gt;|The error message string.|</source>
          <target state="translated">|属性 |值 |  |--------------|-----------|  |&lt;xref:System.Exception.InnerException%2A&gt;|空引用 (<ph id="ph1">`Nothing`</ph>在 Visual Basic 中)。 |  |&lt;xref:System.Exception.Message%2A&gt;|错误消息字符串。 |&lt;/xref:System.Exception.Message%2A&gt; &lt;/xref:System.Exception.InnerException%2A&gt;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.String&gt; that describes the error.</source>
          <target state="translated">A&lt;xref:System.String&gt;描述该错误。&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The content of message is intended to be understood by humans.</source>
          <target state="translated">消息的内容但应为人所理解。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The caller of this constructor is required to ensure that this string has been localized for the current system culture.</source>
          <target state="translated">此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.StackOverflowException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified error message and a reference to the inner exception that is the cause of this exception.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.StackOverflowException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>使用指定的错误消息和对导致此异常的内部异常的引用的类。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>An exception that is thrown as a direct result of a previous exception can include a reference to the previous exception in the &lt;xref:System.Exception.InnerException%2A&gt; property.</source>
          <target state="translated">前一个异常的直接结果可以包含的引用中的前一个异常引发的异常，&lt;xref:System.Exception.InnerException%2A&gt;属性。&lt;/xref:System.Exception.InnerException%2A&gt;</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Exception.InnerException%2A&gt; property returns the same value that is passed into the constructor, or a null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic) if the &lt;xref:System.Exception.InnerException%2A&gt; property does not supply the inner exception value to the constructor.</source>
          <target state="translated">&lt;xref:System.Exception.InnerException%2A&gt;属性返回相同的值传递到构造函数中，则为空引用 (<ph id="ph1">`Nothing`</ph>在 Visual Basic 中) 如果&lt;xref:System.Exception.InnerException%2A&gt;属性不会提供给构造函数的内部异常值。&lt;/xref:System.Exception.InnerException%2A&gt; &lt;/xref:System.Exception.InnerException%2A&gt;</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following table shows the initial property values for an instance of &lt;xref:System.StackOverflowException&gt;.</source>
          <target state="translated">下表显示&lt;xref:System.StackOverflowException&gt;.&lt;/xref:System.StackOverflowException&gt;实例的初始属性的值</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>|Property|Value|   |--------------|-----------|   |&lt;xref:System.Exception.InnerException%2A&gt;|The inner exception reference.|   |&lt;xref:System.Exception.Message%2A&gt;|The error message string.|</source>
          <target state="translated">|属性 |值 |  |--------------|-----------|  |&lt;xref:System.Exception.InnerException%2A&gt;|内部异常引用。 |  |&lt;xref:System.Exception.Message%2A&gt;|错误消息字符串。 |&lt;/xref:System.Exception.Message%2A&gt; &lt;/xref:System.Exception.InnerException%2A&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The error message that explains the reason for the exception.</source>
          <target state="translated">解释异常原因的错误消息。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The exception that is the cause of the current exception.</source>
          <target state="translated">导致当前异常的异常。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`innerException`</ph> parameter is not a null reference (<bpt id="p1">&lt;xref uid="langword_csharp_Nothing" name="Nothing" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in Visual Basic), the current exception is raised in a <bpt id="p2">&lt;xref uid="langword_csharp_catch" name="catch" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> block that handles the inner exception.</source>
          <target state="translated">如果<ph id="ph1">`innerException`</ph>参数不是 null 引用 (<bpt id="p1">&lt;xref uid="langword_csharp_Nothing" name="Nothing" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>在 Visual Basic 中) 中, 引发当前异常<bpt id="p2">&lt;xref uid="langword_csharp_catch" name="catch" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>处理内部异常的块。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>