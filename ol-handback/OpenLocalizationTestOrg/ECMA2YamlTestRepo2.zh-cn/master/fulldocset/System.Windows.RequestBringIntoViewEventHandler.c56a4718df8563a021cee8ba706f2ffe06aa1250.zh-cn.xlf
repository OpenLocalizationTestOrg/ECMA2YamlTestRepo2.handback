<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">090ebe53f727be99a100b9af773bb82108c2964a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.RequestBringIntoViewEventHandler.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">146702ede9be5f78d82f7591bf67735bc53b4f08</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bc516054c8f11ef86c766b5d8deb2ae53815760f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents the method that will handle the <bpt id="p1">&lt;xref href="System.Windows.FrameworkElement.RequestBringIntoView"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> routed event.</source>
          <target state="translated">表示将处理的方法<bpt id="p1">&lt;xref href="System.Windows.FrameworkElement.RequestBringIntoView"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>路由的事件。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</source>
          <target state="translated">处理此事件通常仅完成的支持的可滚动区域，或通过其他有意设置其呈现大小小于所需大小总和其子元素内容，元素中，并且仅可通过有意处理事件后它在元素树向上路由，并且已达到提供滚动区域支持的第一个父级。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is &lt;xref:System.Windows.Controls.ScrollViewer&gt;.</source>
          <target state="translated">处理方式是通常需要为用户控件的滚动区域的现有实现为&lt;xref:System.Windows.Controls.ScrollViewer&gt;。&lt;/xref:System.Windows.Controls.ScrollViewer&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>If you derive from &lt;xref:System.Windows.Controls.ScrollViewer&gt;, you can register a class handler for &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; and supplement the base class handling of the event.</source>
          <target state="translated">如果派生自&lt;xref:System.Windows.Controls.ScrollViewer&gt;，你可以注册的类处理程序&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;和补充的事件的基的类处理。&lt;/xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; &lt;/xref:System.Windows.Controls.ScrollViewer&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You should also consider using or class-handling the class-defined &lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt; event instead of &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;.</source>
          <target state="translated">你还应考虑使用或类处理类定义的&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;事件而不是&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;。&lt;/xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; &lt;/xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Alternatively, if you create an entirely custom class that does not derive from &lt;xref:System.Windows.Controls.ScrollViewer&gt;, you can still add class handling by calling &lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=fullName&gt; in your class instantiation.</source>
          <target state="translated">或者，如果您创建不是派生自一个完全自定义类&lt;xref:System.Windows.Controls.ScrollViewer&gt;，仍然可以将项目添加类处理通过调用&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=fullName&gt;中的类实例化。&lt;/xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=fullName&gt; &lt;/xref:System.Windows.Controls.ScrollViewer&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For details on class handling, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关类处理的详细信息，请参阅<bpt id="p1">[</bpt>标记作为 Handled，和类处理的路由事件<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Content elements can cause the event to be raised by their content hosts (through calling &lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt; and raising &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; from the content host).</source>
          <target state="translated">内容元素可能会导致该事件引发由内容主机 (通过调用&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;和引发&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;来自内容主机)。&lt;/xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; &lt;/xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Similarly, you can request logical tree elements to be brought into view with the helper method &lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">同样，你可以在其中请求要使用的帮助器方法&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=fullName&gt;.&lt;/xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=fullName&gt;放入视图的逻辑树元素</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Windows.Controls.ListBox&gt; implements a related but different method &lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;.</source>
          <target state="translated">的&lt;xref:System.Windows.Controls.ListBox&gt;实现相关但不同的方法&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;.&lt;/xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt; &lt;/xref:System.Windows.Controls.ListBox&gt;</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>