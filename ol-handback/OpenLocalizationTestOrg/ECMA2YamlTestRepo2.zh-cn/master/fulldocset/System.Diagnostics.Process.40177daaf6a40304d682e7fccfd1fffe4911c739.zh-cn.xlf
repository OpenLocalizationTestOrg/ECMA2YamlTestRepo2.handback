<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8c11756717e56d564d1de0ee42bda991978235c1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Diagnostics.Process.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">85f95f3fb09d2d38dd2b7610c4c4c51198cb3d22</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7c03c88f161228add9889b271f663fc35a0bffd9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides access to local and remote processes and enables you to start and stop local system processes.</source>
          <target state="translated">提供对本地和远程进程的访问，并使你能够启动和停止本地系统进程。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>To browse the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)</ept>.</source>
          <target state="translated">若要浏览此类型的.NET Framework 源代码，请参阅<bpt id="p1">[</bpt>引用源<ept id="p1">](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)</ept>。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>类。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;xref:System.Diagnostics.Process.MachineName%2A&gt; property, the default is the local computer, (".").</source>
          <target state="translated">如果不指定&lt;xref:System.Diagnostics.Process.MachineName%2A&gt;属性，则默认为本地计算机 ("。")。&lt;/xref:System.Diagnostics.Process.MachineName%2A&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You have two options for associating a new &lt;xref:System.Diagnostics.Process&gt; component with a process on the computer.</source>
          <target state="translated">你有两个选项可用于将新&lt;xref:System.Diagnostics.Process&gt;组件与计算机上的进程。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The first option is to use the constructor to create the &lt;xref:System.Diagnostics.Process&gt; component, set the appropriate members of the &lt;xref:System.Diagnostics.Process.StartInfo%2A&gt; property and call &lt;xref:System.Diagnostics.Process.Start%2A&gt; to associate the &lt;xref:System.Diagnostics.Process&gt; with a new system process.</source>
          <target state="translated">第一个选项是使用构造函数来创建&lt;xref:System.Diagnostics.Process&gt;组件，设置的相应成员&lt;xref:System.Diagnostics.Process.StartInfo%2A&gt;属性并调用&lt;xref:System.Diagnostics.Process.Start%2A&gt;关联&lt;xref:System.Diagnostics.Process&gt;使用新的系统进程。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Start%2A&gt; &lt;/xref:System.Diagnostics.Process.StartInfo%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The second option is to associate the &lt;xref:System.Diagnostics.Process&gt; with a running system process by using &lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt; or one of the &lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt; return values.</source>
          <target state="translated">第二个选项是将关联&lt;xref:System.Diagnostics.Process&gt;与正在运行的系统进程，使用&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;或之一&lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt;返回值。&lt;/xref:System.Diagnostics.Process.GetProcesses%2A&gt; &lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you use a <ph id="ph1">`static`</ph> overload of the &lt;xref:System.Diagnostics.Process.Start%2A&gt; method to start a new system process, the method creates a new &lt;xref:System.Diagnostics.Process&gt; component and associates it with the process.</source>
          <target state="translated">如果你使用<ph id="ph1">`static`</ph>重载&lt;xref:System.Diagnostics.Process.Start%2A&gt;方法来启动一个新的系统进程，该方法创建一个新&lt;xref:System.Diagnostics.Process&gt;组件并将它与进程相关联。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>When the &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; property is set to its default value, <ph id="ph1">`true`</ph>, you can start applications and documents in a way that is similar to using the <ph id="ph2">`Run`</ph> dialog box of the Windows <ph id="ph3">`Start`</ph> menu.</source>
          <target state="translated">当&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;属性设置为其默认值， <ph id="ph1">`true`</ph>，您可以在类似于使用一种方法启动应用程序和文档<ph id="ph2">`Run`</ph>对话框中的 windows<ph id="ph3">`Start`</ph>菜单。&lt;/xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is <ph id="ph1">`false`</ph>, you can start only executables.</source>
          <target state="translated">当&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;是<ph id="ph1">`false`</ph>，你可以开始仅可执行文件。&lt;/xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Any executable file that you can call from the command line can be started in one of two ways: by setting the appropriate members of the &lt;xref:System.Diagnostics.Process.StartInfo%2A&gt; property and calling the &lt;xref:System.Diagnostics.Process.Start%2A&gt; method with no parameters, or by passing the appropriate parameter to the <ph id="ph1">`static`</ph>&lt;xref:System.Diagnostics.Process.Start%2A&gt; member.</source>
          <target state="translated">可以在两种方式之一中启动，可以从命令行调用任何可执行文件︰ 通过设置的相应成员&lt;xref:System.Diagnostics.Process.StartInfo%2A&gt;属性和调用&lt;xref:System.Diagnostics.Process.Start%2A&gt;方法提供任何参数，或通过将传递到适当的参数<ph id="ph1">`static`</ph>&lt;xref:System.Diagnostics.Process.Start%2A&gt;成员。&lt;/xref:System.Diagnostics.Process.Start%2A&gt; &lt;/xref:System.Diagnostics.Process.Start%2A&gt; &lt;/xref:System.Diagnostics.Process.StartInfo%2A&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can create a &lt;xref:System.Diagnostics.Process&gt; component by using the constructor, one of the static &lt;xref:System.Diagnostics.Process.Start%2A&gt; overloads, or any of the &lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;, &lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt;, or &lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; methods.</source>
          <target state="translated">你可以创建&lt;xref:System.Diagnostics.Process&gt;组件通过使用构造函数中，一个静态&lt;xref:System.Diagnostics.Process.Start%2A&gt;重载，或任何&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;， &lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt;，或&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;方法。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; &lt;/xref:System.Diagnostics.Process.GetProcesses%2A&gt; &lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt; &lt;/xref:System.Diagnostics.Process.Start%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>After you have done so, you have a view into the associated process.</source>
          <target state="translated">你这样做之后，必须为关联进程的视图。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This is not a dynamic view that updates itself automatically when the process properties have changed in memory.</source>
          <target state="translated">这不会自动更新自身，当进程属性更改在内存中的动态视图。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Instead, you must call &lt;xref:System.Diagnostics.Process.Refresh%2A&gt; for the component to update the &lt;xref:System.Diagnostics.Process&gt; property information in your application.</source>
          <target state="translated">相反，您必须调用&lt;xref:System.Diagnostics.Process.Refresh%2A&gt;以更新组件的&lt;xref:System.Diagnostics.Process&gt;应用程序中的属性信息。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Refresh%2A&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Gets the base priority of the associated process.</source>
          <target state="translated">获取关联进程的基本优先级。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The BasePriority of the process is the starting priority for threads created within the associated process.</source>
          <target state="translated">进程的 BasePriority 是关联的进程内创建的线程的起始优先级。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can view information about the base priority through the System Monitor's Priority Base counter.</source>
          <target state="translated">你可以查看通过系统监视器的优先级基数计数器的基本优先级有关的信息。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Based on the time elapsed or other boosts, the operating system can change the base priority when a process should be placed ahead of others.</source>
          <target state="translated">基于的时间应早其他放置过程时，运行时间或其他提升，操作系统可以更改的基本优先级。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The BasePriority property lets you view the starting priority assigned to a process.</source>
          <target state="translated">BasePriority 属性，允许您查看分配给过程的起始优先级。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>However, because it is read-only, you cannot use the BasePriority to set the priority of the process.</source>
          <target state="translated">但是，因为它是只读的不能使用 BasePriority 设置进程的优先级。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>To change the priority, use the &lt;xref:System.Diagnostics.Process.PriorityClass%2A&gt; property.</source>
          <target state="translated">若要更改的优先级，使用&lt;xref:System.Diagnostics.Process.PriorityClass%2A&gt;属性。&lt;/xref:System.Diagnostics.Process.PriorityClass%2A&gt;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The BasePriority is viewable using the System Monitor, while the &lt;xref:System.Diagnostics.Process.PriorityClass%2A&gt; is not.</source>
          <target state="translated">BasePriority 是可查看使用系统监视器，而&lt;xref:System.Diagnostics.Process.PriorityClass%2A&gt;不是。&lt;/xref:System.Diagnostics.Process.PriorityClass%2A&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Both the BasePriority and the &lt;xref:System.Diagnostics.Process.PriorityClass%2A&gt; can be viewed programmatically.</source>
          <target state="translated">这两个 BasePriority 和&lt;xref:System.Diagnostics.Process.PriorityClass%2A&gt;可以以编程方式查看。&lt;/xref:System.Diagnostics.Process.PriorityClass%2A&gt;</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following table shows the relationship between BasePriority values and &lt;xref:System.Diagnostics.Process.PriorityClass%2A&gt; values.</source>
          <target state="translated">下表显示 BasePriority 值之间的关系和&lt;xref:System.Diagnostics.Process.PriorityClass%2A&gt;值。&lt;/xref:System.Diagnostics.Process.PriorityClass%2A&gt;</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>|BasePriority|PriorityClass|   |------------------|-------------------|   |4|&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|   |8|&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|   |13|&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|   |24|&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|</source>
          <target state="translated">|BasePriority |PriorityClass |  |------------------|-------------------|  |&amp;4; |&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|  |&amp;8; |&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|  |&amp;13; |&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|  |&amp;24; |&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The base priority, which is computed from the &lt;xref:System.Diagnostics.Process.PriorityClass*&gt; of the associated process.</source>
          <target state="translated">基本优先级，从计算&lt;xref:System.Diagnostics.Process.PriorityClass*&gt;关联进程。&lt;/xref:System.Diagnostics.Process.PriorityClass*&gt;</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> property to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>属性<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The process has exited.</source>
          <target state="translated">该进程已退出。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-or-       The process has not started, so there is no process ID.</source>
          <target state="translated">-或者-尚未启动进程，因此没有进程 id。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Begins asynchronous read operations on the redirected &lt;xref:System.Diagnostics.Process.StandardError*&gt; stream of the application.</source>
          <target state="translated">上开始进行异步读取的操作的重定向&lt;xref:System.Diagnostics.Process.StandardError*&gt;应用程序流。&lt;/xref:System.Diagnostics.Process.StandardError*&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream can be read synchronously or asynchronously.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;可以读取流，同步或异步。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Methods such as &lt;xref:System.IO.StreamReader.Read%2A&gt;, &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;, and &lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt; perform synchronous read operations on the error output stream of the process.</source>
          <target state="translated">等方法&lt;xref:System.IO.StreamReader.Read%2A&gt;， &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;，和&lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt;同步对执行读取的操作的错误输出流的过程。&lt;/xref:System.IO.StreamReader.ReadToEnd%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.IO.StreamReader.Read%2A&gt;</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>These synchronous read operations do not complete until the associated &lt;xref:System.Diagnostics.Process&gt; writes to its &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream, or closes the stream.</source>
          <target state="translated">这些同步读取操作不会完成之前关联&lt;xref:System.Diagnostics.Process&gt;写入其&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流处理时，或关闭流。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In contrast, BeginErrorReadLine starts asynchronous read operations on the &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream.</source>
          <target state="translated">与此相反，BeginErrorReadLine 开始异步读取操作上&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This method enables the designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</source>
          <target state="translated">此方法启用的指定的事件处理程序输出进行流式处理，并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Follow these steps to perform asynchronous read operations on &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; for a &lt;xref:System.Diagnostics.Process&gt; :      1.</source>
          <target state="translated">按照这些步骤上执行异步读取的操作&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;为&lt;xref:System.Diagnostics.Process&gt;: 1。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Set &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A&gt; to <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Set &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A&gt; to <ph id="ph1">`false`</ph>.&lt;/xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>2.</source>
          <target state="translated">2.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Set &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A&gt; to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Set &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A&gt; to <ph id="ph1">`true`</ph>.&lt;/xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>3.</source>
          <target state="translated">3.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Add your event handler to the &lt;xref:System.Diagnostics.Process.ErrorDataReceived&gt; event.</source>
          <target state="translated">添加到事件处理程序&lt;xref:System.Diagnostics.Process.ErrorDataReceived&gt;事件。&lt;/xref:System.Diagnostics.Process.ErrorDataReceived&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The event handler must match the &lt;xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName&gt; delegate signature.</source>
          <target state="translated">事件处理程序必须与匹配&lt;xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName&gt;委托签名。&lt;/xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>4.</source>
          <target state="translated">4.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Start the &lt;xref:System.Diagnostics.Process&gt;.</source>
          <target state="translated">启动&lt;xref:System.Diagnostics.Process&gt;。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>5.</source>
          <target state="translated">5.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Call BeginErrorReadLine for the &lt;xref:System.Diagnostics.Process&gt;.</source>
          <target state="translated">调用 BeginErrorReadLine &lt;xref:System.Diagnostics.Process&gt;。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This call starts asynchronous read operations on &lt;xref:System.Diagnostics.Process.StandardError%2A&gt;.</source>
          <target state="translated">此调用会启动异步读取的操作的时间为&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>When asynchronous read operations start, the event handler is called each time the associated &lt;xref:System.Diagnostics.Process&gt; writes a line of text to its &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream.</source>
          <target state="translated">调用异步读取的操作开始时，事件处理程序时每次关联&lt;xref:System.Diagnostics.Process&gt;写入到的文本行其&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can cancel an asynchronous read operation by calling &lt;xref:System.Diagnostics.Process.CancelErrorRead%2A&gt;.</source>
          <target state="translated">你可以通过调用&lt;xref:System.Diagnostics.Process.CancelErrorRead%2A&gt;.&lt;/xref:System.Diagnostics.Process.CancelErrorRead%2A&gt;取消异步读的操作</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The read operation can be canceled by the caller or by the event handler.</source>
          <target state="translated">由调用方或事件处理程序，可以取消读取的操作。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>After canceling, you can call BeginErrorReadLine again to resume asynchronous read operations.</source>
          <target state="translated">取消之后，你可以调用 BeginErrorReadLine 再次继续异步读取的操作。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  You cannot mix asynchronous and synchronous read operations on a redirected stream.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 不能混合使用重定向流上的异步和同步读取的操作。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Once the redirected stream of a &lt;xref:System.Diagnostics.Process&gt; is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</source>
          <target state="translated">一次的重定向的流&lt;xref:System.Diagnostics.Process&gt;打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For example, do not follow BeginErrorReadLine with a call to &lt;xref:System.IO.StreamReader.ReadLine%2A&gt; on the &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream, or vice versa.</source>
          <target state="translated">例如，不要通过调用遵循 BeginErrorReadLine&lt;xref:System.IO.StreamReader.ReadLine%2A&gt;上&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流，反之亦然。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>However, you can read two different streams in different modes.</source>
          <target state="translated">但是，你可以读取在不同模式下的两个不同的流。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For example, you can call BeginErrorReadLine and then call &lt;xref:System.IO.StreamReader.ReadLine%2A&gt; for the &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream.</source>
          <target state="translated">例如，你可以调用 BeginErrorReadLine，然后调用&lt;xref:System.IO.StreamReader.ReadLine%2A&gt;为&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Begins asynchronous read operations on the redirected &lt;xref:System.Diagnostics.Process.StandardOutput*&gt; stream of the application.</source>
          <target state="translated">上开始进行异步读取的操作的重定向&lt;xref:System.Diagnostics.Process.StandardOutput*&gt;应用程序流。&lt;/xref:System.Diagnostics.Process.StandardOutput*&gt;</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream can be read synchronously or asynchronously.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;可以读取流，同步或异步。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Methods such as &lt;xref:System.IO.StreamReader.Read%2A&gt;, &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;, and &lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt; perform synchronous read operations on the output stream of the process.</source>
          <target state="translated">等方法&lt;xref:System.IO.StreamReader.Read%2A&gt;， &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;，和&lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt;同步对执行读取的操作过程的输出流。&lt;/xref:System.IO.StreamReader.ReadToEnd%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.IO.StreamReader.Read%2A&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>These synchronous read operations do not complete until the associated &lt;xref:System.Diagnostics.Process&gt; writes to its &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream, or closes the stream.</source>
          <target state="translated">这些同步读取操作不会完成之前关联&lt;xref:System.Diagnostics.Process&gt;写入其&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流处理时，或关闭流。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In contrast, BeginOutputReadLine starts asynchronous read operations on the &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream.</source>
          <target state="translated">与此相反，BeginOutputReadLine 开始异步读取操作上&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</source>
          <target state="translated">此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Follow these steps to perform asynchronous read operations on &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; for a &lt;xref:System.Diagnostics.Process&gt; :      1.</source>
          <target state="translated">按照这些步骤上执行异步读取的操作&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;为&lt;xref:System.Diagnostics.Process&gt;: 1。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Set &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A&gt; to <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Set &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A&gt; to <ph id="ph1">`false`</ph>.&lt;/xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A&gt;</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>2.</source>
          <target state="translated">2.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Set &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A&gt; to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Set &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A&gt; to <ph id="ph1">`true`</ph>.&lt;/xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>3.</source>
          <target state="translated">3.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Add your event handler to the &lt;xref:System.Diagnostics.Process.OutputDataReceived&gt; event.</source>
          <target state="translated">添加到事件处理程序&lt;xref:System.Diagnostics.Process.OutputDataReceived&gt;事件。&lt;/xref:System.Diagnostics.Process.OutputDataReceived&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The event handler must match the &lt;xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName&gt; delegate signature.</source>
          <target state="translated">事件处理程序必须与匹配&lt;xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName&gt;委托签名。&lt;/xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>4.</source>
          <target state="translated">4.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Start the &lt;xref:System.Diagnostics.Process&gt;.</source>
          <target state="translated">启动&lt;xref:System.Diagnostics.Process&gt;。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>5.</source>
          <target state="translated">5.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Call BeginOutputReadLine for the &lt;xref:System.Diagnostics.Process&gt;.</source>
          <target state="translated">调用 BeginOutputReadLine &lt;xref:System.Diagnostics.Process&gt;。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This call starts asynchronous read operations on &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;.</source>
          <target state="translated">此调用会启动异步读取的操作的时间为&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When asynchronous read operations start, the event handler is called each time the associated &lt;xref:System.Diagnostics.Process&gt; writes a line of text to its &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream.</source>
          <target state="translated">调用异步读取的操作开始时，事件处理程序时每次关联&lt;xref:System.Diagnostics.Process&gt;写入到的文本行其&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can cancel an asynchronous read operation by calling &lt;xref:System.Diagnostics.Process.CancelOutputRead%2A&gt;.</source>
          <target state="translated">你可以通过调用&lt;xref:System.Diagnostics.Process.CancelOutputRead%2A&gt;.&lt;/xref:System.Diagnostics.Process.CancelOutputRead%2A&gt;取消异步读的操作</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The read operation can be canceled by the caller or by the event handler.</source>
          <target state="translated">由调用方或事件处理程序，可以取消读取的操作。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>After canceling, you can call BeginOutputReadLine again to resume asynchronous read operations.</source>
          <target state="translated">取消之后，你可以调用 BeginOutputReadLine 再次继续异步读取的操作。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  You cannot mix asynchronous and synchronous read operations on a redirected stream.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 不能混合使用重定向流上的异步和同步读取的操作。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Once the redirected stream of a &lt;xref:System.Diagnostics.Process&gt; is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</source>
          <target state="translated">一次的重定向的流&lt;xref:System.Diagnostics.Process&gt;打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For example, do not follow BeginOutputReadLine with a call to &lt;xref:System.IO.StreamReader.ReadLine%2A&gt; on the &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream, or vice versa.</source>
          <target state="translated">例如，不要通过调用遵循 BeginOutputReadLine&lt;xref:System.IO.StreamReader.ReadLine%2A&gt;上&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流，反之亦然。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>However, you can read two different streams in different modes.</source>
          <target state="translated">但是，你可以读取在不同模式下的两个不同的流。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example, you can call BeginOutputReadLine and then call &lt;xref:System.IO.StreamReader.ReadLine%2A&gt; for the &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream.</source>
          <target state="translated">例如，你可以调用 BeginOutputReadLine，然后调用&lt;xref:System.IO.StreamReader.ReadLine%2A&gt;为&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Cancels the asynchronous read operation on the redirected &lt;xref:System.Diagnostics.Process.StandardError*&gt; stream of an application.</source>
          <target state="translated">取消执行的异步读取操作的重定向&lt;xref:System.Diagnostics.Process.StandardError*&gt;的应用程序的流。&lt;/xref:System.Diagnostics.Process.StandardError*&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt; starts an asynchronous read operation on the &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;启动异步读取操作&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;&lt;/xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>CancelErrorRead ends the asynchronous read operation.</source>
          <target state="translated">CancelErrorRead 结束异步读取的操作。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>After canceling, you can resume the asynchronous read operation by calling &lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt; again.</source>
          <target state="translated">取消之后，您可以通过来继续异步读取的操作调用&lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;再次。&lt;/xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>When you call CancelErrorRead, all in-progress read operations for &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; are completed and then the event handler is disabled.</source>
          <target state="translated">所有正在进行时调用 CancelErrorRead，读取操作&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;完成和事件处理程序，则会禁用。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>All further redirected output to &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; is saved in a buffer.</source>
          <target state="translated">所有进一步重定向到输出&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;保存在缓冲区中。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>If you re-enable the event handler with a call to &lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;, the saved output is sent to the event handler and asynchronous read operations resume.</source>
          <target state="translated">如果重新启用事件处理程序通过调用&lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;，已保存的输出发送到事件处理程序并异步读取的操作恢复。&lt;/xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:      <ph id="ph1">```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  You cannot mix asynchronous and synchronous read operations on the redirected &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream.</source>
          <target state="translated">如果你想要继续执行异步读取的操作之前更改事件处理程序，则必须在添加新的事件处理程序之前删除现有的事件处理程序︰ <ph id="ph1">```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```</ph> <ph id="ph2">      &gt; </ph> <ph id="ph3">[!NOTE]</ph>&amp;1;&gt; 不能混合使用异步和同步读取的操作的重定向&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Once the redirected stream of a &lt;xref:System.Diagnostics.Process&gt; is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</source>
          <target state="translated">一次的重定向的流&lt;xref:System.Diagnostics.Process&gt;打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If you cancel an asynchronous read operation on &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; and then need to read from the stream again, you must use &lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt; to resume asynchronous read operations.</source>
          <target state="translated">如果您取消异步，则读取上操作&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;，然后需要从流中读取同样，你必须使用&lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;继续异步读取的操作。&lt;/xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt; &lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Do not follow CancelErrorRead with a call to the synchronous read methods of &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; such as &lt;xref:System.IO.StreamReader.Read%2A&gt;, &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;, or &lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt;.</source>
          <target state="translated">通过同步读取方法的调用不遵循 CancelErrorRead&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;如&lt;xref:System.IO.StreamReader.Read%2A&gt;， &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;，或&lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt;。&lt;/xref:System.IO.StreamReader.ReadToEnd%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.IO.StreamReader.Read%2A&gt; &lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Diagnostics.Process.StandardError*&gt; stream is not enabled for asynchronous read operations.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.StandardError*&gt;没有为异步读取操作启用流。&lt;/xref:System.Diagnostics.Process.StandardError*&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Cancels the asynchronous read operation on the redirected &lt;xref:System.Diagnostics.Process.StandardOutput*&gt; stream of an application.</source>
          <target state="translated">取消执行的异步读取操作的重定向&lt;xref:System.Diagnostics.Process.StandardOutput*&gt;的应用程序的流。&lt;/xref:System.Diagnostics.Process.StandardOutput*&gt;</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt; starts an asynchronous read operation on the &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;启动异步读取操作&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;&lt;/xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>CancelOutputRead ends the asynchronous read operation.</source>
          <target state="translated">CancelOutputRead 结束异步读取的操作。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>After canceling, you can resume asynchronous read operations by calling &lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt; again.</source>
          <target state="translated">取消之后，您可以通过来继续异步读取的操作调用&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;再次。&lt;/xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>When you call CancelOutputRead, all in-progress read operations for &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; are completed and then the event handler is disabled.</source>
          <target state="translated">所有正在进行时调用 CancelOutputRead，读取操作&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;完成和事件处理程序，则会禁用。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>All further redirected output to &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; is saved in a buffer.</source>
          <target state="translated">所有进一步重定向到输出&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;保存在缓冲区中。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If you re-enable the event handler with a call to &lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;, the saved output is sent to the event handler and asynchronous read operations resume.</source>
          <target state="translated">如果重新启用事件处理程序通过调用&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;，已保存的输出发送到事件处理程序并异步读取的操作恢复。&lt;/xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:      <ph id="ph1">```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  You cannot mix asynchronous and synchronous read operations on the redirected &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream.</source>
          <target state="translated">如果你想要继续执行异步读取的操作之前更改事件处理程序，则必须在添加新的事件处理程序之前删除现有的事件处理程序︰ <ph id="ph1">```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```</ph> <ph id="ph2">      &gt; </ph> <ph id="ph3">[!NOTE]</ph>&amp;1;&gt; 不能混合使用异步和同步读取的操作的重定向&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Once the redirected stream of a &lt;xref:System.Diagnostics.Process&gt; is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</source>
          <target state="translated">一次的重定向的流&lt;xref:System.Diagnostics.Process&gt;打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If you cancel an asynchronous read operation on &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; and then need to read from the stream again, you must use &lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt; to resume asynchronous read operations.</source>
          <target state="translated">如果您取消异步，则读取上操作&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;，然后需要从流中读取同样，你必须使用&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;继续异步读取的操作。&lt;/xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt; &lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Do not follow CancelOutputRead with a call to the synchronous read methods of &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; such as &lt;xref:System.IO.StreamReader.Read%2A&gt;, &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;, or &lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt;.</source>
          <target state="translated">通过同步读取方法的调用不遵循 CancelOutputRead&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;如&lt;xref:System.IO.StreamReader.Read%2A&gt;， &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;，或&lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt;。&lt;/xref:System.IO.StreamReader.ReadToEnd%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.IO.StreamReader.Read%2A&gt; &lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Diagnostics.Process.StandardOutput*&gt; stream is not enabled for asynchronous read operations.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.StandardOutput*&gt;没有为异步读取操作启用流。&lt;/xref:System.Diagnostics.Process.StandardOutput*&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Frees all the resources that are associated with this component.</source>
          <target state="translated">释放与此组件关联的所有资源。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The Close method causes the process to stop waiting for exit if it was waiting, closes the process handle, and clears process-specific properties.</source>
          <target state="translated">Close 方法会导致进程停止等待退出，如果它正在等待、 关闭进程句柄，并清除特定于进程的属性。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Close does not close the standard output, input, and error readers and writers in case they are being referenced externally.</source>
          <target state="translated">关闭不会关闭标准输出、 输入和错误的读取器和编写器，它们将被从外部引用的情况下。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The &lt;xref:System.Diagnostics.Process.Dispose%2A&gt; method calls Close.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt;&lt;xref:System.Diagnostics.Process.Dispose%2A&gt;方法调用关闭。&lt;/xref:System.Diagnostics.Process.Dispose%2A&gt;</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Placing the &lt;xref:System.Diagnostics.Process&gt; object in a <ph id="ph1">`using`</ph> block disposes of resources without the need to call Close.</source>
          <target state="translated">放置&lt;xref:System.Diagnostics.Process&gt;对象在<ph id="ph1">`using`</ph>块释放资源而无需调用关闭。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Closes a process that has a user interface by sending a close message to its main window.</source>
          <target state="translated">关闭通过向其主窗口发送关闭消息具有用户界面的进程。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>When a process is executing, its message loop is in a wait state.</source>
          <target state="translated">执行过程时，其消息循环将处于等待状态。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The message loop executes every time a Windows message is sent to the process by the operating system.</source>
          <target state="translated">消息循环执行每次操作系统的 Windows 消息发送到进程。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Calling CloseMainWindow sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</source>
          <target state="translated">调用 CloseMainWindow 接近主窗口中，其格式正确的应用程序，在关闭子窗口，并撤消应用程序的所有正在运行消息循环中发送到的请求。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The request to exit the process by calling CloseMainWindow does not force the application to quit.</source>
          <target state="translated">通过调用 CloseMainWindow 退出该进程的请求不会强制应用程序退出。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The application can ask for user verification before quitting, or it can refuse to quit.</source>
          <target state="translated">应用程序可以请求用户验证之前退出，或它可以拒绝退出。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>To force the application to quit, use the &lt;xref:System.Diagnostics.Process.Kill%2A&gt; method.</source>
          <target state="translated">若要强制应用程序退出，请使用&lt;xref:System.Diagnostics.Process.Kill%2A&gt;方法。&lt;/xref:System.Diagnostics.Process.Kill%2A&gt;</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The behavior of CloseMainWindow is identical to that of a user closing an application's main window using the system menu.</source>
          <target state="translated">CloseMainWindow 的行为是用户的相同关闭应用程序的主窗口中使用系统菜单。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</source>
          <target state="translated">因此，通过关闭主窗口退出该进程的请求不会强制应用程序立即退出。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Data edited by the process or resources allocated to the process can be lost if you call &lt;xref:System.Diagnostics.Process.Kill%2A&gt;.</source>
          <target state="translated">该进程编辑的数据或分配给进程的资源可能会丢失如果调用&lt;xref:System.Diagnostics.Process.Kill%2A&gt;.&lt;/xref:System.Diagnostics.Process.Kill%2A&gt;</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.Kill%2A&gt; causes an abnormal process termination, and should be used only when necessary.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.Kill%2A&gt;导致异常的进程终止，并应仅在必要时使用。&lt;/xref:System.Diagnostics.Process.Kill%2A&gt;</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>CloseMainWindow enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</source>
          <target state="translated">CloseMainWindow 启用进程的有序地终止并关闭所有窗口，以使更为可取的接口的应用程序。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If CloseMainWindow fails, you can use &lt;xref:System.Diagnostics.Process.Kill%2A&gt; to terminate the process.</source>
          <target state="translated">如果 CloseMainWindow 失败，则可以使用&lt;xref:System.Diagnostics.Process.Kill%2A&gt;终止进程。&lt;/xref:System.Diagnostics.Process.Kill%2A&gt;</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.Kill%2A&gt; is the only way to terminate processes that do not have graphical interfaces.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.Kill%2A&gt;是终止不具有图形界面的进程的唯一方法。&lt;/xref:System.Diagnostics.Process.Kill%2A&gt;</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>You can call &lt;xref:System.Diagnostics.Process.Kill%2A&gt; and CloseMainWindow only for processes that are running on the local computer.</source>
          <target state="translated">你可以调用&lt;xref:System.Diagnostics.Process.Kill%2A&gt;和 CloseMainWindow 仅的本地计算机运行的进程。&lt;/xref:System.Diagnostics.Process.Kill%2A&gt;</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>You cannot cause processes on remote computers to exit.</source>
          <target state="translated">在退出的远程计算机上，不会导致进程。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>You can only view information for processes running on remote computers.</source>
          <target state="translated">仅可以查看在远程计算机上运行的进程的信息。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the close message was successfully sent; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果成功发送了关闭消息;<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>如果关联的进程没有主窗口或 （例如，如果当前显示模式对话框） 禁用了主窗口。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> property to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>属性<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The process has already exited.</source>
          <target state="translated">已经退出进程。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>-or-       No process is associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">-或-没有进程是否与此相关联<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Release all resources used by this process.</source>
          <target state="translated">释放此进程使用的所有资源。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to release both managed and unmanaged resources; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> to release only unmanaged resources.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>若要释放托管和非托管资源;<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>若要仅释放非托管的资源。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Gets or sets whether the <bpt id="p1">&lt;xref href="System.Diagnostics.Process.Exited"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> event should be raised when the process terminates.</source>
          <target state="translated">获取或设置是否<bpt id="p1">&lt;xref href="System.Diagnostics.Process.Exited"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>在进程终止时，应引发事件。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The EnableRaisingEvents property indicates whether the component should be notified when the operating system has shut down a process.</source>
          <target state="translated">EnableRaisingEvents 属性指示当操作系统已关闭进程时是否应通知该组件。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The EnableRaisingEvents property is used in asynchronous processing to notify your application that a process has exited.</source>
          <target state="translated">在异步处理使用 EnableRaisingEvents 属性以通知应用程序进程已退出。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>To force your application to synchronously wait for an exit event (which interrupts processing of the application until the exit event has occurred), use the &lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt; method.</source>
          <target state="translated">若要强制应用程序同步等待退出事件 （它中断的应用程序处理，直到退出事件发生为止），请使用&lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt;方法。&lt;/xref:System.Diagnostics.Process.WaitForExit%2A&gt;</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are using Visual Studio and double-click a &lt;xref:System.Diagnostics.Process&gt; component in your project, an &lt;xref:System.Diagnostics.Process.Exited&gt; event delegate and event handler are automatically generated.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 如果你使用的 Visual Studio 并双击&lt;xref:System.Diagnostics.Process&gt;组件在项目中，&lt;xref:System.Diagnostics.Process.Exited&gt;自动生成事件委托和事件处理程序。&lt;/xref:System.Diagnostics.Process.Exited&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Additional code sets the EnableRaisingEvents property to <ph id="ph1">`false`</ph>.</source>
          <target state="translated">其他代码将 EnableRaisingEvents 属性设置为<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>You must change this property to <ph id="ph1">`true`</ph> for your event handler to be executed when the associated process exits.</source>
          <target state="translated">必须更改此属性设置为<ph id="ph1">`true`</ph>事件处理程序关联的进程退出时要执行的。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>When an associated process exits after being shut down by the operating system either through a normal or abnormal termination, the operating system notifies each process component to which the process was associated, as long as the component's EnableRaisingEvents value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">关联的进程在后的退出时关闭由操作系统或者通过正常或不正常终止时，操作系统通知到的进程相关联，每个进程组件，组件的 EnableRaisingEvents 值为<ph id="ph1">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>If a component started the process, the component can then access the administrative information for the associated process, which is still being stored by the operating system.</source>
          <target state="translated">如果组件启动该进程，组件可以访问关联的进程，仍由操作系统存储的管理信息。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Such information includes the &lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;, and the &lt;xref:System.Diagnostics.Process.ExitCode%2A&gt;.</source>
          <target state="translated">此类信息包括&lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;，和&lt;xref:System.Diagnostics.Process.ExitCode%2A&gt;.&lt;/xref:System.Diagnostics.Process.ExitCode%2A&gt; &lt;/xref:System.Diagnostics.Process.ExitTime%2A&gt;</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>After the associated process exits, the &lt;xref:System.Diagnostics.Process.Handle%2A&gt; of the component no longer points to an existing process resource.</source>
          <target state="translated">关联的进程退出后，则&lt;xref:System.Diagnostics.Process.Handle%2A&gt;的组件不再指向现有进程资源。&lt;/xref:System.Diagnostics.Process.Handle%2A&gt;</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Instead, it can be used only to access the operating system's information about the process resource.</source>
          <target state="translated">相反，它可以是仅用于访问有关的进程资源的操作系统的信息。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The operating system is aware that there are handles to exited processes that have not been released by &lt;xref:System.Diagnostics.Process&gt; components, so it keeps the &lt;xref:System.Diagnostics.Process.ExitTime%2A&gt; and &lt;xref:System.Diagnostics.Process.Handle%2A&gt; information in memory.</source>
          <target state="translated">操作系统已注意到有不通过已发布的已退出进程的句柄&lt;xref:System.Diagnostics.Process&gt;组件，因此它会保留&lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;和&lt;xref:System.Diagnostics.Process.Handle%2A&gt;内存中的信息。&lt;/xref:System.Diagnostics.Process.Handle%2A&gt; &lt;/xref:System.Diagnostics.Process.ExitTime%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>There is a cost associated with watching for a process to exit.</source>
          <target state="translated">没有监视进程的退出会带来开销。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>If EnableRaisingEvents is <ph id="ph1">`true`</ph>, the &lt;xref:System.Diagnostics.Process.Exited&gt; event is raised when the associated process terminates.</source>
          <target state="translated">如果 EnableRaisingEvents <ph id="ph1">`true`</ph>、&lt;xref:System.Diagnostics.Process.Exited&gt;在关联的进程终止时，将引发事件。&lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The procedures that you have specified for the &lt;xref:System.Diagnostics.Process.Exited&gt; event run at that time.</source>
          <target state="translated">为指定的过程&lt;xref:System.Diagnostics.Process.Exited&gt;在该时间运行的事件。&lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Sometimes, your application starts a process but does not need to be notified of its closure.</source>
          <target state="translated">有时，你的应用程序将启动一个进程，但不需要的关闭通知。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>For example, your application can start Notepad to allow the user to perform text editing, but make no further use of the Notepad application.</source>
          <target state="translated">例如，你的应用程序可启动记事本以允许用户执行文本编辑，但没有任何进一步利用记事本应用程序。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>You can choose to not be notified when the process exits, because it is not relevant to the continued operation of your application.</source>
          <target state="translated">你可以选择不会通知时在进程退出，因为它不是与你的应用程序继续运行。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Setting EnableRaisingEvents to <ph id="ph1">`false`</ph> saves system resources.</source>
          <target state="translated">设置为 EnableRaisingEvents<ph id="ph1">`false`</ph>节省系统资源。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Diagnostics.Process.Exited"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> event should be raised when the associated process is terminated (through either an exit or a call to &lt;xref:System.Diagnostics.Process.Kill*&gt;); otherwise, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果<bpt id="p2">&lt;xref href="System.Diagnostics.Process.Exited"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>关联的进程终止时，应引发事件 (通过退出或者调用&lt;xref:System.Diagnostics.Process.Kill*&gt;); 否则为<bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>。&lt;/xref:System.Diagnostics.Process.Kill*&gt;</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">默认值是<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Puts a <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component in state to interact with operating system processes that run in a special mode by enabling the native property <bpt id="p2">&lt;xref uid="langword_csharp_SeDebugPrivilege" name="SeDebugPrivilege" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> on the current thread.</source>
          <target state="translated">放入<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>处于状态，以便与操作系统进行交互的组件处理以特殊模式运行的启用的本机属性<bpt id="p2">&lt;xref uid="langword_csharp_SeDebugPrivilege" name="SeDebugPrivilege" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>当前线程上。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Some operating system processes run in a special mode.</source>
          <target state="translated">以特殊模式运行某些操作系统进程。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Attempting to read properties of or attach to these processes is not possible unless you have called EnterDebugMode on the component.</source>
          <target state="translated">除非你在组件上调用了 EnterDebugMode，尝试读取的属性或将附加到这些进程不能。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Call &lt;xref:System.Diagnostics.Process.LeaveDebugMode%2A&gt; when you no longer need access to these processes that run in special mode.</source>
          <target state="translated">调用&lt;xref:System.Diagnostics.Process.LeaveDebugMode%2A&gt;不再需要对这些特殊模式运行的进程的访问。&lt;/xref:System.Diagnostics.Process.LeaveDebugMode%2A&gt;</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Occurs when an application writes to its redirected &lt;xref:System.Diagnostics.Process.StandardError*&gt; stream.</source>
          <target state="translated">当应用程序写入其重定向时发生&lt;xref:System.Diagnostics.Process.StandardError*&gt;流。&lt;/xref:System.Diagnostics.Process.StandardError*&gt;</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The ErrorDataReceived event indicates that the associated process has written to its redirected &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream.</source>
          <target state="translated">ErrorDataReceived 事件指示关联的进程已写入其重定向&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The event only occurs during asynchronous read operations on &lt;xref:System.Diagnostics.Process.StandardError%2A&gt;.</source>
          <target state="translated">在事件仅发生在异步读取操作的时间为&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;过程</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>To start asynchronous read operations, you must redirect the &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream of a &lt;xref:System.Diagnostics.Process&gt;, add your event handler to the ErrorDataReceived event, and call &lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;.</source>
          <target state="translated">若要开始异步读取的操作，必须重定向&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;&lt;xref:System.Diagnostics.Process&gt;，添加到 ErrorDataReceived 事件，事件处理程序，调用&lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;.&lt;/xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;&lt;/xref:System.Diagnostics.Process&gt;流&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Thereafter, the ErrorDataReceived event signals each time the process writes a line to the redirected &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream, until the process exits or calls &lt;xref:System.Diagnostics.Process.CancelErrorRead%2A&gt;.</source>
          <target state="translated">此后，ErrorDataReceived 事件信号每次该过程将行写入重定向&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流，进程退出后才或调用&lt;xref:System.Diagnostics.Process.CancelErrorRead%2A&gt;.&lt;/xref:System.Diagnostics.Process.CancelErrorRead%2A&gt; &lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The application that is processing the asynchronous output should call the &lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt; method to ensure that the output buffer has been flushed.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 正在处理的异步输出应用程序应调用&lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt;方法，以确保已刷新输出缓冲区。&lt;/xref:System.Diagnostics.Process.WaitForExit%2A&gt;</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">要添加。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Gets the value that the associated process specified when it terminated.</source>
          <target state="translated">获取关联的进程终止时指定的值。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Use ExitCode to get the status that the system process returned when it exited.</source>
          <target state="translated">ExitCode 用于获取系统过程返回时退出该循环的状态。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You can use the exit code much like an integer return value from a <ph id="ph1">`main()`</ph> procedure.</source>
          <target state="translated">您可以使用的退出代码更像一个整数，返回值从<ph id="ph1">`main()`</ph>过程。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The ExitCode value for a process reflects the specific convention implemented by the application developer for that process.</source>
          <target state="translated">进程的退出代码值反映该进程的应用程序开发人员实现的特定约定。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If you use the exit code value to make decisions in your code, be sure that you know the exit code convention used by the application process.</source>
          <target state="translated">如果你使用的退出代码值在你的代码中进行决策，请确保你知道使用应用程序进程的退出代码约定。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Developers usually indicate a successful exit by an ExitCode value of zero, and designate errors by nonzero values that the calling method can use to identify the cause of an abnormal process termination.</source>
          <target state="translated">开发人员通常指示成功退出的 ExitCode 值为零，并且可以调用的方法可用于确定异常的进程终止原因的非零值，从而指定错误。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>It is not necessary to follow these guidelines, but they are the convention.</source>
          <target state="translated">不需要遵循这些指导原则，但它们约定。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>If you try to get the ExitCode before the process has exited, the attempt throws an exception.</source>
          <target state="translated">如果你尝试获取 ExitCode 之前该进程已退出，则尝试将引发异常。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Examine the &lt;xref:System.Diagnostics.Process.HasExited%2A&gt; property first to verify whether the associated process has terminated.</source>
          <target state="translated">检查&lt;xref:System.Diagnostics.Process.HasExited%2A&gt;属性首先以验证是否已终止关联的进程。&lt;/xref:System.Diagnostics.Process.HasExited%2A&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when &lt;xref:System.Diagnostics.Process.HasExited%2A&gt; returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 当已重标准输出定向到异步事件处理程序中时，有可能，输出处理还未完成时&lt;xref:System.Diagnostics.Process.HasExited%2A&gt;返回<ph id="ph2">`true`</ph>。&lt;/xref:System.Diagnostics.Process.HasExited%2A&gt;</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>To ensure that asynchronous event handling has been completed, call the &lt;xref:System.Diagnostics.Process.WaitForExit&gt; overload that takes no parameter before checking &lt;xref:System.Diagnostics.Process.HasExited%2A&gt;.</source>
          <target state="translated">若要确保已完成异步事件处理，调用的&lt;xref:System.Diagnostics.Process.WaitForExit&gt;重载采用再进行检查&lt;xref:System.Diagnostics.Process.HasExited%2A&gt;.&lt;/xref:System.Diagnostics.Process.HasExited%2A&gt;无参数&lt;/xref:System.Diagnostics.Process.WaitForExit&gt;</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>You can use the &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; or the &lt;xref:System.Diagnostics.Process.Kill%2A&gt; method to cause an associated process to exit.</source>
          <target state="translated">你可以使用&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;或&lt;xref:System.Diagnostics.Process.Kill%2A&gt;方法，使关联的进程退出。&lt;/xref:System.Diagnostics.Process.Kill%2A&gt; &lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>There are two ways of being notified when the associated process exits: synchronously and asynchronously.</source>
          <target state="translated">关联的进程退出时收到通知的两种方式︰ 同步和异步方式。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Synchronous notification relies on calling the &lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt; method to pause the processing of your application until the associated component exits.</source>
          <target state="translated">同步通知依赖于调用&lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt;方法来暂停应用程序处理，直到退出关联的组件。&lt;/xref:System.Diagnostics.Process.WaitForExit%2A&gt;</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Asynchronous notification relies on the &lt;xref:System.Diagnostics.Process.Exited&gt; event.</source>
          <target state="translated">异步通知依赖于&lt;xref:System.Diagnostics.Process.Exited&gt;事件。&lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>When using asynchronous notification, &lt;xref:System.Diagnostics.Process.EnableRaisingEvents%2A&gt; must be set to <ph id="ph1">`true`</ph> for the &lt;xref:System.Diagnostics.Process&gt; component to receive notification that the process has exited.</source>
          <target state="translated">使用异步通知时&lt;xref:System.Diagnostics.Process.EnableRaisingEvents%2A&gt;必须设置为<ph id="ph1">`true`</ph>为&lt;xref:System.Diagnostics.Process&gt;组件可以接收该进程已退出的通知。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.EnableRaisingEvents%2A&gt;</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The code that the associated process specified when it terminated.</source>
          <target state="translated">关联的进程终止时指定的代码。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The process has not exited.</source>
          <target state="translated">进程尚未退出。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>-or-       The process &lt;xref:System.Diagnostics.Process.Handle*&gt; is not valid.</source>
          <target state="translated">-过程&lt;xref:System.Diagnostics.Process.Handle*&gt;无效。&lt;/xref:System.Diagnostics.Process.Handle*&gt;</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You are trying to access the ExitCode property for a process that is running on a remote computer.</source>
          <target state="translated">正在尝试访问在远程计算机运行的进程的 ExitCode 属性。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Occurs when a process exits.</source>
          <target state="translated">在进程退出时发生。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The Exited event indicates that the associated process exited.</source>
          <target state="translated">Exited 事件指示关联的进程退出。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>This occurrence means either that the process terminated (aborted) or successfully closed.</source>
          <target state="translated">此事件意味着任一进程终止 （中止） 或已成功关闭。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>This event can occur only if the value of the &lt;xref:System.Diagnostics.Process.EnableRaisingEvents%2A&gt; property is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">仅当，可能发生此事件的值&lt;xref:System.Diagnostics.Process.EnableRaisingEvents%2A&gt;属性是<ph id="ph1">`true`</ph>。&lt;/xref:System.Diagnostics.Process.EnableRaisingEvents%2A&gt;</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>There are two ways of being notified when the associated process exits: synchronously and asynchronously.</source>
          <target state="translated">关联的进程退出时收到通知的两种方式︰ 同步和异步方式。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Synchronous notification means calling the &lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt; method to block the current thread until the process exits.</source>
          <target state="translated">同步通知意味着调用&lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt;方法进行阻止当前线程，直到在进程退出。&lt;/xref:System.Diagnostics.Process.WaitForExit%2A&gt;</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Asynchronous notification uses the Exited event, which allows the calling thread to continue execution in the meantime.</source>
          <target state="translated">异步通知使用 Exited 事件，允许调用线程继续在此期间执行。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>In the latter case, &lt;xref:System.Diagnostics.Process.EnableRaisingEvents%2A&gt; must be set to <ph id="ph1">`true`</ph> for the calling application to receive the Exited event.</source>
          <target state="translated">在后一种情况下，&lt;xref:System.Diagnostics.Process.EnableRaisingEvents%2A&gt;必须设置为<ph id="ph1">`true`</ph>调用应用程序中，若要对 Exited 事件进行接收。&lt;/xref:System.Diagnostics.Process.EnableRaisingEvents%2A&gt;</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>When the operating system shuts down a process, it notifies all other processes that have registered handlers for the Exited event.</source>
          <target state="translated">当操作系统关闭进程时，它将通知所有已注册 Exited 事件的处理其他进程。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>At this time, the handle of the process that just exited can be used to access some properties such as  &lt;xref:System.Diagnostics.Process.ExitTime%2A&gt; and &lt;xref:System.Diagnostics.Process.HasExited%2A&gt; that the operating system maintains until it releases that handle completely.</source>
          <target state="translated">在此期间，只需退出进程的句柄可以用于访问某些属性如&lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;和&lt;xref:System.Diagnostics.Process.HasExited%2A&gt;操作系统维护，直到它完全释放该句柄。&lt;/xref:System.Diagnostics.Process.HasExited%2A&gt; &lt;/xref:System.Diagnostics.Process.ExitTime%2A&gt;</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Even if you have a handle to an exited process, you cannot call &lt;xref:System.Diagnostics.Process.Start%2A&gt; again to reconnect to the same process.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 即使你具有已退出的进程的句柄，不能调用&lt;xref:System.Diagnostics.Process.Start%2A&gt;以重新连接到相同的进程。&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Calling &lt;xref:System.Diagnostics.Process.Start%2A&gt; automatically releases the associated process and connects to a process with the same file but an entirely new &lt;xref:System.Diagnostics.Process.Handle%2A&gt;.</source>
          <target state="translated">调用&lt;xref:System.Diagnostics.Process.Start%2A&gt;自动释放关联的进程和连接到具有相同的文件但全新&lt;xref:System.Diagnostics.Process.Handle%2A&gt;.&lt;/xref:System.Diagnostics.Process.Handle%2A&gt;的进程&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>For more information about the use of the Exited event in Windows Forms applications, see the &lt;xref:System.Diagnostics.Process.SynchronizingObject%2A&gt; property.</source>
          <target state="translated">有关使用 Windows 窗体应用程序中的 Exited 事件的详细信息，请参阅&lt;xref:System.Diagnostics.Process.SynchronizingObject%2A&gt;属性。&lt;/xref:System.Diagnostics.Process.SynchronizingObject%2A&gt;</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">要添加。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Gets the time that the associated process exited.</source>
          <target state="translated">获取关联的进程退出的时间。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>If the process has not terminated, attempting to retrieve the ExitTime property throws an exception.</source>
          <target state="translated">如果未终止过程，尝试检索 ExitTime 属性引发异常。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Diagnostics.Process.HasExited%2A&gt; before getting the ExitTime property to determine whether the associated process has terminated.</source>
          <target state="translated">使用&lt;xref:System.Diagnostics.Process.HasExited%2A&gt;之前获取 ExitTime 属性，以确定是否已终止关联的进程。&lt;/xref:System.Diagnostics.Process.HasExited%2A&gt;</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.DateTime&gt; that indicates when the associated process was terminated.</source>
          <target state="translated">A &lt;xref:System.DateTime&gt;，该值指示关联的进程终止时。&lt;/xref:System.DateTime&gt;</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>You are trying to access the ExitTime property for a process that is running on a remote computer.</source>
          <target state="translated">正在尝试访问在远程计算机运行的进程的 ExitTime 属性。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Gets a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component and associates it with the currently active process.</source>
          <target state="translated">获取一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件并将其与当前活动的进程关联。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Use this method to create a new &lt;xref:System.Diagnostics.Process&gt; instance and associate it with the process resource on the local computer.</source>
          <target state="translated">使用此方法创建一个新&lt;xref:System.Diagnostics.Process&gt;实例，并将其与本地计算机上的进程资源关联。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Like the similar &lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;, &lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;, and &lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt; methods, GetCurrentProcess associates an existing resource with a new &lt;xref:System.Diagnostics.Process&gt; component.</source>
          <target state="translated">如类似&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;， &lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;，和&lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt;方法，GetCurrentProcess 将现有的资源与新关联&lt;xref:System.Diagnostics.Process&gt;组件。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.GetProcesses%2A&gt; &lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; &lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt;</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>A new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component associated with the process resource that is running the calling application.</source>
          <target state="translated">一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>与运行调用应用程序的进程资源关联的组件。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Returns a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component, given the identifier of a process on the local computer.</source>
          <target state="translated">返回一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件，在本地计算机上给定进程的标识符。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Use this method to create a new &lt;xref:System.Diagnostics.Process&gt; component and associate it with a process resource on the local computer.</source>
          <target state="translated">使用此方法创建一个新&lt;xref:System.Diagnostics.Process&gt;组件并将它与本地计算机上的进程资源关联。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The process resource must already exist on the computer, because GetProcessById does not create a system resource, but rather associates a resource with an application-generated &lt;xref:System.Diagnostics.Process&gt; component.</source>
          <target state="translated">进程资源必须已经存在的计算机上，因为 GetProcessById 不会创建一个系统资源，但而是将资源与应用程序生成相关联&lt;xref:System.Diagnostics.Process&gt;组件。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>A process &lt;xref:System.Diagnostics.Process.Id%2A&gt; can be retrieved only for a process that is currently running on the computer.</source>
          <target state="translated">进程&lt;xref:System.Diagnostics.Process.Id%2A&gt;可以检索仅为当前计算机运行的进程。&lt;/xref:System.Diagnostics.Process.Id%2A&gt;</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>After the process terminates, GetProcessById throws an exception if you pass it an expired identifier.</source>
          <target state="translated">在进程终止后，GetProcessById 将引发异常，如果你将其传递一个过期的标识符。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>On any particular computer, the identifier of a process is unique.</source>
          <target state="translated">任何特定计算机上进程的标识符是唯一的。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>GetProcessById returns one process at most.</source>
          <target state="translated">GetProcessById 最多返回一个进程。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>If you want to get all the processes running a particular application, use &lt;xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;.</source>
          <target state="translated">如果你想要获取所有运行特定应用程序的进程，使用&lt;xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>If multiple processes exist on the computer running the specified application, &lt;xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt; returns an array containing all the associated processes.</source>
          <target state="translated">如果运行指定的应用程序的计算机上存在多个进程&lt;xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;返回数组，其中包含所有关联的进程。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>You can query each of these processes in turn for its identifier.</source>
          <target state="translated">你可以查询每个标识符反过来这些进程。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The process identifier can be viewed in the <ph id="ph1">`Processes`</ph> panel of the Windows Task Manager.</source>
          <target state="translated">可以在中查看进程标识符<ph id="ph1">`Processes`</ph>面板的 Windows 任务管理器。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`PID`</ph> column displays the process identifier that is assigned to a process.</source>
          <target state="translated"><ph id="ph1">`PID`</ph>列显示分配给进程的进程标识符。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The system-unique identifier of a process resource.</source>
          <target state="translated">进程资源的系统唯一标识符。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component that is associated with the local process resource identified by the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">processId</ph><ept id="p2">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>由标识的本地进程资源关联的组件<bpt id="p2">&lt;code&gt;</bpt> <ph id="ph1">processId</ph> <ept id="p2">&lt;/code&gt;</ept>参数。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The process specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">processId</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not running.</source>
          <target state="translated">指定的进程<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">processId</ph> <ept id="p1">&lt;/code&gt;</ept>参数未运行。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The identifier might be expired.</source>
          <target state="translated">此标识符可能已过期。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The process was not started by this object.</source>
          <target state="translated">此对象未启动进程。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Returns a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component, given a process identifier and the name of a computer on the network.</source>
          <target state="translated">返回一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件，在网络上给定进程标识符和的计算机的名称。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Use this method to create a new &lt;xref:System.Diagnostics.Process&gt; component and associate it with a process resource on a remote computer on the network.</source>
          <target state="translated">使用此方法创建一个新&lt;xref:System.Diagnostics.Process&gt;组件并将其与网络上的远程计算机上的进程资源关联。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The process resource must already exist on the specified computer, because GetProcessById does not create a system resource, but rather associates a resource with an application-generated &lt;xref:System.Diagnostics.Process&gt; component.</source>
          <target state="translated">进程资源必须已经存在在指定计算机上，因为 GetProcessById 不会创建一个系统资源，但而是将资源与应用程序生成相关联&lt;xref:System.Diagnostics.Process&gt;组件。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>A process &lt;xref:System.Diagnostics.Process.Id%2A&gt; can be retrieved only for a process that is currently running on the computer.</source>
          <target state="translated">进程&lt;xref:System.Diagnostics.Process.Id%2A&gt;可以检索仅为当前计算机运行的进程。&lt;/xref:System.Diagnostics.Process.Id%2A&gt;</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>After the process terminates, GetProcessById throws an exception if you pass it an expired identifier.</source>
          <target state="translated">在进程终止后，GetProcessById 将引发异常，如果你将其传递一个过期的标识符。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>On any particular computer, the identifier of a process is unique.</source>
          <target state="translated">任何特定计算机上进程的标识符是唯一的。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>GetProcessById returns one process at most.</source>
          <target state="translated">GetProcessById 最多返回一个进程。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>If you want to get all the processes running a particular application, use &lt;xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;.</source>
          <target state="translated">如果你想要获取所有运行特定应用程序的进程，使用&lt;xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>If multiple processes exist on the computer running the specified application, &lt;xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt; returns an array containing all the associated processes.</source>
          <target state="translated">如果运行指定的应用程序的计算机上存在多个进程&lt;xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;返回数组，其中包含所有关联的进程。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29&gt;</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>You can query each of these processes in turn for its identifier.</source>
          <target state="translated">你可以查询每个标识符反过来这些进程。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The process identifier can be viewed in the <ph id="ph1">`Processes`</ph> panel of the Windows Task Manager.</source>
          <target state="translated">可以在中查看进程标识符<ph id="ph1">`Processes`</ph>面板的 Windows 任务管理器。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`PID`</ph> column displays the process identifier that is assigned to a process.</source>
          <target state="translated"><ph id="ph1">`PID`</ph>列显示分配给进程的进程标识符。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>If you do not specify a <ph id="ph1">`machineName`</ph>, the local computer is used.</source>
          <target state="translated">如果不指定<ph id="ph1">`machineName`</ph>，则使用本地计算机。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify the local computer by setting <ph id="ph1">`machineName`</ph> to the value "." or to an empty string ("").</source>
          <target state="translated">或者，你可以通过设置<ph id="ph1">`machineName`</ph>为值"。"或为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The system-unique identifier of a process resource.</source>
          <target state="translated">进程资源的系统唯一标识符。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The name of a computer on the network.</source>
          <target state="translated">网络上计算机的名称。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component that is associated with a remote process resource identified by the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">processId</ph><ept id="p2">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>由标识的远程进程资源关联的组件<bpt id="p2">&lt;code&gt;</bpt> <ph id="ph1">processId</ph> <ept id="p2">&lt;/code&gt;</ept>参数。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The process specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">processId</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not running.</source>
          <target state="translated">指定的进程<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">processId</ph> <ept id="p1">&lt;/code&gt;</ept>参数未运行。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The identifier might be expired.</source>
          <target state="translated">此标识符可能已过期。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>-or-       The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">machineName</ph><ept id="p1">&lt;/code&gt;</ept> parameter syntax is invalid.</source>
          <target state="translated">-或- <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">machineName</ph> <ept id="p1">&lt;/code&gt;</ept>参数的语法无效。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The name might have length zero (0).</source>
          <target state="translated">名称可能包含长度为零 (0)。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">machineName</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">machineName</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The process was not started by this object.</source>
          <target state="translated">此对象未启动进程。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Creates a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component for each process resource on the local computer.</source>
          <target state="translated">创建一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件的本地计算机上每个进程资源。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Use this method to create an array of new &lt;xref:System.Diagnostics.Process&gt; components and associate them with all the process resources on the local computer.</source>
          <target state="translated">此方法用于创建新的数组&lt;xref:System.Diagnostics.Process&gt;组件并将它们与本地计算机上的所有进程资源关联。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The process resources must already exist on the local computer, because GetProcesses does not create system resources but rather associates resources with application-generated &lt;xref:System.Diagnostics.Process&gt; components.</source>
          <target state="translated">进程资源必须已经存在的本地计算机上，因为 GetProcesses 不会创建系统资源，但而是将资源与应用程序生成相关联&lt;xref:System.Diagnostics.Process&gt;组件。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Because the operating system itself is running background processes, this array is never empty.</source>
          <target state="translated">因为操作系统本身正在运行的后台进程，此数组不为空。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the &lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt; or &lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; method.</source>
          <target state="translated">如果您不想要检索所有计算机上运行的进程，你可以通过使用来限制它们的数量&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;或&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;方法。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; &lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt;</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt; creates a &lt;xref:System.Diagnostics.Process&gt; component that is associated with the process identified on the system by the process identifier that you pass to the method.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;创建&lt;xref:System.Diagnostics.Process&gt;与由传递给该方法的进程标识符标识系统上的进程关联的组件。&lt;/xref:System.Diagnostics.Process&gt;&lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt;</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; creates an array of &lt;xref:System.Diagnostics.Process&gt; components whose associated process resources share the executable file you pass to the method.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;创建的数组&lt;xref:System.Diagnostics.Process&gt;其关联的进程资源共享的可执行文件的组件你传递给方法。&lt;/xref:System.Diagnostics.Process&gt;&lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 可以在服务主机进程 (svchost.exe) 的同一个实例中加载多个 Windows 服务。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>GetProcesses does not identify those individual services; for that, see &lt;xref:System.ServiceProcess.ServiceController.GetServices%2A&gt;.</source>
          <target state="translated">GetProcesses 不会确定这些单个服务; 示例︰为此，请参阅&lt;xref:System.ServiceProcess.ServiceController.GetServices%2A&gt;。&lt;/xref:System.ServiceProcess.ServiceController.GetServices%2A&gt;</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>An array of type <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that represents all the process resources running on the local computer.</source>
          <target state="translated">类型的数组<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> ，表示本地计算机上运行的所有进程资源。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Creates a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component for each process resource on the specified computer.</source>
          <target state="translated">创建一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件为指定的计算机上每个进程资源。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Use this method to create an array of new &lt;xref:System.Diagnostics.Process&gt; components and associate them with all the process resources on the specified (usually remote) computer.</source>
          <target state="translated">此方法用于创建新的数组&lt;xref:System.Diagnostics.Process&gt;组件并将其与指定 （通常为远程） 的计算机上的所有进程资源关联。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The process resources must already exist on the local computer, because &lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt; does not create system resources but rather associates resources with application-generated &lt;xref:System.Diagnostics.Process&gt; components.</source>
          <target state="translated">进程资源必须已经存在的本地计算机上，因为&lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt;不会创建系统资源，但而是将资源与应用程序生成相关联&lt;xref:System.Diagnostics.Process&gt;组件。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.GetProcesses%2A&gt;</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Because the operating system itself is running background processes, this array is never empty.</source>
          <target state="translated">因为操作系统本身正在运行的后台进程，此数组不为空。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the &lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt; or &lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; method.</source>
          <target state="translated">如果您不想要检索所有计算机上运行的进程，你可以通过使用来限制它们的数量&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;或&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;方法。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; &lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt;</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt; creates a &lt;xref:System.Diagnostics.Process&gt; component that is associated with the process identified on the system by the process identifier that you pass to the method.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;创建&lt;xref:System.Diagnostics.Process&gt;与由传递给该方法的进程标识符标识系统上的进程关联的组件。&lt;/xref:System.Diagnostics.Process&gt;&lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt;</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; creates an array of &lt;xref:System.Diagnostics.Process&gt; components whose associated process resources share the executable file you pass to the method.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;创建的数组&lt;xref:System.Diagnostics.Process&gt;其关联的进程资源共享的可执行文件的组件你传递给方法。&lt;/xref:System.Diagnostics.Process&gt;&lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>This overload of the &lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt; method is generally used to retrieve the list of process resources running on a remote computer on the network, but you can specify the local computer by passing ".".</source>
          <target state="translated">此重载&lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt;方法通常用于检索在网络上的远程计算机上运行的进程资源的列表，但你可以通过传递指定本地计算机"。"。&lt;/xref:System.Diagnostics.Process.GetProcesses%2A&gt;</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 可以在服务主机进程 (svchost.exe) 的同一个实例中加载多个 Windows 服务。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>GetProcesses does not identify those individual services; for that, see &lt;xref:System.ServiceProcess.ServiceController.GetServices%2A&gt;.</source>
          <target state="translated">GetProcesses 不会确定这些单个服务; 示例︰为此，请参阅&lt;xref:System.ServiceProcess.ServiceController.GetServices%2A&gt;。&lt;/xref:System.ServiceProcess.ServiceController.GetServices%2A&gt;</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The computer from which to read the list of processes.</source>
          <target state="translated">要从其中读取进程列表计算机。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>An array of type <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that represents all the process resources running on the specified computer.</source>
          <target state="translated">类型的数组<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> ，表示指定计算机上运行的所有进程资源。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">machineName</ph><ept id="p1">&lt;/code&gt;</ept> parameter syntax is invalid.</source>
          <target state="translated"><bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">machineName</ph> <ept id="p1">&lt;/code&gt;</ept>参数的语法无效。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>It might have length zero (0).</source>
          <target state="translated">它可能具有长度为零 (0)。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">machineName</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">machineName</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The operating system platform does not support this operation on remote computers.</source>
          <target state="translated">操作系统平台不支持在远程计算机上的此操作。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>There are problems accessing the performance counter API's used to get process information.</source>
          <target state="translated">有访问 API 的用于获取进程信息的性能计数器的问题。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>This exception is specific to Windows NT, Windows 2000, and Windows XP.</source>
          <target state="translated">此例外情况是特定于 Windows NT、 Windows 2000 和 Windows XP。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>A problem occurred accessing an underlying system API.</source>
          <target state="translated">访问基础系统 API 时出现问题。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Creates an array of new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> components and associates them with all the process resources on the local computer that share the specified process name.</source>
          <target state="translated">新创建的数组<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件并将它们与本地计算机上所有共享指定的进程名称的进程资源关联。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Use this method to create an array of new &lt;xref:System.Diagnostics.Process&gt; components and associate them with all the process resources that are running the same executable file on the local computer.</source>
          <target state="translated">此方法用于创建新的数组&lt;xref:System.Diagnostics.Process&gt;组件并将它们与正在本地计算机上的相同可执行文件的所有进程资源关联。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>The process resources must already exist on the computer, because GetProcessesByName does not create system resources but rather associates them with application-generated &lt;xref:System.Diagnostics.Process&gt; components.</source>
          <target state="translated">进程资源必须已经存在的计算机上，因为 GetProcessesByName 不会创建系统资源，但而是将它们与应用程序生成关联&lt;xref:System.Diagnostics.Process&gt;组件。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`processName`</ph> can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</source>
          <target state="translated">A<ph id="ph1">`processName`</ph>可为指定当前未运行的本地计算机，因此该方法返回的数组可以是空的可执行文件。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</source>
          <target state="translated">进程名称是为了让进程，如 Outlook，不包含扩展名为.exe 或路径的友好名称。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>GetProcessesByName is helpful for getting and manipulating all the processes that are associated with the same executable file.</source>
          <target state="translated">GetProcessesByName 可帮助获取和操作与相同的可执行文件相关联的所有进程。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>For example, you can pass an executable file name as the <ph id="ph1">`processName`</ph> parameter, in order to shut down all the running instances of that executable file.</source>
          <target state="translated">例如，可以传递作为可执行文件名<ph id="ph1">`processName`</ph>参数，以便关闭该可执行文件的所有正在运行的实例。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Although a process &lt;xref:System.Diagnostics.Process.Id%2A&gt; is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the <ph id="ph1">`processName`</ph> parameter.</source>
          <target state="translated">尽管进程&lt;xref:System.Diagnostics.Process.Id%2A&gt;是唯一的系统上的单个进程资源，本地计算机上的多个进程可以运行指定的应用程序<ph id="ph1">`processName`</ph>参数。&lt;/xref:System.Diagnostics.Process.Id%2A&gt;</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt; returns one process at most, but GetProcessesByName returns an array containing all the associated processes.</source>
          <target state="translated">因此，&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;最多返回一个进程，但却 GetProcessesByName 返回数组，其中包含所有关联的进程。&lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt;</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</source>
          <target state="translated">如果你需要操作使用标准的 API 调用的进程，可以查询每个标识符反过来这些进程。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>You cannot access process resources through the process name alone but, once you have retrieved an array of &lt;xref:System.Diagnostics.Process&gt; components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</source>
          <target state="translated">无法访问进程资源，通过单独的进程名称中，但一旦检索到的数组&lt;xref:System.Diagnostics.Process&gt;已相关联的组件与进程资源，你可以启动、 终止和以其他方式操作的系统资源。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The friendly name of the process.</source>
          <target state="translated">进程的友好名称。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>An array of type <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that represents the process resources running the specified application or file.</source>
          <target state="translated">类型的数组<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> ，表示运行指定的应用程序或文件的进程资源。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>There are problems accessing the performance counter API's used to get process information.</source>
          <target state="translated">有访问 API 的用于获取进程信息的性能计数器的问题。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>This exception is specific to Windows NT, Windows 2000, and Windows XP.</source>
          <target state="translated">此例外情况是特定于 Windows NT、 Windows 2000 和 Windows XP。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Creates an array of new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> components and associates them with all the process resources on a remote computer that share the specified process name.</source>
          <target state="translated">新创建的数组<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件并将它们与远程计算机上所有共享指定的进程名称的进程资源关联。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Use this method to create an array of new &lt;xref:System.Diagnostics.Process&gt; components and associate them with all the process resources that are running the same executable file on the specified computer.</source>
          <target state="translated">此方法用于创建新的数组&lt;xref:System.Diagnostics.Process&gt;组件并将它们与正在运行指定的计算机上的相同可执行文件的所有进程资源关联。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>The process resources must already exist on the computer, because &lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; does not create system resources but rather associates them with application-generated &lt;xref:System.Diagnostics.Process&gt; components.</source>
          <target state="translated">进程资源必须已经存在的计算机上，因为&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;不会创建系统资源，但而是将它们与应用程序生成关联&lt;xref:System.Diagnostics.Process&gt;组件。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`processName`</ph> can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</source>
          <target state="translated">A<ph id="ph1">`processName`</ph>可为指定当前未运行的本地计算机，因此该方法返回的数组可以是空的可执行文件。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</source>
          <target state="translated">进程名称是为了让进程，如 Outlook，不包含扩展名为.exe 或路径的友好名称。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; is helpful for getting and manipulating all the processes that are associated with the same executable file.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;可帮助获取和操作与相同的可执行文件相关联的所有进程。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>For example, you can pass an executable file name as the <ph id="ph1">`processName`</ph> parameter, in order to shut down all the running instances of that executable file.</source>
          <target state="translated">例如，可以传递作为可执行文件名<ph id="ph1">`processName`</ph>参数，以便关闭该可执行文件的所有正在运行的实例。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Although a process &lt;xref:System.Diagnostics.Process.Id%2A&gt; is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the <ph id="ph1">`processName`</ph> parameter.</source>
          <target state="translated">尽管进程&lt;xref:System.Diagnostics.Process.Id%2A&gt;是唯一的系统上的单个进程资源，本地计算机上的多个进程可以运行指定的应用程序<ph id="ph1">`processName`</ph>参数。&lt;/xref:System.Diagnostics.Process.Id%2A&gt;</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt; returns one process at most, but &lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; returns an array containing all the associated processes.</source>
          <target state="translated">因此， &lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;，最多返回一个进程但&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;返回数组，其中包含所有关联的进程。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt; &lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt;</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</source>
          <target state="translated">如果你需要操作使用标准的 API 调用的进程，可以查询每个标识符反过来这些进程。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>You cannot access process resources through the process name alone but, once you have retrieved an array of &lt;xref:System.Diagnostics.Process&gt; components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</source>
          <target state="translated">无法访问进程资源，通过单独的进程名称中，但一旦检索到的数组&lt;xref:System.Diagnostics.Process&gt;已相关联的组件与进程资源，你可以启动、 终止和以其他方式操作的系统资源。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>You can use this overload to get processes on the local computer as well as on a remote computer.</source>
          <target state="translated">此重载可用于在本地计算机上以及在远程计算机获取进程。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Use "." to specify the local computer.</source>
          <target state="translated">使用"。"若要指定本地计算机。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Another overload exists that uses the local computer by default.</source>
          <target state="translated">存在另一个重载，默认情况下使用本地计算机。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>You can access processes on remote computers only to view information, such as statistics, about the processes.</source>
          <target state="translated">你可以访问仅以查看有关进程的信息，统计信息，如的远程计算机上的进程。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>You cannot close, terminate (using &lt;xref:System.Diagnostics.Process.Kill%2A&gt;), or start processes on remote computers.</source>
          <target state="translated">无法关闭，终止 (使用&lt;xref:System.Diagnostics.Process.Kill%2A&gt;)，或在远程计算机上启动进程。&lt;/xref:System.Diagnostics.Process.Kill%2A&gt;</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The friendly name of the process.</source>
          <target state="translated">进程的友好名称。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The name of a computer on the network.</source>
          <target state="translated">网络上计算机的名称。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>An array of type <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that represents the process resources running the specified application or file.</source>
          <target state="translated">类型的数组<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> ，表示运行指定的应用程序或文件的进程资源。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">machineName</ph><ept id="p1">&lt;/code&gt;</ept> parameter syntax is invalid.</source>
          <target state="translated"><bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">machineName</ph> <ept id="p1">&lt;/code&gt;</ept>参数的语法无效。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>It might have length zero (0).</source>
          <target state="translated">它可能具有长度为零 (0)。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">machineName</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">machineName</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The operating system platform does not support this operation on remote computers.</source>
          <target state="translated">操作系统平台不支持在远程计算机上的此操作。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>There are problems accessing the performance counter API's used to get process information.</source>
          <target state="translated">有访问 API 的用于获取进程信息的性能计数器的问题。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>This exception is specific to Windows NT, Windows 2000, and Windows XP.</source>
          <target state="translated">此例外情况是特定于 Windows NT、 Windows 2000 和 Windows XP。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>A problem occurred accessing an underlying system API.</source>
          <target state="translated">访问基础系统 API 时出现问题。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>Gets the native handle of the associated process.</source>
          <target state="translated">获取关联进程的本机句柄。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>An application can obtain a handle to a process that can be used as a parameter to many process-information and control functions.</source>
          <target state="translated">应用程序可以获得到的进程，可以使用作为参数传递给许多进程信息和控制功能的句柄。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>You can use this handle to initialize a &lt;xref:System.Threading.WaitHandle&gt; or to call native methods with platform invoke.</source>
          <target state="translated">你可以使用此句柄初始化&lt;xref:System.Threading.WaitHandle&gt;或调用与平台的本机方法调用。&lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>This process handle is private to an application--in other words, process handles cannot be shared.</source>
          <target state="translated">此进程句柄是私有的某个应用程序，换而言之，句柄不能共享的过程。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>A process also has a process &lt;xref:System.Diagnostics.Process.Id%2A&gt; which, unlike the Handle, is unique and, therefore, valid throughout the system.</source>
          <target state="translated">进程也有过程&lt;xref:System.Diagnostics.Process.Id%2A&gt;，与该句柄，是唯一的因此，在整个系统有效。&lt;/xref:System.Diagnostics.Process.Id%2A&gt;</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Only processes started through a call to &lt;xref:System.Diagnostics.Process.Start%2A&gt; set the Handle property of the corresponding &lt;xref:System.Diagnostics.Process&gt; instances.</source>
          <target state="translated">通过调用启动仅进程&lt;xref:System.Diagnostics.Process.Start%2A&gt;设置相应的句柄属性&lt;xref:System.Diagnostics.Process&gt;实例。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>The handle that the operating system assigned to the associated process when the process was started.</source>
          <target state="translated">启动该进程时，操作系统将分配给关联的进程句柄。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>The system uses this handle to keep track of process attributes.</source>
          <target state="translated">系统使用此句柄来跟踪进程特性。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The process has not been started or has exited.</source>
          <target state="translated">进程尚未启动或已退出。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The Handle property cannot be read because there is no process associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance.</source>
          <target state="translated">无法读取句柄属性，因为没有与此关联的进程<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>实例。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>-or-       The <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</source>
          <target state="translated">-或- <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>实例已附加到正在运行的进程，但你没有足够的权限来获取具有完全访问权限的句柄。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>You are trying to access the Handle property for a process that is running on a remote computer.</source>
          <target state="translated">正在尝试访问在远程计算机运行的进程的句柄属性。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Gets the number of handles opened by the process.</source>
          <target state="translated">获取由进程打开的句柄数。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>Handles provide a way for a process to refer to objects.</source>
          <target state="translated">句柄提供使进程可以引用的对象的方法。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>A process can obtain handles to files, resources, message queues, and many other operating system objects.</source>
          <target state="translated">进程可以获取指向文件、 资源、 消息队列和许多其他操作系统对象的句柄。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The operating system reclaims the memory associated with the process only when the handle count is zero.</source>
          <target state="translated">操作系统回收仅当句柄计数为零时，才与进程关联的内存。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>The number of operating system handles the process has opened.</source>
          <target state="translated">进程打开的操作系统句柄数。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> property to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>属性<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the associated process has been terminated.</source>
          <target state="translated">获取一个值，该值指示关联的进程是否已终止。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>A value of <ph id="ph1">`true`</ph> for HasExited indicates that the associated process has terminated, either normally or abnormally.</source>
          <target state="translated">值为<ph id="ph1">`true`</ph>HasExited 指示关联的进程已终止，正常或异常。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>You can request or force the associated process to exit by calling &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; or &lt;xref:System.Diagnostics.Process.Kill%2A&gt;.</source>
          <target state="translated">可以请求，也可以强制关联的进程退出通过调用&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;或&lt;xref:System.Diagnostics.Process.Kill%2A&gt;。&lt;/xref:System.Diagnostics.Process.Kill%2A&gt; &lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>If a handle is open to the process, the operating system releases the process memory when the process has exited, but retains administrative information about the process, such as the handle, exit code, and exit time.</source>
          <target state="translated">如果到进程打开的句柄，操作系统将释放的进程内存时进程已退出，但会保留有关过程，如句柄、 退出代码和退出时的管理信息。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>To get this information, you can use the &lt;xref:System.Diagnostics.Process.ExitCode%2A&gt; and &lt;xref:System.Diagnostics.Process.ExitTime%2A&gt; properties.</source>
          <target state="translated">若要获取此信息，可以使用&lt;xref:System.Diagnostics.Process.ExitCode%2A&gt;和&lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;属性。&lt;/xref:System.Diagnostics.Process.ExitTime%2A&gt; &lt;/xref:System.Diagnostics.Process.ExitCode%2A&gt;</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>These properties are populated automatically for processes that were started by this component.</source>
          <target state="translated">这些属性将自动填充此组件已启动的进程。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The administrative information is released when all the &lt;xref:System.Diagnostics.Process&gt; components that are associated with the system process are destroyed and hold no more handles to the exited process.</source>
          <target state="translated">发布的管理信息时所有&lt;xref:System.Diagnostics.Process&gt;与系统进程关联的组件将销毁，并没有更多的句柄保留至已退出进程。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>A process can terminate independently of your code.</source>
          <target state="translated">独立于你的代码可以终止进程。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>If you started the process using this component, the system updates the value of HasExited automatically, even if the associated process exits independently.</source>
          <target state="translated">如果你在开始使用此组件的过程，系统 HasExited 的值会自动更新，即使独立关联的进程退出。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this property returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 当已重标准输出定向到异步事件处理程序中时，有可能时此属性返回不具有完成输出处理<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>To ensure that asynchronous event handling has been completed, call the &lt;xref:System.Diagnostics.Process.WaitForExit&gt; overload that takes no parameter before checking HasExited.</source>
          <target state="translated">若要确保已完成异步事件处理，调用&lt;xref:System.Diagnostics.Process.WaitForExit&gt;在检查 HasExited 之前不接受任何参数的重载。&lt;/xref:System.Diagnostics.Process.WaitForExit&gt;</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the operating system process referenced by the <bpt id="p2">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> component has terminated; otherwise, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果引用的操作系统进程<bpt id="p2">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>组件已终止; 否则为<bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>There is no process associated with the object.</source>
          <target state="translated">没有与对象关联的进程。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>The exit code for the process could not be retrieved.</source>
          <target state="translated">无法检索进程的退出代码。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>You are trying to access the HasExited property for a process that is running on a remote computer.</source>
          <target state="translated">正在尝试访问在远程计算机运行的进程的 HasExited 属性。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Gets the unique identifier for the associated process.</source>
          <target state="translated">获取为关联进程的唯一标识符。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The process Id is not valid if the associated process is not running.</source>
          <target state="translated">进程 Id 不是有效如果关联的进程未运行的。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Therefore, you should ensure that the process is running before attempting to retrieve the Id property.</source>
          <target state="translated">因此，您应确保在尝试检索的 Id 属性之前正在运行的进程。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</source>
          <target state="translated">在进程终止，直到进程标识符唯一地标识在整个系统的过程。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>You can connect a process that is running on a local or remote computer to a new &lt;xref:System.Diagnostics.Process&gt; instance by passing the process identifier to the &lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt; method.</source>
          <target state="translated">你可以连接到新的本地或远程计算机运行的进程&lt;xref:System.Diagnostics.Process&gt;实例通过将传递到的进程标识符&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;方法。&lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt; is a <ph id="ph1">`static`</ph> method that creates a new component and sets the Id property for the new &lt;xref:System.Diagnostics.Process&gt; instance automatically.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.GetProcessById%2A&gt;是<ph id="ph1">`static`</ph>方法，创建一个新的组件的新设置的 Id 属性&lt;xref:System.Diagnostics.Process&gt;自动实例。&lt;/xref:System.Diagnostics.Process&gt;&lt;/xref:System.Diagnostics.Process.GetProcessById%2A&gt;</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Process identifiers can be reused by the system.</source>
          <target state="translated">可以由系统重用进程标识符。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>The Id property value is unique only while the associated process is running.</source>
          <target state="translated">仅在关联的进程正在运行时，Id 属性值是唯一的。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>After the process has terminated, the system can reuse the Id property value for an unrelated process.</source>
          <target state="translated">进程已终止后，系统可以重复使用不相关的进程的 Id 属性值。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>Because the identifier is unique on the system, you can pass it to other threads as an alternative to passing a &lt;xref:System.Diagnostics.Process&gt; instance.</source>
          <target state="translated">因为该标识符是唯一系统上，你可以将其传递给其他线程作为传递的替代方法&lt;xref:System.Diagnostics.Process&gt;实例。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>This action can save system resources yet guarantee that the process is correctly identified.</source>
          <target state="translated">此操作可以节省系统资源，又可保证正确标识进程。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The system-generated unique identifier of the process that is referenced by this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance.</source>
          <target state="translated">此引用的进程的系统生成的唯一标识符<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>实例。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The process's Id property has not been set.</source>
          <target state="translated">尚未设置进程的 Id 属性。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>-or-       There is no process associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">-或-没有与此关联的进程<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> property to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>属性<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Immediately stops the associated process.</source>
          <target state="translated">立即停止关联的进程。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>Kill forces a termination of the process, while &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; only requests a termination.</source>
          <target state="translated">Kill 强制终止的进程，而&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;只请求在终止。&lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>When a process with a graphical interface is executing, its message loop is in a wait state.</source>
          <target state="translated">具有图形界面的进程执行时，其消息循环将处于等待状态。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The message loop executes every time a Windows message is sent to the process by the operating system.</source>
          <target state="translated">消息循环执行每次操作系统的 Windows 消息发送到进程。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>Calling &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</source>
          <target state="translated">调用&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;将请求发送到接近主窗口中，其格式正确的应用程序，在关闭子窗口，并撤消应用程序的所有正在运行消息循环。&lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>The request to exit the process by calling &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; does not force the application to quit.</source>
          <target state="translated">通过调用退出该进程的请求&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;不会强制应用程序退出。&lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>The application can ask for user verification before quitting, or it can refuse to quit.</source>
          <target state="translated">应用程序可以请求用户验证之前退出，或它可以拒绝退出。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>To force the application to quit, use the Kill method.</source>
          <target state="translated">若要强制应用程序退出，请使用 Kill 方法。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; is identical to that of a user closing an application's main window using the system menu.</source>
          <target state="translated">行为&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;等同于用户关闭应用程序的主窗口中使用系统菜单。&lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</source>
          <target state="translated">因此，通过关闭主窗口退出该进程的请求不会强制应用程序立即退出。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The Kill method executes asynchronously.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; Kill 方法以异步方式执行。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>After calling the Kill method, call the &lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt; method to wait for the process to exit, or check the &lt;xref:System.Diagnostics.Process.HasExited%2A&gt; property to determine if the process has exited.</source>
          <target state="translated">调用 Kill 方法后，调用&lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt;方法来等待进程退出，或检查&lt;xref:System.Diagnostics.Process.HasExited%2A&gt;属性来确定该进程已退出。&lt;/xref:System.Diagnostics.Process.HasExited%2A&gt; &lt;/xref:System.Diagnostics.Process.WaitForExit%2A&gt;</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Data edited by the process or resources allocated to the process can be lost if you call Kill.</source>
          <target state="translated">如果调用 kill 命令，该进程编辑的数据或分配给进程的资源可能会丢失。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Kill causes an abnormal process termination and should be used only when necessary.</source>
          <target state="translated">Kill 导致的异常进程终止，并仅在必要时才应使用。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;启用过程的有序终止并关闭所有窗口，以使更为可取的接口的应用程序。&lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>If &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; fails, you can use Kill to terminate the process.</source>
          <target state="translated">如果&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;失败，你可以使用 Kill 终止进程。&lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Kill is the only way to terminate processes that do not have graphical interfaces.</source>
          <target state="translated">Kill 是终止不具有图形界面的进程的唯一方法。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>You can call Kill and &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; only for processes that are running on the local computer.</source>
          <target state="translated">你可以调用 Kill 和&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;仅的本地计算机运行的进程。&lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>You cannot cause processes on remote computers to exit.</source>
          <target state="translated">在退出的远程计算机上，不会导致进程。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>You can only view information for processes running on remote computers.</source>
          <target state="translated">仅可以查看在远程计算机上运行的进程的信息。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the call to the Kill method is made while the process is currently terminating, a &lt;xref:System.ComponentModel.Win32Exception&gt; is thrown for Access Denied.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 如果对 Kill 方法的调用时当前在终止进程，由&lt;xref:System.ComponentModel.Win32Exception&gt;引发因访问被拒绝。&lt;/xref:System.ComponentModel.Win32Exception&gt;</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>The associated process could not be terminated.</source>
          <target state="translated">无法终止关联的进程。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>-or-       The process is terminating.</source>
          <target state="translated">-或者-在终止进程。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>-or-       The associated process is a Win16 executable.</source>
          <target state="translated">-或者-关联的进程是 Win16 可执行文件。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>You are attempting to call Kill for a process that is running on a remote computer.</source>
          <target state="translated">你尝试在远程计算机上运行的进程调用 kill 命令。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The method is available only for processes running on the local computer.</source>
          <target state="translated">此方法是仅适用于本地计算机上运行的进程。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The process has already exited.</source>
          <target state="translated">已经退出进程。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>-or-       There is no process associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">-或-没有与此关联的进程<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>Takes a <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component out of the state that lets it interact with operating system processes that run in a special mode.</source>
          <target state="translated">采用<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件离开允许它与以特殊模式运行的操作系统进程交互的状态。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>Some operating system processes run in a special mode.</source>
          <target state="translated">以特殊模式运行某些操作系统进程。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>Attempting to read properties of or attach to these processes is not possible unless you have called &lt;xref:System.Diagnostics.Process.EnterDebugMode%2A&gt; on the component.</source>
          <target state="translated">尝试读取的属性或将附加到这些进程不能除非你调用了&lt;xref:System.Diagnostics.Process.EnterDebugMode%2A&gt;组件上。&lt;/xref:System.Diagnostics.Process.EnterDebugMode%2A&gt;</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>Call LeaveDebugMode when you no longer need access to these processes that run in special mode.</source>
          <target state="translated">当你不再需要对这些特殊模式运行的进程的访问时，请调用 LeaveDebugMode。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>Gets the name of the computer the associated process is running on.</source>
          <target state="translated">获取关联的进程正在运行的计算机的名称。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>You can view statistical data and process information for processes running on remote computers but you cannot call &lt;xref:System.Diagnostics.Process.Start%2A&gt;, &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;, or &lt;xref:System.Diagnostics.Process.Kill%2A&gt; on remote computers.</source>
          <target state="translated">你可以查看统计数据，并在远程计算机上，但是你运行的进程的进程信息不能调用&lt;xref:System.Diagnostics.Process.Start%2A&gt;， &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;，或&lt;xref:System.Diagnostics.Process.Kill%2A&gt;在远程计算机上。&lt;/xref:System.Diagnostics.Process.Kill%2A&gt; &lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; &lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When the associated process is executing on the local machine, this property returns a period (".") for the machine name.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 时关联的进程在本地计算机上执行的此属性返回一个句点 ("。") 为计算机名称。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>You should use the &lt;xref:System.Environment.MachineName%2A?displayProperty=fullName&gt; property to get the correct machine name.</source>
          <target state="translated">应使用&lt;xref:System.Environment.MachineName%2A?displayProperty=fullName&gt;属性获取正确的计算机名称。&lt;/xref:System.Environment.MachineName%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The name of the computer that the associated process is running on.</source>
          <target state="translated">关联的进程正在运行的计算机的名称。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>There is no process associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">没有与此关联的进程<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Gets the main module for the associated process.</source>
          <target state="translated">获取为关联进程的主模块。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>A process module represents a.dll or .exe file that is loaded into a particular process.</source>
          <target state="translated">进程模块表示加载到特定的进程的.dll 或.exe 文件。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>The MainModule property lets you view information about the executable used to start the process, including the module name, file name, and module memory details.</source>
          <target state="translated">MainModule 属性允许你查看有关用于启动进程，包括模块名称、 文件名和模块内存详细信息的可执行文件的信息。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Diagnostics.ProcessModule"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that was used to start the process.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Diagnostics.ProcessModule"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>用于启动进程。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>You are trying to access the MainModule property for a process that is running on a remote computer.</source>
          <target state="translated">正在尝试访问在远程计算机运行的进程的 MainModule 属性。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>A 32-bit process is trying to access the modules of a 64-bit process.</source>
          <target state="translated">32 位进程尝试访问的 64 位进程的模块。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>到<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>The process &lt;xref:System.Diagnostics.Process.Id*&gt; is not available.</source>
          <target state="translated">进程&lt;xref:System.Diagnostics.Process.Id*&gt;不可用。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>-or-       The process has exited.</source>
          <target state="translated">-或者-该进程已退出。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Gets the window handle of the main window of the associated process.</source>
          <target state="translated">获取关联进程主窗口的窗口句柄。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>The main window is the window opened by the process that currently has the focus (the &lt;xref:System.Windows.Forms.Form.TopLevel%2A&gt; form).</source>
          <target state="translated">主窗口是由当前具有焦点的进程打开的窗口 (&lt;xref:System.Windows.Forms.Form.TopLevel%2A&gt;窗体)。&lt;/xref:System.Windows.Forms.Form.TopLevel%2A&gt;</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>You must use the &lt;xref:System.Diagnostics.Process.Refresh%2A&gt; method to refresh the &lt;xref:System.Diagnostics.Process&gt; object to get the current main window handle if it has changed.</source>
          <target state="translated">必须使用&lt;xref:System.Diagnostics.Process.Refresh%2A&gt;方法来刷新&lt;xref:System.Diagnostics.Process&gt;对象以获取当前的主窗口句柄，如果它已更改。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Refresh%2A&gt;</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>In general, because the window handle is cached, use &lt;xref:System.Diagnostics.Process.Refresh%2A&gt; beforehand to guarantee that you’ll retrieve the current handle.</source>
          <target state="translated">一般情况下，因为缓存的窗口句柄，则使用&lt;xref:System.Diagnostics.Process.Refresh%2A&gt;事先若要确保你将检索当前句柄。&lt;/xref:System.Diagnostics.Process.Refresh%2A&gt;</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>You can get the MainWindowHandle property only for processes that are running on the local computer.</source>
          <target state="translated">你可以获取 MainWindowHandle 属性仅在本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>The MainWindowHandle property is a value that uniquely identifies the window that is associated with the process.</source>
          <target state="translated">MainWindowHandle 属性是用于唯一标识与进程相关联的窗口的值。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>A process has a main window associated with it only if the process has a graphical interface.</source>
          <target state="translated">一个进程有一个仅当该过程提供一个图形界面与之关联的主窗口。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>If the associated process does not have a main window, the MainWindowHandle value is zero.</source>
          <target state="translated">如果关联的进程没有主窗口，MainWindowHandle 值为零。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>The value is also zero for processes that have been hidden, that is, processes that are not visible in the taskbar.</source>
          <target state="translated">值也是对于进程已被隐藏，则为零，即处理，在任务栏中不可见。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>This can be the case for processes that appear as icons in the notification area, at the far right of the taskbar.</source>
          <target state="translated">这可能会在通知区域中，在任务栏最右侧显示为图标的进程的情况。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>If you have just started a process and want to use its main window handle, consider using the &lt;xref:System.Diagnostics.Process.WaitForInputIdle%2A&gt; method to allow the process to finish starting, ensuring that the main window handle has been created.</source>
          <target state="translated">如果你刚刚启动了一个进程，并想要使用其主窗口句柄，请考虑使用&lt;xref:System.Diagnostics.Process.WaitForInputIdle%2A&gt;方法以允许该进程完成后从开始，确保已创建了主窗口句柄。&lt;/xref:System.Diagnostics.Process.WaitForInputIdle%2A&gt;</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>Otherwise, an exception will be thrown.</source>
          <target state="translated">否则，将引发异常。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>The system-generated window handle of the main window of the associated process.</source>
          <target state="translated">关联进程主窗口的系统生成的窗口句柄。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>The MainWindowHandle is not defined because the process has exited.</source>
          <target state="translated">因为该进程已退出，未定义 MainWindowHandle。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>You are trying to access the MainWindowHandle property for a process that is running on a remote computer.</source>
          <target state="translated">正在尝试访问在远程计算机运行的进程的 MainWindowHandle 属性。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>到<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>Gets the caption of the main window of the process.</source>
          <target state="translated">获取进程的主窗口的标题。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>A process has a main window associated with it only if the process has a graphical interface.</source>
          <target state="translated">一个进程有一个仅当该过程提供一个图形界面与之关联的主窗口。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>If the associated process does not have a main window (so that &lt;xref:System.Diagnostics.Process.MainWindowHandle%2A&gt; is zero), MainWindowTitle is an empty string ("").</source>
          <target state="translated">如果关联的进程没有主窗口 (以便&lt;xref:System.Diagnostics.Process.MainWindowHandle%2A&gt;为零)，MainWindowTitle 为空字符串 ("")。&lt;/xref:System.Diagnostics.Process.MainWindowHandle%2A&gt;</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>If you have just started a process and want to use its main window title, consider using the &lt;xref:System.Diagnostics.Process.WaitForInputIdle%2A&gt; method to allow the process to finish starting, ensuring that the main window handle has been created.</source>
          <target state="translated">如果你刚刚启动了一个进程，并想要使用其主窗口标题，请考虑使用&lt;xref:System.Diagnostics.Process.WaitForInputIdle%2A&gt;方法以允许该进程完成后从开始，确保已创建了主窗口句柄。&lt;/xref:System.Diagnostics.Process.WaitForInputIdle%2A&gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>Otherwise, the system throws an exception.</source>
          <target state="translated">否则，系统将引发异常。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main window is the window that currently has the focus; note that this might not be the primary window for the process.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 主窗口是当前具有焦点的窗口; 这可能不是进程的主窗口的注意。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>You must use the &lt;xref:System.Diagnostics.Process.Refresh%2A&gt; method to refresh the &lt;xref:System.Diagnostics.Process&gt; object to get the current main window handle if it has changed.</source>
          <target state="translated">必须使用&lt;xref:System.Diagnostics.Process.Refresh%2A&gt;方法来刷新&lt;xref:System.Diagnostics.Process&gt;对象以获取当前的主窗口句柄，如果它已更改。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Refresh%2A&gt;</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>The main window title of the process.</source>
          <target state="translated">进程主窗口标题。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>The MainWindowTitle property is not defined because the process has exited.</source>
          <target state="translated">因为该进程已退出，未定义 MainWindowTitle 属性。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>You are trying to access the MainWindowTitle property for a process that is running on a remote computer.</source>
          <target state="translated">正在尝试访问在远程计算机运行的进程的 MainWindowTitle 属性。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>到<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>Gets or sets the maximum allowable working set size, in bytes, for the associated process.</source>
          <target state="translated">获取或设置的最大允许工作集大小，以字节为单位，为关联的进程。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</source>
          <target state="translated">进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>These pages are resident and available for an application to use without triggering a page fault.</source>
          <target state="translated">这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>The working set includes both shared and private data.</source>
          <target state="translated">工作集包括共享和私有数据。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</source>
          <target state="translated">共享的数据包括包含应用程序的执行，包括页面.dll 文件和 system.dll 文件中的所有说明的页。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>As the working set size increases, memory demand increases.</source>
          <target state="translated">随着工作集大小的增加，则会增加内存需求。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>A process has minimum and maximum working set sizes.</source>
          <target state="translated">进程都有最小和最大工作集大小。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</source>
          <target state="translated">每次创建一个进程资源时，系统都会保留等于最小工作集大小的进程的内存量。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</source>
          <target state="translated">虚拟内存管理器尝试保持至少最小内存量常驻进程处于活动状态，但决不会保留的最大大小超过时。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>The system sets the default working set sizes.</source>
          <target state="translated">系统设置的默认工作集大小。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>You can modify these sizes using the MaxWorkingSet and &lt;xref:System.Diagnostics.Process.MinWorkingSet%2A&gt; members.</source>
          <target state="translated">你可以修改使用 MaxWorkingSet 这些大小和&lt;xref:System.Diagnostics.Process.MinWorkingSet%2A&gt;成员。&lt;/xref:System.Diagnostics.Process.MinWorkingSet%2A&gt;</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>However, setting these values does not guarantee that the memory will be reserved or resident.</source>
          <target state="translated">但是，设置这些值不保证内存将保留或驻留。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When you increase the working set size of a process, you take physical memory away from the rest of the system.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 时增加进程工作集大小，你需要从系统的其余部分的物理内存。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</source>
          <target state="translated">确保你不会请求是太大，因为这样做会降低系统性能最小值或最大工作集大小。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The maximum working set size that is allowed in memory for the process, in bytes.</source>
          <target state="translated">最大工作进程，以字节为单位的内存中集允许的大小。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>The maximum working set size is invalid.</source>
          <target state="translated">最大工作集大小无效。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>It must be greater than or equal to the minimum working set size.</source>
          <target state="translated">它必须大于或等于最小工作集大小。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>Working set information cannot be retrieved from the associated process resource.</source>
          <target state="translated">从关联的进程资源，无法检索工作集信息。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>-or-       The process identifier or process handle is zero because the process has not been started.</source>
          <target state="translated">-或者-进程标识符或进程句柄为零，因为尚未启动进程。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>You are trying to access the MaxWorkingSet property for a process that is running on a remote computer.</source>
          <target state="translated">正在尝试访问在远程计算机运行的进程的 MaxWorkingSet 属性。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>The process &lt;xref:System.Diagnostics.Process.Id*&gt; is not available.</source>
          <target state="translated">进程&lt;xref:System.Diagnostics.Process.Id*&gt;不可用。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>-or-       The process has exited.</source>
          <target state="translated">-或者-该进程已退出。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Gets or sets the minimum allowable working set size, in bytes, for the associated process.</source>
          <target state="translated">获取或设置的最小允许工作集大小，以字节为单位，为关联的进程。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</source>
          <target state="translated">进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>These pages are resident and available for an application to use without triggering a page fault.</source>
          <target state="translated">这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>The working set includes both shared and private data.</source>
          <target state="translated">工作集包括共享和私有数据。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</source>
          <target state="translated">共享的数据包括包含应用程序的执行，包括页面.dll 文件和 system.dll 文件中的所有说明的页。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>As the working set size increases, memory demand increases.</source>
          <target state="translated">随着工作集大小的增加，则会增加内存需求。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>A process has minimum and maximum working set sizes.</source>
          <target state="translated">进程都有最小和最大工作集大小。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</source>
          <target state="translated">每次创建一个进程资源时，系统都会保留等于最小工作集大小的进程的内存量。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</source>
          <target state="translated">虚拟内存管理器尝试保持至少最小内存量常驻进程处于活动状态，但决不会保留的最大大小超过时。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>The system sets the default working set sizes.</source>
          <target state="translated">系统设置的默认工作集大小。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>You can modify these sizes using the &lt;xref:System.Diagnostics.Process.MaxWorkingSet%2A&gt; and MinWorkingSet members.</source>
          <target state="translated">你可以修改使用这些大小&lt;xref:System.Diagnostics.Process.MaxWorkingSet%2A&gt;和 MinWorkingSet 成员。&lt;/xref:System.Diagnostics.Process.MaxWorkingSet%2A&gt;</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>However, setting these values does not guarantee that the memory will be reserved or resident.</source>
          <target state="translated">但是，设置这些值不保证内存将保留或驻留。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When you increase the working set size of a process, you take physical memory away from the rest of the system.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 时增加进程工作集大小，你需要从系统的其余部分的物理内存。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</source>
          <target state="translated">确保你不会请求是太大，因为这样做会降低系统性能最小值或最大工作集大小。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>The minimum working set size that is required in memory for the process, in bytes.</source>
          <target state="translated">最小工作集所需的大小，以进程，以字节为单位的内存。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>The minimum working set size is invalid.</source>
          <target state="translated">最小工作集大小无效。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>It must be less than or equal to the maximum working set size.</source>
          <target state="translated">它必须小于或等于最大工作集大小。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Working set information cannot be retrieved from the associated process resource.</source>
          <target state="translated">从关联的进程资源，无法检索工作集信息。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>-or-       The process identifier or process handle is zero because the process has not been started.</source>
          <target state="translated">-或者-进程标识符或进程句柄为零，因为尚未启动进程。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>You are trying to access the MinWorkingSet property for a process that is running on a remote computer.</source>
          <target state="translated">正在尝试访问在远程计算机运行的进程的 MinWorkingSet 属性。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>The process &lt;xref:System.Diagnostics.Process.Id*&gt; is not available.</source>
          <target state="translated">进程&lt;xref:System.Diagnostics.Process.Id*&gt;不可用。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>-or-       The process has exited.</source>
          <target state="translated">-或者-该进程已退出。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>Gets the modules that have been loaded by the associated process.</source>
          <target state="translated">获取已由关联进程加载的模块。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>A process module represents a.dll or .exe file that is loaded into a particular process.</source>
          <target state="translated">进程模块表示加载到特定的进程的.dll 或.exe 文件。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Diagnostics.ProcessModule&gt; instance lets you view information about a module, including the module name, file name, and module memory details.</source>
          <target state="translated">A&lt;xref:System.Diagnostics.ProcessModule&gt;实例，您可以查看有关模块，包括模块名称、 文件名和模块内存详细信息的信息。&lt;/xref:System.Diagnostics.ProcessModule&gt;</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>A process can load multiple modules into memory.</source>
          <target state="translated">一个进程可以加载到内存中的多个模块。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>For example,.exe files that load additional .dll files have multiple modules.</source>
          <target state="translated">例如，加载其他.dll 文件的.exe 文件具有多个模块。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>After starting the process, this collection is empty until the system has loaded the process.</source>
          <target state="translated">之后启动该进程，此集合为空直到系统加载该进程。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>If the process has a main window, you can call &lt;xref:System.Diagnostics.Process.WaitForInputIdle%2A&gt; before retrieving this property to ensure that the collection is nonempty when you get the list.</source>
          <target state="translated">如果进程都有一个主窗口，则可以调用&lt;xref:System.Diagnostics.Process.WaitForInputIdle%2A&gt;之前检索此属性，以确保集合非空时你可以获取的列表。&lt;/xref:System.Diagnostics.Process.WaitForInputIdle%2A&gt;</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>An array of type <bpt id="p1">&lt;xref href="System.Diagnostics.ProcessModule"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that represents the modules that have been loaded by the associated process.</source>
          <target state="translated">类型的数组<bpt id="p1">&lt;xref href="System.Diagnostics.ProcessModule"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> ，表示已由关联进程加载的模块。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>You are attempting to access the Modules property for a process that is running on a remote computer.</source>
          <target state="translated">你尝试访问在远程计算机运行的进程的模块属性。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>The process &lt;xref:System.Diagnostics.Process.Id*&gt; is not available.</source>
          <target state="translated">进程&lt;xref:System.Diagnostics.Process.Id*&gt;不可用。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>到<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>You are attempting to access the Modules property for either the system process or the idle process.</source>
          <target state="translated">你尝试访问的系统过程或空闲的进程的模块属性。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>These processes do not have modules.</source>
          <target state="translated">这些进程不具有模块。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的非分页的系统内存量。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>The amount of memory, in bytes, the system has allocated for the associated process that cannot be written to the virtual memory paging file.</source>
          <target state="translated">系统已为不能写入虚拟内存分页文件的关联进程分配的内存，以字节为单位，量。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的非分页的系统内存量。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The value returned by this property represents the current size of nonpaged system memory used by the process, in bytes.</source>
          <target state="translated">返回此属性的值表示使用的过程中，以字节为单位的非分页的系统内存的当前大小。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</source>
          <target state="translated">系统内存是由操作系统的物理内存，并且分为分页和非页面缓冲池。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>Nonpaged memory allocations remain in system memory and are not paged out to the virtual memory paging file.</source>
          <target state="translated">非分页的内存分配保留在系统内存，并且不会调出到虚拟内存分页文件。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</source>
          <target state="translated">此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>The property value is equivalent to the <bpt id="p1">**</bpt>Pool Nonpaged Bytes<ept id="p1">**</ept> performance counter for the process.</source>
          <target state="translated">属性值等于<bpt id="p1">**</bpt>池非分页字节数<ept id="p1">**</ept>进程的性能计数器。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>The amount of system memory, in bytes, allocated for the associated process that cannot be written to the virtual memory paging file.</source>
          <target state="translated">系统内存，以字节为单位，为不能写入虚拟内存分页文件的关联进程分配的量。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Raises the <bpt id="p1">&lt;xref href="System.Diagnostics.Process.Exited"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> event.</source>
          <target state="translated">引发<bpt id="p1">&lt;xref href="System.Diagnostics.Process.Exited"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>事件。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>OnExited is the API method that raises the &lt;xref:System.Diagnostics.Process.Exited&gt; event.</source>
          <target state="translated">OnExited 是引发的 API 方法&lt;xref:System.Diagnostics.Process.Exited&gt;事件。&lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>Calling OnExited causes the &lt;xref:System.Diagnostics.Process.Exited&gt; event to occur and is the only way to raise the event using the &lt;xref:System.Diagnostics.Process&gt; component.</source>
          <target state="translated">调用 OnExited 原因&lt;xref:System.Diagnostics.Process.Exited&gt;事件发生，是唯一的方法来引发事件使用&lt;xref:System.Diagnostics.Process&gt;组件。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>OnExited is primarily used when deriving classes from the component.</source>
          <target state="translated">从组件派生类时，主要使用 OnExited。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>As an alternative to OnExited, you can write your own event handler.</source>
          <target state="translated">作为 OnExited 的替代方法，你可以编写事件处理程序。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>You create your own event handler delegate and your own event-handling method.</source>
          <target state="translated">创建你自己的事件处理程序委托和事件处理方法。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are using the Visual Studio environment, an event handler delegate (AddOnExited) and an event-handling method (Process1_Exited) are created for you when you drag a &lt;xref:System.Diagnostics.Process&gt; component onto a form and double-click the icon.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 如果使用 Visual Studio 环境，一个事件处理程序委托 (AddOnExited) 和一个事件处理方法 (Process1_Exited) 会为您创建在拖动时&lt;xref:System.Diagnostics.Process&gt;组件拖动到窗体并双击该图标。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>The code you create to run when the &lt;xref:System.Diagnostics.Process.Exited&gt; event occurs is entered into the Process1_Exited procedure.</source>
          <target state="translated">创建时要运行代码&lt;xref:System.Diagnostics.Process.Exited&gt;进入 Process1_Exited 过程发生的事件。&lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>You do not need to create the OnExited member, because it is implemented for you.</source>
          <target state="translated">你不需要创建 OnExited 成员，因为它已为您实现。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">引发事件时，将调用事件处理程序，通过委托。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>For an overview, see <bpt id="p1">[</bpt>Events<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关概述，请参阅<bpt id="p1">[</bpt>事件<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>Occurs each time an application writes a line to its redirected &lt;xref:System.Diagnostics.Process.StandardOutput*&gt; stream.</source>
          <target state="translated">每当应用程序将行写入其重定向&lt;xref:System.Diagnostics.Process.StandardOutput*&gt;流。&lt;/xref:System.Diagnostics.Process.StandardOutput*&gt;</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>The OutputDataReceived event indicates that the associated &lt;xref:System.Diagnostics.Process&gt; has written a line, terminating with a newline character, to its redirected &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream.</source>
          <target state="translated">OutputDataReceived 事件指示关联&lt;xref:System.Diagnostics.Process&gt;编写一条线路，以换行符，向其重定向终止&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>The event is enabled during asynchronous read operations on &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;.</source>
          <target state="translated">该事件在异步读取操作的时间为&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;过程已启用</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>To start asynchronous read operations, you must redirect the &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream of a &lt;xref:System.Diagnostics.Process&gt;, add your event handler to the OutputDataReceived event, and call &lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;.</source>
          <target state="translated">若要开始异步读取的操作，必须重定向&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;&lt;xref:System.Diagnostics.Process&gt;，添加到 OutputDataReceived 事件，事件处理程序，调用&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;.&lt;/xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;&lt;/xref:System.Diagnostics.Process&gt;流&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>Thereafter, the OutputDataReceived event signals each time the process writes a line to the redirected &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream, until the process exits or calls &lt;xref:System.Diagnostics.Process.CancelOutputRead%2A&gt;.</source>
          <target state="translated">此后，OutputDataReceived 事件信号每次该过程将行写入重定向&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流，进程退出后才或调用&lt;xref:System.Diagnostics.Process.CancelOutputRead%2A&gt;.&lt;/xref:System.Diagnostics.Process.CancelOutputRead%2A&gt; &lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The application that is processing the asynchronous output should call the &lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt; method to ensure that the output buffer has been flushed.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 正在处理的异步输出应用程序应调用&lt;xref:System.Diagnostics.Process.WaitForExit%2A&gt;方法，以确保已刷新输出缓冲区。&lt;/xref:System.Diagnostics.Process.WaitForExit%2A&gt;</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">要添加。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>Gets the amount of paged memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的分页内存量。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>The amount of memory, in bytes, allocated by the associated process that can be written to the virtual memory paging file.</source>
          <target state="translated">以字节为单位，由可写入虚拟内存分页文件的关联进程分配的内存量。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Gets the amount of paged memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的分页内存量。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>The value returned by this property represents the current size of memory in the virtual memory paging file used by the process, in bytes.</source>
          <target state="translated">返回此属性的值表示内存中使用的过程，以字节为单位的虚拟内存分页文件的当前大小。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</source>
          <target state="translated">操作系统使用与物理内存结合使用的虚拟内存分页文件来管理每个进程的虚拟地址空间。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</source>
          <target state="translated">分页的内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>To obtain the size of memory used by the operating system for the process, use the &lt;xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A&gt; property.</source>
          <target state="translated">若要获取由操作系统使用的进程的内存大小，使用&lt;xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A&gt;属性。&lt;/xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A&gt;</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</source>
          <target state="translated">此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The property value is equivalent to the <bpt id="p1">**</bpt>Page File Bytes<ept id="p1">**</ept> performance counter for the process.</source>
          <target state="translated">属性值等于<bpt id="p1">**</bpt>页面文件字节<ept id="p1">**</ept>进程的性能计数器。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>The amount of memory, in bytes, allocated in the virtual memory paging file for the associated process.</source>
          <target state="translated">以字节为单位，在虚拟内存分页文件中为关联进程分配的内存量。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的可分页系统内存量。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>The amount of memory, in bytes, the system has allocated for the associated process that can be written to the virtual memory paging file.</source>
          <target state="translated">系统已为可以写入虚拟内存分页文件的关联进程分配的内存，以字节为单位，量。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的可分页系统内存量。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>The value returned by this property value represents the current size of pageable system memory used by the process, in bytes.</source>
          <target state="translated">返回此属性的值的值表示使用的过程中，以字节为单位的可分页系统内存的当前大小。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</source>
          <target state="translated">系统内存是由操作系统的物理内存，并且分为分页和非页面缓冲池。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</source>
          <target state="translated">分页的内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>To obtain the size of the application memory used by the process, use the &lt;xref:System.Diagnostics.Process.PagedMemorySize64%2A&gt; property.</source>
          <target state="translated">若要获取的进程使用的应用程序内存的大小，使用&lt;xref:System.Diagnostics.Process.PagedMemorySize64%2A&gt;属性。&lt;/xref:System.Diagnostics.Process.PagedMemorySize64%2A&gt;</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</source>
          <target state="translated">此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>The property value is equivalent to the <bpt id="p1">**</bpt>Pool Paged Bytes<ept id="p1">**</ept> performance counter for the process.</source>
          <target state="translated">属性值等于<bpt id="p1">**</bpt>Pool Paged Bytes<ept id="p1">**</ept>进程的性能计数器。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>The amount of system memory, in bytes, allocated for the associated process that can be written to the virtual memory paging file.</source>
          <target state="translated">系统内存，以字节为单位，为可写入虚拟内存分页文件的关联进程分配的量。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</source>
          <target state="translated">获取在虚拟内存分页文件中，以字节为单位，由关联进程使用的最大内存量。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>The maximum amount of memory, in bytes, allocated by the associated process that could be written to the virtual memory paging file.</source>
          <target state="translated">最大内存，以字节为单位，由可写入到虚拟内存分页文件的关联进程分配的量。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</source>
          <target state="translated">获取在虚拟内存分页文件中，以字节为单位，由关联进程使用的最大内存量。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>The value returned by this property value represents the maximum size of memory in the virtual memory paging file used by the process since it started, in bytes.</source>
          <target state="translated">返回此属性的值的值表示自启动，以字节为单位的进程使用的虚拟内存分页文件中的内存的最大大小。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</source>
          <target state="translated">操作系统使用与物理内存结合使用的虚拟内存分页文件来管理每个进程的虚拟地址空间。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</source>
          <target state="translated">分页的内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</source>
          <target state="translated">此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>The property value is equivalent to the <bpt id="p1">**</bpt>Page File Bytes Peak<ept id="p1">**</ept> performance counter for the process.</source>
          <target state="translated">属性值等于<bpt id="p1">**</bpt>页面文件字节峰值<ept id="p1">**</ept>进程的性能计数器。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>The maximum amount of memory, in bytes, allocated in the virtual memory paging file for the associated process since it was started.</source>
          <target state="translated">最大内存，以字节为单位，自启动以来为关联进程的虚拟内存分页文件中分配量。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</source>
          <target state="translated">获取用字节表示，由关联进程使用的最大虚拟内存量。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>The maximum amount of virtual memory, in bytes, that the associated process has requested.</source>
          <target state="translated">最大虚拟内存，以字节为单位，关联的进程请求的量。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</source>
          <target state="translated">获取用字节表示，由关联进程使用的最大虚拟内存量。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>The value returned by this property represents the maximum size of virtual memory used by the process since it started, in bytes.</source>
          <target state="translated">返回此属性的值表示自启动，以字节为单位的进程使用的虚拟内存的最大大小。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</source>
          <target state="translated">操作系统将映射到页加载在物理内存中，或存储在磁盘上的虚拟内存分页文件的页面的每个进程的虚拟地址空间。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</source>
          <target state="translated">此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>The property value is equivalent to the <bpt id="p1">**</bpt>Virtual Bytes Peak<ept id="p1">**</ept> performance counter for the process.</source>
          <target state="translated">属性值等于<bpt id="p1">**</bpt>虚拟字节峰值<ept id="p1">**</ept>进程的性能计数器。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The maximum amount of virtual memory, in bytes, allocated for the associated process since it was started.</source>
          <target state="translated">最大虚拟内存，以字节为单位，自启动以来为关联进程分配量。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Gets the peak working set size for the associated process, in bytes.</source>
          <target state="translated">获取的峰值工作集大小为关联进程中，以字节为单位。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</source>
          <target state="translated">进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>These pages are resident and available for an application to use without triggering a page fault.</source>
          <target state="translated">这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The working set includes both shared and private data.</source>
          <target state="translated">工作集包括共享和私有数据。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>The shared data includes the pages that contain all the instructions that the process executes, including process modules and the system libraries.</source>
          <target state="translated">共享的数据包括那些包含该进程执行，包括进程模块和系统库的所有说明的页。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The maximum amount of physical memory that the associated process has required all at once, in bytes.</source>
          <target state="translated">最大关联的进程已在一次，以字节为单位所需的物理内存量。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>Gets the maximum amount of physical memory, in bytes, used by the associated process.</source>
          <target state="translated">获取用字节表示，由关联进程使用的最大物理内存量。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>The value returned by this property represents the maximum size of working set memory used by the process since it started, in bytes.</source>
          <target state="translated">返回此属性的值表示工作集内存进程使用的自启动，以字节为单位的最大的大小。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</source>
          <target state="translated">进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>These pages are resident and available for an application to use without triggering a page fault.</source>
          <target state="translated">这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>The working set includes both shared and private data.</source>
          <target state="translated">工作集包括共享和私有数据。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The shared data includes the pages that contain all the instructions that the process executes, including instructions from the process modules and the system libraries.</source>
          <target state="translated">共享的数据包括那些包含该进程执行，包括从进程模块和系统库的说明的所有说明的页。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</source>
          <target state="translated">此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>The property value is equivalent to the <bpt id="p1">**</bpt>Working Set Peak<ept id="p1">**</ept> performance counter for the process.</source>
          <target state="translated">属性值等于<bpt id="p1">**</bpt>工作集峰值<ept id="p1">**</ept>进程的性能计数器。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The maximum amount of physical memory, in bytes, allocated for the associated process since it was started.</source>
          <target state="translated">最大物理内存，以字节为单位，自启动以来为关联进程分配量。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</source>
          <target state="translated">获取或设置一个值，该值是否主窗口拥有焦点时应由操作系统暂时提升关联的进程优先级。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>When a thread runs in a process for which the priority class has one of the dynamic priority enumeration values (&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;, &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;, or &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;), the system temporarily boosts the thread's priority when it is taken out of a wait state.</source>
          <target state="translated">线程在进程中对其优先级类具有动态优先级枚举值之一的运行时 (&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;， &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;，或&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;)，在它离开等待状态时系统便暂时提升的线程的优先级。&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt; &lt;/xref:System.Diagnostics.ProcessPriorityClass&gt; &lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>This action prevents other processes from interrupting the processing of the current thread.</source>
          <target state="translated">此操作可防止其他进程中断当前线程的处理。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>The PriorityBoostEnabled setting affects all the existing threads and any threads subsequently created by the process.</source>
          <target state="translated">PriorityBoostEnabled 设置会影响所有现有的线程和进程随后创建的任何线程。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>To restore normal behavior, set the PriorityBoostEnabled property to <ph id="ph1">`false`</ph>.</source>
          <target state="translated">若要还原正常行为，请将 PriorityBoostEnabled 属性设置为<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Boosting the priority too high can drain resources from essential operating system and network functions, causing problems with other operating system tasks.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 提升过高的优先级会耗尽基本操作系统和网络功能，导致与其他操作系统任务的问题的资源。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if dynamic boosting of the process priority should take place for a process when it is taken out of the wait state; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果动态提升进程优先级别时应采取进程离开等待状态;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">默认值是<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>Priority boost information could not be retrieved from the associated process resource.</source>
          <target state="translated">从关联的进程资源，无法检索优先级提升信息。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>-or-       The process identifier or process handle is zero.</source>
          <target state="translated">-或者-进程标识符或进程句柄为零。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>(The process has not been started.)</source>
          <target state="translated">（进程尚未启动。）</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>You are attempting to access the PriorityBoostEnabled property for a process that is running on a remote computer.</source>
          <target state="translated">你尝试访问在远程计算机运行的进程的 PriorityBoostEnabled 属性。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>The process &lt;xref:System.Diagnostics.Process.Id*&gt; is not available.</source>
          <target state="translated">进程&lt;xref:System.Diagnostics.Process.Id*&gt;不可用。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>Gets or sets the overall priority category for the associated process.</source>
          <target state="translated">获取或设置关联进程的总体优先级类别。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>A process priority class encompasses a range of thread priority levels.</source>
          <target state="translated">进程优先级类包含一系列线程优先级级别。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>Threads with different priorities that are running in the process run relative to the priority class of the process.</source>
          <target state="translated">具有不同优先级的正在运行相对于进程的优先级类进程中运行的线程。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>Win32 uses four priority classes with seven base priority levels per class.</source>
          <target state="translated">Win32 了七个基本优先级级别，每个类使用四个优先级类。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>These process priority classes are captured in the &lt;xref:System.Diagnostics.ProcessPriorityClass&gt; enumeration, which lets you set the process priority to &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;, &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;, &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;, &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;, &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;, or &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;.</source>
          <target state="translated">这些进程优先级类将在&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;枚举，这样就可以将进程优先级设置为&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;， &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;， &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;， &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;， &lt;xref:System.Diagnostics.ProcessPriorityClass&gt;，或&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;。&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt; &lt;/xref:System.Diagnostics.ProcessPriorityClass&gt; &lt;/xref:System.Diagnostics.ProcessPriorityClass&gt; &lt;/xref:System.Diagnostics.ProcessPriorityClass&gt; &lt;/xref:System.Diagnostics.ProcessPriorityClass&gt; &lt;/xref:System.Diagnostics.ProcessPriorityClass&gt; &lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>Based on the time elapsed or other boosts, the base priority level can be changed by the operating system when a process needs to be put ahead of others for access to the processor.</source>
          <target state="translated">基于的时间的进程需要其他出于放访问到处理器时，可以由操作系统已更改的运行时间或其他提升，基本优先级别。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>In addition, you can set the &lt;xref:System.Diagnostics.Process.PriorityBoostEnabled%2A&gt; to temporarily boost the priority level of threads that have been taken out of the wait state.</source>
          <target state="translated">此外，你可以设置&lt;xref:System.Diagnostics.Process.PriorityBoostEnabled%2A&gt;以暂时提升离开等待状态的线程的优先级。&lt;/xref:System.Diagnostics.Process.PriorityBoostEnabled%2A&gt;</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>The priority is reset when the process returns to the wait state.</source>
          <target state="translated">当过程返回到等待状态时，将重置优先级。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Diagnostics.Process.BasePriority%2A&gt; property lets you view the starting priority that is assigned to a process.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.BasePriority%2A&gt;属性，可以查看分配给过程的起始优先级。&lt;/xref:System.Diagnostics.Process.BasePriority%2A&gt;</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>However, because it is read-only, you cannot use the &lt;xref:System.Diagnostics.Process.BasePriority%2A&gt; property to set the priority of a process.</source>
          <target state="translated">但是，因为它是只读的不能使用&lt;xref:System.Diagnostics.Process.BasePriority%2A&gt;属性来设置进程的优先级。&lt;/xref:System.Diagnostics.Process.BasePriority%2A&gt;</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>To change the priority, use the PriorityClass property, which gets or sets the overall priority category for the process.</source>
          <target state="translated">若要更改的优先级，使用 PriorityClass 属性，用于获取或设置进程的总体优先级类别。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The priority class cannot be viewed using System Monitor.</source>
          <target state="translated">不能使用系统监视器查看优先级类。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>The following table shows the relationship between the &lt;xref:System.Diagnostics.Process.BasePriority%2A&gt; and PriorityClass values.</source>
          <target state="translated">下表显示之间的关系&lt;xref:System.Diagnostics.Process.BasePriority%2A&gt;和 PriorityClass 值。&lt;/xref:System.Diagnostics.Process.BasePriority%2A&gt;</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>|BasePriority|PriorityClass|   |------------------|-------------------|   |4|&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|   |8|&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|   |13|&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|   |24|&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|</source>
          <target state="translated">|BasePriority |PriorityClass |  |------------------|-------------------|  |&amp;4; |&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|  |&amp;8; |&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|  |&amp;13; |&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|  |&amp;24; |&lt;xref:System.Diagnostics.ProcessPriorityClass&gt;|&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;&lt;/xref:System.Diagnostics.ProcessPriorityClass&gt;</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>The priority category for the associated process, from which the &lt;xref:System.Diagnostics.Process.BasePriority*&gt; of the process is calculated.</source>
          <target state="translated">依据的关联进程的优先级类别&lt;xref:System.Diagnostics.Process.BasePriority*&gt;计算进程。&lt;/xref:System.Diagnostics.Process.BasePriority*&gt;</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>Process priority information could not be set or retrieved from the associated process resource.</source>
          <target state="translated">无法设置或从关联的进程资源中检索进程优先级信息。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>-or-       The process identifier or process handle is zero.</source>
          <target state="translated">-或者-进程标识符或进程句柄为零。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>(The process has not been started.)</source>
          <target state="translated">（进程尚未启动。）</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>You are attempting to access the PriorityClass property for a process that is running on a remote computer.</source>
          <target state="translated">你尝试访问在远程计算机运行的进程的 PriorityClass 属性。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>The process &lt;xref:System.Diagnostics.Process.Id*&gt; is not available.</source>
          <target state="translated">进程&lt;xref:System.Diagnostics.Process.Id*&gt;不可用。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>You have set the PriorityClass to <bpt id="p1">&lt;xref uid="langword_csharp_AboveNormal" name="AboveNormal" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> or <bpt id="p2">&lt;xref uid="langword_csharp_BelowNormal" name="BelowNormal" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> when using Windows 98 or Windows Millennium Edition (Windows Me).</source>
          <target state="translated">你已设置为 PriorityClass <bpt id="p1">&lt;xref uid="langword_csharp_AboveNormal" name="AboveNormal" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>或<bpt id="p2">&lt;xref uid="langword_csharp_BelowNormal" name="BelowNormal" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>使用 Windows 98 或 Windows Millennium Edition (Windows Me) 时。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>These platforms do not support those values for the priority class.</source>
          <target state="translated">优先级类的情况下，这些平台不支持这些值。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Priority class cannot be set because it does not use a valid value, as defined in the <bpt id="p1">&lt;xref href="System.Diagnostics.ProcessPriorityClass"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> enumeration.</source>
          <target state="translated">优先级类无法设置，因为它不使用有效的值，因为在中定义<bpt id="p1">&lt;xref href="System.Diagnostics.ProcessPriorityClass"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>枚举。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>Gets the amount of private memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的专用内存量。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>The number of bytes allocated by the associated process that cannot be shared with other processes.</source>
          <target state="translated">由不能与其他进程共享的关联进程分配的字节数。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>Gets the amount of private memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的专用内存量。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>The value returned by this property represents the current size of memory used by the process, in bytes, that cannot be shared with other processes.</source>
          <target state="translated">返回此属性的值表示的过程，以字节为单位，不能共享与其他进程使用的内存的当前大小。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</source>
          <target state="translated">此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>The property value is equivalent to the <bpt id="p1">**</bpt>Private Bytes<ept id="p1">**</ept> performance counter for the process.</source>
          <target state="translated">属性值等于<bpt id="p1">**</bpt>专用字节<ept id="p1">**</ept>进程的性能计数器。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>The amount of memory, in bytes, allocated for the associated process that cannot be shared with other processes.</source>
          <target state="translated">以字节为单位，为不能与其他进程共享的关联进程分配的内存量。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>Gets the privileged processor time for this process.</source>
          <target state="translated">获取此进程的特权的处理器时间。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; that indicates the amount of time that the process has spent running code inside the operating system core.</source>
          <target state="translated">A &lt;xref:System.TimeSpan&gt;，该值指示进程在操作系统内核中运行代码所用的时间量。&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>You are attempting to access the PrivilegedProcessorTime property for a process that is running on a remote computer.</source>
          <target state="translated">你尝试访问在远程计算机运行的进程的 PrivilegedProcessorTime 属性。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>Gets the name of the process.</source>
          <target state="translated">获取该进程的名称。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>The ProcessName property holds an executable file name, such as Outlook, that does not include the .exe extension or the path.</source>
          <target state="translated">ProcessName 属性包含可执行文件名称，例如 Outlook 中，不包含扩展名为.exe 或路径。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>It is helpful for getting and manipulating all the processes that are associated with the same executable file.</source>
          <target state="translated">它可帮助获取和操作与相同的可执行文件相关联的所有进程。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On <ph id="ph2">[!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)]</ph> operating systems, the ProcessName property may be truncated to 15 characters if the process module information cannot be obtained.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph> 1&gt; 上<ph id="ph2">[!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)]</ph>操作系统上，ProcessName 属性可能会被截断至 15 个字符如果无法获取进程模块信息。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>You can call &lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;, passing it an executable file name, to retrieve an array that contains every running instance on the specified computer.</source>
          <target state="translated">你可以调用&lt;xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;，将其传递可执行文件名称，以检索包含指定的计算机上每个正在运行的实例的数组。&lt;/xref:System.Diagnostics.Process.GetProcessesByName%2A&gt;</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>You can use this array, for example, to shut down all the running instances of the executable file.</source>
          <target state="translated">可以使用此数组，例如，若要关闭所有运行的可执行文件的实例。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>The name that the system uses to identify the process to the user.</source>
          <target state="translated">系统用以向用户标识该进程的名称。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>The process does not have an identifier, or no process is associated with the <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">进程没有标识符，或与关联的进程<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>-or-       The associated process has exited.</source>
          <target state="translated">-或者-关联的进程已退出。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>到<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The process is not on this computer.</source>
          <target state="translated">进程不是此计算机上。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Gets or sets the processors on which the threads in this process can be scheduled to run.</source>
          <target state="translated">获取或设置在其上的线程在此过程中可以按计划运行的处理器。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>In Windows 2000 and later, a thread in a process can migrate from processor to processor, with each migration reloading the processor cache.</source>
          <target state="translated">Windows 2000 及更高版本，一个进程中的线程可以迁移处理器间重新加载处理器缓存每个迁移。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>Under heavy system loads, specifying which processor should run a specific thread can improve performance by reducing the number of times the processor cache is reloaded.</source>
          <target state="translated">在高系统负荷情况下指定在哪个处理器应运行特定线程可以提高性能通过减少处理器缓存都会重新加载的次数。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>The association between a processor and a thread is called the processor affinity.</source>
          <target state="translated">处理器和线程之间的关联称为处理器关联。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>Each processor is represented as a bit.</source>
          <target state="translated">每个处理器表示为一位。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>Bit 0 is processor one, bit 1 is processor two, and so forth.</source>
          <target state="translated">位 0 是一个处理器，位 1 是处理器二，等等。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>If you set a bit to the value 1, the corresponding processor is selected for thread assignment.</source>
          <target state="translated">如果将位设置为值 1，进行线程分配情况下会选择相应的处理器。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>When you set the ProcessorAffinity value to zero, the operating system's scheduling algorithms set the thread's affinity.</source>
          <target state="translated">当设置为零的 ProcessorAffinity 值时，操作系统的计划算法会设置线程的关联。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>When the ProcessorAffinity value is set to any nonzero value, the value is interpreted as a bitmask that specifies those processors eligible for selection.</source>
          <target state="translated">当 ProcessorAffinity 值设置为任一非零值时，该值被解释为指定可供选择的处理器的位掩码。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>The following table shows a selection of ProcessorAffinity values for an eight-processor system.</source>
          <target state="translated">下表显示了选择的八个处理器系统 ProcessorAffinity 值。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>|Bitmask|Binary value|Eligible processors|   |-------------|------------------|-------------------------|   |0x0001|00000000 00000001|1|   |0x0003|00000000 00000011|1 and 2|   |0x0007|00000000 00000111|1, 2 and 3|   |0x0009|00000000 00001001|1 and 4|   |0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 and 7|</source>
          <target state="translated">|位掩码 |二进制值 |符合条件的处理器 |  |-------------|------------------|-------------------------|  | 从 0x0001 | 00000000 00000001 | 1 |  | 0x0003 | 00000000 00000011 | 1 和 2 |  | 0x0007 | 00000000 00000111 | 1、 2 和 3 |  | 0x0009 | 00000000 00001001 | 1 和 4 |  | 0x007F | 00000000 01111111 | 1、 2、 3、 4、 5、 6 和 7 |</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>A bitmask representing the processors that the threads in the associated process can run on.</source>
          <target state="translated">位掩码，表示关联进程中的线程可以在运行的处理器。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The default depends on the number of processors on the computer.</source>
          <target state="translated">默认值取决于计算机上的处理器数。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>The default value is 2 <bpt id="p1">&lt;sup&gt;</bpt>n<ept id="p1">&lt;/sup&gt;</ept> -1, where n is the number of processors.</source>
          <target state="translated">默认值为 2 <bpt id="p1">&lt;sup&gt;</bpt>n<ept id="p1">&lt;/sup&gt;</ept> -1，其中 n 是处理器数。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>ProcessorAffinity information could not be set or retrieved from the associated process resource.</source>
          <target state="translated">无法设置或从关联的进程资源中检索 ProcessorAffinity 信息。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>-or-       The process identifier or process handle is zero.</source>
          <target state="translated">-或者-进程标识符或进程句柄为零。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>(The process has not been started.)</source>
          <target state="translated">（进程尚未启动。）</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>You are attempting to access the ProcessorAffinity property for a process that is running on a remote computer.</source>
          <target state="translated">你尝试访问在远程计算机运行的进程的 ProcessorAffinity 属性。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>The process &lt;xref:System.Diagnostics.Process.Id*&gt; was not available.</source>
          <target state="translated">进程&lt;xref:System.Diagnostics.Process.Id*&gt;不可用，因而。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>-or-       The process has exited.</source>
          <target state="translated">-或者-该进程已退出。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>Discards any information about the associated process that has been cached inside the process component.</source>
          <target state="translated">放弃已缓存到进程组件的关联进程有关的任何信息。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>After Refresh is called, the first request for information about each property causes the process component to obtain a new value from the associated process.</source>
          <target state="translated">调用刷新后，有关每个属性的信息的第一个请求将导致进程组件从关联进程中获取新值。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>When a &lt;xref:System.Diagnostics.Process&gt; component is associated with a process resource, the property values of the &lt;xref:System.Diagnostics.Process&gt; are immediately populated according to the status of the associated process.</source>
          <target state="translated">当&lt;xref:System.Diagnostics.Process&gt;组件是关联的进程资源的属性值&lt;xref:System.Diagnostics.Process&gt;立即填充根据关联的进程的状态。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>If the information about the associated process subsequently changes, those changes are not reflected in the &lt;xref:System.Diagnostics.Process&gt; component's cached values.</source>
          <target state="translated">如果随后更改有关关联的进程的信息，这些更改不会反映在&lt;xref:System.Diagnostics.Process&gt;组件的缓存值。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Diagnostics.Process&gt; component is a snapshot of the process resource at the time they are associated.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process&gt;组件时的进程资源的快照是对与其关联。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>To view the current values for the associated process, call the Refresh method.</source>
          <target state="translated">若要查看为关联进程的当前值，调用刷新方法。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the user interface of the process is responding.</source>
          <target state="translated">获取一个值，该值指示是否响应进程的用户界面。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>If a process has a user interface, the Responding property contacts the user interface to determine whether the process is responding to user input.</source>
          <target state="translated">如果进程都有一个用户界面，正在响应属性将联系来确定进程是否正在响应用户输入的用户界面。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>If the interface does not respond immediately, the Responding property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果接口未响应立即，正在响应属性返回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>Use this property to determine whether the interface of the associated process has stopped responding.</source>
          <target state="translated">使用此属性确定关联的进程的界面已停止响应。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>If the process does not have a &lt;xref:System.Diagnostics.Process.MainWindowHandle%2A&gt;, this property returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">如果进程不具有&lt;xref:System.Diagnostics.Process.MainWindowHandle%2A&gt;，此属性返回<ph id="ph1">`true`</ph>。&lt;/xref:System.Diagnostics.Process.MainWindowHandle%2A&gt;</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the user interface of the associated process is responding to the system; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果关联进程的用户界面当前响应系统，则为否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>到<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>There is no process associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">没有与此关联的进程<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>You are attempting to access the Responding property for a process that is running on a remote computer.</source>
          <target state="translated">你尝试访问在远程计算机上运行的进程的正在响应属性。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>Gets the native handle to this process.</source>
          <target state="translated">获取此进程的本机句柄。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>The handle is only available if the calling component started the process.</source>
          <target state="translated">此句柄才只有一个调用组件启动该进程。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>The native handle to this process.</source>
          <target state="translated">此进程的本机句柄。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>Gets the Terminal Services session identifier for the associated process.</source>
          <target state="translated">获取为关联进程的终端服务会话标识符。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>The SessionId property identifies the session in which the application is currently running.</source>
          <target state="translated">SessionId 属性标识在其中应用程序当前正在运行的会话。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>The Terminal Services session identifier for the associated process.</source>
          <target state="translated">关联进程的的终端服务会话标识符。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>There is no session associated with this process.</source>
          <target state="translated">没有与此进程关联会话。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>There is no process associated with this session identifier.</source>
          <target state="translated">没有与此会话标识符关联的进程。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>-or-       The associated process is not on this machine.</source>
          <target state="translated">-或者-关联的进程不在此计算机上。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>The SessionId property is not supported on Windows 98.</source>
          <target state="translated">在 Windows 98 上不支持的 SessionId 属性。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>Gets a stream used to read the error output of the application.</source>
          <target state="translated">获取用于读取应用程序的错误输出流。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>When a &lt;xref:System.Diagnostics.Process&gt; writes text to its standard error stream, that text is normally displayed on the console.</source>
          <target state="translated">当&lt;xref:System.Diagnostics.Process&gt;将文本写入其标准错误流中，通常在控制台上显示文本。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>By redirecting the StandardError stream, you can manipulate or suppress the error output of a process.</source>
          <target state="translated">通过将 StandardError 流重定向，你可以操作或取消进程的错误输出。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</source>
          <target state="translated">例如，你可以筛选文本、 格式设置不同，或将输出写入控制台和一个指定的日志文件。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  To use StandardError, you must set &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; to <ph id="ph2">`false`</ph>, and you must set &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 若要使用 StandardError，必须设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<ph id="ph2">`false`</ph>，并且必须设置&lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt;到<ph id="ph3">`true`</ph>。&lt;/xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Otherwise, reading from the StandardError stream throws an exception.</source>
          <target state="translated">否则，读取 StandardError 流将引发异常。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The redirected StandardError stream can be read synchronously or asynchronously.</source>
          <target state="translated">重定向的 StandardError 流可以同步或异步读取。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>Methods such as &lt;xref:System.IO.StreamReader.Read%2A&gt;, &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;, and &lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt; perform synchronous read operations on the error output stream of the process.</source>
          <target state="translated">等方法&lt;xref:System.IO.StreamReader.Read%2A&gt;， &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;，和&lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt;同步对执行读取的操作的错误输出流的过程。&lt;/xref:System.IO.StreamReader.ReadToEnd%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.IO.StreamReader.Read%2A&gt;</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>These synchronous read operations do not complete until the associated &lt;xref:System.Diagnostics.Process&gt; writes to its StandardError stream, or closes the stream.</source>
          <target state="translated">这些同步读取操作不会完成之前关联&lt;xref:System.Diagnostics.Process&gt;写入其 StandardError 流，或关闭流。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt; starts asynchronous read operations on the StandardError stream.</source>
          <target state="translated">与此相反，&lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;开始异步读取 StandardError 流上的操作。&lt;/xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</source>
          <target state="translated">此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>Synchronous read operations introduce a dependency between the caller reading from the StandardError stream and the child process writing to that stream.</source>
          <target state="translated">同步读取的操作引入从 StandardError 流和子进程写入该流中读取的调用方之间的依赖项。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>These dependencies can result in deadlock conditions.</source>
          <target state="translated">这些依赖关系可能会导致死锁条件。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>When the caller reads from the redirected stream of a child process, it is dependent on the child.</source>
          <target state="translated">当调用方读取子进程的重定向流时，它是依赖于子。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>The caller waits on the read operation until the child writes to the stream or closes the stream.</source>
          <target state="translated">调用方上读取操作会一直等到子写入流或关闭流。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</source>
          <target state="translated">子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</source>
          <target state="translated">子进程一直等到下一步的写入操作上的父项从完整的流中读取或关闭流。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</source>
          <target state="translated">当调用方和子进程互相等待来完成操作，并且都可以继续执行，死锁条件的结果。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>You can avoid deadlocks by evaluating dependencies between the caller and child process.</source>
          <target state="translated">可以通过评估的调用方和子进程之间的依赖关系来避免死锁。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</source>
          <target state="translated">下面的 C# 代码，例如，演示如何从重定向流中读取并等待子进程退出。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source><ph id="ph1">```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = "Write500Lines.exe";    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```</ph>       The code example avoids a deadlock condition by calling <ph id="ph2">`p.StandardError.ReadToEnd`</ph> before <ph id="ph3">`p.WaitForExit`</ph>.</source>
          <target state="translated"><ph id="ph1">```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = "Write500Lines.exe";    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```</ph>下面的代码示例通过调用来避免死锁条件<ph id="ph2">`p.StandardError.ReadToEnd`</ph>之前<ph id="ph3">`p.WaitForExit`</ph>。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>A deadlock condition can result if the parent process calls <ph id="ph1">`p.WaitForExit`</ph> before <ph id="ph2">`p.StandardError.ReadToEnd`</ph> and the child process writes enough text to fill the redirected stream.</source>
          <target state="translated">如果父进程调用会导致死锁条件<ph id="ph1">`p.WaitForExit`</ph>之前<ph id="ph2">`p.StandardError.ReadToEnd`</ph>和子进程将足够多的文本以填充重定向的流。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>The parent process would wait indefinitely for the child process to exit.</source>
          <target state="translated">父进程将无限期地等待子进程退出。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>The child process would wait indefinitely for the parent to read from the full StandardError stream.</source>
          <target state="translated">子进程将无限期地等待父以从完整 StandardError 流中读取。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>There is a similar issue when you read all text from both the standard output and standard error streams.</source>
          <target state="translated">从标准输出和标准错误流读取所有文本时类似问题。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>The following C# code, for example, performs a read operation on both streams.</source>
          <target state="translated">下面的 C# 代码，例如，执行对这两种流的读取的操作。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source><ph id="ph1">```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```</ph>       The code example avoids the deadlock condition by performing asynchronous read operations on the &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream.</source>
          <target state="translated"><ph id="ph1">```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```</ph>下面的代码示例通过执行异步上读取操作来避免死锁条件&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>A deadlock condition results if the parent process calls <ph id="ph1">`p.StandardOutput.ReadToEnd`</ph> followed by <ph id="ph2">`p.StandardError.ReadToEnd`</ph> and the child process writes enough text to fill its error stream.</source>
          <target state="translated">死锁条件结果如果父进程调用<ph id="ph1">`p.StandardOutput.ReadToEnd`</ph>跟<ph id="ph2">`p.StandardError.ReadToEnd`</ph>和子进程将足够多的文本以填充其错误流。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>The parent process would wait indefinitely for the child process to close its &lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt; stream.</source>
          <target state="translated">父进程将无限期地等待子进程以关闭其&lt;xref:System.Diagnostics.Process.StandardOutput%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardOutput%2A&gt;</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>The child process would wait indefinitely for the parent to read from the full StandardError stream.</source>
          <target state="translated">子进程将无限期地等待父以从完整 StandardError 流中读取。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</source>
          <target state="translated">异步读取的操作可用于避免这些依赖关系和其潜在的死锁。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</source>
          <target state="translated">或者，可以通过创建两个线程并读取在单独线程上的每个流的输出来避免出现死锁条件。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  You cannot mix asynchronous and synchronous read operations on a redirected stream.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 不能混合使用重定向流上的异步和同步读取的操作。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>Once the redirected stream of a &lt;xref:System.Diagnostics.Process&gt; is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</source>
          <target state="translated">一次的重定向的流&lt;xref:System.Diagnostics.Process&gt;打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>For example, do not follow &lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt; with a call to &lt;xref:System.IO.StreamReader.ReadLine%2A&gt; on the StandardError stream, or vice versa.</source>
          <target state="translated">例如，不遵循&lt;xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;通过调用&lt;xref:System.IO.StreamReader.ReadLine%2A&gt;StandardError 流上，反之亦然。&lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.Diagnostics.Process.BeginErrorReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>However, you can read two different streams in different modes.</source>
          <target state="translated">但是，你可以读取在不同模式下的两个不同的流。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>For example, you can call &lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt; and then call &lt;xref:System.IO.StreamReader.ReadLine%2A&gt; for the StandardError stream.</source>
          <target state="translated">例如，你可以调用&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;，然后调用&lt;xref:System.IO.StreamReader.ReadLine%2A&gt;为 StandardError 的流。&lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.IO.StreamReader&gt; that can be used to read the standard error stream of the application.</source>
          <target state="translated">A&lt;xref:System.IO.StreamReader&gt;可以用于读取应用程序的标准错误流。&lt;/xref:System.IO.StreamReader&gt;</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>Gets a stream used to write the input of the application.</source>
          <target state="translated">获取用于写入应用程序的输入流。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Diagnostics.Process&gt; can read input text from its standard input stream, typically the keyboard.</source>
          <target state="translated">A&lt;xref:System.Diagnostics.Process&gt;可以从其标准的输入流，通常是键盘读取输入的文本。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>By redirecting the StandardInput stream, you can programmatically specify the input.</source>
          <target state="translated">通过将 StandardInput 流重定向，你可以以编程方式指定输入。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>For example, instead of using keyboard input, you can provide text from the contents of a designated file or output from another application.</source>
          <target state="translated">例如，而不是使用键盘输入，你可以提供从指定文件的内容的文本或从另一个应用程序的输出。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  To use StandardInput, you must set &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; to <ph id="ph2">`false`</ph>, and you must set &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 若要使用 StandardInput，必须设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<ph id="ph2">`false`</ph>，并且必须设置&lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;到<ph id="ph3">`true`</ph>。&lt;/xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>Otherwise, writing to the StandardInput stream throws an exception.</source>
          <target state="translated">否则，流将写入 StandardInput 引发异常。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.IO.StreamWriter&gt; that can be used to write the standard input stream of the application.</source>
          <target state="translated">A&lt;xref:System.IO.StreamWriter&gt;可以用于写入应用程序的标准输入的流。&lt;/xref:System.IO.StreamWriter&gt;</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>The StandardInput stream has not been defined because <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> is set to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">因为尚未定义 StandardInput 流<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>设置为<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>Gets a stream used to read the textual output of the application.</source>
          <target state="translated">获取用于读取应用程序文本输出流。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>When a &lt;xref:System.Diagnostics.Process&gt; writes text to its standard stream, that text is normally displayed on the console.</source>
          <target state="translated">当&lt;xref:System.Diagnostics.Process&gt;将文本写入其标准的流，通常在控制台上显示文本。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>By redirecting the StandardOutput stream, you can manipulate or suppress the output of a process.</source>
          <target state="translated">通过将 StandardOutput 流重定向，你可以操作或取消进程的输出。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</source>
          <target state="translated">例如，你可以筛选文本、 格式设置不同，或将输出写入控制台和一个指定的日志文件。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  To use StandardOutput, you must set &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; to <ph id="ph2">`false`</ph>, and you must set &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 若要使用 StandardOutput，必须设置&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;到<ph id="ph2">`false`</ph>，并且必须设置&lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;到<ph id="ph3">`true`</ph>。&lt;/xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>Otherwise, reading from the StandardOutput stream throws an exception.</source>
          <target state="translated">否则，读取 StandardOutput 流将引发异常。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>The redirected StandardOutput stream can be read synchronously or asynchronously.</source>
          <target state="translated">重定向的 StandardOutput 流可以同步或异步读取。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>Methods such as &lt;xref:System.IO.StreamReader.Read%2A&gt;, &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;, and &lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt; perform synchronous read operations on the output stream of the process.</source>
          <target state="translated">等方法&lt;xref:System.IO.StreamReader.Read%2A&gt;， &lt;xref:System.IO.StreamReader.ReadLine%2A&gt;，和&lt;xref:System.IO.StreamReader.ReadToEnd%2A&gt;同步对执行读取的操作过程的输出流。&lt;/xref:System.IO.StreamReader.ReadToEnd%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.IO.StreamReader.Read%2A&gt;</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>These synchronous read operations do not complete until the associated &lt;xref:System.Diagnostics.Process&gt; writes to its StandardOutput stream, or closes the stream.</source>
          <target state="translated">这些同步读取操作不会完成之前关联&lt;xref:System.Diagnostics.Process&gt;写入其 StandardOutput 流，或关闭流。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt; starts asynchronous read operations on the StandardOutput stream.</source>
          <target state="translated">与此相反，&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;开始异步读取 StandardOutput 流上的操作。&lt;/xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</source>
          <target state="translated">此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Synchronous read operations introduce a dependency between the caller reading from the StandardOutput stream and the child process writing to that stream.</source>
          <target state="translated">同步读取的操作引入从 StandardOutput 流和子进程写入该流中读取的调用方之间的依赖项。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>These dependencies can result in deadlock conditions.</source>
          <target state="translated">这些依赖关系可能会导致死锁条件。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>When the caller reads from the redirected stream of a child process, it is dependent on the child.</source>
          <target state="translated">当调用方读取子进程的重定向流时，它是依赖于子。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>The caller waits on the read operation until the child writes to the stream or closes the stream.</source>
          <target state="translated">调用方上读取操作会一直等到子写入流或关闭流。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</source>
          <target state="translated">子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</source>
          <target state="translated">子进程一直等到下一步的写入操作上的父项从完整的流中读取或关闭流。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</source>
          <target state="translated">当调用方和子进程互相等待来完成操作，并且都可以继续执行，死锁条件的结果。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>You can avoid deadlocks by evaluating dependencies between the caller and child process.</source>
          <target state="translated">可以通过评估的调用方和子进程之间的依赖关系来避免死锁。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</source>
          <target state="translated">下面的 C# 代码，例如，演示如何从重定向流中读取并等待子进程退出。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source><ph id="ph1">```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = "Write500Lines.exe";   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```</ph>       The code example avoids a deadlock condition by calling <ph id="ph2">`p.StandardOutput.ReadToEnd`</ph> before <ph id="ph3">`p.WaitForExit`</ph>.</source>
          <target state="translated"><ph id="ph1">```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = "Write500Lines.exe";   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```</ph>下面的代码示例通过调用来避免死锁条件<ph id="ph2">`p.StandardOutput.ReadToEnd`</ph>之前<ph id="ph3">`p.WaitForExit`</ph>。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>A deadlock condition can result if the parent process calls <ph id="ph1">`p.WaitForExit`</ph> before <ph id="ph2">`p.StandardOutput.ReadToEnd`</ph> and the child process writes enough text to fill the redirected stream.</source>
          <target state="translated">如果父进程调用会导致死锁条件<ph id="ph1">`p.WaitForExit`</ph>之前<ph id="ph2">`p.StandardOutput.ReadToEnd`</ph>和子进程将足够多的文本以填充重定向的流。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>The parent process would wait indefinitely for the child process to exit.</source>
          <target state="translated">父进程将无限期地等待子进程退出。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>The child process would wait indefinitely for the parent to read from the full StandardOutput stream.</source>
          <target state="translated">子进程将无限期地等待父以从完整 StandardOutput 流中读取。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>There is a similar issue when you read all text from both the standard output and standard error streams.</source>
          <target state="translated">从标准输出和标准错误流读取所有文本时类似问题。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>The following C# code, for example, performs a read operation on both streams.</source>
          <target state="translated">下面的 C# 代码，例如，执行对这两种流的读取的操作。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source><ph id="ph1">```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```</ph>       The code example avoids the deadlock condition by performing asynchronous read operations on the StandardOutput stream.</source>
          <target state="translated"><ph id="ph1">```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```</ph>下面的代码示例通过执行对 StandardOutput 流异步读取的操作来避免死锁条件。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>A deadlock condition results if the parent process calls <ph id="ph1">`p.StandardOutput.ReadToEnd`</ph> followed by <ph id="ph2">`p.StandardError.ReadToEnd`</ph> and the child process writes enough text to fill its error stream.</source>
          <target state="translated">死锁条件结果如果父进程调用<ph id="ph1">`p.StandardOutput.ReadToEnd`</ph>跟<ph id="ph2">`p.StandardError.ReadToEnd`</ph>和子进程将足够多的文本以填充其错误流。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>The parent process would wait indefinitely for the child process to close its StandardOutput stream.</source>
          <target state="translated">父进程将无限期地等待子进程以关闭其 StandardOutput 流。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>The child process would wait indefinitely for the parent to read from the full &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream.</source>
          <target state="translated">子进程将无限期地等待父从完整读取&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt;</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</source>
          <target state="translated">异步读取的操作可用于避免这些依赖关系和其潜在的死锁。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</source>
          <target state="translated">或者，可以通过创建两个线程并读取在单独线程上的每个流的输出来避免出现死锁条件。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  You cannot mix asynchronous and synchronous read operations on a redirected stream.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 不能混合使用重定向流上的异步和同步读取的操作。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>Once the redirected stream of a &lt;xref:System.Diagnostics.Process&gt; is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</source>
          <target state="translated">一次的重定向的流&lt;xref:System.Diagnostics.Process&gt;打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>For example, do not follow &lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt; with a call to &lt;xref:System.IO.StreamReader.ReadLine%2A&gt; on the StandardOutput stream, or vice versa.</source>
          <target state="translated">例如，不遵循&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;通过调用&lt;xref:System.IO.StreamReader.ReadLine%2A&gt;StandardOutput 流上，反之亦然。&lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>However, you can read two different streams in different modes.</source>
          <target state="translated">但是，你可以读取在不同模式下的两个不同的流。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>For example, you can call &lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt; and then call &lt;xref:System.IO.StreamReader.ReadLine%2A&gt; for the &lt;xref:System.Diagnostics.Process.StandardError%2A&gt; stream.</source>
          <target state="translated">例如，你可以调用&lt;xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;，然后调用&lt;xref:System.IO.StreamReader.ReadLine%2A&gt;为&lt;xref:System.Diagnostics.Process.StandardError%2A&gt;流。&lt;/xref:System.Diagnostics.Process.StandardError%2A&gt; &lt;/xref:System.IO.StreamReader.ReadLine%2A&gt; &lt;/xref:System.Diagnostics.Process.BeginOutputReadLine%2A&gt;</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.IO.StreamReader&gt; that can be used to read the standard output stream of the application.</source>
          <target state="translated">A&lt;xref:System.IO.StreamReader&gt;可以用于读取应用程序的标准输出流。&lt;/xref:System.IO.StreamReader&gt;</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>Starts (or reuses) the process resource that is specified by the &lt;xref:System.Diagnostics.Process.StartInfo*&gt; property of this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component and associates it with the component.</source>
          <target state="translated">启动 （或重用） 由指定的进程资源&lt;xref:System.Diagnostics.Process.StartInfo*&gt;此属性<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件并将它与该组件关联。&lt;/xref:System.Diagnostics.Process.StartInfo*&gt;</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if a process resource is started; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if no new process resource is started (for example, if an existing process is reused).</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果启动一个进程资源;<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>如果没有新的进程资源 （例如，如果重用了现有进程） 已启动。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>No file name was specified in the <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component's &lt;xref:System.Diagnostics.Process.StartInfo<bpt id="p2">*</bpt>&gt;.       -or-       The <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> member of the &lt;xref:System.Diagnostics.Process.StartInfo<ept id="p2">*</ept>&gt; property is <bpt id="p3">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> while <ph id="ph3">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>, <ph id="ph5">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName<ph id="ph6">&amp;gt;</ph>, or <ph id="ph7">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName<ph id="ph8">&amp;gt;</ph> is <bpt id="p4">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated">中指定任何文件名<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件的&lt;&gt; <bpt id="p2">*</bpt>1&gt;。      -或- <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>的成员&lt;&gt; <ept id="p2">*</ept>1&gt; 属性是<bpt id="p3">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>时<ph id="ph3">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>， <ph id="ph5">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName<ph id="ph6">&amp;gt;</ph>，或<ph id="ph7">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName<ph id="ph8">&amp;gt;</ph>是<bpt id="p4">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>There was an error in opening the associated file.</source>
          <target state="translated">打开关联的文件时出错。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>The process object has already been disposed.</source>
          <target state="translated">已释放此进程对象。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component.</source>
          <target state="translated">启动由包含进程启动信息 （例如，要启动的进程的文件名称） 的参数指定的进程资源和将资源与新关联<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Diagnostics.ProcessStartInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the information that is used to start the process, including the file name and any command-line arguments.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Diagnostics.ProcessStartInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> ，包含用于启动进程，包括文件名和任何命令行自变量的信息。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>A new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is associated with the process resource, or <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if no process resource is started.</source>
          <target state="translated">一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>的进程资源，与该键相关联或<bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>如果未启动进程。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</source>
          <target state="translated">请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>In addition, Start may return a non-null Process with its &lt;xref:System.Diagnostics.Process.HasExited*&gt; property already set to <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">此外，启动可能返回非 null 进程其&lt;xref:System.Diagnostics.Process.HasExited*&gt;属性已设置为<bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。&lt;/xref:System.Diagnostics.Process.HasExited*&gt;</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>In this case, the started process may have activated an existing instance of itself and then exited.</source>
          <target state="translated">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>No file name was specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startInfo</ph><ept id="p1">&lt;/code&gt;</ept> parameter's &lt;xref:System.Diagnostics.ProcessStartInfo.FileName<bpt id="p2">*</bpt>&gt; property.       -or-       The &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute<ept id="p2">*</ept>&gt; property of the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph2">startInfo</ph><ept id="p3">&lt;/code&gt;</ept> parameter is <bpt id="p4">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept> and the &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput<bpt id="p5">*</bpt>&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput<ept id="p5">*</ept>&gt;, or &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError<bpt id="p6">*</bpt>&gt; property is also <bpt id="p7">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p7">&lt;/xref&gt;</ept>.       -or-       The &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute<ept id="p6">*</ept>&gt; property of the <bpt id="p8">&lt;code&gt;</bpt><ph id="ph3">startInfo</ph><ept id="p8">&lt;/code&gt;</ept> parameter is <bpt id="p9">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p9">&lt;/xref&gt;</ept> and the &lt;xref:System.Diagnostics.ProcessStartInfo.UserName<bpt id="p10">*</bpt>&gt; property is not <bpt id="p11">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p11">&lt;/xref&gt;</ept> or empty or the &lt;xref:System.Diagnostics.ProcessStartInfo.Password<ept id="p10">*</ept>&gt; property is not <bpt id="p12">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p12">&lt;/xref&gt;</ept>.</source>
          <target state="translated">中指定任何文件名<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">startInfo</ph> <ept id="p1">&lt;/code&gt;</ept>参数的&lt;&gt; <bpt id="p2">*</bpt>1&gt; 属性。      -or-       The &lt;&gt;<ept id="p2">*</ept>&gt; property of the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph2">startInfo</ph><ept id="p3">&lt;/code&gt;</ept> parameter is <bpt id="p4">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept> and the &lt;&gt;<bpt id="p5">*</bpt>&gt;, &lt;&gt;<ept id="p5">*</ept>&gt;, or &lt;&gt;<bpt id="p6">*</bpt>&gt; property is also <bpt id="p7">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p7">&lt;/xref&gt;</ept>.      -或- &lt;&gt; &lt;/&gt; <ept id="p6">*</ept>1&gt; 属性<bpt id="p8">&lt;code&gt;</bpt> <ph id="ph3">startInfo</ph> <ept id="p8">&lt;/code&gt;</ept>参数是<bpt id="p9">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p9">&lt;/xref&gt;</ept>和&lt;&gt; <bpt id="p10">*</bpt>1&gt; 属性不是<bpt id="p11">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p11">&lt;/xref&gt;</ept>或为空或&lt;&gt; <ept id="p10">*</ept>1&gt; 属性不是<bpt id="p12">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p12">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startInfo</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startInfo</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>The process object has already been disposed.</source>
          <target state="translated">已释放此进程对象。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>The file specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startInfo</ph><ept id="p1">&lt;/code&gt;</ept> parameter's &lt;xref:System.Diagnostics.ProcessStartInfo.FileName*&gt; property could not be found.</source>
          <target state="translated">中指定的文件<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">startInfo</ph> <ept id="p1">&lt;/code&gt;</ept>参数的&lt;xref:System.Diagnostics.ProcessStartInfo.FileName*&gt;找不到属性。&lt;/xref:System.Diagnostics.ProcessStartInfo.FileName*&gt;</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>An error occurred when opening the associated file.</source>
          <target state="translated">打开关联的文件时出错。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>-or-       The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</source>
          <target state="translated">-或者-自变量的长度与进程的完整路径的长度的总和超过了 2080年。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</source>
          <target state="translated">与此异常关联的错误消息可以是以下之一:"传递到系统调用的数据区域是太小"。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>or "Access is denied."</source>
          <target state="translated">或者"访问被拒绝"。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>Starts a process resource by specifying the name of a document or application file and associates the resource with a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component.</source>
          <target state="translated">通过指定文档或应用程序文件的名称来启动一个进程资源和将资源与新关联<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The name of a document or application file to run in the process.</source>
          <target state="translated">要在进程中运行的文档或应用程序文件的名称。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>A new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is associated with the process resource, or <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if no process resource is started.</source>
          <target state="translated">一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>的进程资源，与该键相关联或<bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>如果未启动进程。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</source>
          <target state="translated">请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>In addition, Start may return a non-null Process with its &lt;xref:System.Diagnostics.Process.HasExited*&gt; property already set to <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">此外，启动可能返回非 null 进程其&lt;xref:System.Diagnostics.Process.HasExited*&gt;属性已设置为<bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。&lt;/xref:System.Diagnostics.Process.HasExited*&gt;</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>In this case, the started process may have activated an existing instance of itself and then exited.</source>
          <target state="translated">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>An error occurred when opening the associated file.</source>
          <target state="translated">打开关联的文件时出错。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>The process object has already been disposed.</source>
          <target state="translated">已释放此进程对象。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>The PATH environment variable has a string containing quotes.</source>
          <target state="translated">PATH 环境变量具有一个包含引号的字符串。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component.</source>
          <target state="translated">通过指定应用程序的名称和一组命令行自变量，来启动一个进程资源并将资源与新关联<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>The name of an application file to run in the process.</source>
          <target state="translated">在进程中运行的应用程序文件的名称。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">若要启动进程时传递的命令行参数。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>A new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is associated with the process resource, or <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if no process resource is started.</source>
          <target state="translated">一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>的进程资源，与该键相关联或<bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>如果未启动进程。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</source>
          <target state="translated">请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>In addition, Start may return a non-null Process with its &lt;xref:System.Diagnostics.Process.HasExited*&gt; property already set to <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">此外，启动可能返回非 null 进程其&lt;xref:System.Diagnostics.Process.HasExited*&gt;属性已设置为<bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。&lt;/xref:System.Diagnostics.Process.HasExited*&gt;</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>In this case, the started process may have activated an existing instance of itself and then exited.</source>
          <target state="translated">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileName</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arguments</ph><ept id="p2">&lt;/code&gt;</ept> parameter is <bpt id="p3">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileName</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arguments</ph><ept id="p2">&lt;/code&gt;</ept> parameter is <bpt id="p3">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>An error occurred when opening the associated file.</source>
          <target state="translated">打开关联的文件时出错。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>-or-       The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</source>
          <target state="translated">-或者-自变量的长度与进程的完整路径的长度的总和超过了 2080年。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</source>
          <target state="translated">与此异常关联的错误消息可以是以下之一:"传递到系统调用的数据区域是太小"。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>or "Access is denied."</source>
          <target state="translated">或者"访问被拒绝"。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>The process object has already been disposed.</source>
          <target state="translated">已释放此进程对象。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>The PATH environment variable has a string containing quotes.</source>
          <target state="translated">PATH 环境变量具有一个包含引号的字符串。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component.</source>
          <target state="translated">通过指定应用程序的名称、 用户名、 密码和域来启动一个进程资源和将资源与新关联<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>Use this overload to create a new process and its primary thread by specifying its file name, user name, password, and domain.</source>
          <target state="translated">使用此重载来通过指定其文件名称、 用户名、 密码和域中创建新的进程和其主线程。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</source>
          <target state="translated">然后，新进程指定的凭据 （用户、 域和密码） 的安全上下文中运行指定的可执行文件。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 时可执行文件位于远程驱动器上，你必须通过使用统一资源标识符 (URI)，不链接的驱动器号来确定网络共享。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the address of the executable file to start is a URL, the process is not started and <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 如果要启动的可执行文件的地址是 URL，则不会启动进程和<ph id="ph2">`null`</ph>返回。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>This overload lets you start a process without first creating a new &lt;xref:System.Diagnostics.Process&gt; instance.</source>
          <target state="translated">此重载使你无需首先创建一个新启动的进程&lt;xref:System.Diagnostics.Process&gt;实例。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>The overload is an alternative to the explicit steps of creating a new &lt;xref:System.Diagnostics.Process&gt; instance, setting the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.UserName%2A&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.Password%2A&gt;, and &lt;xref:System.Diagnostics.ProcessStartInfo.Domain%2A&gt; properties of the &lt;xref:System.Diagnostics.Process.StartInfo%2A&gt; property, and calling &lt;xref:System.Diagnostics.Process.Start%2A&gt; for the &lt;xref:System.Diagnostics.Process&gt; instance.</source>
          <target state="translated">该重载是创建一个新的显式步骤的替代方法&lt;xref:System.Diagnostics.Process&gt;实例，设置&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;， &lt;xref:System.Diagnostics.ProcessStartInfo.UserName%2A&gt;， &lt;xref:System.Diagnostics.ProcessStartInfo.Password%2A&gt;，和&lt;xref:System.Diagnostics.ProcessStartInfo.Domain%2A&gt;属性&lt;xref:System.Diagnostics.Process.StartInfo%2A&gt;属性，再调用&lt;xref:System.Diagnostics.Process.Start%2A&gt;为&lt;xref:System.Diagnostics.Process&gt;实例。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Start%2A&gt; &lt;/xref:System.Diagnostics.Process.StartInfo%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.Domain%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.Password%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.UserName%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>Similarly, in the same way that the <bpt id="p1">**</bpt>Run<ept id="p1">**</ept> dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <ph id="ph1">`fileName`</ph> parameter.</source>
          <target state="translated">同样，在相同的方式<bpt id="p1">**</bpt>运行<ept id="p1">**</ept>对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选<ph id="ph1">`fileName`</ph>参数。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>For example, you can set the <ph id="ph1">`fileName`</ph> parameter to either "Notepad.exe" or "Notepad".</source>
          <target state="translated">例如，你可以设置<ph id="ph1">`fileName`</ph>参数以"Notepad.exe"或"记事本"。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`fileName`</ph> parameter represents an executable file, the <ph id="ph2">`arguments`</ph> parameter might represent a file to act upon, such as the text file in <ph id="ph3">`Notepad.exe myfile.txt`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`fileName`</ph>参数表示一个可执行文件，<ph id="ph2">`arguments`</ph>参数可能表示要执行操作，例如文本文件中的文件<ph id="ph3">`Notepad.exe myfile.txt`</ph>。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The file name must represent an executable file in the &lt;xref:System.Diagnostics.Process.Start%2A&gt; overloads that have <ph id="ph2">`userName`</ph>, <ph id="ph3">`password`</ph>, and <ph id="ph4">`domain`</ph> parameters.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 的文件名称必须表示中的可执行文件&lt;xref:System.Diagnostics.Process.Start%2A&gt;具有重载<ph id="ph2">`userName`</ph>， <ph id="ph3">`password`</ph>，和<ph id="ph4">`domain`</ph>参数。&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>Whenever you use &lt;xref:System.Diagnostics.Process.Start%2A&gt; to start a process, you might need to close it or you risk losing system resources.</source>
          <target state="translated">无论何时使用&lt;xref:System.Diagnostics.Process.Start%2A&gt;若要启动进程时，你可能需要将其关闭或冒系统资源。&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>Close processes using &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; or &lt;xref:System.Diagnostics.Process.Kill%2A&gt;.</source>
          <target state="translated">关闭进程使用&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;或&lt;xref:System.Diagnostics.Process.Kill%2A&gt;.&lt;/xref:System.Diagnostics.Process.Kill%2A&gt; &lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>You can check whether a process has already been closed by using its &lt;xref:System.Diagnostics.Process.HasExited%2A&gt; property..</source>
          <target state="translated">你可以检查是否已关闭进程通过其&lt;xref:System.Diagnostics.Process.HasExited%2A&gt;属性...&lt;/xref:System.Diagnostics.Process.HasExited%2A&gt;</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The name of an application file to run in the process.</source>
          <target state="translated">在进程中运行的应用程序文件的名称。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>The user name to use when starting the process.</source>
          <target state="translated">启动进程时要使用的用户名。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Security.SecureString"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the password to use when starting the process.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Security.SecureString"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>包含启动进程时要使用的密码。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>The domain to use when starting the process.</source>
          <target state="translated">要启动该进程时使用的域。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>A new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is associated with the process resource, or <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if no process resource is started.</source>
          <target state="translated">一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>的进程资源，与该键相关联或<bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>如果未启动进程。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</source>
          <target state="translated">请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>In addition, Start may return a non-null Process with its &lt;xref:System.Diagnostics.Process.HasExited*&gt; property already set to <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">此外，启动可能返回非 null 进程其&lt;xref:System.Diagnostics.Process.HasExited*&gt;属性已设置为<bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。&lt;/xref:System.Diagnostics.Process.HasExited*&gt;</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>In this case, the started process may have activated an existing instance of itself and then exited.</source>
          <target state="translated">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>No file name was specified.</source>
          <target state="translated">不指定任何文件名。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>There was an error in opening the associated file.</source>
          <target state="translated">打开关联的文件时出错。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>The process object has already been disposed.</source>
          <target state="translated">已释放此进程对象。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component.</source>
          <target state="translated">通过指定应用程序、 一组命令行自变量、 用户名、 密码和域的名称来启动一个进程资源和将资源与新关联<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>Use this overload to create a new process and its primary thread by specifying its file name, command-line arguments, user name, password, and domain.</source>
          <target state="translated">使用此重载来通过指定其文件名、 命令行自变量、 用户名、 密码和域中创建新的进程和其主线程。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</source>
          <target state="translated">然后，新进程指定的凭据 （用户、 域和密码） 的安全上下文中运行指定的可执行文件。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 时可执行文件位于远程驱动器上，你必须通过使用统一资源标识符 (URI)，不链接的驱动器号来确定网络共享。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the address of the executable file to start is a URL, the process is not started and <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 如果要启动的可执行文件的地址是 URL，则不会启动进程和<ph id="ph2">`null`</ph>返回。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>This overload lets you start a process without first creating a new &lt;xref:System.Diagnostics.Process&gt; instance.</source>
          <target state="translated">此重载使你无需首先创建一个新启动的进程&lt;xref:System.Diagnostics.Process&gt;实例。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>The overload is an alternative to the explicit steps of creating a new &lt;xref:System.Diagnostics.Process&gt; instance, setting the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.Arguments%2A&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.UserName%2A&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.Password%2A&gt;, and &lt;xref:System.Diagnostics.ProcessStartInfo.Domain%2A&gt; properties of the &lt;xref:System.Diagnostics.Process.StartInfo%2A&gt; property, and calling &lt;xref:System.Diagnostics.Process.Start%2A&gt; for the &lt;xref:System.Diagnostics.Process&gt; instance.</source>
          <target state="translated">该重载是创建一个新的显式步骤的替代方法&lt;xref:System.Diagnostics.Process&gt;实例，设置&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;， &lt;xref:System.Diagnostics.ProcessStartInfo.Arguments%2A&gt;， &lt;xref:System.Diagnostics.ProcessStartInfo.UserName%2A&gt;， &lt;xref:System.Diagnostics.ProcessStartInfo.Password%2A&gt;，和&lt;xref:System.Diagnostics.ProcessStartInfo.Domain%2A&gt;属性&lt;xref:System.Diagnostics.Process.StartInfo%2A&gt;属性，再调用&lt;xref:System.Diagnostics.Process.Start%2A&gt;为&lt;xref:System.Diagnostics.Process&gt;实例。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Start%2A&gt; &lt;/xref:System.Diagnostics.Process.StartInfo%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.Domain%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.Password%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.UserName%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.Arguments%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>Similarly, in the same way that the <bpt id="p1">**</bpt>Run<ept id="p1">**</ept> dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <ph id="ph1">`fileName`</ph> parameter.</source>
          <target state="translated">同样，在相同的方式<bpt id="p1">**</bpt>运行<ept id="p1">**</ept>对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选<ph id="ph1">`fileName`</ph>参数。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>For example, you can set the <ph id="ph1">`fileName`</ph> parameter to either "Notepad.exe" or "Notepad".</source>
          <target state="translated">例如，你可以设置<ph id="ph1">`fileName`</ph>参数以"Notepad.exe"或"记事本"。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`fileName`</ph> parameter represents an executable file, the <ph id="ph2">`arguments`</ph> parameter might represent a file to act upon, such as the text file in <ph id="ph3">`Notepad.exe myfile.txt`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`fileName`</ph>参数表示一个可执行文件，<ph id="ph2">`arguments`</ph>参数可能表示要执行操作，例如文本文件中的文件<ph id="ph3">`Notepad.exe myfile.txt`</ph>。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The file name must represent an executable file in the &lt;xref:System.Diagnostics.Process.Start%2A&gt; overloads that have <ph id="ph2">`userName`</ph>, <ph id="ph3">`password`</ph>, and <ph id="ph4">`domain`</ph> parameters.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph>&amp;1;&gt; 的文件名称必须表示中的可执行文件&lt;xref:System.Diagnostics.Process.Start%2A&gt;具有重载<ph id="ph2">`userName`</ph>， <ph id="ph3">`password`</ph>，和<ph id="ph4">`domain`</ph>参数。&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>Whenever you use &lt;xref:System.Diagnostics.Process.Start%2A&gt; to start a process, you might need to close it or you risk losing system resources.</source>
          <target state="translated">无论何时使用&lt;xref:System.Diagnostics.Process.Start%2A&gt;若要启动进程时，你可能需要将其关闭或冒系统资源。&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>Close processes using &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; or &lt;xref:System.Diagnostics.Process.Kill%2A&gt;.</source>
          <target state="translated">关闭进程使用&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;或&lt;xref:System.Diagnostics.Process.Kill%2A&gt;.&lt;/xref:System.Diagnostics.Process.Kill%2A&gt; &lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>You can check whether a process has already been closed by using its &lt;xref:System.Diagnostics.Process.HasExited%2A&gt; property..</source>
          <target state="translated">你可以检查是否已关闭进程通过其&lt;xref:System.Diagnostics.Process.HasExited%2A&gt;属性...&lt;/xref:System.Diagnostics.Process.HasExited%2A&gt;</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>The name of an application file to run in the process.</source>
          <target state="translated">在进程中运行的应用程序文件的名称。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">若要启动进程时传递的命令行参数。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>The user name to use when starting the process.</source>
          <target state="translated">启动进程时要使用的用户名。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Security.SecureString"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the password to use when starting the process.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Security.SecureString"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>包含启动进程时要使用的密码。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>The domain to use when starting the process.</source>
          <target state="translated">要启动该进程时使用的域。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>A new <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is associated with the process resource, or <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if no process resource is started.</source>
          <target state="translated">一个新<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>的进程资源，与该键相关联或<bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>如果未启动进程。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</source>
          <target state="translated">请注意，与已在运行同一进程的实例一起启动的新进程将独立于其他。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>In addition, Start may return a non-null Process with its &lt;xref:System.Diagnostics.Process.HasExited*&gt; property already set to <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">此外，启动可能返回非 null 进程其&lt;xref:System.Diagnostics.Process.HasExited*&gt;属性已设置为<bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。&lt;/xref:System.Diagnostics.Process.HasExited*&gt;</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>In this case, the started process may have activated an existing instance of itself and then exited.</source>
          <target state="translated">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>No file name was specified.</source>
          <target state="translated">不指定任何文件名。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>An error occurred when opening the associated file.</source>
          <target state="translated">打开关联的文件时出错。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>-or-       The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080.</source>
          <target state="translated">-或者-自变量的长度与该关联文件的完整路径的长度的总和超过了 2080年。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</source>
          <target state="translated">与此异常关联的错误消息可以是以下之一:"传递到系统调用的数据区域是太小"。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>or "Access is denied."</source>
          <target state="translated">或者"访问被拒绝"。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source>The process object has already been disposed.</source>
          <target state="translated">已释放此进程对象。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>Gets or sets the properties to pass to the &lt;xref:System.Diagnostics.Process.Start*&gt; method of the <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">获取或设置属性以传递给&lt;xref:System.Diagnostics.Process.Start*&gt;方法<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。&lt;/xref:System.Diagnostics.Process.Start*&gt;</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>StartInfo represents the set of parameters to use to start a process.</source>
          <target state="translated">StartInfo 表示要用于启动过程的参数集。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>When &lt;xref:System.Diagnostics.Process.Start%2A&gt; is called, the StartInfo is used to specify the process to start.</source>
          <target state="translated">当&lt;xref:System.Diagnostics.Process.Start%2A&gt;是调用，StartInfo 用于指定要启动的进程。&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source>The only necessary StartInfo member to set is the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; property.</source>
          <target state="translated">仅将必需的 StartInfo 成员，设置是&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;属性。&lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>Starting a process by specifying the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; property is similar to typing the information in the <bpt id="p1">**</bpt>Run<ept id="p1">**</ept> dialog box of the Windows <bpt id="p2">**</bpt>Start<ept id="p2">**</ept> menu.</source>
          <target state="translated">通过指定启动进程&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;属性是类似于键入中的信息<bpt id="p1">**</bpt>运行<ept id="p1">**</ept>对话框中的 windows<bpt id="p2">**</bpt>启动<ept id="p2">**</ept>菜单。&lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>Therefore, the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; property does not need to represent an executable file.</source>
          <target state="translated">因此，&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;属性不需要表示一个可执行文件。&lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>It can be of any file type for which the extension has been associated with an application installed on the system.</source>
          <target state="translated">它可以是为其扩展已关联与应用程序在系统上安装任何文件类型。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>For example the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</source>
          <target state="translated">例如&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;可以具有.txt 扩展名，如果你具有使用编辑器 （如记事本） 相关联的文本文件或者如果你已经将提供一个文字处理的工具，如 Microsoft Word 的文本文件，也可能产生.doc。&lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>Similarly, in the same way that the <bpt id="p1">**</bpt>Run<ept id="p1">**</ept> dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; member.</source>
          <target state="translated">同样，在相同的方式<bpt id="p1">**</bpt>运行<ept id="p1">**</ept>对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;成员。&lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>For example, you can set the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; property to either "Notepad.exe" or "Notepad".</source>
          <target state="translated">例如，你可以设置&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;属性设置为"Notepad.exe"或"记事本"。&lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>You can start a ClickOnce application by setting the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; property to the location (for example, a Web address) from which you originally installed the application.</source>
          <target state="translated">您可以通过设置启动 ClickOnce 应用程序&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;最初从中安装应用程序的位置 （例如，Web 地址） 的属性。&lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source>Do not start a ClickOnce application by specifying its installed location on your hard drive.</source>
          <target state="translated">不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>If the file name involves a nonexecutable file, such as a .doc file, you can include a verb specifying what action to take on the file.</source>
          <target state="translated">如果文件名涉及非可执行文件，例如.doc 文件，你可以包括一个谓词指定要对该文件执行的操作。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>For example, you could set the &lt;xref:System.Diagnostics.ProcessStartInfo.Verb%2A&gt; to "Print" for a file ending in the .doc extension.</source>
          <target state="translated">例如，你可以设置&lt;xref:System.Diagnostics.ProcessStartInfo.Verb%2A&gt;到以.doc 扩展名的文件的"打印"。&lt;/xref:System.Diagnostics.ProcessStartInfo.Verb%2A&gt;</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>The file name specified in the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; property does not need to have an extension if you manually enter a value for the &lt;xref:System.Diagnostics.ProcessStartInfo.Verb%2A&gt; property.</source>
          <target state="translated">中指定的文件名称&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;属性不需要具有扩展名，如果你手动输入的值&lt;xref:System.Diagnostics.ProcessStartInfo.Verb%2A&gt;属性。&lt;/xref:System.Diagnostics.ProcessStartInfo.Verb%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>However, if you use the &lt;xref:System.Diagnostics.ProcessStartInfo.Verbs%2A&gt; property to determine what verbs are available, you must include the extension.</source>
          <target state="translated">但是，如果你使用&lt;xref:System.Diagnostics.ProcessStartInfo.Verbs%2A&gt;属性来确定哪些谓词的可用，必须包括扩展名。&lt;/xref:System.Diagnostics.ProcessStartInfo.Verbs%2A&gt;</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>You can change the parameters specified in the StartInfo property up to the time that you call the &lt;xref:System.Diagnostics.Process.Start%2A&gt; method on the process.</source>
          <target state="translated">你可以更改在你调用的时间 StartInfo 属性中指定的参数&lt;xref:System.Diagnostics.Process.Start%2A&gt;方法的过程。&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>After you start the process, changing the StartInfo values does not affect or restart the associated process.</source>
          <target state="translated">启动过程后，更改 StartInfo 值不会影响或重新启动关联的进程。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>If you call the &lt;xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29&gt; method with the &lt;xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName&gt; and &lt;xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName&gt; properties set, the unmanaged <ph id="ph1">`CreateProcessWithLogonW`</ph> function is called, which starts the process in a new window even if the &lt;xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A&gt; property value is <ph id="ph2">`true`</ph> or the &lt;xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A&gt; property value is &lt;xref:System.Diagnostics.ProcessWindowStyle&gt;.</source>
          <target state="translated">如果调用&lt;xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29&gt;方法替换&lt;xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName&gt;和&lt;xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName&gt;属性集，则非托管<ph id="ph1">`CreateProcessWithLogonW`</ph>调用函数，以启动该过程在新窗口即使&lt;xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A&gt;属性值是<ph id="ph2">`true`</ph>或&lt;xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A&gt;属性值为&lt;xref:System.Diagnostics.ProcessWindowStyle&gt;。&lt;/xref:System.Diagnostics.ProcessWindowStyle&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName&gt; &lt;/xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29&gt;</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>If you did not use the &lt;xref:System.Diagnostics.Process.Start%2A&gt; method to start a process, the StartInfo property does not reflect the parameters used to start the process.</source>
          <target state="translated">如果你未使用&lt;xref:System.Diagnostics.Process.Start%2A&gt;方法来启动一个进程，StartInfo 属性不会反映用于启动进程的参数。&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>For example, if you use &lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt; to get an array of processes running on the computer, the StartInfo property of each &lt;xref:System.Diagnostics.Process&gt; does not contain the original file name or arguments used to start the process.</source>
          <target state="translated">例如，如果你使用&lt;xref:System.Diagnostics.Process.GetProcesses%2A&gt;获取进程运行的计算机上，每个 StartInfo 属性的数组&lt;xref:System.Diagnostics.Process&gt;不包含的原始文件名或用于启动进程的自变量。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.GetProcesses%2A&gt;</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>When the process is started, the file name is the file that populates the (read-only) &lt;xref:System.Diagnostics.Process.MainModule%2A&gt; property.</source>
          <target state="translated">当启动进程时，文件名是填充 （只读） 的文件&lt;xref:System.Diagnostics.Process.MainModule%2A&gt;属性。&lt;/xref:System.Diagnostics.Process.MainModule%2A&gt;</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the executable file that is associated with the process after the process has started, use the &lt;xref:System.Diagnostics.Process.MainModule%2A&gt; property.</source>
          <target state="translated">如果你想要检索进程启动后与进程相关联的可执行文件，请使用&lt;xref:System.Diagnostics.Process.MainModule%2A&gt;属性。&lt;/xref:System.Diagnostics.Process.MainModule%2A&gt;</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>If you want to set the executable file of a &lt;xref:System.Diagnostics.Process&gt; instance for which an associated process has not been started, use the StartInfo property's &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; member.</source>
          <target state="translated">如果你想要设置的可执行文件&lt;xref:System.Diagnostics.Process&gt;实例为其关联的进程尚未启动，请使用 StartInfo 属性&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;成员。&lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>Because the members of the StartInfo property are arguments that are passed to the &lt;xref:System.Diagnostics.Process.Start%2A&gt; method of a process, changing the &lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; property after the associated process has started will not reset the &lt;xref:System.Diagnostics.Process.MainModule%2A&gt; property.</source>
          <target state="translated">因为 StartInfo 属性的成员是自变量传递给&lt;xref:System.Diagnostics.Process.Start%2A&gt;方法的过程中，更改&lt;xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt;属性关联的进程启动后将不会重置&lt;xref:System.Diagnostics.Process.MainModule%2A&gt;属性。&lt;/xref:System.Diagnostics.Process.MainModule%2A&gt; &lt;/xref:System.Diagnostics.ProcessStartInfo.FileName%2A&gt; &lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>These properties are used only to initialize the associated process.</source>
          <target state="translated">这些属性仅用于初始化关联的进程。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Diagnostics.ProcessStartInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that represents the data with which to start the process.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Diagnostics.ProcessStartInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>表示启动进程使用的数据。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source>These arguments include the name of the executable file or document used to start the process.</source>
          <target state="translated">这些参数包括的可执行文件或用于启动进程的文档的名称。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>The value that specifies the StartInfo is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">用于指定 StartInfo 的值是<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>Gets the time that the associated process was started.</source>
          <target state="translated">获取关联的进程启动的时间。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>An object  that indicates when the process started.</source>
          <target state="translated">一个对象，指示进程启动的时间。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>An exception is thrown if the process is not running.</source>
          <target state="translated">如果进程未运行，将引发异常。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>You are attempting to access the StartTime property for a process that is running on a remote computer.</source>
          <target state="translated">你尝试访问在远程计算机运行的进程的 StartTime 属性。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source>The process has exited.</source>
          <target state="translated">该进程已退出。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source>-or-       The process has not been started.</source>
          <target state="translated">-或者-尚未启动进程。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source>An error occurred in the call to the Windows function.</source>
          <target state="translated">对 Windows 函数的调用中出错。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</source>
          <target state="translated">获取或设置用于封送由于进程退出事件而发出的事件处理程序调用的对象。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source>When &lt;xref:System.Diagnostics.EventLog.SynchronizingObject%2A&gt; is <ph id="ph1">`null`</ph>, methods that handle the &lt;xref:System.Diagnostics.Process.Exited&gt; event are called on a thread from the system thread pool.</source>
          <target state="translated">当&lt;xref:System.Diagnostics.EventLog.SynchronizingObject%2A&gt;是<ph id="ph1">`null`</ph>，方法，用于处理&lt;xref:System.Diagnostics.Process.Exited&gt;事件调用从系统线程池线程上。&lt;/xref:System.Diagnostics.Process.Exited&gt; &lt;/xref:System.Diagnostics.EventLog.SynchronizingObject%2A&gt;</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>For more information about system thread pools, see &lt;xref:System.Threading.ThreadPool&gt;.</source>
          <target state="translated">有关系统线程池的详细信息，请参阅&lt;xref:System.Threading.ThreadPool&gt;。&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>When the &lt;xref:System.Diagnostics.Process.Exited&gt; event is handled by a visual Windows Forms component, such as a &lt;xref:System.Windows.Forms.Button&gt;, accessing the component through the system thread pool might not work, or might result in an exception.</source>
          <target state="translated">当&lt;xref:System.Diagnostics.Process.Exited&gt;事件由 visual 的 Windows 窗体组件，如处理&lt;xref:System.Windows.Forms.Button&gt;，通过系统线程池访问组件可能不起作用，或者可能会导致异常。&lt;/xref:System.Windows.Forms.Button&gt; &lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source>Avoid this by setting SynchronizingObject to a Windows Forms component, which causes the methods handling the &lt;xref:System.Diagnostics.Process.Exited&gt; event to be called on the same thread on which the component was created.</source>
          <target state="translated">通过设置 SynchronizingObject 到 Windows 窗体组件时，这会导致处理的方法来避免这&lt;xref:System.Diagnostics.Process.Exited&gt;事件在其创建该组件在同一线程上调用。&lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve">
          <source>If the &lt;xref:System.Diagnostics.Process&gt; is used inside <ph id="ph1">[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]</ph> in a Windows Forms designer, SynchronizingObject is automatically set to the control that contains the &lt;xref:System.Diagnostics.Process&gt;.</source>
          <target state="translated">如果&lt;xref:System.Diagnostics.Process&gt;在内部使用<ph id="ph1">[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]</ph>在 Windows 窗体设计器中，SynchronizingObject 自动设置为该控件包含&lt;xref:System.Diagnostics.Process&gt;.&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve">
          <source>For example, if you place a &lt;xref:System.Diagnostics.Process&gt; on a designer for <ph id="ph1">`Form1`</ph> (which inherits from &lt;xref:System.Windows.Forms.Form&gt;) the SynchronizingObject property of &lt;xref:System.Diagnostics.Process&gt; is set to the instance of <ph id="ph2">`Form1`</ph>:       <bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Process_SynchronizingObject#2<ept id="p2">](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>Process_SynchronizingObject#2<ept id="p4">](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Process_SynchronizingObject#2<ept id="p6">](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb)</ept><ept id="p5">]</ept>       Typically, this property is set when the component is placed inside a control or form, because those components are bound to a specific thread.</source>
          <target state="translated">例如，如果你将放置&lt;xref:System.Diagnostics.Process&gt;的设计器上<ph id="ph1">`Form1`</ph>(其继承自&lt;xref:System.Windows.Forms.Form&gt;) 的 SynchronizingObject 属性&lt;xref:System.Diagnostics.Process&gt;设置为的实例<ph id="ph2">`Form1`</ph>: <bpt id="p1">[!code-cpp</bpt> <bpt id="p2">[</bpt>Process_SynchronizingObject&amp;#2;<ept id="p2">](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)</ept><ept id="p1">]</ept><bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>Process_SynchronizingObject&amp;#2;<ept id="p4">](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)</ept><ept id="p3">]</ept><bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Process_SynchronizingObject&amp;#2;<ept id="p6">](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb)</ept> <ept id="p5">]</ept>通常情况下，设置此属性时该组件放置在控件或窗体中，因为这些组件绑定到特定线程。    &lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Windows.Forms.Form&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.ComponentModel.ISynchronizeInvoke"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to marshal event handler calls that are issued as a result of an <bpt id="p2">&lt;xref href="System.Diagnostics.Process.Exited"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> event on the process.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.ComponentModel.ISynchronizeInvoke"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>用于封送的结果发出的事件处理程序调用<bpt id="p2">&lt;xref href="System.Diagnostics.Process.Exited"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>进程上的事件。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve">
          <source>Gets the set of threads that are running in the associated process.</source>
          <target state="translated">获取在关联进程中运行的线程的集。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source>A thread executes code in a process.</source>
          <target state="translated">线程在进程中执行代码。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>Each process is started with a single thread, its primary thread.</source>
          <target state="translated">每个进程开始使用单线程，其主线程。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>Any thread can create additional threads.</source>
          <target state="translated">任何线程可以创建其他线程。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>Threads within a process share the address space of the process.</source>
          <target state="translated">在一个进程内的线程都共享进程的地址空间。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Diagnostics.ProcessThread&gt; to get all the threads associated with the current process.</source>
          <target state="translated">使用&lt;xref:System.Diagnostics.ProcessThread&gt;可获取与当前进程关联的所有线程。&lt;/xref:System.Diagnostics.ProcessThread&gt;</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>The primary thread is not necessarily at index zero in the array.</source>
          <target state="translated">主线程不一定是位于索引零数组中。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source>An array of type <bpt id="p1">&lt;xref href="System.Diagnostics.ProcessThread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the operating system threads currently running in the associated process.</source>
          <target state="translated">类型的数组<bpt id="p1">&lt;xref href="System.Diagnostics.ProcessThread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>表示操作系统线程当前在关联进程中运行。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source>The process does not have an &lt;xref:System.Diagnostics.Process.Id*&gt;, or no process is associated with the <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance.</source>
          <target state="translated">进程不具有&lt;xref:System.Diagnostics.Process.Id*&gt;，与关联的进程或<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>实例。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>-or-       The associated process has exited.</source>
          <target state="translated">-或者-关联的进程已退出。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> to <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to access this property on Windows 98 and Windows Me.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me);设置<ph id="ph1">&amp;lt;</ph>xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>到<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以 Windows 98 和 Windows me 上访问此属性</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>Formats the process's name as a string, combined with the parent component type, if applicable.</source>
          <target state="translated">进程的名称格式化为字符串，如果适用与父组件类型，并组合。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Diagnostics.Process.ProcessName<bpt id="p1">*</bpt>&gt;, combined with the base component's &lt;xref:System.Object.ToString<ept id="p1">*</ept>&gt; return value.</source>
          <target state="translated">&lt;&gt; &lt;/&gt; <bpt id="p1">*</bpt>1&gt;，与基组件的组合&lt;&gt; <ept id="p1">*</ept>1&gt; 返回值。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source>ToString is not supported on Windows 98.</source>
          <target state="translated">在 Windows 98 上不支持 ToString。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>Gets the total processor time for this process.</source>
          <target state="translated">获取此进程的总处理器时间。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; that indicates the amount of time that the associated process has spent utilizing the CPU.</source>
          <target state="translated">A &lt;xref:System.TimeSpan&gt;，该值指示关联的进程使用 CPU，所用的时间量。&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source>This value is the sum of the &lt;xref:System.Diagnostics.Process.UserProcessorTime<bpt id="p1">*</bpt>&gt; and the &lt;xref:System.Diagnostics.Process.PrivilegedProcessorTime<ept id="p1">*</ept>&gt;.</source>
          <target state="translated">此值是的总和&lt;&gt; <bpt id="p1">*</bpt>1&gt; 和&lt;&gt; <ept id="p1">*</ept>1&gt;。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve">
          <source>You are attempting to access the TotalProcessorTime property for a process that is running on a remote computer.</source>
          <target state="translated">你尝试访问在远程计算机运行的进程的 TotalProcessorTime 属性。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source>Gets the user processor time for this process.</source>
          <target state="translated">获取此进程的用户处理器时间。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; that indicates the amount of time that the associated process has spent running code inside the application portion of the process (not inside the operating system core).</source>
          <target state="translated">A &lt;xref:System.TimeSpan&gt;，该值指示关联的进程的过程 （而不是在操作系统内核中） 的应用程序部分内的运行代码所用的时间量。&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>You are attempting to access the UserProcessorTime property for a process that is running on a remote computer.</source>
          <target state="translated">你尝试访问在远程计算机运行的进程的 UserProcessorTime 属性。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve">
          <source>This property is available only for processes that are running on the local computer.</source>
          <target state="translated">此属性是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve">
          <source>Gets the size of the process's virtual memory, in bytes.</source>
          <target state="translated">获取用字节表示的进程的虚拟内存大小。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>The amount of virtual memory, in bytes, that the associated process has requested.</source>
          <target state="translated">虚拟内存，以字节为单位，关联的进程请求的量。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>Gets the amount of the virtual memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的虚拟内存量。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve">
          <source>The value returned by this property represents the current size of virtual memory used by the process, in bytes.</source>
          <target state="translated">返回此属性的值表示使用的过程中，以字节为单位的虚拟内存的当前大小。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve">
          <source>The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</source>
          <target state="translated">操作系统将映射到页加载在物理内存中，或存储在磁盘上的虚拟内存分页文件的页面的每个进程的虚拟地址空间。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</source>
          <target state="translated">此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source>The property value is equivalent to the <bpt id="p1">**</bpt>Virtual Bytes<ept id="p1">**</ept> performance counter for the process.</source>
          <target state="translated">属性值等于<bpt id="p1">**</bpt>虚拟字节<ept id="p1">**</ept>进程的性能计数器。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>The amount of virtual memory, in bytes, allocated for the associated process.</source>
          <target state="translated">虚拟内存，以字节为单位，为关联进程分配的量。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve">
          <source>Instructs the <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component to wait indefinitely for the associated process to exit.</source>
          <target state="translated">指示<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件无限期地等待关联进程退出。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve">
          <source>WaitForExit makes the current thread wait until the associated process terminates.</source>
          <target state="translated">WaitForExit 使当前线程等待，直到在关联的进程终止。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>It should be called after all other methods are called on the process.</source>
          <target state="translated">过程调用的所有其他方法后，应调用它。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>To avoid blocking the current thread, use the &lt;xref:System.Diagnostics.Process.Exited&gt; event.</source>
          <target state="translated">若要避免妨碍当前线程，请使用&lt;xref:System.Diagnostics.Process.Exited&gt;事件。&lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source>This method instructs the &lt;xref:System.Diagnostics.Process&gt; component to wait an infinite amount of time for the process and event handlers to exit.</source>
          <target state="translated">此方法指示&lt;xref:System.Diagnostics.Process&gt;组件等待无限进程和事件处理程序退出的时间量。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>This can cause an application to stop responding.</source>
          <target state="translated">这会导致应用程序停止响应。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>For example, if you call &lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt; for a process that has a user interface, the request to the operating system to terminate the associated process might not be handled if the process is written to never enter its message loop.</source>
          <target state="translated">例如，如果你调用&lt;xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;对于具有用户界面的进程，对操作系统的请求，终止关联的进程可能不会处理如果进程被编写为从来不用输入其消息循环。&lt;/xref:System.Diagnostics.Process.CloseMainWindow%2A&gt;</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In the <ph id="ph2">[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]</ph> and earlier versions, the WaitForExit overload waited for &lt;xref:System.Int32.MaxValue&gt; milliseconds (approximately 24 days), not indefinitely.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph> 1&gt; 中<ph id="ph2">[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]</ph>和早期版本中，WaitForExit 重载会等待&lt;xref:System.Int32.MaxValue&gt;毫秒 （大约 24 天），并不是无限期。&lt;/xref:System.Int32.MaxValue&gt;</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source>Also, previous versions did not wait for the event handlers to exit if the full &lt;xref:System.Int32.MaxValue&gt; time was reached.</source>
          <target state="translated">此外，以前的版本不会等待事件处理程序，以退出如果完整&lt;xref:System.Int32.MaxValue&gt;时间已达到。&lt;/xref:System.Int32.MaxValue&gt;</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>This overload ensures that all processing has been completed, including the handling of asynchronous events for redirected standard output.</source>
          <target state="translated">此重载可确保所有处理均已都完成，包括的重定向的标准输出的异步事件处理。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve">
          <source>You should use this overload after a call to the &lt;xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29&gt; overload when standard output has been redirected to asynchronous event handlers.</source>
          <target state="translated">在调用后，应使用此重载&lt;xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29&gt;重载时标准输出已被重定向到异步事件处理程序。&lt;/xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29&gt;</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve">
          <source>When an associated process exits (that is, when it is shut down by the operation system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called WaitForExit.</source>
          <target state="translated">当关联的进程退出 （即，当它关闭的情况下通过操作系统通过正常或不正常终止） 时，系统存储过程的管理信息，并返回到调用一样 WaitForExit 的组件。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Diagnostics.Process&gt; component can then access the information, which includes the &lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;, by using the &lt;xref:System.Diagnostics.Process.Handle%2A&gt; to the exited process.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process&gt;组件然后可以访问的信息，其中包括&lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;，通过使用&lt;xref:System.Diagnostics.Process.Handle%2A&gt;已退出进程。&lt;/xref:System.Diagnostics.Process.Handle%2A&gt; &lt;/xref:System.Diagnostics.Process.ExitTime%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve">
          <source>Because the associated process has exited, the &lt;xref:System.Diagnostics.Process.Handle%2A&gt; property of the component no longer points to an existing process resource.</source>
          <target state="translated">关联的进程已退出，因为&lt;xref:System.Diagnostics.Process.Handle%2A&gt;组件属性不再指向现有进程资源。&lt;/xref:System.Diagnostics.Process.Handle%2A&gt;</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve">
          <source>Instead, the handle can be used only to access the operating system's information about the process resource.</source>
          <target state="translated">相反，句柄仅用于访问有关的进程资源的操作系统的信息。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve">
          <source>The system is aware of handles to exited processes that have not been released by &lt;xref:System.Diagnostics.Process&gt; components, so it keeps the &lt;xref:System.Diagnostics.Process.ExitTime%2A&gt; and &lt;xref:System.Diagnostics.Process.Handle%2A&gt; information in memory until the &lt;xref:System.Diagnostics.Process&gt; component specifically frees the resources.</source>
          <target state="translated">系统是不通过已发布的已退出进程的句柄感知&lt;xref:System.Diagnostics.Process&gt;组件，因此它会保留&lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;和&lt;xref:System.Diagnostics.Process.Handle%2A&gt;之前的内存中的信息&lt;xref:System.Diagnostics.Process&gt;组件明确释放这些资源。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Handle%2A&gt; &lt;/xref:System.Diagnostics.Process.ExitTime%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve">
          <source>For this reason, any time you call &lt;xref:System.Diagnostics.Process.Start%2A&gt; for a &lt;xref:System.Diagnostics.Process&gt; instance, call &lt;xref:System.Diagnostics.Process.Close%2A&gt; when the associated process has terminated and you no longer need any administrative information about it.</source>
          <target state="translated">为此，任何时候要寻求&lt;xref:System.Diagnostics.Process.Start%2A&gt;的&lt;xref:System.Diagnostics.Process&gt;实例，调用&lt;xref:System.Diagnostics.Process.Close%2A&gt;关联的进程终止时，并且你不再需要它。 有关的任何管理信息&lt;/xref:System.Diagnostics.Process.Close%2A&gt;&lt;/xref:System.Diagnostics.Process&gt;&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.Close%2A&gt; frees the memory allocated to the exited process.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.Close%2A&gt;释放分配给已退出的进程的内存。&lt;/xref:System.Diagnostics.Process.Close%2A&gt;</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve">
          <source>The wait setting could not be accessed.</source>
          <target state="translated">无法访问等待设置。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve">
          <source>No process &lt;xref:System.Diagnostics.Process.Id<bpt id="p1">*</bpt>&gt; has been set, and a &lt;xref:System.Diagnostics.Process.Handle<ept id="p1">*</ept>&gt; from which the &lt;xref:System.Diagnostics.Process.Id*&gt; property can be determined does not exist.</source>
          <target state="translated">没有进程&lt;&gt; <bpt id="p1">*</bpt>1&gt; 已设置和&lt;&gt; <ept id="p1">*</ept>1&gt; 从中&lt;xref:System.Diagnostics.Process.Id*&gt;属性可以确定不存在。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve">
          <source>-or-       There is no process associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">-或-没有与此关联的进程<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source>-or-       You are attempting to call WaitForExit for a process that is running on a remote computer.</source>
          <target state="translated">-或者-你尝试在远程计算机上运行的进程调用 WaitForExit。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>This method is available only for processes that are running on the local computer.</source>
          <target state="translated">此方法是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve">
          <source>Instructs the <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component to wait the specified number of milliseconds for the associated process to exit.</source>
          <target state="translated">指示<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件等待指定的关联进程退出的毫秒数。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve">
          <source>WaitForExit makes the current thread wait until the associated process terminates.</source>
          <target state="translated">WaitForExit 使当前线程等待，直到在关联的进程终止。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve">
          <source>It should be called after all other methods are called on the process.</source>
          <target state="translated">过程调用的所有其他方法后，应调用它。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>To avoid blocking the current thread, use the &lt;xref:System.Diagnostics.Process.Exited&gt; event.</source>
          <target state="translated">若要避免妨碍当前线程，请使用&lt;xref:System.Diagnostics.Process.Exited&gt;事件。&lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source>This method instructs the &lt;xref:System.Diagnostics.Process&gt; component to wait a finite amount of time for the process to exit.</source>
          <target state="translated">此方法指示&lt;xref:System.Diagnostics.Process&gt;组件等待有限进程退出的时间量。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve">
          <source>If the associated process does not exit by the end of the interval because the request to terminate is denied, <ph id="ph1">`false`</ph> is returned to the calling procedure.</source>
          <target state="translated">如果终止该请求被拒绝，因为，关联的进程不退出的时间间隔结束<ph id="ph1">`false`</ph>被返回到调用的过程。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source>You can specify a negative number (&lt;xref:System.Threading.Timeout.Infinite&gt;) for <ph id="ph1">`milliseconds`</ph>, and WaitForExit will behave the same as the &lt;xref:System.Diagnostics.Process.WaitForExit&gt; overload.</source>
          <target state="translated">您可以指定一个负号 (&lt;xref:System.Threading.Timeout.Infinite&gt;) 为<ph id="ph1">`milliseconds`</ph>，并且 WaitForExit 的行为相同&lt;xref:System.Diagnostics.Process.WaitForExit&gt;重载。&lt;/xref:System.Diagnostics.Process.WaitForExit&gt; &lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve">
          <source>If you pass 0 (zero) to the method, it returns <ph id="ph1">`true`</ph> only if the process has already exited; otherwise, it immediately returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果向方法传递 0 （零），它将返回<ph id="ph1">`true`</ph>仅当已经退出进程; 否则，它立即返回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In the <ph id="ph2">[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]</ph> and earlier versions, if <ph id="ph3">`milliseconds`</ph> was -1, the WaitForExit overload waited for &lt;xref:System.Int32.MaxValue&gt; milliseconds (approximately 24 days), not indefinitely.</source>
          <target state="translated">1&gt; <ph id="ph1">[!NOTE]</ph> 1&gt; 中<ph id="ph2">[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]</ph>和早期版本中，如果<ph id="ph3">`milliseconds`</ph>是-1，重载会等待 WaitForExit&lt;xref:System.Int32.MaxValue&gt;毫秒 （大约 24 天），并不是无限期。&lt;/xref:System.Int32.MaxValue&gt;</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve">
          <source>When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this method returns.</source>
          <target state="translated">当已重标准输出定向到异步事件处理程序中时，有可能，输出处理还未完成此方法返回时。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve">
          <source>To ensure that asynchronous event handling has been completed, call the &lt;xref:System.Diagnostics.Process.WaitForExit&gt; overload that takes no parameter after receiving a <ph id="ph1">`true`</ph> from this overload.</source>
          <target state="translated">若要确保已完成异步事件处理，调用&lt;xref:System.Diagnostics.Process.WaitForExit&gt;接收后不接受任何参数的重载<ph id="ph1">`true`</ph>从此重载。&lt;/xref:System.Diagnostics.Process.WaitForExit&gt;</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>To help ensure that the &lt;xref:System.Diagnostics.Process.Exited&gt; event is handled correctly in Windows Forms applications, set the &lt;xref:System.Diagnostics.Process.SynchronizingObject%2A&gt; property.</source>
          <target state="translated">为了帮助确保&lt;xref:System.Diagnostics.Process.Exited&gt;在 Windows 窗体应用程序中正确处理事件，请将设置&lt;xref:System.Diagnostics.Process.SynchronizingObject%2A&gt;属性。&lt;/xref:System.Diagnostics.Process.SynchronizingObject%2A&gt; &lt;/xref:System.Diagnostics.Process.Exited&gt;</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>When an associated process exits (is shut down by the operating system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called WaitForExit.</source>
          <target state="translated">关联的进程的退出时 （正通过正常或异常终止操作系统关闭） 时，系统存储过程的管理信息并返回到调用一样 WaitForExit 的组件。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Diagnostics.Process&gt; component can then access the information, which includes the &lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;, by using the &lt;xref:System.Diagnostics.Process.Handle%2A&gt; to the exited process.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process&gt;组件然后可以访问的信息，其中包括&lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;，通过使用&lt;xref:System.Diagnostics.Process.Handle%2A&gt;已退出进程。&lt;/xref:System.Diagnostics.Process.Handle%2A&gt; &lt;/xref:System.Diagnostics.Process.ExitTime%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve">
          <source>Because the associated process has exited, the &lt;xref:System.Diagnostics.Process.Handle%2A&gt; property of the component no longer points to an existing process resource.</source>
          <target state="translated">关联的进程已退出，因为&lt;xref:System.Diagnostics.Process.Handle%2A&gt;组件属性不再指向现有进程资源。&lt;/xref:System.Diagnostics.Process.Handle%2A&gt;</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve">
          <source>Instead, the handle can be used only to access the operating system's information about the process resource.</source>
          <target state="translated">相反，句柄仅用于访问有关的进程资源的操作系统的信息。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve">
          <source>The system is aware of handles to exited processes that have not been released by &lt;xref:System.Diagnostics.Process&gt; components, so it keeps the &lt;xref:System.Diagnostics.Process.ExitTime%2A&gt; and &lt;xref:System.Diagnostics.Process.Handle%2A&gt; information in memory until the &lt;xref:System.Diagnostics.Process&gt; component specifically frees the resources.</source>
          <target state="translated">系统是不通过已发布的已退出进程的句柄感知&lt;xref:System.Diagnostics.Process&gt;组件，因此它会保留&lt;xref:System.Diagnostics.Process.ExitTime%2A&gt;和&lt;xref:System.Diagnostics.Process.Handle%2A&gt;之前的内存中的信息&lt;xref:System.Diagnostics.Process&gt;组件明确释放这些资源。&lt;/xref:System.Diagnostics.Process&gt; &lt;/xref:System.Diagnostics.Process.Handle%2A&gt; &lt;/xref:System.Diagnostics.Process.ExitTime%2A&gt; &lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve">
          <source>For this reason, any time you call &lt;xref:System.Diagnostics.Process.Start%2A&gt; for a &lt;xref:System.Diagnostics.Process&gt; instance, call &lt;xref:System.Diagnostics.Process.Close%2A&gt; when the associated process has terminated and you no longer need any administrative information about it.</source>
          <target state="translated">为此，任何时候要寻求&lt;xref:System.Diagnostics.Process.Start%2A&gt;的&lt;xref:System.Diagnostics.Process&gt;实例，调用&lt;xref:System.Diagnostics.Process.Close%2A&gt;关联的进程终止时，并且你不再需要它。 有关的任何管理信息&lt;/xref:System.Diagnostics.Process.Close%2A&gt;&lt;/xref:System.Diagnostics.Process&gt;&lt;/xref:System.Diagnostics.Process.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Diagnostics.Process.Close%2A&gt; frees the memory allocated to the exited process.</source>
          <target state="translated">&lt;xref:System.Diagnostics.Process.Close%2A&gt;释放分配给已退出的进程的内存。&lt;/xref:System.Diagnostics.Process.Close%2A&gt;</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve">
          <source>The amount of time, in milliseconds, to wait for the associated process to exit.</source>
          <target state="translated">时间 （毫秒），等待关联进程退出的量。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve">
          <source>The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</source>
          <target state="translated">最大为对于操作系统而言表示无限大的 32 位整数的最大可能值。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the associated process has exited; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果关联的进程已退出;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve">
          <source>The wait setting could not be accessed.</source>
          <target state="translated">无法访问等待设置。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source>No process &lt;xref:System.Diagnostics.Process.Id<bpt id="p1">*</bpt>&gt; has been set, and a &lt;xref:System.Diagnostics.Process.Handle<ept id="p1">*</ept>&gt; from which the &lt;xref:System.Diagnostics.Process.Id*&gt; property can be determined does not exist.</source>
          <target state="translated">没有进程&lt;&gt; <bpt id="p1">*</bpt>1&gt; 已设置和&lt;&gt; <ept id="p1">*</ept>1&gt; 从中&lt;xref:System.Diagnostics.Process.Id*&gt;属性可以确定不存在。&lt;/xref:System.Diagnostics.Process.Id*&gt;</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve">
          <source>-or-       There is no process associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">-或-没有与此关联的进程<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve">
          <source>-or-       You are attempting to call WaitForExit for a process that is running on a remote computer.</source>
          <target state="translated">-或者-你尝试在远程计算机上运行的进程调用 WaitForExit。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve">
          <source>This method is available only for processes that are running on the local computer.</source>
          <target state="translated">此方法是仅适用于本地计算机运行的进程。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve">
          <source>Causes the <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component to wait indefinitely for the associated process to enter an idle state.</source>
          <target state="translated">导致<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件无限期地等待关联进程进入空闲状态。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve">
          <source>This overload applies only to processes with a user interface and, therefore, a message loop.</source>
          <target state="translated">此重载仅适用于具有用户界面并因此，消息循环的进程。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve">
          <source>Use WaitForInputIdle to force the processing of your application to wait until the message loop has returned to the idle state.</source>
          <target state="translated">使用 WaitForInputIdle 强制应用程序消息循环已返回到空闲状态等待处理。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</source>
          <target state="translated">用户界面的进程执行时，其消息循环将执行每次操作系统的 Windows 消息发送到进程。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve">
          <source>The process then returns to the message loop.</source>
          <target state="translated">然后，该进程返回到消息循环。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve">
          <source>A process is said to be in an idle state when it is waiting for messages inside of a message loop.</source>
          <target state="translated">说进程时它正在等待消息的消息循环内处于空闲状态。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve">
          <source>This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</source>
          <target state="translated">此状态非常有用，例如，当你的应用程序需要等待启动的进程以完成创建其主窗口之前与该窗口的应用程序通信时。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve">
          <source>If a process does not have a message loop, WaitForInputIdle throws an &lt;xref:System.InvalidOperationException&gt;.</source>
          <target state="translated">如果进程不具有消息循环，WaitForInputIdle 引发&lt;xref:System.InvalidOperationException&gt;.&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve">
          <source>The WaitForInputIdle overload instructs the &lt;xref:System.Diagnostics.Process&gt; component to wait indefinitely for the process to become idle in the message loop.</source>
          <target state="translated">WaitForInputIdle 重载指示&lt;xref:System.Diagnostics.Process&gt;组件无限期地等待进程变为空闲状态消息循环中。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source>This instruction can cause an application to stop responding.</source>
          <target state="translated">此指令可能会导致应用程序停止响应。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source>For example, if the process is written to always exit its message loop immediately, as in the code fragment <ph id="ph1">`while(true)`</ph>.</source>
          <target state="translated">例如，如果过程始终写入其消息循环立即退出，如下所示的代码片段<ph id="ph1">`while(true)`</ph>。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the associated process has reached an idle state.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果关联的进程已经达到空闲状态。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>The process does not have a graphical interface.</source>
          <target state="translated">进程不具有图形界面。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source>-or-       An unknown error occurred.</source>
          <target state="translated">-或者-出现未知的错误。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>The process failed to enter an idle state.</source>
          <target state="translated">进程无法进入空闲状态。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve">
          <source>-or-       The process has already exited.</source>
          <target state="translated">-或者-已经退出进程。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve">
          <source>-or-       No process is associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">-或-没有进程是否与此相关联<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve">
          <source>Causes the <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> component to wait the specified number of milliseconds for the associated process to enter an idle state.</source>
          <target state="translated">导致<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>组件等待指定的关联进程进入空闲状态的毫秒数。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve">
          <source>This overload applies only to processes with a user interface and, therefore, a message loop.</source>
          <target state="translated">此重载仅适用于具有用户界面并因此，消息循环的进程。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve">
          <source>Use WaitForInputIdle to force the processing of your application to wait until the message loop has returned to the idle state.</source>
          <target state="translated">使用 WaitForInputIdle 强制应用程序消息循环已返回到空闲状态等待处理。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve">
          <source>When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</source>
          <target state="translated">用户界面的进程执行时，其消息循环将执行每次操作系统的 Windows 消息发送到进程。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve">
          <source>The process then returns to the message loop.</source>
          <target state="translated">然后，该进程返回到消息循环。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve">
          <source>A process is said to be in an idle state when it is waiting for messages inside of a message loop.</source>
          <target state="translated">说进程时它正在等待消息的消息循环内处于空闲状态。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve">
          <source>This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</source>
          <target state="translated">此状态非常有用，例如，当你的应用程序需要等待启动的进程以完成创建其主窗口之前与该窗口的应用程序通信时。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve">
          <source>If a process does not have a message loop, WaitForInputIdle throws an &lt;xref:System.InvalidOperationException&gt;.</source>
          <target state="translated">如果进程不具有消息循环，WaitForInputIdle 引发&lt;xref:System.InvalidOperationException&gt;.&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve">
          <source>The WaitForInputIdle overload instructs the &lt;xref:System.Diagnostics.Process&gt; component to wait a finite amount of time for the process to become idle in the message loop.</source>
          <target state="translated">WaitForInputIdle 重载指示&lt;xref:System.Diagnostics.Process&gt;组件等待有限的进程变为空闲状态消息循环中的时间量。&lt;/xref:System.Diagnostics.Process&gt;</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve">
          <source>If the associated process has not become idle by the end of the interval because the loop is still processing messages, <ph id="ph1">`false`</ph> is returned to the calling procedure.</source>
          <target state="translated">如果关联的进程不具有进入空闲状态的时间间隔结束循环仍在处理消息，因为<ph id="ph1">`false`</ph>被返回到调用的过程。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Events<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关处理事件的详细信息，请参阅<bpt id="p1">[</bpt>事件<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve">
          <source>A value of 1 to &lt;xref:System.Int32&gt; that specifies the amount of time, in milliseconds, to wait for the associated process to become idle.</source>
          <target state="translated">值为 1 到&lt;xref:System.Int32&gt;，它指定的时间，以毫秒为单位，等待关联进程变为空闲状态。&lt;/xref:System.Int32&gt;</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve">
          <source>A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</source>
          <target state="translated">0 值指定立即返回，而-1 值则指定无限期等待。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the associated process has reached an idle state; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果关联的进程已经达到空闲状态;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve">
          <source>The process does not have a graphical interface.</source>
          <target state="translated">进程不具有图形界面。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve">
          <source>-or-       An unknown error occurred.</source>
          <target state="translated">-或者-出现未知的错误。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve">
          <source>The process failed to enter an idle state.</source>
          <target state="translated">进程无法进入空闲状态。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve">
          <source>-or-       The process has already exited.</source>
          <target state="translated">-或者-已经退出进程。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve">
          <source>-or-       No process is associated with this <bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">-或-没有进程是否与此相关联<bpt id="p1">&lt;xref href="System.Diagnostics.Process"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve">
          <source>Gets the associated process's physical memory usage, in bytes.</source>
          <target state="translated">获取关联的进程的物理内存使用量，以字节为单位。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve">
          <source>The value returned by this property represents the current size of working set memory used by the process, in bytes.</source>
          <target state="translated">返回此属性的值表示工作集内存使用的过程中，以字节为单位的当前大小。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve">
          <source>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</source>
          <target state="translated">进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve">
          <source>These pages are resident and available for an application to use without triggering a page fault.</source>
          <target state="translated">这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve">
          <source>The working set includes both shared and private data.</source>
          <target state="translated">工作集包括共享和私有数据。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve">
          <source>The shared data includes the pages that contain all the instructions that the process executes, including the process modules and the system libraries.</source>
          <target state="translated">共享的数据包括那些包含该进程执行，包括进程模块和系统库的所有说明的页。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source>The total amount of physical memory the associated process is using, in bytes.</source>
          <target state="translated">关联的进程正在使用的物理内存总量，以字节为单位。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve">
          <source>Gets the amount of physical memory, in bytes, allocated for the associated process.</source>
          <target state="translated">获取用字节表示，为关联进程分配的物理内存量。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve">
          <source>The value returned by this property represents the current size of working set memory used by the process, in bytes.</source>
          <target state="translated">返回此属性的值表示工作集内存使用的过程中，以字节为单位的当前大小。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve">
          <source>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</source>
          <target state="translated">进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve">
          <source>These pages are resident and available for an application to use without triggering a page fault.</source>
          <target state="translated">这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve">
          <source>The working set includes both shared and private data.</source>
          <target state="translated">工作集包括共享和私有数据。</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve">
          <source>The shared data includes the pages that contain all the instructions that the process executes, including instructions in the process modules and the system libraries.</source>
          <target state="translated">共享的数据包括那些包含该进程执行，包括进程模块和系统库中的说明的所有说明的页。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve">
          <source>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</source>
          <target state="translated">此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve">
          <source>The property value is equivalent to the <bpt id="p1">**</bpt>Working Set<ept id="p1">**</ept> performance counter for the process.</source>
          <target state="translated">属性值等于<bpt id="p1">**</bpt>工作集大小<ept id="p1">**</ept>进程的性能计数器。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve">
          <source>The amount of physical memory, in bytes, allocated for the associated process.</source>
          <target state="translated">以字节为单位，为关联进程分配的物理内存量。</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve">
          <source>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</source>
          <target state="translated">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>