<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ad45d5350d7ce0512a3ddb042ebe116819840d05</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.DependencyProperty.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b2d3012c503074ba78e9c00deca385d4525e993f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e77660bde0953d13f802b828789b2dd37b1699e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</source>
          <target state="translated">表示可如通过方法设置的属性、 样式、 数据绑定、 动画和继承。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>A DependencyProperty supports the following capabilities in <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]</ph>:      -   The property can be set in a style.</source>
          <target state="translated">DependencyProperty 支持中的以下功能<ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]</ph>:-该属性可以设置样式。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>样式和模板化<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>-   The property can be set through data binding.</source>
          <target state="translated">-该属性可以设置数据绑定。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For more information about data binding dependency properties, see <bpt id="p1">[</bpt>How to: Bind the Properties of Two Controls<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关数据绑定依赖项属性的详细信息，请参阅<bpt id="p1">[</bpt>如何︰ 将两个控件属性的绑定<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>-   The property can be set with a dynamic resource reference.</source>
          <target state="translated">-该属性可以设置的动态资源引用。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>XAML 资源<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>-   The property can inherit its value automatically from a parent element in the element tree.</source>
          <target state="translated">-该属性可以继承其值自动从元素树中父元素。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>属性值继承<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>-   The property can be animated.</source>
          <target state="translated">-该属性可以进行动画处理。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Animation Overview<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>动画概述<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>-   The property can report when the previous value of the property has been changed and the property value can be coerced.</source>
          <target state="translated">-该属性可以报告时已更改属性的上一个值，并且可强制转换的属性值。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>依赖项属性的回调和验证<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>-   The property reports information to <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>, such as whether changing a property value should require the layout system to recompose the visuals for an element.</source>
          <target state="translated">-属性报告到的信息<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>，例如更改属性值是否应需要布局系统重新编写的元素的视觉对象。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>-   The property receives support in the <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)]</ph>.</source>
          <target state="translated">-属性接收中的支持<ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For example, the property can be edited in the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window.</source>
          <target state="translated">例如，可以在中编辑属性<bpt id="p1">**</bpt>属性<ept id="p1">**</ept>窗口。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>To learn more about dependency properties, see <bpt id="p1">[</bpt>Dependency Properties Overview<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">若要了解有关依赖项属性的详细信息，请参阅<bpt id="p1">[</bpt>依赖项属性概述<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</source>
          <target state="translated">如果希望在你自定义的类型，上面的列表中支持的功能上的属性，则应创建一个依赖项属性。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To learn how to create custom dependency properties, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">若要了解如何创建自定义的依赖项属性，请参阅<bpt id="p1">[</bpt>自定义的依赖项属性<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>An attached property is a property that enables any object to report information to the type that defines the attached property.</source>
          <target state="translated">附加的属性是一个属性，使报表信息传递到定义附加的属性的类型的任何对象。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>, any type that inherits from &lt;xref:System.Windows.DependencyObject&gt; can use an attached property regardless of whether the type inherits from the type that defines the property.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>，任何类型，继承自&lt;xref:System.Windows.DependencyObject&gt;可以使用附加的属性而不考虑该类型是否继承自定义属性的类型。&lt;/xref:System.Windows.DependencyObject&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>An attached property is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph> language.</source>
          <target state="translated">附加的属性是一项功能的<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>语言。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>To set an attached property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>, use the <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt>propertyName<ept id="p2">*</ept> syntax.</source>
          <target state="translated">在中设置附加的属性<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>，使用<bpt id="p1">*</bpt>所有者类型<ept id="p1">*</ept>。<bpt id="p2">*</bpt>propertyName<ept id="p2">*</ept>语法。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>An example of an attached property is the &lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt; property.</source>
          <target state="translated">附加属性的一个示例是&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;属性。&lt;/xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If you want to create a property that can be used on all &lt;xref:System.Windows.DependencyObject&gt; types, then you should create an attached property.</source>
          <target state="translated">如果你想要创建一个属性，可以使用对所有&lt;xref:System.Windows.DependencyObject&gt;类型，则你应创建附加的属性。&lt;/xref:System.Windows.DependencyObject&gt;</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>To learn more about attached properties, including how to create them, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">若要了解有关附加属性，包括如何创建它们，请参阅<bpt id="p1">[</bpt>附加属性概述<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="xamlAttributeUsage_DependencyProperty"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Attribute Usage      <ph id="ph1">```   &lt;object property="dependencyPropertyName"/&gt;   - or -   &lt;object property="ownerType.dependencyPropertyName"/&gt;   - or -   &lt;object property="attachedPropertyOwnerType.attachedPropertyName"/&gt;   ```</ph>      <bpt id="p2">&lt;a name="xamlValues_DependencyProperty"&gt;</bpt><ept id="p2">&lt;/a&gt;</ept>    ## XAML Values    <ph id="ph2">`dependencyPropertyName`</ph>    A string that specifies the &lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName&gt; of the desired dependency property.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlAttributeUsage_DependencyProperty"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # XAML 属性用法<ph id="ph1">```   &lt;object property="dependencyPropertyName"/&gt;   - or -   &lt;object property="ownerType.dependencyPropertyName"/&gt;   - or -   &lt;object property="attachedPropertyOwnerType.attachedPropertyName"/&gt;   ```</ph> <bpt id="p2">&lt;a name="xamlValues_DependencyProperty"&gt;</bpt> <ept id="p2">&lt;/a&gt;</ept> # # XAML 值<ph id="ph2">`dependencyPropertyName`</ph>一个字符串，指定&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName&gt;的所需的依赖属性。&lt;/xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName&gt;      </target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see <bpt id="p1">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.)       <ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></source>
          <target state="translated">这可以前面是 XML 命名空间前缀如果属性不在默认 XML 命名空间 (有关详细信息，请参阅<bpt id="p1">[</bpt>XAML 命名空间和 Namespace 映射为 WPF XAML<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。)      <ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A string that specifies an owner type of a dependency property, a dot (.), then the &lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">一个字符串，指定的依赖项属性，句点 （.），然后&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName&gt;.&lt;/xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName&gt;所有者类型</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ownerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`ownerType`</ph>此外前面是 XML 命名空间前缀。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the <ph id="ph1">`TargetType`</ph> is not yet known.</source>
          <target state="translated">这种用法是特定于后期绑定样式和模板，其中依赖项属性的所有者必须指定用于分析上下文，因为<ph id="ph1">`TargetType`</ph>来说未知。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](../Topic/Styling%20and%20Templating.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>样式和模板化<ept id="p1">](../Topic/Styling%20and%20Templating.md)</ept>。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`attachedPropertyName`</ph>    A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</source>
          <target state="translated"><ph id="ph1">`attachedPropertyName`</ph>一个字符串，指定附加的属性，句点 （.），然后附加的属性名称的所有者。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph>此外前面是 XML 命名空间前缀。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Adds another type as an owner of a dependency property that has already been registered.</source>
          <target state="translated">将另一种类型添加为已注册的依赖项属性的所有者。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">此方法使属性系统可以识别在最初未注册该特定的依赖项属性的类型上的依赖项属性。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Typically, AddOwner is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</source>
          <target state="translated">通常情况下，使用 AddOwner 将依赖项属性添加到已不会公开通过托管的类继承该依赖项属性的类 （类继承将导致要由派生类继承的包装器属性，并且进而已提供对依赖项属性的一般的成员表访问）。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>AddOwner enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</source>
          <target state="translated">AddOwner 使属性系统可以识别在最初未注册该依赖项属性的类型上的依赖项属性。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This signature does not allow for specifying metadata.</source>
          <target state="translated">此签名不允许用于指定元数据。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When you use this method, the metadata is automatically generated for the new &lt;xref:System.Windows.DependencyProperty&gt; and its owner type.</source>
          <target state="translated">当你使用此方法时，元数据自动生成的新&lt;xref:System.Windows.DependencyProperty&gt;和其所有者类型。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</source>
          <target state="translated">自动生成元数据是从所有已定义此属性的基类型合并的元数据的结果。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If no merged metadata is available, then the default metadata for the property is used.</source>
          <target state="translated">如果未合并的元数据可用，则会使用属性的默认元数据。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If the property is registered by using the &lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt; method, then the default metadata is the same as the metadata that is created when &lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt; was called.</source>
          <target state="translated">如果通过使用注册属性&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;方法，则默认元数据是时，将创建的元数据相同&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;曾。&lt;/xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt; &lt;/xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;xref:System.Windows.PropertyMetadata&gt; object is created with the &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; property set to the property type's default and all other properties of the &lt;xref:System.Windows.PropertyMetadata&gt; is set to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">否则为&lt;xref:System.Windows.PropertyMetadata&gt;对象创建与&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;属性设置为该属性类型的默认和所有其他属性&lt;xref:System.Windows.PropertyMetadata&gt;设置为<ph id="ph1">`null`</ph>。&lt;/xref:System.Windows.PropertyMetadata&gt; &lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; &lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Use the &lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt; signature if you want to provide metadata for the version of the dependency property as added to the provided type.</source>
          <target state="translated">使用&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;签名，如果你想要为添加到所提供的类型的依赖项属性的版本提供元数据。&lt;/xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</source>
          <target state="translated">此方法的返回值通常用于声明和通过将存储一个依赖属性标识符公开的依赖属性。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The identifier provides access to the dependency property if you want to call property system <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]</ph> against the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">此标识符提供对依赖项属性的访问，如果你想要调用属性系统<ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]</ph>针对依赖项，尤其是当它上是否存在添加的所有者类。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">原始所有者和添加的所有者的相同属性名称应该用于指示类似的功能。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You should use the &lt;xref:System.Windows.DependencyProperty&gt; return value of the AddOwner method to define the dependency property identifier, and also to declare <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using AddOwner.</source>
          <target state="translated">应使用&lt;xref:System.Windows.DependencyProperty&gt;返回 AddOwner 方法来定义依赖属性标识符，并还声明值<ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph>属性包装器，将添加到使用 AddOwner 的类型的依赖项属性。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The AddOwner methodology recommended above is used when creating the dependency properties that are declared within <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated">创建声明内的依赖项属性时使用了上面推荐 AddOwner 方法<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For instance, both &lt;xref:System.Windows.Controls.Border&gt; and &lt;xref:System.Windows.Controls.Control&gt; define a <ph id="ph1">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">例如，同时&lt;xref:System.Windows.Controls.Border&gt;和&lt;xref:System.Windows.Controls.Control&gt;定义<ph id="ph1">`BorderBrush`</ph>具有类似的功能的依赖项属性。&lt;/xref:System.Windows.Controls.Control&gt; &lt;/xref:System.Windows.Controls.Border&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Windows.Controls.Control&gt; defines its <ph id="ph1">`BorderBrush`</ph> property to the property system by calling AddOwner based on the original owner &lt;xref:System.Windows.Controls.Border&gt; and its registered &lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt; dependency property identifer.</source>
          <target state="translated">&lt;xref:System.Windows.Controls.Control&gt;定义其<ph id="ph1">`BorderBrush`</ph>到通过调用 AddOwner 属性系统的属性基于原始所有者&lt;xref:System.Windows.Controls.Border&gt;和其已注册&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;依赖项属性标识符。&lt;/xref:System.Windows.Controls.Border.BorderBrushProperty&gt; &lt;/xref:System.Windows.Controls.Border&gt;&lt;/xref:System.Windows.Controls.Control&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The AddOwner return value is then used to establish a new static &lt;xref:System.Windows.DependencyProperty&gt; field (&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;) for that property on the added owner, and a <ph id="ph1">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated">AddOwner 返回值然后用于建立新的静态&lt;xref:System.Windows.DependencyProperty&gt;字段 (&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;) 上添加的所有者，该属性的和<ph id="ph1">`BorderBrush`</ph>属性包装也被声明。&lt;/xref:System.Windows.Controls.Control.BorderBrushProperty&gt; &lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The type to add as an owner of this dependency property.</source>
          <target state="translated">要作为此依赖属性所有者添加的类型。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A reference to the original <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> identifier that identifies the dependency property.</source>
          <target state="translated">与原始引用<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>标识的依赖项属性的标识符。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This identifier should be exposed by the adding class as a <bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> field.</source>
          <target state="translated">应通过将类添加为公开此标识符<bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>字段。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</source>
          <target state="translated">将另一种类型添加为已注册的依赖项属性的所有者，因为它将在提供的所有者类型上存在的依赖项属性提供依赖属性元数据。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">此方法使属性系统可以识别在最初未注册该特定的依赖项属性的类型上的依赖项属性。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">此方法的返回值用于声明和公开这样的依赖项属性中，尤其当它位于添加的所有者类。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">通常情况下，应使用原始所有者和添加的所有者的相同属性名称以指示类似的功能。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It is good practice to expose the identifiers, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;.</source>
          <target state="translated">它是公开的标识符，也作为新的好办法<ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph>属性包装器，将添加到使用&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;.&lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;的类型的依赖项属性</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; methodology recommended above is used when creating <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]</ph> declared within <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;上面推荐的方法创建使用<ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]</ph>内声明<ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>。&lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For instance, both &lt;xref:System.Windows.Controls.Border&gt; and &lt;xref:System.Windows.Controls.Control&gt; define a <ph id="ph1">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">例如，同时&lt;xref:System.Windows.Controls.Border&gt;和&lt;xref:System.Windows.Controls.Control&gt;定义<ph id="ph1">`BorderBrush`</ph>具有类似的功能的依赖项属性。&lt;/xref:System.Windows.Controls.Control&gt; &lt;/xref:System.Windows.Controls.Border&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Windows.Controls.Control&gt; defines its <ph id="ph1">`BorderBrush`</ph> property to the property system by calling &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; on original owner &lt;xref:System.Windows.Controls.Border&gt; and its registered &lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt; dependency property identifer.</source>
          <target state="translated">&lt;xref:System.Windows.Controls.Control&gt;定义其<ph id="ph1">`BorderBrush`</ph>到通过调用属性系统属性&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;的原始所有者&lt;xref:System.Windows.Controls.Border&gt;和其已注册&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;依赖项属性标识符。&lt;/xref:System.Windows.Controls.Border.BorderBrushProperty&gt; &lt;/xref:System.Windows.Controls.Border&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;&lt;/xref:System.Windows.Controls.Control&gt;</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; return value is then used to establish a static &lt;xref:System.Windows.DependencyProperty&gt; field (&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;)for that property on the added owner, and a <ph id="ph1">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;返回值然后用于建立一个静态&lt;xref:System.Windows.DependencyProperty&gt;字段 (&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;) 上添加的所有者，该属性的和<ph id="ph1">`BorderBrush`</ph>属性包装也被声明。&lt;/xref:System.Windows.Controls.Control.BorderBrushProperty&gt; &lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The added owner's dependency property identifier should be used for operations such as &lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;.</source>
          <target state="translated">添加的所有者的依赖属性标识符应使用&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;.&lt;/xref:System.Windows.DependencyObject.GetValue%2A&gt;等操作</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as &lt;xref:System.Windows.DependencyObject.GetValue%2A&gt; or &lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;.</source>
          <target state="translated">但是，涉及类型或已添加，因为仍将使用不同的元数据的所有者的类的实例的特定类型的操作返回预期的结果，即使原始 （不是添加的所有者的） 对如&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;或&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;.&lt;/xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;&lt;/xref:System.Windows.DependencyObject.GetValue%2A&gt;方法调用中指定的依赖项属性标识符</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The metadata for the added owner is perpetuated by the AddOwner call itself, not necessarily referenced exclusively by the adding owner class identifier field.</source>
          <target state="translated">元数据的添加所有者 AddOwner 通过调用其自身，不一定是以独占方式添加的所有者类标识符字段引用。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Nevertheless, it is good practice to expose the  identifier, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using AddOwner, because failing to do so creates disparity between the <ph id="ph2">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph> and <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph> representations of your properties.</source>
          <target state="translated">不过，它是公开的标识符，也作为新的好办法，<ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph>都会添加到类型使用 AddOwner，因为如果不这样做创建之间的差异的依赖项属性的属性包装，<ph id="ph2">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph>和<ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>您的属性的表示形式。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">提供的元数据与依赖项属性的属性元数据合并，因为它存在于基的所有者。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Any characteristics that were specified in the original base metadata will persist.</source>
          <target state="translated">将保留在原始的基本元数据中未指定任何特征。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">仅已专门在新的元数据中更改这些特征将重写的基本元数据的特征。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Some characteristics, such as &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;, are replaced if they are specified in the new metadata.</source>
          <target state="translated">某些特征，如&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;，如果在新的元数据中指定了替换。&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Others, such as &lt;xref:System.Windows.PropertyChangedCallback&gt;, are combined.</source>
          <target state="translated">其他，如&lt;xref:System.Windows.PropertyChangedCallback&gt;，又。&lt;/xref:System.Windows.PropertyChangedCallback&gt;</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">最终，合并行为取决于正在用于重写时，因此此处所述的行为是使用现有的属性元数据类的属性元数据类型<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>依赖项属性。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>依赖属性元数据<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>和<bpt id="p2">[</bpt>Framework 属性元数据<ept id="p2">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The type to add as owner of this dependency property.</source>
          <target state="translated">要作为此依赖属性所有者添加的类型。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The metadata that qualifies the dependency property as it exists on the provided type.</source>
          <target state="translated">限定依赖项属性，因为它存在于所提供的类型的元数据。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>A reference to the original <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> identifier that identifies the dependency property.</source>
          <target state="translated">与原始引用<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>标识的依赖项属性的标识符。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This identifier should be exposed by the adding class as a <bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> field.</source>
          <target state="translated">应通过将类添加为公开此标识符<bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>字段。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Gets the default metadata of the dependency property.</source>
          <target state="translated">获取依赖项属性的默认元数据。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; call.</source>
          <target state="translated">默认元数据是通过显式提供任何替换元数据已其中将适用于该特定对象或派生类型的对象的属性元数据&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;调用。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If the original owner applied metadata to the first &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; call that established the dependency property, then that metadata is returned as DefaultMetadata.</source>
          <target state="translated">如果原始所有者元数据应用到第一个&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;建立依赖项属性，则为 DefaultMetadata 返回该元数据的调用。&lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>If no metadata was applied in the original &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; call, then default metadata is generated from within the &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; call and this value is returned as the DefaultMetadata.</source>
          <target state="translated">如果没有元数据已应用在原始&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;调用，则默认元数据生成内&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;调用并将此值将作为 DefaultMetadata。&lt;/xref:System.Windows.DependencyProperty.Register%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The main purpose of having default metadata associated with a &lt;xref:System.Windows.DependencyProperty&gt; is to supply a default value for this property on any &lt;xref:System.Windows.DependencyObject&gt; or a derived type.</source>
          <target state="translated">具有与关联的默认元数据的主要用途&lt;xref:System.Windows.DependencyProperty&gt;旨在提供对任何此属性的默认值&lt;xref:System.Windows.DependencyObject&gt;或派生的类型。&lt;/xref:System.Windows.DependencyObject&gt; &lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>For nonattached properties, the metadata type returned by this property cannot be cast to derived types of &lt;xref:System.Windows.PropertyMetadata&gt; type, even if the property was originally registered with a derived metadata type.</source>
          <target state="translated">对于非附加属性，此属性返回的元数据类型不能强制转换为派生类型的&lt;xref:System.Windows.PropertyMetadata&gt;键入，即使该属性最初注册了一个派生的元数据类型。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If you want the originally registered metadata including its original possibly derived metadata type, call &lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt; instead, passing the original registering type as a parameter.</source>
          <target state="translated">如果您需要最初已注册的元数据，包括其原始的可能派生的元数据类型，调用&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;，传递原始注册类型作为参数。&lt;/xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For attached properties, the type of the metadata returned by this property will match the type given in the original &lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt; registration method.</source>
          <target state="translated">对于附加属性，此属性返回的元数据的类型将与原始中给定的类型匹配&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;注册方法。&lt;/xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The default metadata of the dependency property.</source>
          <target state="translated">依赖项属性的默认元数据。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Returns a hash code for this <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">返回此哈希代码<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The property system uses its own unique identifier &lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;, and the value of that property is returned by GetHashCode.</source>
          <target state="translated">属性系统使用其自己的唯一标识符&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;，并且由 GetHashCode 返回该属性的值。&lt;/xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The hash code for this <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">此哈希代码<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Returns the metadata for this dependency property as it exists on a specified existing type.</source>
          <target state="translated">返回此依赖项属性的元数据，因为它存在于指定的现有类型上。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; calls that alter the metadata of the dependency property as it exists on a type.</source>
          <target state="translated">指定的类型或对象引用以用作类是必需的元数据可能会不同于原始注册原因可能是因为&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;alter 依赖项属性的元数据，因为它存在于一种类型的调用。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The specific type from which to retrieve the dependency property metadata.</source>
          <target state="translated">要从中检索依赖属性元数据的特定类型。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A property metadata object.</source>
          <target state="translated">属性元数据对象。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Returns the metadata for this dependency property as it exists on the specified object instance.</source>
          <target state="translated">返回此依赖项属性的元数据，因为它存在于指定的对象实例上。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">指定的类型或对象引用必需的任何给定的依赖项属性的元数据可能会不同于原始注册原因可能是因为&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;可以优化的属性元数据，因为它存在于一种类型的调用。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</source>
          <target state="translated">在请求基于实例的属性元数据时，都实际上只通过实例，以便其类型可在内部计算。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</source>
          <target state="translated">依赖属性元数据不发生改变每个实例;它始终是一致的任何给定的类型属性组合。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</source>
          <target state="translated">检查的类型，以便确定哪些特定类型的版本依赖项属性的元数据应来自依赖对象。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A property metadata object.</source>
          <target state="translated">属性元数据对象。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Returns the metadata for this dependency property as it exists on a specified type.</source>
          <target state="translated">返回此依赖项属性的元数据，因为它存在于指定的类型。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">指定的类型或对象引用必需的任何给定的依赖项属性的元数据可能会不同于原始注册原因可能是因为&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;可以优化的属性元数据，因为它存在于一种类型的调用。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>A specific object that records the dependency object type from which the dependency property metadata is desired.</source>
          <target state="translated">记录从其依赖属性元数据所需的依赖项对象类型的特定对象。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>A property metadata object.</source>
          <target state="translated">属性元数据对象。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Gets an internally generated value that uniquely identifies the dependency property.</source>
          <target state="translated">获取唯一标识该依赖项属性的内部生成的值。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>This value is an integer, not a <ph id="ph1">[!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]</ph>.</source>
          <target state="translated">此值不是一个整数， <ph id="ph1">[!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</source>
          <target state="translated">通常情况下，使用此索引值不是必需的并且没有任何索引访问的所有依赖项属性的表。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Dependency properties should instead be referenced by their identifier fields.</source>
          <target state="translated">而是应由其标识符字段引用依赖项属性。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>GlobalIndex is used internally for faster access to data structures that use the GlobalIndex as a zero-based array index.</source>
          <target state="translated">GlobalIndex 内部用于更快地访问 GlobalIndex 用作从零开始的数组索引的数据结构。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A similar usage might have applications for designers or tools.</source>
          <target state="translated">类似的用法可能具有的应用程序设计器或工具。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A unique numeric identifier.</source>
          <target state="translated">唯一的数字标识符。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</source>
          <target state="translated">确定指定的值是否可接受的此依赖项属性的类型，如提供在原始注册的依赖项属性的属性类型进行比照。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>A value of <ph id="ph1">`null`</ph> is a valid type for reference type dependency properties, or for a &lt;xref:System.Nullable%601&gt; dependency property, and would return <ph id="ph2">`true`</ph> for these cases.</source>
          <target state="translated">值为<ph id="ph1">`null`</ph>是有效类型的引用类型依赖项属性，或为&lt;xref:System.Nullable%601&gt;依赖项属性，并将返回<ph id="ph2">`true`</ph>在这些情况下。&lt;/xref:System.Nullable%601&gt;</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>In cases where the dependency property is neither a reference nor a &lt;xref:System.Nullable%601&gt; type, IsValidType will return <ph id="ph1">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">在其中依赖项属性是既不是引用的情况下也不是&lt;xref:System.Nullable%601&gt;类型，将返回 IsValidType<ph id="ph1">`false`</ph>为 null 值，而不是引发异常。&lt;/xref:System.Nullable%601&gt;</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The value to check.</source>
          <target state="translated">要检查的值。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the specified value is the registered property type or an acceptable derived type; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果指定的值是已注册的属性类型或可接受的派生的类型;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</source>
          <target state="translated">确定是否为类型的属性通过基本类型检查，接受提供的值，可能还要是否允许该类型的值的范围内。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>For a dependency property, an allowed range of values for that type can be specified through a &lt;xref:System.Windows.ValidateValueCallback&gt; that is provided in the dependency property registration.</source>
          <target state="translated">依赖项属性，可通过指定允许的范围内的该类型的值&lt;xref:System.Windows.ValidateValueCallback&gt;提供在注册依赖属性。&lt;/xref:System.Windows.ValidateValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This method calls &lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt; internally.</source>
          <target state="translated">此方法调用&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;内部。&lt;/xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If the dependency property in question has no &lt;xref:System.Windows.ValidateValueCallback&gt;,then calling this method is effectively equivalent to calling &lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;.</source>
          <target state="translated">涉及的依赖属性是否没有提供&lt;xref:System.Windows.ValidateValueCallback&gt;，则调用此方法是有效地等效于调用&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;.&lt;/xref:System.Windows.DependencyProperty.IsValidType%2A&gt; &lt;/xref:System.Windows.ValidateValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>If the dependency property does have a &lt;xref:System.Windows.ValidateValueCallback&gt;, and if &lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt; would have returned <ph id="ph1">`true`</ph>, then the value returned will be as implemented in the callback.</source>
          <target state="translated">如果具有依赖项属性&lt;xref:System.Windows.ValidateValueCallback&gt;，并且如果&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;将返回<ph id="ph1">`true`</ph>，则在回调中实现时将返回的值。&lt;/xref:System.Windows.DependencyProperty.IsValidType%2A&gt; &lt;/xref:System.Windows.ValidateValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A null value is a valid value for reference type dependency properties, or for a &lt;xref:System.Nullable%601&gt; dependency property, and would return <ph id="ph1">`true`</ph> for these cases.</source>
          <target state="translated">空值是有效的值对于引用类型依赖项对象，或者对于&lt;xref:System.Nullable%601&gt;依赖项属性，并将返回<ph id="ph1">`true`</ph>在这些情况下。&lt;/xref:System.Nullable%601&gt;</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>In cases where the dependency property is neither a reference nor a &lt;xref:System.Nullable%601&gt; type, &lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt; will return <ph id="ph1">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">在其中依赖项属性是既不是引用的情况下也不是&lt;xref:System.Nullable%601&gt;类型，&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;将返回<ph id="ph1">`false`</ph>为 null 值，而不是引发异常。&lt;/xref:System.Windows.DependencyProperty.IsValidType%2A&gt; &lt;/xref:System.Nullable%601&gt;</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The value to check.</source>
          <target state="translated">要检查的值。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the value is acceptable and is of the correct type or a derived type; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果值是可以接受的并且是正确的类型或派生的类型;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Gets the name of the dependency property.</source>
          <target state="translated">获取依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>This property gets the name provided as the <ph id="ph1">`name`</ph> parameter during dependency property registration.</source>
          <target state="translated">此属性获取形式提供的名称<ph id="ph1">`name`</ph>期间注册依赖属性的参数。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This name is immutable, and cannot be <ph id="ph1">`null`</ph> or an empty string.</source>
          <target state="translated">此名称是不可变的并且不能为<ph id="ph1">`null`</ph>或空字符串。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</source>
          <target state="translated">重复名称注册相同的所有者类型上不允许使用，并尝试注册重复的情况下将引发异常。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The Name of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</source>
          <target state="translated">1&gt; <ph id="ph1">[!IMPORTANT]</ph>&amp;1;&gt; 依赖项属性的名称必须遵循的后缀"Property"减去其依赖项属性标识符的名称匹配的约定。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>自定义依赖项属性<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The name of the property.</source>
          <target state="translated">属性的名称。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</source>
          <target state="translated">指定的类型，重写如继承自基类型时存在的依赖项属性的元数据的实例上存在时，请指定此依赖项属性的替换元数据。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">依赖属性元数据应被替代，然后再属性系统将使用依赖项属性。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This equates to the time that specific instances are created using the class that registers the dependency property.</source>
          <target state="translated">这相当于使用注册的依赖项属性的类来创建特定实例的时间。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Calls to OverrideMetadata should only be performed within the static constructors of the type that provides itself as the <ph id="ph1">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">只应提供本身为的类型的静态构造函数内执行调用 OverrideMetadata<ph id="ph1">`forType`</ph>参数，此方法，或通过类似实例化。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">尝试更改元数据之后有所有者类型的实例, 不会引发异常，但将导致属性系统中的不一致的行为。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">使用此方法建立了特定派生的类重写元数据后，重写此相同的派生类上的元数据的后续尝试将引发异常。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">提供的元数据与依赖项属性的属性元数据合并，因为它存在于基的所有者。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">在原始的基本元数据中未指定任何特征将保持不变;仅已专门在新的元数据中更改这些特征将重写的基本元数据的特征。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Some characteristics such as &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; are replaced if specified in the new metadata.</source>
          <target state="translated">如某些特征&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;如果新的元数据中指定的替换。&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Others, such as &lt;xref:System.Windows.PropertyChangedCallback&gt;, are combined.</source>
          <target state="translated">其他，如&lt;xref:System.Windows.PropertyChangedCallback&gt;，又。&lt;/xref:System.Windows.PropertyChangedCallback&gt;</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">最终，合并行为取决于正在用于重写时，因此此处所述的行为是使用现有的属性元数据类的属性元数据类型<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>依赖项属性。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>依赖属性元数据<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>和<bpt id="p2">[</bpt>Framework 属性元数据<ept id="p2">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">上继承该依赖项属性的类型并将应用所提供的替换元数据。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">要应用于重写类型上的依赖项属性的元数据。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</source>
          <target state="translated">尝试重写只读依赖属性的元数据 (无法完成该操作使用此签名)。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Metadata was already established for the dependency property as it exists on the provided type.</source>
          <target state="translated">因为它存在于所提供的类型，已建立的依赖项属性的元数据。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">当存在指定的类型，重写在最初注册依赖属性时提供的元数据的实例上，提供替换只读依赖属性的元数据。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>You must pass the <bpt id="p1">&lt;xref href="System.Windows.DependencyPropertyKey"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for the read-only dependency property to avoid raising an exception.</source>
          <target state="translated">必须传递<bpt id="p1">&lt;xref href="System.Windows.DependencyPropertyKey"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>只读依赖属性，以避免引发异常。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>This signature provides underlying implementation for a read-only dependency property identifier (&lt;xref:System.Windows.DependencyPropertyKey&gt;) method.</source>
          <target state="translated">此签名提供了一个只读依赖属性标识符的基础实现 (&lt;xref:System.Windows.DependencyPropertyKey&gt;) 方法。&lt;/xref:System.Windows.DependencyPropertyKey&gt;</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>If overriding metadata for a read-write dependency property, use &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;.</source>
          <target state="translated">如果重写读写依赖项属性的元数据，使用&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">依赖属性元数据应被替代，然后再属性系统将使用依赖项属性。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>This equates to the time that specific objects are created for the class that registers the dependency property.</source>
          <target state="translated">这相当于注册依赖属性的类创建特定对象的时间。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Calls to &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; should only be performed within the static constructors of the type that provides itself as the <ph id="ph1">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">调用&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;仅应在提供本身为的类型的静态构造函数中执行<ph id="ph1">`forType`</ph>参数，此方法，或通过类似实例化。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">尝试更改元数据之后有所有者类型的实例, 不会引发异常，但将导致属性系统中的不一致的行为。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">使用此方法建立了特定派生的类重写元数据后，重写此相同的派生类上的元数据的后续尝试将引发异常。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">提供的元数据与依赖项属性的属性元数据合并，因为它存在于基的所有者。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">在原始的基本元数据中未指定任何特征将保持不变;仅已专门在新的元数据中更改这些特征将重写的基本元数据的特征。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Some characteristics such as &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; are replaced if specified in the new metadata.</source>
          <target state="translated">如某些特征&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;如果新的元数据中指定的替换。&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Others, such as &lt;xref:System.Windows.PropertyChangedCallback&gt;, are combined.</source>
          <target state="translated">其他，如&lt;xref:System.Windows.PropertyChangedCallback&gt;，又。&lt;/xref:System.Windows.PropertyChangedCallback&gt;</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The merge behavior depends on the property metadata type being used for the override.</source>
          <target state="translated">合并行为取决于正在使用用于重写的属性元数据类型。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>依赖属性元数据<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>和<bpt id="p2">[</bpt>Framework 属性元数据<ept id="p2">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">上继承该依赖项属性的类型并将应用所提供的替换元数据。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">要应用于重写类型上的依赖项属性的元数据。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The access key for a read-only dependency property.</source>
          <target state="translated">只读依赖属性的访问密钥。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</source>
          <target state="translated">获取使用属性系统注册依赖属性或者将自己作为属性所有者添加的对象的类型。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This value was provided during property registration.</source>
          <target state="translated">属性注册期间提供此值。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The owner will be either the original registering type in the case of a &lt;xref:System.Windows.DependencyProperty&gt; identifier generated from a &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; call, or the type that added itself as owner in the case of a &lt;xref:System.Windows.DependencyProperty&gt; identifier generated from an &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; call.</source>
          <target state="translated">所有者将任一原始注册类型的情况下&lt;xref:System.Windows.DependencyProperty&gt;从生成标识符&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;调用，或者将自己作为所有者的情况下添加的类型&lt;xref:System.Windows.DependencyProperty&gt;从生成标识符&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;调用。&lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt; &lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The OwnerType on any given &lt;xref:System.Windows.DependencyProperty&gt; is immutable, and cannot be <ph id="ph1">`null`</ph> in a valid &lt;xref:System.Windows.DependencyProperty&gt;.</source>
          <target state="translated">针对任何给定所有者类型&lt;xref:System.Windows.DependencyProperty&gt;是不可变，并且不能为<ph id="ph1">`null`</ph>中有效的&lt;xref:System.Windows.DependencyProperty&gt;。&lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The type of the object that registered the property or added itself as owner of the property.</source>
          <target state="translated">注册属性或者将自己作为属性所有者添加的对象类型。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Gets the type that the dependency property uses for its value.</source>
          <target state="translated">获取用于其值的依赖项属性的类型。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>This property reports the type of the property's value as declared by the original property registration, through the <ph id="ph1">`propertyType`</ph> parameter.</source>
          <target state="translated">此属性报告类型的属性的值所声明的原始的注册属性中，通过<ph id="ph1">`propertyType`</ph>参数。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;xref:System.Windows.DependencyProperty.Name%2A&gt;, the property type of a dependency property is immutable after registration.</source>
          <target state="translated">类似于&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;，依赖项属性的属性类型注册后不可变。&lt;/xref:System.Windows.DependencyProperty.Name%2A&gt;</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Type&gt; of the property value.</source>
          <target state="translated">&lt;xref:System.Type&gt;的属性值。&lt;/xref:System.Type&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the dependency property identified by this <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance is a read-only dependency property.</source>
          <target state="translated">获取一个值，该值指示依赖属性是否标识此<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>实例是一个只读依赖属性。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Read-only dependency properties are registered within the property system by calling the &lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt; method as opposed to the &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; method.</source>
          <target state="translated">在属性系统注册只读依赖属性，应调用&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;方法而非&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;方法。&lt;/xref:System.Windows.DependencyProperty.Register%2A&gt; &lt;/xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Attached properties can also be registered as read-only; see &lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;.</source>
          <target state="translated">此外可以将附加的属性注册为只读的;请参阅&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;。&lt;/xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Read-only dependency properties require a &lt;xref:System.Windows.DependencyPropertyKey&gt; identifier rather than a &lt;xref:System.Windows.DependencyProperty&gt; identifier to perform metadata operations such as overriding the metadata or setting the value.</source>
          <target state="translated">只读依赖属性可能需要&lt;xref:System.Windows.DependencyPropertyKey&gt;标识符而不是&lt;xref:System.Windows.DependencyProperty&gt;标识符来执行元数据操作，例如重写元数据或将值设置。&lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyPropertyKey&gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>If you obtained a collection of &lt;xref:System.Windows.DependencyProperty&gt; identifiers through a call to &lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt; or another <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)]</ph> that exposes identifiers, check the ReadOnly value before attempting to call &lt;xref:System.Windows.DependencyObject.SetValue%2A&gt; or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</source>
          <target state="translated">如果你获得的集合&lt;xref:System.Windows.DependencyProperty&gt;通过调用标识符&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;或另一个<ph id="ph1">[!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)]</ph>公开标识符，请在尝试调用之前检查的 ReadOnly 值&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;使用该依赖属性标识符作为输入参数，以验证标识符表示的依赖项属性不是只读的。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyObject.SetValue%2A&gt; &lt;/xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt; &lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>If the value of ReadOnly is <ph id="ph1">`true`</ph> on a dependency property, there is no programmatic way to obtain a reference to the &lt;xref:System.Windows.DependencyPropertyKey&gt; identifier of that dependency property, from the metadata or from the &lt;xref:System.Windows.DependencyProperty&gt; identifier; the identifier must be available as a static field in order to call &lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt; against a read-only dependency property.</source>
          <target state="translated">如果值为 ReadOnly<ph id="ph1">`true`</ph>某个依赖项属性，没有获得对的引用无法通过编程方式&lt;xref:System.Windows.DependencyPropertyKey&gt;从元数据或从该依赖属性标识符&lt;xref:System.Windows.DependencyProperty&gt;标识符; 标识符必须可用作静态字段才能调用&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;针对只读依赖属性。&lt;/xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt; &lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyPropertyKey&gt;</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph> wrapper property.</source>
          <target state="translated">当你创建自定义的依赖项属性，并将其注册为只读的时应定义仅一个 get 访问器为<ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]</ph>包装属性。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</source>
          <target state="translated">否则，你的类将具有相比对后备依赖项属性的访问权限属性包装令人困惑的对象模型。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> or <bpt id="p2">[</bpt>Read-Only Dependency Properties<ept id="p2">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>自定义依赖项属性<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>或<bpt id="p2">[</bpt>只读依赖项属性<ept id="p2">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the dependency property is read-only; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果依赖项属性是只读的;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Registers a dependency property with the specified property name, property type, and owner type.</source>
          <target state="translated">使用指定的属性名称、 属性类型和所有者类型注册依赖属性。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For more information on dependency property registration, see &lt;xref:System.Windows.DependencyProperty&gt;.</source>
          <target state="translated">注册依赖属性的详细信息，请参阅&lt;xref:System.Windows.DependencyProperty&gt;。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The name must be unique within the registration namespace of the owner type.</source>
          <target state="translated">名称必须是唯一的所有者类型的注册命名空间中。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>A dependency property identifier that should be used to set the value of a <bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> field in your class.</source>
          <target state="translated">应该用于设置的值的依赖项属性标识符<bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>字段在您的类。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">使用指定的属性名称、 属性类型、 所有者类型和属性元数据注册依赖属性。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>For more information on dependency property registration, see &lt;xref:System.Windows.DependencyProperty&gt;.</source>
          <target state="translated">注册依赖属性的详细信息，请参阅&lt;xref:System.Windows.DependencyProperty&gt;。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">依赖项属性的属性元数据。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>A dependency property identifier that should be used to set the value of a <bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> field in your class.</source>
          <target state="translated">应该用于设置的值的依赖项属性标识符<bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>字段在您的类。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</source>
          <target state="translated">使用指定的属性名称、 属性类型、 所有者类型、 属性元数据和属性的值验证回叫注册的依赖项属性。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>For more information on dependency property registration, see &lt;xref:System.Windows.DependencyProperty&gt;.</source>
          <target state="translated">注册依赖属性的详细信息，请参阅&lt;xref:System.Windows.DependencyProperty&gt;。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">依赖项属性的属性元数据。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">对应执行依赖属性值，除了典型的类型验证之外的任何自定义验证回调的引用。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>A dependency property identifier that should be used to set the value of a <bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> field in your class.</source>
          <target state="translated">应该用于设置的值的依赖项属性标识符<bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>字段在您的类。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Registers an attached property with the specified property name, property type, and owner type.</source>
          <target state="translated">使用指定的属性名称、 属性类型和所有者类型注册附加的属性。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">附加的属性是由定义的属性概念<ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>实现附加作为依赖项属性的属性。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">因为<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>附加的属性都是依赖项属性，它们可以应用可以用于操作，如 reporting 布局特征的常规属性系统的元数据。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>附加属性概述<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>For more information on dependency property registration, see &lt;xref:System.Windows.DependencyProperty&gt;.</source>
          <target state="translated">注册依赖属性的详细信息，请参阅&lt;xref:System.Windows.DependencyProperty&gt;。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>A dependency property identifier that should be used to set the value of a <bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> field in your class.</source>
          <target state="translated">应该用于设置的值的依赖项属性标识符<bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>字段在您的类。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Registers an attached property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">使用指定的属性名称、 属性类型、 所有者类型和属性元数据注册附加的属性。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">依赖项属性的属性元数据。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">这可以包括默认值，以及其他特征。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>A dependency property identifier that should be used to set the value of a <bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> field in your class.</source>
          <target state="translated">应该用于设置的值的依赖项属性标识符<bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>字段在您的类。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</source>
          <target state="translated">使用指定的属性类型、 所有者类型、 属性元数据和属性的值验证回叫注册附加的属性。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">依赖项属性的属性元数据。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">这可以包括默认值，以及其他特征。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">对应执行依赖属性值，除了典型的类型验证之外的任何自定义验证回调的引用。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>A dependency property identifier that should be used to set the value of a <bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> field in your class.</source>
          <target state="translated">应该用于设置的值的依赖项属性标识符<bpt id="p1">&lt;xref uid="langword_csharp_public static readonly" name="public static readonly" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>字段在您的类。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">该标识符然后用于以编程方式设置其值或获取元数据等操作的更高版本，引用该依赖属性。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">使用指定的属性类型、 所有者类型和属性元数据注册只读附加的属性。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">依赖项属性的属性元数据。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">一个用于在您的类，然后使用以供以后参考依赖项属性中设置静态只读字段的值的依赖属性键。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">使用指定的属性类型、 所有者类型、 属性元数据和验证回叫注册只读附加的属性。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">依赖项属性的属性元数据。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">对用户创建应执行依赖属性值，除了典型的类型验证之外的任何自定义验证的回调的引用。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">一个用于在你的类，该类用来引用依赖项属性中设置静态只读字段的值的依赖属性键。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">使用指定的属性类型、 所有者类型和属性元数据注册只读依赖属性。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>This method returns the type &lt;xref:System.Windows.DependencyPropertyKey&gt;, whereas &lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt; returns the type &lt;xref:System.Windows.DependencyProperty&gt;.</source>
          <target state="translated">此方法返回的类型&lt;xref:System.Windows.DependencyPropertyKey&gt;，而&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;返回的类型&lt;xref:System.Windows.DependencyProperty&gt;.&lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt; &lt;/xref:System.Windows.DependencyPropertyKey&gt;</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling &lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;.</source>
          <target state="translated">通常，表示只读属性的键不是公共的因为密钥可用于设置依赖项属性值，通过调用&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;.&lt;/xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any &lt;xref:System.Windows.DependencyPropertyKey&gt; to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">类设计会影响你的要求，但通常建议来限制访问和可见性的任何&lt;xref:System.Windows.DependencyPropertyKey&gt;到仅这些部分的代码所需将该依赖项属性设置为类或应用程序逻辑的一部分。&lt;/xref:System.Windows.DependencyPropertyKey&gt;</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of &lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName&gt; as a <ph id="ph1">`public static readonly`</ph> field on your class.</source>
          <target state="translated">此外，还建议通过公开的值公开只读依赖属性，一个依赖属性标识符&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName&gt;作为<ph id="ph1">`public static readonly`</ph>你类字段&lt;/xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Read-only dependency properties are a fairly typical scenario both in the existing <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)]</ph> and for customization scenarios, because other <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> features might require a dependency property even if that property is not intended to be settable by callers.</source>
          <target state="translated">只读依赖属性是相当典型的方案中这两个现有<ph id="ph1">[!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)]</ph>和自定义方案，因为其他<ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>功能可能需要依赖项属性，即使该属性不是可由调用方。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a &lt;xref:System.Windows.Trigger&gt; on the dependency property in a style.</source>
          <target state="translated">你可以执行需要依赖项属性，例如使其他属性系统操作只读依赖属性的值将用作基础&lt;xref:System.Windows.Trigger&gt;样式中的依赖属性。&lt;/xref:System.Windows.Trigger&gt;</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>For more information on dependency property registration, see &lt;xref:System.Windows.DependencyProperty&gt;.</source>
          <target state="translated">注册依赖属性的详细信息，请参阅&lt;xref:System.Windows.DependencyProperty&gt;。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">依赖项属性的属性元数据。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">一个用于在你的类，该类用来引用依赖项属性中设置静态只读字段的值的依赖属性键。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">使用指定的属性类型、 所有者类型、 属性元数据和验证回叫注册只读依赖属性。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>This method returns the type &lt;xref:System.Windows.DependencyPropertyKey&gt;, whereas &lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt; returns the type &lt;xref:System.Windows.DependencyProperty&gt;.</source>
          <target state="translated">此方法返回的类型&lt;xref:System.Windows.DependencyPropertyKey&gt;，而&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;返回的类型&lt;xref:System.Windows.DependencyProperty&gt;.&lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt; &lt;/xref:System.Windows.DependencyPropertyKey&gt;</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling &lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;.</source>
          <target state="translated">通常，表示只读属性的键不是公共的因为密钥可用于设置依赖项属性值，通过调用&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;.&lt;/xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any &lt;xref:System.Windows.DependencyPropertyKey&gt; to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">类设计会影响你的要求，但通常建议来限制访问和可见性的任何&lt;xref:System.Windows.DependencyPropertyKey&gt;到仅这些部分的代码所需将该依赖项属性设置为类或应用程序逻辑的一部分。&lt;/xref:System.Windows.DependencyPropertyKey&gt;</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of &lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName&gt; as a <ph id="ph1">`public static readonly`</ph> field on your class.</source>
          <target state="translated">此外，还建议通过公开的值公开只读依赖属性，一个依赖属性标识符&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName&gt;作为<ph id="ph1">`public static readonly`</ph>你类字段&lt;/xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Read-only dependency properties are a fairly typical scenario.</source>
          <target state="translated">只读依赖属性是相当典型的方案。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a &lt;xref:System.Windows.Trigger&gt; on the dependency property in a style.</source>
          <target state="translated">你可以执行需要依赖项属性，例如使其他属性系统操作只读依赖属性的值将用作基础&lt;xref:System.Windows.Trigger&gt;样式中的依赖属性。&lt;/xref:System.Windows.Trigger&gt;</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>For more information on dependency property registration, see &lt;xref:System.Windows.DependencyProperty&gt;.</source>
          <target state="translated">注册依赖属性的详细信息，请参阅&lt;xref:System.Windows.DependencyProperty&gt;。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Validation on a read-only dependency property might be less important.</source>
          <target state="translated">对只读依赖属性的验证可能不太重要。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</source>
          <target state="translated">你为密钥指定的非公共访问级别降低了对任意无效输入的可能性。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The name of the dependency property to register.</source>
          <target state="translated">要注册的依赖项属性的名称。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
          <target state="translated">属性的类型。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">正在注册依赖属性所有者类型。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">依赖项属性的属性元数据。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">对用户创建应执行依赖属性值，除了典型的类型验证之外的任何自定义验证的回调的引用。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">一个用于在您的类，然后使用以供以后参考依赖项属性中设置静态只读字段的值的依赖属性键。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the dependency property.</source>
          <target state="translated">返回的字符串表示形式的依赖属性。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>This implementation returns the &lt;xref:System.Windows.DependencyProperty.Name%2A&gt; property value.</source>
          <target state="translated">此实现返回&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;属性值。&lt;/xref:System.Windows.DependencyProperty.Name%2A&gt;</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>The string representation of the dependency property.</source>
          <target state="translated">依赖项属性的字符串表示形式。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Specifies a static value that is used by the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> property system rather than <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to indicate that the property exists, but does not have its value set by the property system.</source>
          <target state="translated">指定一个静态值，由<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>属性系统而不是<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>以指示该属性存在，但不具有其值由属性系统设置。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>UnsetValue is a sentinel value that is used for scenarios where the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> property system is unable to determine a requested &lt;xref:System.Windows.DependencyProperty&gt; value.</source>
          <target state="translated">UnsetValue 是用于方案的 sentinel 值其中<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>属性系统不能确定请求&lt;xref:System.Windows.DependencyProperty&gt;值。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>UnsetValue is used rather than <ph id="ph1">`null`</ph>, because <ph id="ph2">`null`</ph> could be a valid property value, as well as a valid (and frequently used) &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;.</source>
          <target state="translated">使用 UnsetValue 而非<ph id="ph1">`null`</ph>，这是因为<ph id="ph2">`null`</ph>可能是一个有效的属性值，以及有效 （和常用） &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;.&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>UnsetValue is never returned out of &lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">UnsetValue 永远不会返回超出&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName&gt;.&lt;/xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>When you call &lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName&gt; on a dependency property on a &lt;xref:System.Windows.DependencyObject&gt; instance, one of the following applies:      -   A dependency property has a default value established in metadata and that value is returned.</source>
          <target state="translated">当调用&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName&gt;上的依赖项属性&lt;xref:System.Windows.DependencyObject&gt;适用的情况下，以下项之一:-依赖项属性在元数据中建立的默认值而则返回该值。&lt;/xref:System.Windows.DependencyObject&gt; &lt;/xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>This value might come from &lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;.</source>
          <target state="translated">此值可能来自于&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;.&lt;/xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>-   Some other value was established by the property system, and the default value is no longer relevant.</source>
          <target state="translated">-一些其他值由属性系统，并且默认值不再适用。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>依赖项属性值优先级<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Setting a &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; of UnsetValue is specifically disallowed.</source>
          <target state="translated">设置&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;UnsetValue 的明确不允许。&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName&gt; returns UnsetValue when the requested property has not been locally set.</source>
          <target state="translated">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName&gt;请求的属性未本地设置时，请返回 UnsetValue。&lt;/xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>UnsetValue has a special meaning when used as the return value of a &lt;xref:System.Windows.CoerceValueCallback&gt;.</source>
          <target state="translated">UnsetValue 具有特殊含义时用作一种&lt;xref:System.Windows.CoerceValueCallback&gt;。&lt;/xref:System.Windows.CoerceValueCallback&gt;的返回值</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>依赖项属性的回调和验证<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>If you are binding to a database, note that UnsetValue is not equivalent to &lt;xref:System.DBNull.Value&gt;, in a similar way to how &lt;xref:System.DBNull.Value&gt; is not equivalent to a true null.</source>
          <target state="translated">如果你正在绑定到数据库，请注意，UnsetValue 不等效于&lt;xref:System.DBNull.Value&gt;，如何以类似方式&lt;xref:System.DBNull.Value&gt;不等于 true null。&lt;/xref:System.DBNull.Value&gt; &lt;/xref:System.DBNull.Value&gt;</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">要添加。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Gets the value validation callback for the dependency property.</source>
          <target state="translated">获取依赖项属性的值验证回调。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>This property will contain <ph id="ph1">`null`</ph> for any dependency property with no registered validation callback.</source>
          <target state="translated">此属性将包含<ph id="ph1">`null`</ph>对于没有注册的验证回调的任何依赖项属性。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Validate value callbacks must act in a static sense: validation applied through the &lt;xref:System.Windows.ValidateValueCallback&gt; cannot determine whether the provided value is valid for any particular instance.</source>
          <target state="translated">验证回调必须在静态的意义上执行操作的值︰ 验证通过应用&lt;xref:System.Windows.ValidateValueCallback&gt;无法确定提供的值是否有效的任何特定的实例。&lt;/xref:System.Windows.ValidateValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</source>
          <target state="translated">回调仅可以确定是否具有依赖项属性的所有对象应，或不应接受为有效提供的值。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a &lt;xref:System.Windows.CoerceValueCallback&gt; instead.</source>
          <target state="translated">如果你需要执行依赖于知道上一个特定实例，使用其他依赖项属性的值的验证&lt;xref:System.Windows.CoerceValueCallback&gt;相反。&lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Windows.CoerceValueCallback&gt; is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</source>
          <target state="translated">&lt;xref:System.Windows.CoerceValueCallback&gt;作为一部分的依赖属性元数据，而不是直接在依赖属性标识符内注册。&lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>依赖项属性的回调和验证<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The value validation callback for this dependency property, as provided for the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">validateValueCallback</ph><ept id="p1">&lt;/code&gt;</ept> parameter in the original dependency property registration.</source>
          <target state="translated">此依赖项属性，为提供的值验证回调<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">validateValueCallback</ph> <ept id="p1">&lt;/code&gt;</ept>在原始注册的依赖项属性的参数。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>