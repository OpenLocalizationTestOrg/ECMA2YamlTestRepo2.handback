<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">93899f77dbe9a89a757dd2011e2fe034a73757a3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Security.CodeAccessPermission.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">76e028dcf191768d6cde1ff987f2c0821484576b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">620f466bc0c7923a43efc9b1250f57dc037351b1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines the underlying structure of all code access permissions.</source>
          <target state="translated">定义所有代码访问权限的基础结构。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</source>
          <target state="translated">代码访问权限使用堆栈审核来确保代码的所有调用方已被授予权限。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>If a permission object is <ph id="ph1">`null`</ph>, it is handled the same as a permission object with the state &lt;xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;.</source>
          <target state="translated">如果权限对象是<ph id="ph1">`null`</ph>，对其进行处理权限对象的状态&lt;xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;.&lt;/xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;相同</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">调用堆栈通常表示为向下增长，以便对调用堆栈中调用方法中较低的调用堆栈。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Inheritors of the CodeAccessPermission class must be granted full trust to function correctly as permissions extending the security infrastructure.</source>
          <target state="translated">CodeAccessPermission 类的继承者必须被授予完全信任才能正常工作作为安全基础结构扩展的权限。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>To determine that the inheritors are fully trusted, CodeAccessPermission issues an &lt;xref:System.Security.Permissions.SecurityAction&gt; for &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt; = <ph id="ph1">`true`</ph> and &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt; = <ph id="ph2">`true`</ph>.</source>
          <target state="translated">若要确定继承者均完全受信任，CodeAccessPermission 发出&lt;xref:System.Security.Permissions.SecurityAction&gt;为&lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt;=<ph id="ph1">`true`</ph>和&lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt;= <ph id="ph2">`true`</ph>。&lt;/xref:System.Security.Permissions.SecurityPermissionFlag&gt; &lt;/xref:System.Security.Permissions.SecurityPermissionFlag&gt; &lt;/xref:System.Security.Permissions.SecurityAction&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>类。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This constructor is called to initialize state in the type whenever an instance of the derived class is created.</source>
          <target state="translated">此构造函数调用以初始化类型中的状态，每当创建派生类的实例。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</source>
          <target state="translated">尽管派生的类构造函数的构造函数声明中，您可以显式调用此构造函数，这通常没有必要;大多数编译器将自动生成对你的调用。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">声明调用代码可以访问受权限请求通过调用此方法的代码，即使在堆栈中的高级调用方不具备访问该资源的权限的资源。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Using Assert can create security issues.</source>
          <target state="translated">使用断言会引起安全问题。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">调用堆栈通常表示为向下增长，以便对调用堆栈中调用方法中较低的调用堆栈。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Calling Assert prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</source>
          <target state="translated">调用断言可防止发出的超出调用此方法的代码，在调用堆栈中向上继续执行调用堆栈中下方的堆栈审核。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</source>
          <target state="translated">因此，即使调用堆栈上的高级调用方没有所需的权限来访问的资源，它们可以仍通过访问它的代码上所需的权限调用此方法。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>An assertion is effective only if the code that calls Assert passes the security check for the permission that it is asserting.</source>
          <target state="translated">仅当调用断言的代码，通过它断言的权限的安全检查有效断言。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The call to Assert is effective until the calling code returns to its caller.</source>
          <target state="translated">Assert 调用后调用的代码返回其调用方才有效。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Only one Assert can be active on a frame.</source>
          <target state="translated">只有一个断言可以处于活动状态的帧。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>An attempt to call Assert when an active Assert exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.</source>
          <target state="translated">尝试调用断言 active 断言存在帧上时导致一种&lt;xref:System.Security.SecurityException&gt;。&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Call &lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active Assert.</source>
          <target state="translated">调用&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;或&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;删除 active Assert。&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Assert is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">断言对于未授予对该权限的请求将不会成功的权限，将忽略。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>However, if code lower on the call stack calls &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call Assert.</source>
          <target state="translated">但是，如果调用堆栈上较低的代码调用&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;对该权限&lt;xref:System.Security.SecurityException&gt;堆栈审核达到尝试调用断言的代码时引发。&lt;/xref:System.Security.SecurityException&gt; &lt;/xref:System.Security.CodeAccessPermission.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This happens because the code that called Assert has not been granted the permission, even though it tried to Assert it.</source>
          <target state="translated">这是因为调用断言的代码未被授予权限，即使它尝试断言它也是如此。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Because calling Assert removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</source>
          <target state="translated">1&gt; <ph id="ph1">[!CAUTION]</ph>&amp;1;&gt; 调用断言免除了调用链中的所有代码必须都授予访问指定的资源的权限，因为它可以如果使用不当来打开个安全问题。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">因此，它应谨慎使用。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The calling code does not have <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermissionFlag"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">调用代码没有<bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermissionFlag"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>-or-       There is already an active Assert for the current frame.</source>
          <target state="translated">-或者-已存在用于当前帧的活动断言。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>When implemented by a derived class, creates and returns an identical copy of the current permission object.</source>
          <target state="translated">由派生类实现时，创建并返回当前权限对象的相同副本。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A copy of a permission object represents the same access to resources as the original permission object.</source>
          <target state="translated">权限对象的副本与原始的权限对象的资源表示相同的访问权限。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A copy of the current permission object.</source>
          <target state="translated">当前权限对象的副本。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Forces a &lt;xref:System.Security.SecurityException&gt; at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</source>
          <target state="translated">强制&lt;xref:System.Security.SecurityException&gt;如果尚未授予调用堆栈中的所有高级调用方的当前实例所指定的权限，则在运行时。&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">安全库通常使用此方法以确保调用方有权访问的资源。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For example, a file class in a secure class library calls Demand for the necessary &lt;xref:System.Security.Permissions.FileIOPermission&gt; before performing a file operation requested by the caller.</source>
          <target state="translated">例如，安全类库中的文件类调用所需的需&lt;xref:System.Security.Permissions.FileIOPermission&gt;之前执行文件操作请求由调用方。&lt;/xref:System.Security.Permissions.FileIOPermission&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">调用此方法的代码的权限不会检查;检查开始从该代码的直接调用方，并在堆栈中向上继续进行。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">调用堆栈通常表示为向下增长，以便对调用堆栈中调用方法中较低的调用堆栈。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Demand succeeds only if no &lt;xref:System.Security.SecurityException&gt; is raised.</source>
          <target state="translated">需要时才会成功没有&lt;xref:System.Security.SecurityException&gt;引发。&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have the permission specified by the current instance.</source>
          <target state="translated">调用堆栈中较高调用方没有由当前实例所指定的权限。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>-or-       A caller higher in the call stack has called &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; on the current permission object.</source>
          <target state="translated">-或-调用堆栈中较高调用方已调用&lt;xref:System.Security.CodeAccessPermission.Deny*&gt;对当前权限对象。&lt;/xref:System.Security.CodeAccessPermission.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</source>
          <target state="translated">防止处于调用堆栈较高位置使用调用此方法来访问当前实例所指定的资源的代码。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The Deny method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>1&gt; Deny 方法应仅用于防止意外的访问的资源完全受信任的代码。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">它不应以防止故意误用资源受信任的代码。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a Deny for a permission and then calls method <ph id="ph2">`B`</ph>, method <ph id="ph3">`B`</ph> can overtly override the Deny by issuing an &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.</source>
          <target state="translated">例如，如果方法<ph id="ph1">`A`</ph>发出的 Deny 权限，然后调用方法<ph id="ph2">`B`</ph>，方法<ph id="ph3">`B`</ph>而公开可以通过发出&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;替代拒绝</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">调用的方法是始终对堆栈中。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no Deny or &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; lower in the stack.</source>
          <target state="translated">因此，如果方法<ph id="ph1">`B`</ph>尝试访问受保护的资源，安全系统开始查找与它的权限，因为方法<ph id="ph2">`B`</ph>是直接调用方，上下然后查找步程堆栈，以确认没有任何拒绝或&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;堆栈中下方。&lt;/xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; method.</source>
          <target state="translated">方法<ph id="ph1">`B`</ph>，这尝试访问资源，可以停止堆栈审核立即使用&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;方法。&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In that case, the Deny placed on the stack by method <ph id="ph1">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">在这种情况下，拒绝将位于堆栈上通过方法<ph id="ph1">`A`</ph>永远不会发现 （调用方法）。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">此方法会阻止调用堆栈中的高级调用方通过调用此方法的代码，访问受保护的资源，即使这些调用方已被授予权限来访问它。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">调用堆栈通常表示为向下增长，以便对调用堆栈中调用方法中较低的调用堆栈。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Deny can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls Deny from being used to access the resource protected by the denied permission.</source>
          <target state="translated">拒绝可以限制了编程人员的责任或帮助防止出现意外的安全问题，因为它有助于防止拒绝调用从用于访问被拒绝的权限所保护的资源的方法。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If a method calls Deny on a permission, and if a &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the Deny.</source>
          <target state="translated">如果一个方法调用拒绝对权限，并且&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;到达拒绝时，该安全检查为该权限调用方的调用堆栈中较低级别调用，将会失败。&lt;/xref:System.Security.CodeAccessPermission.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The call to Deny is effective until the calling code returns to its caller.</source>
          <target state="translated">直到调用代码返回其调用方，则调用 Deny 才生效。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Only one Deny can be active on a frame.</source>
          <target state="translated">只有一个拒绝可以处于活动状态的帧。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>An attempt to call Deny when an active Deny exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.</source>
          <target state="translated">尝试调用拒绝 active 拒绝帧上存在时导致一种&lt;xref:System.Security.SecurityException&gt;。&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Call &lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active Deny.</source>
          <target state="translated">调用&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;或&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;删除 active 拒绝。&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Deny is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">拒绝将忽略针对权限未授予对该权限的请求将不会成功。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>There is already an active Deny for the current frame.</source>
          <target state="translated">当前帧的活动拒绝已存在。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Determines whether the specified <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is equal to the current <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">确定是否指定<bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象是否等于当前<bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;xref:System.Object.Equals%2A&gt;.</source>
          <target state="translated">有关详细信息，请参阅&lt;xref:System.Object.Equals%2A&gt;。&lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to compare with the current <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>要与当前比较对象<bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the specified <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object is equal to the current <bpt id="p3">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>; otherwise, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果指定<bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>对象是否等于当前<bpt id="p3">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>; 否则为<bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</source>
          <target state="translated">当在派生类中重写，重新构造具有指定状态的 XML 编码的安全对象。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Custom code that extends security objects needs to implement the &lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt; and FromXml methods to make the objects security-encodable.</source>
          <target state="translated">扩展安全对象的自定义代码需要实现&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;和 FromXml 方法，以便可以对对象的安全性进行编码。&lt;/xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The XML encoding to use to reconstruct the security object.</source>
          <target state="translated">编码用于重新构造安全对象的 XML。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter does not contain the XML encoding for an instance of the same type as the current instance.</source>
          <target state="translated"><bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">elem</ph> <ept id="p1">&lt;/code&gt;</ept>参数不包含与当前实例相同的类型的实例的 XML 编码。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>-or-       The version number of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not supported.</source>
          <target state="translated">-版本数<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">elem</ph> <ept id="p1">&lt;/code&gt;</ept>不支持参数。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Gets a hash code for the <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that is suitable for use in hashing algorithms and data structures such as a hash table.</source>
          <target state="translated">获取的哈希代码<bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>是适合在哈希算法和数据结构，如哈希表中使用的对象。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two &lt;xref:System.Security.CodeAccessPermission&gt; objects.</source>
          <target state="translated">相同的权限的两个实例的哈希代码可能会有所不同，因此不应使用的哈希代码来比较两个&lt;xref:System.Security.CodeAccessPermission&gt;对象。&lt;/xref:System.Security.CodeAccessPermission&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A hash code for the current <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">当前的哈希代码<bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</source>
          <target state="translated">由派生类实现时，创建并返回是当前权限和指定的权限的交集的权限。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The intersection of two permissions is a permission that describes the set of operations they both describe in common.</source>
          <target state="translated">以下两个权限的交集是描述组的二者共同描述的操作的权限。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Only a demand that passes both original permissions will pass the intersection.</source>
          <target state="translated">仅通过两个原始权限的请求将通过该交集。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>A permission to intersect with the current permission.</source>
          <target state="translated">要与当前权限相交的权限。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">它必须与当前权限属于同一类型。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A new permission that represents the intersection of the current permission and the specified permission.</source>
          <target state="translated">表示当前权限和指定的权限的交集的一个新权限。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This new permission is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the intersection is empty.</source>
          <target state="translated">此新权限为<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果交集为空。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">target</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> and is not an instance of the same class as the current permission.</source>
          <target state="translated"><bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">target</ph> <ept id="p1">&lt;/code&gt;</ept>参数不是<bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>并且不是与当前权限相同的类的实例。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</source>
          <target state="translated">由派生类实现时，确定当前权限是否为指定权限的子集。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>A permission that is to be tested for the subset relationship.</source>
          <target state="translated">将要测试子集关系的权限。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This permission must be of the same type as the current permission.</source>
          <target state="translated">此权限必须是与当前权限属于同一类型。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current permission is a subset of the specified permission; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果当前权限是指定权限; 的子集否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">target</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> and is not of the same type as the current permission.</source>
          <target state="translated"><bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">target</ph> <ept id="p1">&lt;/code&gt;</ept>参数不是<bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>并且不是与当前权限属于同一类型。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</source>
          <target state="translated">防止处于调用堆栈较高位置使用的代码将调用此方法来访问除当前实例所指定的资源以外的所有资源。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The PermitOnly method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>1&gt; PermitOnly 方法应仅用于防止意外的访问的资源完全受信任的代码。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">它不应以防止故意误用资源受信任的代码。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a PermitOnly for a permission and then calls method <ph id="ph2">`B`</ph>, method <ph id="ph3">`B`</ph> can overtly override the PermitOnly by issuing an &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.</source>
          <target state="translated">例如，如果方法<ph id="ph1">`A`</ph>发出针对权限 PermitOnly，然后调用方法<ph id="ph2">`B`</ph>，方法<ph id="ph3">`B`</ph>而公开可以通过发出&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;替代 PermitOnly</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">调用的方法是始终对堆栈中。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; or PermitOnly lower in the stack.</source>
          <target state="translated">因此，如果方法<ph id="ph1">`B`</ph>尝试访问受保护的资源，安全系统开始查找与它的权限，因为方法<ph id="ph2">`B`</ph>是直接调用方，上下然后查找步程堆栈，以确认是否存在任何&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;或 PermitOnly 堆栈中下方。&lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; method.</source>
          <target state="translated">方法<ph id="ph1">`B`</ph>，这尝试访问资源，可以停止堆栈审核立即使用&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;方法。&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In that case, the PermitOnly placed on the stack by method <ph id="ph1">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">PermitOnly 方法由放置在堆栈上的这种情况下，<ph id="ph1">`A`</ph>永远不会发现 （调用方法）。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>PermitOnly is similar to &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated">PermitOnly 是类似于&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;，因为同时导致堆栈审核失败时它们原本应该成功。&lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; specifies permissions that will cause the stack walk to fail, but PermitOnly specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">差异在于&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;指定权限将导致堆栈审核失败，但 PermitOnly 指定不会导致堆栈审核失败的唯一权限。&lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">调用此方法，以确保你的代码可以用于访问指定的资源。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The call to PermitOnly is effective until the calling code returns to its caller.</source>
          <target state="translated">PermitOnly 调用后调用的代码返回其调用方才有效。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Only one PermitOnly can be active on a frame.</source>
          <target state="translated">只有一个 PermitOnly 可以处于活动状态的帧。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>An attempt to call PermitOnly when an active PermitOnly exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.</source>
          <target state="translated">尝试调用 PermitOnly active PermitOnly 帧上存在时导致一种&lt;xref:System.Security.SecurityException&gt;。&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Call &lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active PermitOnly.</source>
          <target state="translated">调用&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;或&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;删除 active PermitOnly。&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>PermitOnly is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">PermitOnly 将忽略针对权限未授予对该权限的请求将不会成功。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>However, if code lower on the call stack later calls &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call PermitOnly.</source>
          <target state="translated">但是，如果在调用的低级代码堆栈更高版本调用&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;对该权限&lt;xref:System.Security.SecurityException&gt;堆栈审核达到尝试调用 PermitOnly 代码时引发。&lt;/xref:System.Security.SecurityException&gt; &lt;/xref:System.Security.CodeAccessPermission.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This is because the code that called PermitOnly has not been granted the permission, even though it called PermitOnly for that permission.</source>
          <target state="translated">这是因为调用 PermitOnly 的代码未被授予权限，即使它为该权限调用 PermitOnly 也是如此。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">调用堆栈通常表示为向下增长，以便对调用堆栈中调用方法中较低的调用堆栈。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>There is already an active PermitOnly for the current frame.</source>
          <target state="translated">当前帧 active PermitOnly 已存在。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Causes all previous overrides for the current frame to be removed and no longer in effect.</source>
          <target state="translated">导致当前帧要删除且不再有效的所有以前替代。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If there are no overrides (&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;, &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, or &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;) for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">如果没有重写 (&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;， &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;，或&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;) 当前帧，&lt;xref:System.ExecutionEngineException&gt;引发。&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.Assert<bpt id="p1">*</bpt>&gt;, &lt;xref:System.Security.CodeAccessPermission.Deny<ept id="p1">*</ept>&gt;, or &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame.</source>
          <target state="translated">不再具有以前&lt;&gt; <bpt id="p1">*</bpt>1&gt;， &lt;&gt; &lt;/&gt; <ept id="p1">*</ept>1&gt;，或&lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt;当前帧。&lt;/xref:System.Security.CodeAccessPermission.PermitOnly*&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Causes any previous &lt;xref:System.Security.CodeAccessPermission.Assert*&gt; for the current frame to be removed and no longer in effect.</source>
          <target state="translated">以前所有的原因&lt;xref:System.Security.CodeAccessPermission.Assert*&gt;当前帧要删除且不再有效。&lt;/xref:System.Security.CodeAccessPermission.Assert*&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If there is no &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">如果没有任何&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;当前帧，&lt;xref:System.ExecutionEngineException&gt;引发。&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.Assert*&gt; for the current frame.</source>
          <target state="translated">不再具有以前&lt;xref:System.Security.CodeAccessPermission.Assert*&gt;当前帧。&lt;/xref:System.Security.CodeAccessPermission.Assert*&gt;</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Causes any previous &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; for the current frame to be removed and no longer in effect.</source>
          <target state="translated">以前所有的原因&lt;xref:System.Security.CodeAccessPermission.Deny*&gt;当前帧要删除且不再有效。&lt;/xref:System.Security.CodeAccessPermission.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If there is no &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">如果没有任何&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;当前帧，&lt;xref:System.ExecutionEngineException&gt;引发。&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; for the current frame.</source>
          <target state="translated">不再具有以前&lt;xref:System.Security.CodeAccessPermission.Deny*&gt;当前帧。&lt;/xref:System.Security.CodeAccessPermission.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Causes any previous &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame to be removed and no longer in effect.</source>
          <target state="translated">以前所有的原因&lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt;当前帧要删除且不再有效。&lt;/xref:System.Security.CodeAccessPermission.PermitOnly*&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If there is no &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">如果没有任何&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;当前帧，&lt;xref:System.ExecutionEngineException&gt;引发。&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame.</source>
          <target state="translated">不再具有以前&lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt;当前帧。&lt;/xref:System.Security.CodeAccessPermission.PermitOnly*&gt;</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Creates and returns a string representation of the current permission object.</source>
          <target state="translated">创建并返回当前权限对象的字符串表示。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This method is useful in debugging when you need to display the permission as a string.</source>
          <target state="translated">此方法可在调试时需要显示为字符串的权限。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>A string representation of the current permission object.</source>
          <target state="translated">当前权限对象的字符串表示形式。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, creates an XML encoding of the security object and its current state.</source>
          <target state="translated">当在派生类中重写，则创建安全对象及其当前状态的 XML 编码。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Custom code that extends security objects needs to implement the ToXml and &lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt; methods to make the objects security-encodable.</source>
          <target state="translated">扩展安全对象的自定义代码需要实现 ToXml 和&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;方法来使对象安全性进行编码。&lt;/xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>An XML encoding of the security object, including any state information.</source>
          <target state="translated">安全对象，包括任何状态信息的 XML 编码。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</source>
          <target state="translated">当在派生类中重写，创建兼具当前权限和指定的权限的权限。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The result of a call to Union is a permission that represents all the operations represented by both the current permission and the specified permission.</source>
          <target state="translated">对联合的调用的结果是由当前权限和指定的权限表示所表示的所有操作的权限。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Any demand that passes either permission passes their union.</source>
          <target state="translated">任何请求都会通过任一权限传递其联合。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>A permission to combine with the current permission.</source>
          <target state="translated">若要与当前权限合并的权限。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">它必须与当前权限属于同一类型。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A new permission that represents the union of the current permission and the specified permission.</source>
          <target state="translated">表示同时兼具当前权限和指定的权限的新权限。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This method is only supported at this level when passed <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">此方法仅支持在传递时此级别<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>