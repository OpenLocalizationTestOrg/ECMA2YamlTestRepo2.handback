<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29a99113f6f5e8c636cca37d5dd69f98b78d8b76</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Collections.Hashtable.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b96d3511c2180b784e759ea03fda3d510a918e68</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">39d3f10f8859d27bfef8c293efca692035665ca7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a collection of key/value pairs that are organized based on the hash code of the key.</source>
          <target state="translated">키의 해시 코드에 따라 구성 된 키/값 쌍의 컬렉션을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>To browse the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)</ept>.</source>
          <target state="translated">이 형식에 대 한.NET Framework 소스 코드를 찾아보려면 참조는 <bpt id="p1">[</bpt>참조 소스<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!NOTE]</ph> &gt;  To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)</ept>.</source>
          <target state="translated"><ph id="ph1">&gt; [!NOTE]</ph>&gt;이 형식에 대 한.NET Framework 소스 코드를 보려면를 참조 하십시오.는 <bpt id="p1">[</bpt>참조 소스<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
          <target state="translated">소스 코드를 온라인, 오프 라인에서 살펴보고에 대 한 참조를 다운로드 및; 디버그 시 소스 (패치 및 업데이트 포함)를 단계별로 실행 참조 <bpt id="p1">[</bpt>지침<ept id="p1">](http://referencesource.microsoft.com/)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element is a key/value pair stored in a &lt;xref:System.Collections.DictionaryEntry&gt; object.</source>
          <target state="translated">각 요소에 저장 된 키/값 쌍은는 &lt;xref:System.Collections.DictionaryEntry&gt;개체입니다.&lt;/xref:System.Collections.DictionaryEntry&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">키 일 수 없습니다 <ph id="ph1">`null`</ph>, 하지만 값이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>The objects used as keys by a Hashtable are required to override the &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; method (or the &lt;xref:System.Collections.IHashCodeProvider&gt; interface) and the &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; method (or the &lt;xref:System.Collections.IComparer&gt; interface).</source>
          <target state="translated">해시 테이블에서 키를 재정의 하는 데 필요한 사용 되는 개체는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;메서드 (또는 &lt;xref:System.Collections.IHashCodeProvider&gt;인터페이스) 및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;메서드 (또는 &lt;xref:System.Collections.IComparer&gt;인터페이스).&lt;/xref:System.Collections.IComparer&gt; &lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; &lt;/xref:System.Collections.IHashCodeProvider&gt; &lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The implementation of both methods and interfaces must handle case sensitivity the same way; otherwise, the Hashtable might behave incorrectly.</source>
          <target state="translated">두 메서드 및 인터페이스의 구현을 대/소문자 구분; 같은 방식으로 처리 해야 합니다. 그렇지 않으면 해시 테이블 수 제대로 동작 하지 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, when creating a Hashtable, you must use the &lt;xref:System.Collections.CaseInsensitiveHashCodeProvider&gt; class (or any case-insensitive &lt;xref:System.Collections.IHashCodeProvider&gt; implementation) with the &lt;xref:System.Collections.CaseInsensitiveComparer&gt; class (or any case-insensitive &lt;xref:System.Collections.IComparer&gt; implementation).</source>
          <target state="translated">예를 들어, 해시 테이블을 만들 때 사용 해야는 &lt;xref:System.Collections.CaseInsensitiveHashCodeProvider&gt;클래스 (모든 대/소문자 구분 또는 &lt;xref:System.Collections.IHashCodeProvider&gt;구현)와 &lt;xref:System.Collections.CaseInsensitiveComparer&gt;클래스 (또는 어떤 대/소문자 구분 &lt;xref:System.Collections.IComparer&gt;구현).&lt;/xref:System.Collections.IComparer&gt; &lt;/xref:System.Collections.CaseInsensitiveComparer&gt; &lt;/xref:System.Collections.IHashCodeProvider&gt; &lt;/xref:System.Collections.CaseInsensitiveHashCodeProvider&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Furthermore, these methods must produce the same results when called with the same parameters while the key exists in the Hashtable.</source>
          <target state="translated">또한 이러한 메서드는 해시 테이블에 키가 있는 동안에 동일한 매개 변수를 사용 하 여 호출 될 때 동일한 결과 생성 해야 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>An alternative is to use a Hashtable constructor with an &lt;xref:System.Collections.IEqualityComparer&gt; parameter.</source>
          <target state="translated">대신 사용 하 여 해시 테이블 생성자를 사용 하는 프로그램 &lt;xref:System.Collections.IEqualityComparer&gt;매개 변수.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>If key equality were simply reference equality, the inherited implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; and &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; would suffice.</source>
          <target state="translated">키가 같은지 여부 단순히 참조 일치의 상속 된 구현 된 경우 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;충분 합니다.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; &lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Key objects must be immutable as long as they are used as keys in the Hashtable.</source>
          <target state="translated">해시 테이블의 키로 사용 하는 상태로 키 개체의 변경 하지 않아야 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>When an element is added to the Hashtable, the element is placed into a bucket based on the hash code of the key.</source>
          <target state="translated">요소가 해시 테이블에 추가 되 면 요소 키의 해시 코드에 따라 버킷에 배치 됩니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent lookups of the key use the hash code of the key to search in only one particular bucket, thus substantially reducing the number of key comparisons required to find an element.</source>
          <target state="translated">요소를 찾는 데 필요한 키 비교 수가 상당히 감소 하나만 특정 버킷에 검색 하려면 키의 해시 코드를 사용 하는 키의 후속 조회 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor of a Hashtable determines the maximum ratio of elements to buckets.</source>
          <target state="translated">해시 테이블의 로드 비율 버킷과 요소의 최대 비율을 결정합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>Smaller load factors cause faster average lookup times at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 부하 요인으로 인해 메모리 소모량이 증가 하면 더 빠르게 평균 조회 시간입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default load factor of 1.0 generally provides the best balance between speed and size.</source>
          <target state="translated">일반적으로 1.0의 기본 로드 비율 적절 한 속도와 크기를 제공합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>A different load factor can also be specified when the Hashtable is created.</source>
          <target state="translated">서로 다른 로드 비율 Hashtable를 만들 때 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a Hashtable, the actual load factor of the Hashtable increases.</source>
          <target state="translated">요소가 해시 테이블에 추가 되 면 해시 테이블의 실제 로드 비율이 증가 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets in the Hashtable is automatically increased to the smallest prime number that is larger than twice the current number of Hashtable buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 Hashtable 버킷 수가 두 번 보다 큰 가장 작은 소수로 해시 테이블에서 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key object in the Hashtable must provide its own hash function, which can be accessed by calling &lt;xref:System.Collections.Hashtable.GetHash%2A&gt;.</source>
          <target state="translated">해시 테이블의 각 키 개체 &lt;xref:System.Collections.Hashtable.GetHash%2A&gt;.&lt;/xref:System.Collections.Hashtable.GetHash%2A&gt; 를 호출 하 여 액세스할 수 있는 자체 해시 함수를 제공 해야 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, any object implementing &lt;xref:System.Collections.IHashCodeProvider&gt; can be passed to a Hashtable constructor, and that hash function is used for all objects in the table.</source>
          <target state="translated">그러나 구현 하는 개체 &lt;xref:System.Collections.IHashCodeProvider&gt;해시 가능한 생성자에 전달 될 수 있고 해당 해시 함수는 테이블의 모든 개체에 사용 됩니다.&lt;/xref:System.Collections.IHashCodeProvider&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity of a Hashtable is the number of elements the Hashtable can hold.</source>
          <target state="translated">해시 테이블의 용량은는 해시 테이블에 저장할 수 있는 요소의 수입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a Hashtable, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">요소가 해시 테이블에 추가 되 면 자동으로 용량 증가 하면 재할당을 통해 필요에 따라 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>For very large Hashtable objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph1">`enabled`</ph> attribute of the  configuration element to <ph id="ph2">`true`</ph> in the run-time environment.</source>
          <target state="translated">매우 큰 해시 테이블 개체에 대 한 설정 하 여 64 비트 시스템의 2 십억 요소에 최대 용량을 늘릴 수는 <ph id="ph1">`enabled`</ph> 에 구성 요소의 특성 <ph id="ph2">`true`</ph> 런타임 환경에서 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`For Each`</ph> in Visual Basic) returns an object of the type of the elements in the collection.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> C# 언어의 (<ph id="ph2">`For Each`</ph> Visual basic에서) 컬렉션의 요소 형식의 개체를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since each element of the Hashtable is a key/value pair, the element type is not the type of the key or the type of the value.</source>
          <target state="translated">해시 테이블의 각 요소는 키/값 쌍에 요소 유형 키의 형식 또는 값의 형식입니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the element type is &lt;xref:System.Collections.DictionaryEntry&gt;.</source>
          <target state="translated">대신, 요소 형식이 &lt;xref:System.Collections.DictionaryEntry&gt;.&lt;/xref:System.Collections.DictionaryEntry&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example:       <bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Collections.Hashtable_ClassExample#01<ept id="p2">](~/add/codesnippet/cpp/t-system.collections.has_1.cpp)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>System.Collections.Hashtable_ClassExample#01<ept id="p4">](~/add/codesnippet/csharp/t-system.collections.has_1.cs)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Collections.Hashtable_ClassExample#01<ept id="p6">](~/add/codesnippet/visualbasic/t-system.collections.has_1.vb)</ept><ept id="p5">]</ept>       The <ph id="ph1">`foreach`</ph> statement is a wrapper around the enumerator, which only allows reading from, not writing to, the collection.</source>
          <target state="translated">예를 들어: <bpt id="p1">[!code-cpp</bpt> <bpt id="p2">[</bpt>System.Collections.Hashtable_ClassExample#01<ept id="p2">](~/add/codesnippet/cpp/t-system.collections.has_1.cpp)</ept><ept id="p1">]</ept><bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>System.Collections.Hashtable_ClassExample#01<ept id="p4">](~/add/codesnippet/csharp/t-system.collections.has_1.cs)</ept><ept id="p3">]</ept><bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Collections.Hashtable_ClassExample#01<ept id="p6">](~/add/codesnippet/visualbasic/t-system.collections.has_1.vb)</ept> <ept id="p5">]</ept> 는 <ph id="ph1">`foreach`</ph> 문에 열거자를 컬렉션에 쓰는 것부터 읽기 가능 주변 래퍼입니다.    </target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because serializing and deserializing an enumerator for a Hashtable can cause the elements to become reordered, it is not possible to continue enumeration without calling the &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; method.</source>
          <target state="translated">되기 때문에 직렬화 및 다시 정렬 될 요소 하면이 해시 테이블에 대 한 열거자를 역직렬화, 없습니다 호출 하지 않고 열거를 계속 진행할 수는 &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;메서드.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Because keys can be inherited and their behavior changed, their absolute uniqueness cannot be guaranteed by comparisons using the &lt;xref:System.Type.Equals%2A&gt; method.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 키를 상속할 수의 동작을 변경할의 절대 변경할 수 비교를 사용 하 여 하기 때문에 &lt;xref:System.Type.Equals%2A&gt;메서드.&lt;/xref:System.Type.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class using the default initial capacity, load factor, hash code provider, and comparer.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 초기 용량을 사용 하 여 클래스, 인수, 해시 코드 공급자 및 비교자를 로드 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">용량 자동으로 증가 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">이 생성자는 o (1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class by copying the elements from the specified dictionary to the new <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object has an initial capacity equal to the number of elements copied, and uses the default load factor, hash code provider, and comparer.</source>
          <target state="translated">새 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 기본 로드 비율, 해시 코드 공급자 및 비교자를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new &lt;xref:System.Collections.Hashtable&gt; are sorted in the same order in which the enumerator iterates through the &lt;xref:System.Collections.IDictionary&gt; object.</source>
          <target state="translated">새 요소의 &lt;xref:System.Collections.Hashtable&gt;정렬 되는 열거자를 통해 반복 하는 순서는 &lt;xref:System.Collections.IDictionary&gt;개체입니다.&lt;/xref:System.Collections.IDictionary&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IDictionary&gt; object to copy to a new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">&lt;xref:System.Collections.IDictionary&gt;새 복사할 개체 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.&lt;/xref:System.Collections.IDictionary&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class using the default initial capacity and load factor, and the specified &lt;xref:System.Collections.IEqualityComparer&gt; object.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스에서 기본 초기 용량을 사용 하 고 요소와 지정 된 로드 &lt;xref:System.Collections.IEqualityComparer&gt;개체입니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">용량 자동으로 증가 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object includes both the hash code provider and the comparer.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자 개체를 포함 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an &lt;xref:System.Collections.IEqualityComparer&gt; is used in the &lt;xref:System.Collections.Hashtable&gt; constructor, the objects used as keys in the &lt;xref:System.Collections.Hashtable&gt; object are not required to override the &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; and &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; methods.</source>
          <target state="translated">경우는 &lt;xref:System.Collections.IEqualityComparer&gt;에 사용 되는 &lt;xref:System.Collections.Hashtable&gt;생성자에서 키로 사용 되는 개체는 &lt;xref:System.Collections.Hashtable&gt;개체는 재정의 하지 않아도 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;메서드.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; &lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">해시 코드 공급자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 키에 대 한 해시 코드를 분배합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">이 생성자는 o (1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object that defines the hash code provider and the comparer to use with the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider and the default comparer.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> and the default comparer is each key's implementation of <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 구현의 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 기본 비교자는 각 키의 구현 및 <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class using the specified initial capacity, and the default load factor, hash code provider, and comparer.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스 지정된 된 초기 용량을 기본 로드 비율, 해시 코드 공급자 및 비교자를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">해시 코드 공급자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 키에 대 한 해시 코드를 분배합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`capacity`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object can initially contain.</source>
          <target state="translated">대략적인 개수의 요소를는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 처음 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph>가&amp;0; 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class by copying the elements from the specified dictionary to a new <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object has an initial capacity equal to the number of elements copied, and uses the default load factor and the specified &lt;xref:System.Collections.IEqualityComparer&gt; object.</source>
          <target state="translated">새 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 초기 용량이 복사 된 요소 수와 동일 하며 기본 로드 비율와 지정 된 사용 &lt;xref:System.Collections.IEqualityComparer&gt;개체입니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object includes both the hash code provider and the comparer.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자 개체를 포함 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an &lt;xref:System.Collections.IEqualityComparer&gt; is used in the &lt;xref:System.Collections.Hashtable&gt; constructor, the objects used as keys in the &lt;xref:System.Collections.Hashtable&gt; object are not required to override the &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; and &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; methods.</source>
          <target state="translated">경우는 &lt;xref:System.Collections.IEqualityComparer&gt;에 사용 되는 &lt;xref:System.Collections.Hashtable&gt;생성자에서 키로 사용 되는 개체는 &lt;xref:System.Collections.Hashtable&gt;개체는 재정의 하지 않아도 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;메서드.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; &lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">해시 코드 공급자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 키에 대 한 해시 코드를 분배합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new &lt;xref:System.Collections.Hashtable&gt; are sorted in the same order in which the enumerator iterates through the &lt;xref:System.Collections.IDictionary&gt; object.</source>
          <target state="translated">새 요소의 &lt;xref:System.Collections.Hashtable&gt;정렬 되는 열거자를 통해 반복 하는 순서는 &lt;xref:System.Collections.IDictionary&gt;개체입니다.&lt;/xref:System.Collections.IDictionary&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IDictionary&gt; object to copy to a new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">&lt;xref:System.Collections.IDictionary&gt;새 복사할 개체 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.&lt;/xref:System.Collections.IDictionary&gt;</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object that defines the hash code provider and the comparer to use with the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider and the default comparer.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> and the default comparer is each key's implementation of <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 구현의 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 기본 비교자는 각 키의 구현 및 <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class by copying the elements from the specified dictionary to the new <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, and the default hash code provider and comparer.</source>
          <target state="translated">새 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 지정된 된 로드 비율, 기본 해시 코드 공급자 및 비교자를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new &lt;xref:System.Collections.Hashtable&gt; are sorted in the same order in which the enumerator iterates through the &lt;xref:System.Collections.IDictionary&gt; object.</source>
          <target state="translated">새 요소의 &lt;xref:System.Collections.Hashtable&gt;정렬 되는 열거자를 통해 반복 하는 순서는 &lt;xref:System.Collections.IDictionary&gt;개체입니다.&lt;/xref:System.Collections.IDictionary&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IDictionary&gt; object to copy to a new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">&lt;xref:System.Collections.IDictionary&gt;새 복사할 개체 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.&lt;/xref:System.Collections.IDictionary&gt;</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph>0.1 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> 1.0 보다 큽니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class using the default initial capacity and load factor, and the specified hash code provider and comparer.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스에서 기본 초기 용량을 사용 하 고 인수를 지정 된 해시 코드 공급자 및 비교자를 로드 합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">용량 자동으로 증가 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">이 생성자는 o (1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that supplies the hash codes for all keys in the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IComparer&gt; object to use to determine whether two keys are equal.</source>
          <target state="translated">&lt;xref:System.Collections.IComparer&gt;두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.&lt;/xref:System.Collections.IComparer&gt;</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default comparer, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 비교자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class using the specified initial capacity and &lt;xref:System.Collections.IEqualityComparer&gt;, and the default load factor.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 초기 용량을 사용 하 여 클래스 및 &lt;xref:System.Collections.IEqualityComparer&gt;, 및 기본 로드 비율.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object includes both the hash code provider and the comparer.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자 개체를 포함 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an &lt;xref:System.Collections.IEqualityComparer&gt; is used in the &lt;xref:System.Collections.Hashtable&gt; constructor, the objects used as keys in the &lt;xref:System.Collections.Hashtable&gt; are not required to override the &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; and &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; methods.</source>
          <target state="translated">경우는 &lt;xref:System.Collections.IEqualityComparer&gt;에 사용 되는 &lt;xref:System.Collections.Hashtable&gt;생성자에서 키로 사용 되는 개체는 &lt;xref:System.Collections.Hashtable&gt;재정의 하지 않아도 되는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;메서드.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; &lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">해시 코드 공급자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 키에 대 한 해시 코드를 분배합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object can initially contain.</source>
          <target state="translated">대략적인 개수의 요소를는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 처음 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object that defines the hash code provider and the comparer to use with the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider and the default comparer.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> and the default comparer is each key's implementation of <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 구현의 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 기본 비교자는 각 키의 구현 및 <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph>가&amp;0; 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class using the specified initial capacity and load factor, and the default hash code provider and comparer.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 초기 용량을 사용 하 여 클래스 및 비율과 기본 해시 코드 공급자 및 비교자를 로드 합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">해시 코드 공급자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 키에 대 한 해시 코드를 분배합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object can initially contain.</source>
          <target state="translated">대략적인 개수의 요소를는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 처음 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph>가&amp;0; 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> 0.1 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> 1.0 보다 큽니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is causing an overflow.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph>오버플로가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class that is serializable using the specified <bpt id="p2">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> and &lt;xref:System.Runtime.Serialization.StreamingContext&gt; objects.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스를 사용 하 여 지정 된 직렬화 가능 <bpt id="p2">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 및 &lt;xref:System.Runtime.Serialization.StreamingContext&gt;개체입니다.&lt;/xref:System.Runtime.Serialization.StreamingContext&gt;</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">용량 자동으로 증가 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Hashtable.Count%2A&gt;.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 &lt;xref:System.Collections.Hashtable.Count%2A&gt;.&lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because serializing and deserializing an enumerator for a &lt;xref:System.Collections.Hashtable&gt; can cause the elements to become reordered, it is not possible to continue enumeration without calling the &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; method.</source>
          <target state="translated">직렬화 및 역직렬화에 대 한 열거자 때문에 &lt;xref:System.Collections.Hashtable&gt;다시 정렬 될 요소를 발생할 수 있습니다, 호출 하지 않고 열거를 계속 불가능는 &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;메서드.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object containing the information required to serialize the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체를 serialize 하는 데 필요한 정보를 포함 하는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Runtime.Serialization.StreamingContext&gt; object containing the source and destination of the serialized stream associated with the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A &lt;xref:System.Runtime.Serialization.StreamingContext&gt;소스와 연결 된 직렬화 된 스트림의 대상이 들어 있는 개체는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Runtime.Serialization.StreamingContext&gt;</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;info&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;info&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class by copying the elements from the specified dictionary to the new <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object has an initial capacity equal to the number of elements copied, and uses the default load factor, and the specified hash code provider and comparer.</source>
          <target state="translated">새 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 지정 된 해시 코드 공급자 기본 로드 비율 및 비교자를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>This API is obsolete.</source>
          <target state="translated">이 API는 사용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>For an alternative, see <ph id="ph1">&amp;lt;</ph>xref:System.Collections.Hashtable.%23ctor%2A<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">참조 하십시오. <ph id="ph1">&amp;lt;</ph>xref:System.Collections.Hashtable.%23ctor%2A<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new &lt;xref:System.Collections.Hashtable&gt; are sorted in the same order in which the enumerator iterates through the &lt;xref:System.Collections.IDictionary&gt; object.</source>
          <target state="translated">새 요소의 &lt;xref:System.Collections.Hashtable&gt;정렬 되는 열거자를 통해 반복 하는 순서는 &lt;xref:System.Collections.IDictionary&gt;개체입니다.&lt;/xref:System.Collections.IDictionary&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IDictionary&gt; object to copy to a new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">&lt;xref:System.Collections.IDictionary&gt;새 복사할 개체 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.&lt;/xref:System.Collections.IDictionary&gt;</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that supplies the hash codes for all keys in the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IComparer&gt; object to use to determine whether two keys are equal.</source>
          <target state="translated">&lt;xref:System.Collections.IComparer&gt;두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.&lt;/xref:System.Collections.IComparer&gt;</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default comparer, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 비교자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class by copying the elements from the specified dictionary to the new <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object has an initial capacity equal to the number of elements copied, and uses the specified load factor and &lt;xref:System.Collections.IEqualityComparer&gt; object.</source>
          <target state="translated">새 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 지정된 된 로드 비율을 사용 하 여 및 &lt;xref:System.Collections.IEqualityComparer&gt;개체입니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object includes both the hash code provider and the comparer.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자 개체를 포함 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an &lt;xref:System.Collections.IEqualityComparer&gt; is used in the &lt;xref:System.Collections.Hashtable&gt; constructor, the objects used as keys in the &lt;xref:System.Collections.Hashtable&gt; object are not required to override the &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; and &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; methods.</source>
          <target state="translated">경우는 &lt;xref:System.Collections.IEqualityComparer&gt;에 사용 되는 &lt;xref:System.Collections.Hashtable&gt;생성자에서 키로 사용 되는 개체는 &lt;xref:System.Collections.Hashtable&gt;개체는 재정의 하지 않아도 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;메서드.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; &lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">해시 코드 공급자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 키에 대 한 해시 코드를 분배합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new &lt;xref:System.Collections.Hashtable&gt; are sorted in the same order in which the enumerator iterates through the &lt;xref:System.Collections.IDictionary&gt; object.</source>
          <target state="translated">새 요소의 &lt;xref:System.Collections.Hashtable&gt;정렬 되는 열거자를 통해 반복 하는 순서는 &lt;xref:System.Collections.IDictionary&gt;개체입니다.&lt;/xref:System.Collections.IDictionary&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IDictionary&gt; object to copy to a new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">&lt;xref:System.Collections.IDictionary&gt;새 복사할 개체 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.&lt;/xref:System.Collections.IDictionary&gt;</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object that defines the hash code provider and the comparer to use with the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider and the default comparer.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> and the default comparer is each key's implementation of <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 구현의 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 기본 비교자는 각 키의 구현 및 <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph>0.1 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> 1.0 보다 큽니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class using the specified initial capacity, hash code provider, comparer, and the default load factor.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스 지정된 된 초기 용량, 해시 코드 공급자, 비교자 및 기본 로드 비율을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">해시 코드 공급자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 키에 대 한 해시 코드를 분배합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object can initially contain.</source>
          <target state="translated">대략적인 개수의 요소를는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 처음 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that supplies the hash codes for all keys in the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IComparer&gt; object to use to determine whether two keys are equal.</source>
          <target state="translated">&lt;xref:System.Collections.IComparer&gt;두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.&lt;/xref:System.Collections.IComparer&gt;</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default comparer, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 비교자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph>가&amp;0; 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class using the specified initial capacity, load factor, and &lt;xref:System.Collections.IEqualityComparer&gt; object.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정 된 초기 용량, 로드 비율을 사용 하 여 클래스 및 &lt;xref:System.Collections.IEqualityComparer&gt;개체입니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object includes both the hash code provider and the comparer.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자 개체를 포함 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an &lt;xref:System.Collections.IEqualityComparer&gt; is used in the &lt;xref:System.Collections.Hashtable&gt; constructor, the objects used as keys in the &lt;xref:System.Collections.Hashtable&gt; are not required to override the &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; and &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; methods.</source>
          <target state="translated">경우는 &lt;xref:System.Collections.IEqualityComparer&gt;에 사용 되는 &lt;xref:System.Collections.Hashtable&gt;생성자에서 키로 사용 되는 개체는 &lt;xref:System.Collections.Hashtable&gt;재정의 하지 않아도 되는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;메서드.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; &lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">해시 코드 공급자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 키에 대 한 해시 코드를 분배합니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object can initially contain.</source>
          <target state="translated">대략적인 개수의 요소를는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 처음 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; object that defines the hash code provider and the comparer to use with the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider and the default comparer.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> and the default comparer is each key's implementation of <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 구현의 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 기본 비교자는 각 키의 구현 및 <ph id="ph3">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph4">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph>가&amp;0; 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> 0.1 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> 1.0 보다 큽니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class by copying the elements from the specified dictionary to the new <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>The new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, hash code provider, and comparer.</source>
          <target state="translated">새 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 지정된 로드 비율, 해시 코드 공급자 및 비교자를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new &lt;xref:System.Collections.Hashtable&gt; are sorted in the same order in which the enumerator iterates through the &lt;xref:System.Collections.IDictionary&gt; object.</source>
          <target state="translated">새 요소의 &lt;xref:System.Collections.Hashtable&gt;정렬 되는 열거자를 통해 반복 하는 순서는 &lt;xref:System.Collections.IDictionary&gt;개체입니다.&lt;/xref:System.Collections.IDictionary&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IDictionary&gt; object to copy to a new <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">&lt;xref:System.Collections.IDictionary&gt;새 복사할 개체 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.&lt;/xref:System.Collections.IDictionary&gt;</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that supplies the hash codes for all keys in the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IComparer&gt; object to use to determine whether two keys are equal.</source>
          <target state="translated">&lt;xref:System.Collections.IComparer&gt;두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.&lt;/xref:System.Collections.IComparer&gt;</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default comparer, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 비교자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph>0.1 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> 1.0 보다 큽니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class using the specified initial capacity, load factor, hash code provider, and comparer.</source>
          <target state="translated">새로 만든 빈 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 초기 용량을 사용 하 여 클래스, 인수, 해시 코드 공급자 및 비교자를 로드 합니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">해시 코드 공급자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 키에 대 한 해시 코드를 분배합니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 해시 코드 공급자는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a &lt;xref:System.Collections.Hashtable&gt; must be unique.</source>
          <target state="translated">모든 키에는 &lt;xref:System.Collections.Hashtable&gt;고유 해야 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">기본 비교자는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;안내 하십시오.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; 키의 구현</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object can initially contain.</source>
          <target state="translated">대략적인 개수의 요소를는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체 처음 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that supplies the hash codes for all keys in the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default hash code provider, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.GetHashCode%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IComparer&gt; object to use to determine whether two keys are equal.</source>
          <target state="translated">&lt;xref:System.Collections.IComparer&gt;두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.&lt;/xref:System.Collections.IComparer&gt;</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to use the default comparer, which is each key's implementation of <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기본 비교자를 사용 하려면 각 키의 구현인 <ph id="ph1">&amp;lt;</ph>xref:System.Object.Equals%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph>가&amp;0; 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> 0.1 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> 1.0 보다 큽니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Adds an element with the specified key and value into the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정한 키와 값을 가진 요소에 추가 된 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">키 일 수 없습니다 <ph id="ph1">`null`</ph>, 하지만 값이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object that has no correlation between its state and its hash code value should typically not be used as the key.</source>
          <target state="translated">개체의 상태와 해시 코드 값 간에 상관 관계가 있는 일반적으로 쓰일 수 없습니다 키로 합니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, String objects are better than StringBuilder objects for use as keys.</source>
          <target state="translated">예를 들어 문자열 개체는 키로 사용 하기 위해 StringBuilder 개체 보다 더 나은입니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use the &lt;xref:System.Collections.Hashtable.Item%2A&gt; property to add new elements by setting the value of a key that does not exist in the &lt;xref:System.Collections.Hashtable&gt;; for example, <ph id="ph1">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
          <target state="translated">사용할 수도 있습니다는 &lt;xref:System.Collections.Hashtable.Item%2A&gt;에 속성 키의 값을 설정 하 여 새 요소를 추가할 수 없습니다.는 &lt;xref:System.Collections.Hashtable&gt;; 예를 들어 <ph id="ph1">`myCollection["myNonexistentKey"] = myValue`</ph>.&lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.Hashtable.Item%2A&gt;</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the specified key already exists in the &lt;xref:System.Collections.Hashtable&gt;, setting the &lt;xref:System.Collections.Hashtable.Item%2A&gt; property overwrites the old value.</source>
          <target state="translated">그러나 지정된 된 키에 이미 있는 경우는 &lt;xref:System.Collections.Hashtable&gt;설정는 &lt;xref:System.Collections.Hashtable.Item%2A&gt;속성 이전 값을 덮어씁니다.&lt;/xref:System.Collections.Hashtable.Item%2A&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, the Add method does not modify existing elements.</source>
          <target state="translated">반면, Add 메서드는 기존 요소를 수정 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>If &lt;xref:System.Collections.Hashtable.Count%2A&gt; is less than the capacity of the &lt;xref:System.Collections.Hashtable&gt;, this method is an O(1) operation.</source>
          <target state="translated">경우 &lt;xref:System.Collections.Hashtable.Count%2A&gt;의 용량 보다 작은 &lt;xref:System.Collections.Hashtable&gt;,이 메서드는 o (1) 작업.&lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Hashtable.Count%2A&gt;.</source>
          <target state="translated">이 메서드는 O 됩니다 용량을 새 요소로 적용로 늘려야 하는 경우 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 &lt;xref:System.Collections.Hashtable.Count%2A&gt;.&lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The key of the element to add.</source>
          <target state="translated">추가할 요소의 키입니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The value of the element to add.</source>
          <target state="translated">추가할 요소의 값입니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>The value can be <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">값일 수 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>An element with the same key already exists in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">같은 키를 가진 요소가 이미는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is read-only.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>-or-       The <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> has a fixed size.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 크기가 고정된 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Removes all elements from the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">모든 요소를 제거는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.Hashtable.Count%2A&gt; is set to zero, and references to other objects from elements of the collection are also released.</source>
          <target state="translated">&lt;xref:System.Collections.Hashtable.Count%2A&gt;가&amp;0;으로 설정 하 고 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다.&lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity remains unchanged.</source>
          <target state="translated">용량 변경 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Hashtable.Count%2A&gt;.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 &lt;xref:System.Collections.Hashtable.Count%2A&gt;.&lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is read-only.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Creates a shallow copy of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">단순 복사본을 만듭니다는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">컬렉션의 단순 복사본은 참조 형식 또는 값 형식 참조에서 참조 하는 개체를 복사 하지 않습니다 여부는 컬렉션의 요소에만 복사 합니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">새 컬렉션에 대 한 참조는 원본 컬렉션에 대 한 참조를 가리키는 동일한 개체를 가리킵니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">반면, 요소를 복사 하는 컬렉션의 전체 복사본 및 뿐만 아니라 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목입니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.Hashtable&gt; clone has the same count, the same capacity, the same &lt;xref:System.Collections.IHashCodeProvider&gt; implementation, and the same &lt;xref:System.Collections.IComparer&gt; implementation as the original &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">&lt;xref:System.Collections.Hashtable&gt;복사본은 동일한 개수, 같은 용량, 동일한 &lt;xref:System.Collections.IHashCodeProvider&gt;구현과 같은 &lt;xref:System.Collections.IComparer&gt;원래 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 구현&lt;/xref:System.Collections.IComparer&gt; &lt;/xref:System.Collections.IHashCodeProvider&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Hashtable.Count%2A&gt;.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 &lt;xref:System.Collections.Hashtable.Count%2A&gt;.&lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>A shallow copy of the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">단순 복사는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Gets or sets the &lt;xref:System.Collections.IComparer&gt; to use for the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">가져오거나는 &lt;xref:System.Collections.IComparer&gt;에 사용할는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IComparer&gt;</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하는 것은 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IComparer&gt; to use for the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">&lt;xref:System.Collections.IComparer&gt;에 사용할는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IComparer&gt;</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The property is set to a value, but the hash table was created using an &lt;xref:System.Collections.IEqualityComparer&gt;.</source>
          <target state="translated">속성 값으로 설정 되어 있지만 &lt;xref:System.Collections.IEqualityComparer&gt;.&lt;/xref:System.Collections.IEqualityComparer&gt; 를 사용 하 여 해시 테이블을 만든</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>Determines whether the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> contains a specific key.</source>
          <target state="translated">결정 여부는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 특정 키가 들어 있습니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contains implements &lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">구현 &lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName&gt;.&lt;/xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName&gt; 포함</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>It behaves exactly as &lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;.&lt;/xref:System.Collections.Hashtable.ContainsKey%2A&gt; 과 동일 하 게 작동</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ &lt;xref:System.Object.Equals%2A&gt; and &lt;xref:System.IComparable.CompareTo%2A&gt; methods on <ph id="ph1">`item`</ph> to determine whether item exists.</source>
          <target state="translated">컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 &lt;xref:System.Object.Equals%2A&gt;및 &lt;xref:System.IComparable.CompareTo%2A&gt;에 대 한 메서드 <ph id="ph1">`item`</ph> 항목이 있는지 여부를 확인 합니다.&lt;/xref:System.IComparable.CompareTo%2A&gt; &lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the &lt;xref:System.Object.Equals%2A&gt; and &lt;xref:System.IComparable.CompareTo%2A&gt; methods of the <ph id="ph1">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">.NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 &lt;xref:System.Object.Equals%2A&gt;및 &lt;xref:System.IComparable.CompareTo%2A&gt;의 메서드는 <ph id="ph1">`item`</ph> 컬렉션의 개체에 대 한 매개 변수.&lt;/xref:System.IComparable.CompareTo%2A&gt; &lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>The key to locate in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">찾을 수 있는 키의 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> contains an element with the specified key; otherwise, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 지정 된 요소가 포함 되어 고, 그렇지 않으면 키 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Determines whether the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> contains a specific key.</source>
          <target state="translated">결정 여부는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 특정 키가 들어 있습니다.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method behaves exactly as &lt;xref:System.Collections.Hashtable.Contains%2A&gt;.</source>
          <target state="translated">이 메서드는 &lt;xref:System.Collections.Hashtable.Contains%2A&gt;.&lt;/xref:System.Collections.Hashtable.Contains%2A&gt; 과 동일 하 게 동작</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ &lt;xref:System.Object.Equals%2A&gt; and &lt;xref:System.IComparable.CompareTo%2A&gt; methods on <ph id="ph1">`item`</ph> to determine whether item exists.</source>
          <target state="translated">컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 &lt;xref:System.Object.Equals%2A&gt;및 &lt;xref:System.IComparable.CompareTo%2A&gt;에 대 한 메서드 <ph id="ph1">`item`</ph> 항목이 있는지 여부를 확인 합니다.&lt;/xref:System.IComparable.CompareTo%2A&gt; &lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the &lt;xref:System.Object.Equals%2A&gt; and &lt;xref:System.IComparable.CompareTo%2A&gt; methods of the <ph id="ph1">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">.NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 &lt;xref:System.Object.Equals%2A&gt;및 &lt;xref:System.IComparable.CompareTo%2A&gt;의 메서드는 <ph id="ph1">`item`</ph> 컬렉션의 개체에 대 한 매개 변수.&lt;/xref:System.IComparable.CompareTo%2A&gt; &lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>The key to locate in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">찾을 수 있는 키의 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> contains an element with the specified key; otherwise, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 지정 된 요소가 포함 되어 고, 그렇지 않으면 키 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>Determines whether the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> contains a specific value.</source>
          <target state="translated">결정 여부는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 특정 값을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>The values of the elements of the &lt;xref:System.Collections.Hashtable&gt; are compared to the specified value using the &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; method.</source>
          <target state="translated">요소는 &lt;xref:System.Collections.Hashtable&gt;사용 하 여 지정 된 값이 비교는 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;메서드.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Hashtable.Count%2A&gt;.</source>
          <target state="translated">이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 &lt;xref:System.Collections.Hashtable.Count%2A&gt;.&lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ &lt;xref:System.Object.Equals%2A&gt; and &lt;xref:System.IComparable.CompareTo%2A&gt; methods on <ph id="ph1">`item`</ph> to determine whether item exists.</source>
          <target state="translated">컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 &lt;xref:System.Object.Equals%2A&gt;및 &lt;xref:System.IComparable.CompareTo%2A&gt;에 대 한 메서드 <ph id="ph1">`item`</ph> 항목이 있는지 여부를 확인 합니다.&lt;/xref:System.IComparable.CompareTo%2A&gt; &lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the &lt;xref:System.Object.Equals%2A&gt; and &lt;xref:System.IComparable.CompareTo%2A&gt; methods of the <ph id="ph1">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">.NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 &lt;xref:System.Object.Equals%2A&gt;및 &lt;xref:System.IComparable.CompareTo%2A&gt;의 메서드는 <ph id="ph1">`item`</ph> 컬렉션의 개체에 대 한 매개 변수.&lt;/xref:System.IComparable.CompareTo%2A&gt; &lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>The value to locate in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">찾을 값은 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>The value can be <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">값일 수 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> contains an element with the specified <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p3">&lt;/code&gt;</ept>; otherwise, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 지정 된 요소가 포함 되어 <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">value</ph> <ept id="p3">&lt;/code&gt;</ept>, 그렇지 않으면 <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>Copies the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> elements to a one-dimensional &lt;xref:System.Array&gt; instance at the specified index.</source>
          <target state="translated">복사본의 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 요소를 사용 하는&amp;1; 차원 &lt;xref:System.Array&gt;지정된 된 인덱스에 있는 인스턴스에.&lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied to the &lt;xref:System.Array&gt; in the same order in which the enumerator iterates through the &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">&lt;xref:System.Array&gt;열거자 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 을 반복 하는 같은 순서로&lt;/xref:System.Array&gt; 요소가 복사 되</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>To copy only the keys in the &lt;xref:System.Collections.Hashtable&gt;, use <ph id="ph1">`Hashtable.Keys.CopyTo`</ph>.</source>
          <target state="translated">에 있는 키를 복사 하는 &lt;xref:System.Collections.Hashtable&gt;를 사용 하 여 <ph id="ph1">`Hashtable.Keys.CopyTo`</ph>.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>To copy only the values in the &lt;xref:System.Collections.Hashtable&gt;, use <ph id="ph1">`Hashtable.Values.CopyTo`</ph>.</source>
          <target state="translated">값만 복사 하는 &lt;xref:System.Collections.Hashtable&gt;를 사용 하 여 <ph id="ph1">`Hashtable.Values.CopyTo`</ph>.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Hashtable.Count%2A&gt;.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 &lt;xref:System.Collections.Hashtable.Count%2A&gt;.&lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>The one-dimensional &lt;xref:System.Array&gt; that is the destination of the &lt;xref:System.Collections.DictionaryEntry&gt; objects copied from <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">1 차원 &lt;xref:System.Array&gt;의 대상인은 &lt;xref:System.Collections.DictionaryEntry&gt;에서 복사한 개체 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.DictionaryEntry&gt; &lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Array&gt; must have zero-based indexing.</source>
          <target state="translated">&lt;xref:System.Array&gt;0부터 시작 하는 인덱스가 있어야 합니다.&lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>The zero-based index in <ph id="ph1">`array`</ph> at which copying begins.</source>
          <target state="translated">인덱스는&amp;0;부터 시작 <ph id="ph1">`array`</ph> 복사가 시작 되는 합니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;arrayIndex&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;arrayIndex&lt;/code&gt;</ph>가&amp;0; 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>-or-       The number of elements in the source <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is greater than the available space from <ph id="ph1">&lt;code&gt;arrayIndex&lt;/code&gt;</ph> to the end of the destination <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
          <target state="translated">-또는-소스에 있는 요소의 수 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 에서 사용 가능한 공간 보다 큰 <ph id="ph1">&lt;code&gt;arrayIndex&lt;/code&gt;</ph> 대상의 끝에 <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>The type of the source <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> cannot be cast automatically to the type of the destination <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
          <target state="translated">소스의 형식을 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 대상의 형식으로 자동 캐스팅할 수 없는 <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph1">array</ph> <ept id="p2">&lt;/code&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>Gets the number of key/value pairs contained in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 포함 된 키/값 쌍의 수를 가져옵니다는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하는 것은 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>The number of key/value pairs contained in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 포함 된 키/값 쌍의 수는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>Gets the &lt;xref:System.Collections.IEqualityComparer&gt; to use for the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">가져옵니다는 &lt;xref:System.Collections.IEqualityComparer&gt;에 사용할는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; includes both the comparer and the hash code provider.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;비교자 및 해시 코드 공급자를 모두 포함 합니다.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an &lt;xref:System.Collections.IEqualityComparer&gt; is used in the &lt;xref:System.Collections.Hashtable&gt; constructor, the objects used as keys in the &lt;xref:System.Collections.Hashtable&gt; are not required to override the &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; and &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; methods.</source>
          <target state="translated">경우는 &lt;xref:System.Collections.IEqualityComparer&gt;에 사용 되는 &lt;xref:System.Collections.Hashtable&gt;생성자에서 키로 사용 되는 개체는 &lt;xref:System.Collections.Hashtable&gt;재정의 하지 않아도 되는 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;메서드.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt; &lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하는 것은 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IEqualityComparer&gt; to use for the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">&lt;xref:System.Collections.IEqualityComparer&gt;에 사용할는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IEqualityComparer&gt;</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>The property is set to a value, but the hash table was created using an <bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and an &lt;xref:System.Collections.IComparer&gt;.</source>
          <target state="translated">속성 값으로 설정 되어 있지만 해시 테이블을 사용 하 여 만들어진는 <bpt id="p1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 및 &lt;xref:System.Collections.IComparer&gt;.&lt;/xref:System.Collections.IComparer&gt;</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Returns an &lt;xref:System.Collections.IDictionaryEnumerator&gt; that iterates through the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">반환 된 &lt;xref:System.Collections.IDictionaryEnumerator&gt;반복 하는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IDictionaryEnumerator&gt;</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>[Visual Basic, C#]       The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">[Visual Basic, C#]       <ph id="ph1">`foreach`</ph> C# 언어의 (<ph id="ph2">`for each`</ph> Visual basic에서)은 열거자의 복잡성을 숨깁니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">따라서 사용 하 여 <ph id="ph1">`foreach`</ph> 열거자를 직접 조작 하는 대신이 좋습니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">열거자는 컬렉션의에서 데이터를 읽는 데 사용할 수 있지만 기본 컬렉션을 수정 하는 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치 됩니다.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.IEnumerator.Reset%2A&gt; also brings the enumerator back to this position.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;또한이 위치로 복원 열거자를 가져옵니다.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt;</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT">
          <source>At this position, &lt;xref:System.Collections.IEnumerator.Current%2A&gt; is undefined.</source>
          <target state="translated">이 위치에서 &lt;xref:System.Collections.IEnumerator.Current%2A&gt;정의 되지 않습니다.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; to advance the enumerator to the first element of the collection before reading the value of &lt;xref:System.Collections.IEnumerator.Current%2A&gt;.</source>
          <target state="translated">따라서 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;xref:System.Collections.IEnumerator.Current%2A&gt;.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt; 의 값을 읽기 전에 컬렉션의 첫 번째 요소로 열거자를&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.IEnumerator.Current%2A&gt; returns the same object until either &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; or &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; is called.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;될 때까지 동일한 개체를 반환 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;또는 &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;호출 됩니다.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; sets &lt;xref:System.Collections.IEnumerator.Current%2A&gt; to the next element.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;설정 &lt;xref:System.Collections.IEnumerator.Current%2A&gt;를 다음 요소로.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT">
          <source>If &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; passes the end of the collection, the enumerator is positioned after the last element in the collection and &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">경우 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;반환 <ph id="ph1">`false`</ph>.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the enumerator is at this position, subsequent calls to &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; also return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">열거자가 있는 경우이 위치에 대 한 후속 호출에서 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;반환할 수도 <ph id="ph1">`false`</ph>.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the last call to &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; returned <ph id="ph1">`false`</ph>, &lt;xref:System.Collections.IEnumerator.Current%2A&gt; is undefined.</source>
          <target state="translated">마지막으로 호출 하는 경우 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;반환 <ph id="ph1">`false`</ph>, &lt;xref:System.Collections.IEnumerator.Current%2A&gt;정의 되지 않습니다.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>To set &lt;xref:System.Collections.IEnumerator.Current%2A&gt; to the first element of the collection again, you can call &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; followed by &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;다시, 컬렉션의 첫 번째 요소를 호출할 수 있습니다 &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;그 뒤 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.IEnumerator.Current%2A&gt; 설정 하려면</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">열거자는 컬렉션이 변경 되지으로 유효한 상태를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">컬렉션 변경 되 면 추가, 수정 또는 요소를 삭제와 같은 열거자는 무효화 하 고 해당 동작은 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">열거자는 컬렉션에 배타적으로 액세스가 없습니다. 따라서 컬렉션을 열거지 않습니다 본질적으로 스레드로부터 안전한 프로시저가 합니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">을 열거 하는 동안 스레드로부터 안전을 보장 하려면 전체 열거 동안 컬렉션을 잠글 수 있습니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">컬렉션에 여러 스레드에서 읽기 및 쓰기에 대 한 액세스를 허용 하려면 사용자 지정 동기화를 구현 해야 합니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because serializing and deserializing an enumerator for a &lt;xref:System.Collections.Hashtable&gt; can cause the elements to become reordered, it is not possible to continue enumeration without calling the &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; method.</source>
          <target state="translated">직렬화 및 역직렬화에 대 한 열거자 때문에 &lt;xref:System.Collections.Hashtable&gt;다시 정렬 될 요소를 발생할 수 있습니다, 호출 하지 않고 열거를 계속 불가능는 &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;메서드.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Collections.IDictionaryEnumerator&gt; for the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">An &lt;xref:System.Collections.IDictionaryEnumerator&gt; for the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IDictionaryEnumerator&gt;</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Returns the hash code for the specified key.</source>
          <target state="translated">지정된 된 키에 대 한 해시 코드를 반환합니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the hash table was created with a specific &lt;xref:System.Collections.IHashCodeProvider&gt; implementation, this method uses that hash code provider; otherwise, it uses the &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; implementation of <ph id="ph1">`key`</ph>.</source>
          <target state="translated">특정 해시 테이블을 만든 경우 &lt;xref:System.Collections.IHashCodeProvider&gt;구현에서이 메서드는 해당 해시 코드 공급자를 사용 합니다; 하 고 사용은 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;구현의 <ph id="ph1">`key`</ph>.&lt;/xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; &lt;/xref:System.Collections.IHashCodeProvider&gt;</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Object&gt; for which a hash code is to be returned.</source>
          <target state="translated">&lt;xref:System.Object&gt;해시 코드는 반환 될에 대 한.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>The hash code for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">key</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
          <target state="translated">에 대 한 해시 코드 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">key</ph> <ept id="p1">&lt;/code&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>Implements the <bpt id="p1">&lt;xref href="System.Runtime.Serialization.ISerializable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> interface and returns the data needed to serialize the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">구현 된 <bpt id="p1">&lt;xref href="System.Runtime.Serialization.ISerializable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 인터페이스를 serialize 하는 데 필요한 데이터를 반환 된 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Hashtable.Count%2A&gt;.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 &lt;xref:System.Collections.Hashtable.Count%2A&gt;.&lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object containing the information required to serialize the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체를 serialize 하는 데 필요한 정보를 포함 하는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Runtime.Serialization.StreamingContext&gt; object containing the source and destination of the serialized stream associated with the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A &lt;xref:System.Runtime.Serialization.StreamingContext&gt;소스와 연결 된 직렬화 된 스트림의 대상이 들어 있는 개체는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Runtime.Serialization.StreamingContext&gt;</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;info&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;info&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>The collection was modified.</source>
          <target state="translated">컬렉션이 수정 되었습니다.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Gets or sets the object that can dispense hash codes.</source>
          <target state="translated">해시 코드를 분배할 수 있는 개체를 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하는 것은 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>The object that can dispense hash codes.</source>
          <target state="translated">해시 코드를 분배할 수 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>The property is set to a value, but the hash table was created using an &lt;xref:System.Collections.IEqualityComparer&gt;.</source>
          <target state="translated">속성 값으로 설정 되어 있지만 &lt;xref:System.Collections.IEqualityComparer&gt;.&lt;/xref:System.Collections.IEqualityComparer&gt; 를 사용 하 여 해시 테이블을 만든</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> has a fixed size.</source>
          <target state="translated">나타내는 값을 가져옵니다 여부는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 크기가 고정된 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
          <target state="translated">컬렉션 크기가 고정된 된 컬렉션을 만든 후 기존 요소를 수정할 수 있습니다에 추가 하거나 제거할 요소의 수 없습니다.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">크기가 고정된 된 컬렉션은 지정 된 추가 및 요소를 제거 하지 못하도록 하는 래퍼 컬렉션 따라서를 추가 하거나 제거할 요소를 포함 하 여 내부 컬렉션을 변경 하는 경우 고정 크기 컬렉션에 해당 변경 내용을 반영 합니다.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하는 것은 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> has a fixed size; otherwise, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 고정 되어 고, 그렇지 않으면 크기가 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">기본값은 <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is read-only.</source>
          <target state="translated">나타내는 값을 가져옵니다 여부는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">읽기 전용 컬렉션에서는 컬렉션을 만든 후에 추가, 제거 또는 요소를 수정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 될 경우 읽기 전용 컬렉션 해당 변경 내용을 반영 합니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하는 것은 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> is read-only; otherwise, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 읽기 전용, 되지 않았으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">기본값은 <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether access to the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is synchronized (thread safe).</source>
          <target state="translated">에 대 한 액세스 여부를 나타내는 값을 가져옵니다는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 동기화 되었으면 (스레드로부터 안전 하 게 보호).</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Collections.Hashtable&gt; can support one writer and multiple readers concurrently.</source>
          <target state="translated">A &lt;xref:System.Collections.Hashtable&gt;동시 지원할 수 있습니다 하나 기록기 및 다중 판독기.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>To support multiple writers, all operations must be done through the wrapper returned by the &lt;xref:System.Collections.Hashtable.Synchronized%2A&gt; method.</source>
          <target state="translated">반환 되는 래퍼를 통해 수행 해야 모든 작업을 지원 하기 위해 여러 작성기는 &lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;메서드.&lt;/xref:System.Collections.Hashtable.Synchronized%2A&gt;</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example shows how to lock the collection using the &lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt; during the entire enumeration:       <bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p2">](~/add/codesnippet/cpp/p-system.collections.has_1_1.cpp)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p4">](~/add/codesnippet/visualbasic/p-system.collections.has_1_1.vb)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-cs</bpt><bpt id="p6">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p6">](~/add/codesnippet/csharp/p-system.collections.has_1_1.cs)</ept><ept id="p5">]</ept></source>
          <target state="translated">다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 &lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;열거 하는 동안: <bpt id="p1">[!code-cpp</bpt> <bpt id="p2">[</bpt>클래식 Hashtable.IsSynchronized 예제&amp;#2;<ept id="p2">](~/add/codesnippet/cpp/p-system.collections.has_1_1.cpp)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>클래식 Hashtable.IsSynchronized 예제&amp;#2;<ept id="p4">](~/add/codesnippet/visualbasic/p-system.collections.has_1_1.vb)</ept><ept id="p3">]</ept><bpt id="p5">[!code-cs</bpt><bpt id="p6">[</bpt>클래식 Hashtable.IsSynchronized 예제&amp;#2;<ept id="p6">](~/add/codesnippet/csharp/p-system.collections.has_1_1.cs)</ept> <ept id="p5">]</ept>     &lt;/xref:System.Collections.Hashtable.SyncRoot%2A&gt;</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if access to the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> is synchronized (thread safe); otherwise, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우에 대 한 액세스는 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 은 동기화 (스레드로부터 안전함); 그렇지 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">기본값은 <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>Gets or sets the value associated with the specified key.</source>
          <target state="translated">지정된 된 키와 연결 된 값을 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[key]`</ph>.</source>
          <target state="translated">이 속성은 다음 구문을 사용 하 여 컬렉션의 특정 요소를 액세스 하는 기능 제공: <ph id="ph1">`myCollection[key]`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use the Item property to add new elements by setting the value of a key that does not exist in the &lt;xref:System.Collections.Hashtable&gt;; for example, <ph id="ph1">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
          <target state="translated">에 존재 하지 않는 키의 값을 설정 하 여 새 요소를 추가 하는 항목 속성을 사용할 수도 있습니다는 &lt;xref:System.Collections.Hashtable&gt;; 예를 들어 <ph id="ph1">`myCollection["myNonexistentKey"] = myValue`</ph>.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the specified key already exists in the &lt;xref:System.Collections.Hashtable&gt;, setting the Item property overwrites the old value.</source>
          <target state="translated">그러나 지정된 된 키에 이미 있는 경우는 &lt;xref:System.Collections.Hashtable&gt;, 이전 값을 덮어씁니다 항목 속성을 설정 합니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, the &lt;xref:System.Collections.Hashtable.Add%2A&gt; method does not modify existing elements.</source>
          <target state="translated">반면,는 &lt;xref:System.Collections.Hashtable.Add%2A&gt;메서드는 기존 요소를 수정 하지 않습니다.&lt;/xref:System.Collections.Hashtable.Add%2A&gt;</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">키 일 수 없습니다 <ph id="ph1">`null`</ph>, 하지만 값이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source>To distinguish between <ph id="ph1">`null`</ph> that is returned because the specified key is not found and <ph id="ph2">`null`</ph> that is returned because the value of the specified key is <ph id="ph3">`null`</ph>, use the &lt;xref:System.Collections.Hashtable.Contains%2A&gt; method or the &lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt; method to determine if the key exists in the list.</source>
          <target state="translated">구분 하기 위해 <ph id="ph1">`null`</ph> 지정된 된 키를 찾을 수 없으므로 반환 되는 및 <ph id="ph2">`null`</ph> 지정된 된 키의 값은 반환 되는 <ph id="ph3">`null`</ph>를 사용 하 여는 &lt;xref:System.Collections.Hashtable.Contains%2A&gt;메서드 또는 &lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;목록에 키가 있는지 확인 하는 메서드.&lt;/xref:System.Collections.Hashtable.ContainsKey%2A&gt; &lt;/xref:System.Collections.Hashtable.Contains%2A&gt;</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하 하는 것은 o (1) 연산입니다. o (1) 작업 이기도 속성을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the &lt;xref:System.Collections.IList.Item%2A&gt; property.</source>
          <target state="translated">C# 언어의 키워드를 사용 하 여 구현 하는 대신 인덱서를 정의 하는 &lt;xref:System.Collections.IList.Item%2A&gt;속성.&lt;/xref:System.Collections.IList.Item%2A&gt;</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic implements Item as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Visual Basic에서는 동일한 인덱싱 기능을 기본 속성으로 항목을 구현 합니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>The key whose value to get or set.</source>
          <target state="translated">키 값을 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>The value associated with the specified key.</source>
          <target state="translated">지정된 된 키와 연결 된 값입니다.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>If the specified key is not found, attempting to get it returns <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, and attempting to set it creates a new element using the specified key.</source>
          <target state="translated">지정된 된 키가 없으면 get 반환 하려고 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>가 지정된 된 키를 사용 하 여 새 요소를 만들어 설정 하려고 시도 합니다.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>The property is set and the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is read-only.</source>
          <target state="translated">속성을 설정 및 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>-or-       The property is set, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">key</ph><ept id="p1">&lt;/code&gt;</ept> does not exist in the collection, and the <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> has a fixed size.</source>
          <target state="translated">-또는-속성이 설정 되어, <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">key</ph> <ept id="p1">&lt;/code&gt;</ept> 컬렉션에 존재 하지 않는 및 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 크기가 고정된 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>Compares a specific &lt;xref:System.Object&gt; with a specific key in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">특정 비교 &lt;xref:System.Object&gt;에 특정 키가 있는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the hash table was created with a specific &lt;xref:System.Collections.IComparer&gt; implementation, this method uses that comparer; that is, &lt;xref:System.Collections.IComparer.Compare%2A&gt; (<ph id="ph1">`item`</ph>, <ph id="ph2">`key`</ph>).</source>
          <target state="translated">특정 해시 테이블을 만든 경우 &lt;xref:System.Collections.IComparer&gt;구현이이 메서드는 사용 되는 비교자; &lt;xref:System.Collections.IComparer.Compare%2A&gt;(<ph id="ph1">`item`</ph>, <ph id="ph2">`key`</ph>).&lt;/xref:System.Collections.IComparer.Compare%2A&gt; &lt;/xref:System.Collections.IComparer&gt;</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses <ph id="ph1">`item.Equals(key)`</ph>.</source>
          <target state="translated">그렇지 않으면 사용 <ph id="ph1">`item.Equals(key)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Object&gt; to compare with <ph id="ph1">`key`</ph>.</source>
          <target state="translated">&lt;xref:System.Object&gt;와 비교할 <ph id="ph1">`key`</ph>.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The key in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to compare with <ph id="ph1">`item`</ph>.</source>
          <target state="translated">에 있는 키의 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 와 비교할 <ph id="ph1">`item`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p2">&lt;/code&gt;</ept> and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph2">key</ph><ept id="p3">&lt;/code&gt;</ept> are equal; otherwise, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p2">&lt;/code&gt;</ept> and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph2">key</ph><ept id="p3">&lt;/code&gt;</ept> are equal; otherwise, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;item&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;item&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">-or-       <ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Gets an &lt;xref:System.Collections.ICollection&gt; containing the keys in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">가져옵니다는 &lt;xref:System.Collections.ICollection&gt;키를 포함 하는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.ICollection&gt;</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order of the keys in the &lt;xref:System.Collections.ICollection&gt; is unspecified, but it is the same order as the associated values in the &lt;xref:System.Collections.ICollection&gt; returned by the &lt;xref:System.Collections.Hashtable.Values%2A&gt; method.</source>
          <target state="translated">에 있는 키의 순서는 &lt;xref:System.Collections.ICollection&gt;지정 되어 있지에 연결 된 값과 순서가 동일 하지만 &lt;xref:System.Collections.ICollection&gt;에서 반환 되는 &lt;xref:System.Collections.Hashtable.Values%2A&gt;메서드.&lt;/xref:System.Collections.Hashtable.Values%2A&gt; &lt;/xref:System.Collections.ICollection&gt; &lt;/xref:System.Collections.ICollection&gt;</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>The returned &lt;xref:System.Collections.ICollection&gt; is not a static copy; instead, the &lt;xref:System.Collections.ICollection&gt; refers back to the keys in the original &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">반환 된 &lt;xref:System.Collections.ICollection&gt;정적 복사 하지 않습니다; 대신 &lt;xref:System.Collections.ICollection&gt;원래 &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 의 키를 다시 참조할&lt;/xref:System.Collections.ICollection&gt; &lt;/xref:System.Collections.ICollection&gt;</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, changes to the &lt;xref:System.Collections.Hashtable&gt; continue to be reflected in the &lt;xref:System.Collections.ICollection&gt;.</source>
          <target state="translated">따라서 &lt;xref:System.Collections.Hashtable&gt;계속 &lt;xref:System.Collections.ICollection&gt;.&lt;/xref:System.Collections.ICollection&gt; 반영&lt;/xref:System.Collections.Hashtable&gt; 변경</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하는 것은 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Collections.ICollection&gt; containing the keys in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">&lt;xref:System.Collections.ICollection&gt;키를 포함 하는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.ICollection&gt;</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>Implements the <bpt id="p1">&lt;xref href="System.Runtime.Serialization.ISerializable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> interface and raises the deserialization event when the deserialization is complete.</source>
          <target state="translated">구현 된 <bpt id="p1">&lt;xref href="System.Runtime.Serialization.ISerializable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 인터페이스와 deserialization이 완료 되 면 deserialization 이벤트를 발생 시킵니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Hashtable.Count%2A&gt;.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 &lt;xref:System.Collections.Hashtable.Count%2A&gt;.&lt;/xref:System.Collections.Hashtable.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because serializing and deserializing an enumerator for a &lt;xref:System.Collections.Hashtable&gt; can cause the elements to become reordered, it is not possible to continue enumeration without calling the &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; method.</source>
          <target state="translated">직렬화 및 역직렬화에 대 한 열거자 때문에 &lt;xref:System.Collections.Hashtable&gt;다시 정렬 될 요소를 발생할 수 있습니다, 호출 하지 않고 열거를 계속 불가능는 &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;메서드.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>The source of the deserialization event.</source>
          <target state="translated">Deserialization 이벤트의 소스입니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object associated with the current <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> is invalid.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체와 현재 연결 된 <bpt id="p2">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Removes the element with the specified key from the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정된 된 키를 가진 요소를 제거는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the &lt;xref:System.Collections.Hashtable&gt; does not contain an element with the specified key, the &lt;xref:System.Collections.Hashtable&gt; remains unchanged.</source>
          <target state="translated">경우는 &lt;xref:System.Collections.Hashtable&gt;지정된 키를 가진 요소가 포함 되지 않습니다는 &lt;xref:System.Collections.Hashtable&gt;변경 되지 않습니다.&lt;/xref:System.Collections.Hashtable&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The key of the element to remove.</source>
          <target state="translated">제거할 요소의 키입니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is read-only.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>-or-       The <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> has a fixed size.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 크기가 고정된 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>Returns a synchronized (thread-safe) wrapper for the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 대 한 동기화 (스레드로부터 안전한 지) 래퍼를 반환 합니다.는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Synchronized method is thread safe for multiple readers and writers.</source>
          <target state="translated">Synchronized 메서드는 스레드로부터 안전 하 게 여러 판독기와 작성기에 대 한 보호 합니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Furthermore, the synchronized wrapper ensures that there is only one writer writing at a time.</source>
          <target state="translated">또한 동기화 된 래퍼 한 작성기만 한 번에 작성 되는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">컬렉션을 열거 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example shows how to lock the collection using the &lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt; during the entire enumeration:       <bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p2">](~/add/codesnippet/cpp/m-system.collections.has_11_1.cpp)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.collections.has_11_1.vb)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-cs</bpt><bpt id="p6">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p6">](~/add/codesnippet/csharp/m-system.collections.has_11_1.cs)</ept><ept id="p5">]</ept>       This method is an O(1) operation.</source>
          <target state="translated">다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 &lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;열거 하는 동안: <bpt id="p1">[!code-cpp</bpt> <bpt id="p2">[</bpt>클래식 Hashtable.IsSynchronized 예제&amp;#2;<ept id="p2">](~/add/codesnippet/cpp/m-system.collections.has_11_1.cpp)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>클래식 Hashtable.IsSynchronized 예제&amp;#2;<ept id="p4">](~/add/codesnippet/visualbasic/m-system.collections.has_11_1.vb)</ept><ept id="p3">]</ept><bpt id="p5">[!code-cs</bpt><bpt id="p6">[</bpt>클래식 Hashtable.IsSynchronized 예제&amp;#2;<ept id="p6">](~/add/codesnippet/csharp/m-system.collections.has_11_1.cs)</ept> <ept id="p5">]</ept> 이 메서드는 o (1) 작업.    &lt;/xref:System.Collections.Hashtable.SyncRoot%2A&gt;</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to synchronize.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 동기화 합니다.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>A synchronized (thread-safe) wrapper for the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A (스레드로부터 안전한 지) 래퍼에 대 한 동기화는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Gets an object that can be used to synchronize access to the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 대 한 액세스를 동기화 하는 데 사용할 수 있는 개체를 가져옵니다는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a synchronized version of the &lt;xref:System.Collections.Hashtable&gt;, use the &lt;xref:System.Collections.Hashtable.Synchronized%2A&gt; method.</source>
          <target state="translated">동기화 된 버전을 만들려면는 &lt;xref:System.Collections.Hashtable&gt;를 사용 하 여는 &lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;메서드.&lt;/xref:System.Collections.Hashtable.Synchronized%2A&gt; &lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, derived classes can provide their own synchronized version of the &lt;xref:System.Collections.Hashtable&gt; using the SyncRoot property.</source>
          <target state="translated">하지만 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다는 &lt;xref:System.Collections.Hashtable&gt;SyncRoot 속성을 사용 하 여.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>The synchronizing code must perform operations on the SyncRoot of the &lt;xref:System.Collections.Hashtable&gt;, not directly on the &lt;xref:System.Collections.Hashtable&gt; .</source>
          <target state="translated">동기화 하는 코드의 SyncRoot에 대 한 작업을 수행 해야는 &lt;xref:System.Collections.Hashtable&gt;, &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 으로 만들어지므로&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">이렇게 하면 다른 개체에서 파생 된 컬렉션의 적절 한 작업입니다.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the &lt;xref:System.Collections.Hashtable&gt; object.</source>
          <target state="translated">특히, 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 관리는 &lt;xref:System.Collections.Hashtable&gt;개체입니다.&lt;/xref:System.Collections.Hashtable&gt;</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example shows how to lock the collection using the SyncRoot during the entire enumeration:       <bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p2">](~/add/codesnippet/cpp/p-system.collections.has_0_1.cpp)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p4">](~/add/codesnippet/visualbasic/p-system.collections.has_0_1.vb)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-cs</bpt><bpt id="p6">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p6">](~/add/codesnippet/csharp/p-system.collections.has_0_1.cs)</ept><ept id="p5">]</ept></source>
          <target state="translated">다음 코드 예제에는 SyncRoot를 사용 하 여 전체 열거 동안 컬렉션을 잠그는 방법을 보여 줍니다: <bpt id="p1">[!code-cpp</bpt> <bpt id="p2">[</bpt>클래식 Hashtable.IsSynchronized 예제&amp;#2;<ept id="p2">](~/add/codesnippet/cpp/p-system.collections.has_0_1.cpp)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>클래식 Hashtable.IsSynchronized 예제&amp;#2;<ept id="p4">](~/add/codesnippet/visualbasic/p-system.collections.has_0_1.vb)</ept><ept id="p3">]</ept><bpt id="p5">[!code-cs</bpt><bpt id="p6">[</bpt>클래식 Hashtable.IsSynchronized 예제&amp;#2;    <ept id="p6">](~/add/codesnippet/csharp/p-system.collections.has_0_1.cs)</ept><ept id="p5">]</ept></target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>An object that can be used to synchronize access to the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 대 한 액세스를 동기화 하는 데 사용할 수 있는 개체는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">컬렉션을 반복 하는 열거자를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>[Visual Basic, C#]       The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">[Visual Basic, C#]       <ph id="ph1">`foreach`</ph> C# 언어의 (<ph id="ph2">`for each`</ph> Visual basic에서)은 열거자의 복잡성을 숨깁니다.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">따라서 사용 하 여 <ph id="ph1">`foreach`</ph> 열거자를 직접 조작 하는 대신이 좋습니다.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">열거자는 컬렉션의에서 데이터를 읽는 데 사용할 수 있지만 기본 컬렉션을 수정 하는 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치 됩니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.IEnumerator.Reset%2A&gt; also brings the enumerator back to this position.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;또한이 위치로 복원 열거자를 가져옵니다.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt;</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>At this position, calling &lt;xref:System.Collections.IEnumerator.Current%2A&gt; throws an exception.</source>
          <target state="translated">이 위치에서, 호출 &lt;xref:System.Collections.IEnumerator.Current%2A&gt;예외를 throw 합니다.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; to advance the enumerator to the first element of the collection before reading the value of &lt;xref:System.Collections.IEnumerator.Current%2A&gt;.</source>
          <target state="translated">따라서 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;xref:System.Collections.IEnumerator.Current%2A&gt;.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt; 의 값을 읽기 전에 컬렉션의 첫 번째 요소로 열거자를&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.IEnumerator.Current%2A&gt; returns the same object until either &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; or &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; is called.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;될 때까지 동일한 개체를 반환 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;또는 &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;호출 됩니다.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; sets &lt;xref:System.Collections.IEnumerator.Current%2A&gt; to the next element.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;설정 &lt;xref:System.Collections.IEnumerator.Current%2A&gt;를 다음 요소로.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>If &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; passes the end of the collection, the enumerator is positioned after the last element in the collection and &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">경우 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;반환 <ph id="ph1">`false`</ph>.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the enumerator is at this position, subsequent calls to &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; also return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">열거자가 있는 경우이 위치에 대 한 후속 호출에서 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;반환할 수도 <ph id="ph1">`false`</ph>.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the last call to &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; returned <ph id="ph1">`false`</ph>, calling &lt;xref:System.Collections.IEnumerator.Current%2A&gt; throws an exception.</source>
          <target state="translated">마지막으로 호출 하는 경우 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;반환 <ph id="ph1">`false`</ph>호출, &lt;xref:System.Collections.IEnumerator.Current%2A&gt;예외를 throw 합니다.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT">
          <source>To set &lt;xref:System.Collections.IEnumerator.Current%2A&gt; to the first element of the collection again, you can call &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; followed by &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;다시, 컬렉션의 첫 번째 요소를 호출할 수 있습니다 &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;그 뒤 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.IEnumerator.Current%2A&gt; 설정 하려면</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">열거자는 컬렉션이 변경 되지으로 유효한 상태를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator can be invalidated and the next call to &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; or &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; throws an &lt;xref:System.InvalidOperationException&gt;.</source>
          <target state="translated">컬렉션 변경 되 면 추가, 수정 또는 요소를 삭제와 같은 열거자를 무효화 될 수 있습니다 및을 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;xref:System.InvalidOperationException&gt;.&lt;/xref:System.InvalidOperationException&gt; throw&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; 하거나&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; 다음에 호출</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the collection is modified between &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; and &lt;xref:System.Collections.IEnumerator.Current%2A&gt;, &lt;xref:System.Collections.IEnumerator.Current%2A&gt; returns the element that it is set to, even if the enumerator is already invalidated.</source>
          <target state="translated">사이 컬렉션이 수정 되는 경우 &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;및 &lt;xref:System.Collections.IEnumerator.Current%2A&gt;, &lt;xref:System.Collections.IEnumerator.Current%2A&gt;열거자가 이미 무효로 되 었 하는 경우에 설정 하는 요소를 반환 합니다.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt; &lt;/xref:System.Collections.IEnumerator.Current%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">열거자는 컬렉션에 배타적으로 액세스가 없습니다. 따라서 컬렉션을 열거지 않습니다 본질적으로 스레드로부터 안전한 프로시저가 합니다.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Collections.IEnumerator&gt; that can be used to iterate through the collection.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator&gt;컬렉션을 반복에 사용할 수 있는.&lt;/xref:System.Collections.IEnumerator&gt;</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Gets an &lt;xref:System.Collections.ICollection&gt; containing the values in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">가져옵니다는 &lt;xref:System.Collections.ICollection&gt;값을 포함 하는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.ICollection&gt;</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order of the values in the &lt;xref:System.Collections.ICollection&gt; is unspecified, but it is the same order as the associated keys in the &lt;xref:System.Collections.ICollection&gt; returned by the &lt;xref:System.Collections.Hashtable.Keys%2A&gt; method.</source>
          <target state="translated">에 있는 값의 순서는 &lt;xref:System.Collections.ICollection&gt;지정 되어 있지는 연결 된 키와 순서가 동일 하지만 &lt;xref:System.Collections.ICollection&gt;에서 반환 되는 &lt;xref:System.Collections.Hashtable.Keys%2A&gt;메서드.&lt;/xref:System.Collections.Hashtable.Keys%2A&gt; &lt;/xref:System.Collections.ICollection&gt; &lt;/xref:System.Collections.ICollection&gt;</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>The returned &lt;xref:System.Collections.ICollection&gt; is not a static copy; instead, the &lt;xref:System.Collections.ICollection&gt; refers back to the values in the original &lt;xref:System.Collections.Hashtable&gt;.</source>
          <target state="translated">반환 된 &lt;xref:System.Collections.ICollection&gt;정적 복사 하지 않습니다; 대신 &lt;xref:System.Collections.ICollection&gt; &lt;xref:System.Collections.Hashtable&gt;.&lt;/xref:System.Collections.Hashtable&gt; 원래에서 값을 다시 참조&lt;/xref:System.Collections.ICollection&gt; &lt;/xref:System.Collections.ICollection&gt;</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, changes to the &lt;xref:System.Collections.Hashtable&gt; continue to be reflected in the &lt;xref:System.Collections.ICollection&gt;.</source>
          <target state="translated">따라서 &lt;xref:System.Collections.Hashtable&gt;계속 &lt;xref:System.Collections.ICollection&gt;.&lt;/xref:System.Collections.ICollection&gt; 반영&lt;/xref:System.Collections.Hashtable&gt; 변경</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하는 것은 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Collections.ICollection&gt; containing the values in the <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">&lt;xref:System.Collections.ICollection&gt;값을 포함 하는 <bpt id="p1">&lt;xref href="System.Collections.Hashtable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.ICollection&gt;</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>