<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4f52012fdc802212af3cda41c74dae07125ae01a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Data.Odbc.OdbcDataReader.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7034a3a1919bf406462e9851677dacb8fd7ad376</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0e66a50186f84d2d71500d0d76c4fba9e1ac4011</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides a way of reading a forward-only stream of data rows from a data source.</source>
          <target state="translated">데이터 원본에서 데이터 행의 정방향 전용 스트림을 읽는 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This class cannot be inherited.</source>
          <target state="translated">이 클래스는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create an OdbcDataReader, you must call the &lt;xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A&gt; method of the &lt;xref:System.Data.Odbc.OdbcCommand&gt; object, instead of directly using a constructor.</source>
          <target state="translated">호출 해야 OdbcDataReader를 만들려면는 &lt;xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A&gt;의 메서드는 &lt;xref:System.Data.Odbc.OdbcCommand&gt;직접 생성자를 사용 하는 대신 개체입니다.&lt;/xref:System.Data.Odbc.OdbcCommand&gt; &lt;/xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>While the OdbcDataReader is being used, the associated &lt;xref:System.Data.Odbc.OdbcConnection&gt; is busy serving the OdbcDataReader, and no other operations can be performed on the &lt;xref:System.Data.Odbc.OdbcConnection&gt; other than closing it.</source>
          <target state="translated">OdbcDataReader를 사용 하는 동안에서 관련 된 &lt;xref:System.Data.Odbc.OdbcConnection&gt;사용 중 처리 된 OdbcDataReader을 이며 &lt;xref:System.Data.Odbc.OdbcConnection&gt;합니다. 닫지&lt;/xref:System.Data.Odbc.OdbcConnection&gt; 에 없는 다른 작업을 수행할 수&lt;/xref:System.Data.Odbc.OdbcConnection&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the case until the &lt;xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt; method of the OdbcDataReader is called.</source>
          <target state="translated">이것은 때 까지는 &lt;xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt;는 OdbcDataReader의 메서드가 호출 됩니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you cannot retrieve output parameters until after you call &lt;xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt;.&lt;/xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt; 호출 될 때까지 출력 매개 변수를 검색할 수 없습니다 예를 들어</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Changes made to a result set by another process or thread while data is being read may be visible to the user of the OdbcDataReader.</source>
          <target state="translated">결과 데이터를 읽는 동안 다른 프로세스 또는 스레드별로 집합이 변경은 OdbcDataReader의 사용자에 게 표시 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the precise behavior is both driver and timing dependent.</source>
          <target state="translated">그러나 정확한 동작은 드라이버와 시간에 따라 다릅니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Data.Odbc.OdbcDataReader.IsClosed%2A&gt; and &lt;xref:System.Data.Odbc.OdbcDataReader.RecordsAffected%2A&gt; are the only properties that you can call after the OdbcDataReader is closed.</source>
          <target state="translated">&lt;xref:System.Data.Odbc.OdbcDataReader.IsClosed%2A&gt;및 &lt;xref:System.Data.Odbc.OdbcDataReader.RecordsAffected%2A&gt;호출할 수 있는 속성만 여 OdbcDataReader를 닫은 후.&lt;/xref:System.Data.Odbc.OdbcDataReader.RecordsAffected%2A&gt;&lt;/xref:System.Data.Odbc.OdbcDataReader.IsClosed%2A&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Sometimes, you must call &lt;xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt; before you can call &lt;xref:System.Data.Odbc.OdbcDataReader.RecordsAffected%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt; &lt;xref:System.Data.Odbc.OdbcDataReader.RecordsAffected%2A&gt;.&lt;/xref:System.Data.Odbc.OdbcDataReader.RecordsAffected%2A&gt; 를 호출 하기 전에&lt;/xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt; 호출 해야 경우에 따라</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Closes the <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">닫습니다는 <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must explicitly call the Close method when you are finished using the &lt;xref:System.Data.Odbc.OdbcDataReader&gt; to use the associated &lt;xref:System.Data.Odbc.OdbcConnection&gt; for any other purpose.</source>
          <target state="translated">끝나면 Close 메서드를 명시적으로 호출 해야를 사용 하는 &lt;xref:System.Data.Odbc.OdbcDataReader&gt;연결 된 사용 하도록 &lt;xref:System.Data.Odbc.OdbcConnection&gt;다른 용도로.&lt;/xref:System.Data.Odbc.OdbcConnection&gt; &lt;/xref:System.Data.Odbc.OdbcDataReader&gt;</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Do not call <ph id="ph2">`Close`</ph> or <ph id="ph3">`Dispose`</ph> on a Connection, a DataReader, or any other managed object in the <ph id="ph4">`Finalize`</ph> method of your class.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 호출 하지 않으면 <ph id="ph2">`Close`</ph> 또는 <ph id="ph3">`Dispose`</ph> 연결, DataReader, 또는 다른 관리 개체에는 <ph id="ph4">`Finalize`</ph> 클래스의 메서드로 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a finalizer, you should only release unmanaged resources that your class owns directly.</source>
          <target state="translated">종료자에서만 클래스에 직접 속한 관리 되지 않는 리소스를 해제 해야 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your class does not own any unmanaged resources, do not include a <ph id="ph1">`Finalize`</ph> method in your class definition.</source>
          <target state="translated">클래스에 관리 되지 않는 리소스가 없는 경우 포함 되지 않습니다는 <ph id="ph1">`Finalize`</ph> 클래스 정의에 메서드.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Garbage Collection<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>가비지 수집<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates the depth of nesting for the current row.</source>
          <target state="translated">현재 행의 중첩 깊이 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>The outermost table has a depth of zero.</source>
          <target state="translated">가장 바깥쪽 테이블의 중첩 수준은&amp;0;입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The depth of nesting for the current row.</source>
          <target state="translated">현재 행의 중첩 깊이입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">추가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Gets the number of columns in the current row.</source>
          <target state="translated">현재 행에서 열 수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Includes hidden fields.</source>
          <target state="translated">숨김된 필드도 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use &lt;xref:System.Data.Common.DbDataReader.VisibleFieldCount%2A&gt; to exclude hidden fields.</source>
          <target state="translated">사용 하 여 &lt;xref:System.Data.Common.DbDataReader.VisibleFieldCount%2A&gt;숨겨진된 필드를 제외 하려면.&lt;/xref:System.Data.Common.DbDataReader.VisibleFieldCount%2A&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you execute a query that does not return rows, FieldCount returns 0.</source>
          <target state="translated">행을 반환 하지 않는 쿼리를 실행 하 고 나면 FieldCount 0을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>When not positioned in a valid record set, 0; otherwise the number of columns in the current record.</source>
          <target state="translated">위치 하지 않은 경우에 올바른 레코드 집합 0; 그렇지 않으면 현재 레코드에 있는 열의 수입니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The default is -1.</source>
          <target state="translated">기본값은-1입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>There is no current connection to a data source.</source>
          <target state="translated">데이터 소스에 현재 연결이 없습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a Boolean.</source>
          <target state="translated">부울으로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported then the method call will fail.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A Boolean that is the value of the column.</source>
          <target state="translated">부울은 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a byte.</source>
          <target state="translated">지정 된 열의 값을 바이트로 가져옵니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported, the method call fails.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a byte.</source>
          <target state="translated">값을 byte로 지정된 된 열입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Reads a stream of bytes from the specified column offset into the buffer as an array, starting at the particular buffer offset.</source>
          <target state="translated">지정한 열 오프셋에서의 바이트 스트림을 특정 버퍼 오프셋에서 시작 하는 배열로 버퍼로 읽습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>GetBytes returns the number of available bytes in the field.</source>
          <target state="translated">GetBytes 필드에 사용 가능한 바이트 수를 반환합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most of the time this is the exact length of the field.</source>
          <target state="translated">대부분의 경우 이것은 필드의 길이입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the number returned may be less than the true length of the field if GetBytes has already been used to obtain bytes from the field.</source>
          <target state="translated">그러나 GetBytes 바이트를 얻는 필드에서 이미 사용 하는 경우에 반환 되는 숫자 필드의 길이 보다 작을 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>This may be the case, for example, if the &lt;xref:System.Data.Odbc.OdbcDataReader&gt; is reading a large data structure into a buffer.</source>
          <target state="translated">이 있는 경우 예를 들어 경우 수는 &lt;xref:System.Data.Odbc.OdbcDataReader&gt;버퍼에 대형 데이터 구조를 읽고.&lt;/xref:System.Data.Odbc.OdbcDataReader&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">`SequentialAccess`</ph> setting for &lt;xref:System.Data.CommandBehavior&gt;.</source>
          <target state="translated">자세한 내용은 참조는 <ph id="ph1">`SequentialAccess`</ph> &lt;xref:System.Data.CommandBehavior&gt;.&lt;/xref:System.Data.CommandBehavior&gt; 에 대 한 설정</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you pass a buffer that is a null value, GetBytes returns the length of the field in bytes.</source>
          <target state="translated">버퍼를 null 값을 전달 하면 GetBytes 필드의 길이 바이트 단위로 반환 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported then the method call will fail.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  No exception will be thrown if the value of <ph id="ph2">`bufferIndex`</ph> is outside the array.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 하면 예외가 throw 됩니다 값 <ph id="ph2">`bufferIndex`</ph> 배열 밖에 있습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>No data will be read and the method will return 0.</source>
          <target state="translated">없는 데이터를 읽 및 메서드가 0을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The index within the field where the read operation is to start.</source>
          <target state="translated">읽기 작업을 시작할 필드 내의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The buffer into which to read the stream of bytes.</source>
          <target state="translated">바이트 스트림의 읽을 버퍼입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The index within the <ph id="ph1">`buffer`</ph> where the write operation is to start.</source>
          <target state="translated">내에 있는 인덱스는 <ph id="ph1">`buffer`</ph> 쓰기 작업이 시작 되는 위치입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The number of bytes to read.</source>
          <target state="translated">읽을 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The actual number of bytes read.</source>
          <target state="translated">실제 읽은 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a character.</source>
          <target state="translated">문자로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported, the method call fails.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a character.</source>
          <target state="translated">문자로 지정 된 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Reads a stream of characters from the specified column offset into the buffer as an array, starting at the particular buffer offset.</source>
          <target state="translated">특정 버퍼 오프셋에서 시작 하는 배열로 지정된 된 열 오프셋 버퍼에 문자 스트림을 읽습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>GetChars returns the number of available characters in the field.</source>
          <target state="translated">GetChars 필드에 사용할 수 있는 문자 수를 반환합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most of the time this is the exact length of the field.</source>
          <target state="translated">대부분의 경우 이것은 필드의 길이입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the number returned may be less than the true length of the field if GetChars has already been used to obtain characters from the field.</source>
          <target state="translated">그러나 GetChars 문자를 가져올 필드에서 이미 사용 하는 경우에 반환 되는 숫자 필드의 길이 보다 작을 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>This may be the case, for example, if the &lt;xref:System.Data.Odbc.OdbcDataReader&gt; is reading a large data structure into a buffer.</source>
          <target state="translated">이 있는 경우 예를 들어 경우 수는 &lt;xref:System.Data.Odbc.OdbcDataReader&gt;버퍼에 대형 데이터 구조를 읽고.&lt;/xref:System.Data.Odbc.OdbcDataReader&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">`SequentialAccess`</ph> setting for &lt;xref:System.Data.CommandBehavior&gt;.</source>
          <target state="translated">자세한 내용은 참조는 <ph id="ph1">`SequentialAccess`</ph> &lt;xref:System.Data.CommandBehavior&gt;.&lt;/xref:System.Data.CommandBehavior&gt; 에 대 한 설정</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you pass a buffer that is a null value, GetChars returns the length of the field in characters.</source>
          <target state="translated">버퍼를 null 값을 전달 하면 GetChars 필드의 길이 문자 단위로 반환 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported then the method call will fail.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  No exception will be thrown if the value of <ph id="ph2">`bufferIndex`</ph> is outside the array.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 하면 예외가 throw 됩니다 값 <ph id="ph2">`bufferIndex`</ph> 배열 밖에 있습니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>No data will be read and the method will return 0.</source>
          <target state="translated">없는 데이터를 읽 및 메서드가 0을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The index within the row where the read operation is to start.</source>
          <target state="translated">읽기 작업을 시작할 행 내의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The buffer into which to copy data.</source>
          <target state="translated">데이터를 복사할 대상 버퍼입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The index within the <ph id="ph1">`buffer`</ph> where the write operation is to start.</source>
          <target state="translated">내에 있는 인덱스는 <ph id="ph1">`buffer`</ph> 쓰기 작업이 시작 되는 위치입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The number of characters to read.</source>
          <target state="translated">읽을 문자 수입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The actual number of characters read.</source>
          <target state="translated">실제 읽은 문자 수입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Gets the name of the source data type.</source>
          <target state="translated">원본 데이터 형식의 이름을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The name of the source data type.</source>
          <target state="translated">원본 데이터 형식의 이름입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a &lt;xref:System.DateTime&gt; object.</source>
          <target state="translated">지정 된 열의 값을 가져옵니다는 &lt;xref:System.DateTime&gt;개체입니다.&lt;/xref:System.DateTime&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a &lt;xref:System.DateTime&gt; object.</source>
          <target state="translated">지정 된 열의 값을 &lt;xref:System.DateTime&gt;개체입니다.&lt;/xref:System.DateTime&gt;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a &lt;xref:System.DateTime&gt; object.</source>
          <target state="translated">지정 된 열의 값을 가져옵니다는 &lt;xref:System.DateTime&gt;개체입니다.&lt;/xref:System.DateTime&gt;</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported then the method call will fail.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a &lt;xref:System.DateTime&gt; object.</source>
          <target state="translated">지정 된 열의 값을 &lt;xref:System.DateTime&gt;개체입니다.&lt;/xref:System.DateTime&gt;</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a &lt;xref:System.Decimal&gt; object.</source>
          <target state="translated">지정 된 열의 값을 가져옵니다는 &lt;xref:System.Decimal&gt;개체입니다.&lt;/xref:System.Decimal&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported then the method call will fail.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>GetDecimal has a maximum precision of 28.</source>
          <target state="translated">GetDecimal 최대 전체 자릿수는 28 사이 있습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to retrieve decimal data with a larger precision will cause an exception.</source>
          <target state="translated">더 큰 전체 자릿수를 사용 하 여&amp;10; 진수 데이터를 검색 하려고 하면 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>One solution would be to change the query to cast the decimal type to either a smaller datatype or convert to string or binary.</source>
          <target state="translated">한 가지 해결 더 작은 데이터 형식에&amp;10; 진수 형식을 캐스팅 하도록 쿼리를 변경 하거나 문자열 또는 이진으로 변환 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a &lt;xref:System.Decimal&gt; object.</source>
          <target state="translated">지정 된 열의 값을 &lt;xref:System.Decimal&gt;개체입니다.&lt;/xref:System.Decimal&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a double-precision floating-point number.</source>
          <target state="translated">배정밀도 부동 소수점 숫자로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported, the method call fails.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a double-precision floating-point number.</source>
          <target state="translated">배정밀도 부동 소수점 숫자로 지정 된 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Returns an &lt;xref:System.Collections.IEnumerator&gt; that can be used to iterate through the rows in the data reader.</source>
          <target state="translated">반환 된 &lt;xref:System.Collections.IEnumerator&gt;데이터 판독기의 행을 반복에 사용할 수 있는.&lt;/xref:System.Collections.IEnumerator&gt;</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although you can use this method to retrieve an explicit enumerator, in languages that support a <ph id="ph1">`foreach`</ph> construct, it is simpler to use the looping construct directly in order to iterate through the rows in the data reader.</source>
          <target state="translated">이 메서드를 사용 하 여 명시적 열거자를 검색할 수 있지만 지 원하는 언어는 <ph id="ph1">`foreach`</ph> 구성 하는 것이 데이터 판독기의 행을 반복 하는 직접 루프 구문을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Collections.IEnumerator&gt; that can be used to iterate through the rows in the data reader.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator&gt;데이터 판독기의 행을 반복에 사용할 수 있는.&lt;/xref:System.Collections.IEnumerator&gt;</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Gets the &lt;xref:System.Type&gt; that is the data type of the object.</source>
          <target state="translated">가져옵니다는 &lt;xref:System.Type&gt;개체의 데이터 형식입니다.&lt;/xref:System.Type&gt;</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Type&gt; that is the data type of the object.</source>
          <target state="translated">&lt;xref:System.Type&gt;개체의 데이터 형식입니다.&lt;/xref:System.Type&gt;</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a single-precision floating-point number.</source>
          <target state="translated">단 정밀도 부동 소수점 숫자로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported then the method call will fail.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a single-precision floating-point number.</source>
          <target state="translated">단 정밀도 부동 소수점 숫자로 지정 된 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a globally unique identifier (GUID).</source>
          <target state="translated">전역 고유 식별자 (GUID)로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported, the method call fails.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a GUID.</source>
          <target state="translated">GUID로 지정 된 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a 16-bit signed integer.</source>
          <target state="translated">16 비트 부호 있는 정수로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported, the method call fails.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a 16-bit signed integer.</source>
          <target state="translated">16 비트 부호 있는 정수로 지정 된 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a 32-bit signed integer.</source>
          <target state="translated">부호 있는 32 비트 정수로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported, the method call fails.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a 32-bit signed integer.</source>
          <target state="translated">부호 있는 32 비트 정수로 지정 된 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a 64-bit signed integer.</source>
          <target state="translated">64 비트 부호 있는 정수로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported, the method call fails.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a 64-bit signed integer.</source>
          <target state="translated">64 비트 부호 있는 정수로 지정 된 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Gets the name of the specified column.</source>
          <target state="translated">지정 된 열의 이름을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>A string that is the name of the specified column.</source>
          <target state="translated">지정 된 열의 이름에 해당 하는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Gets the column ordinal, given the name of the column.</source>
          <target state="translated">열을 가져옵니다 서 수 이며 열의 이름을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>GetOrdinal performs a case-sensitive lookup first.</source>
          <target state="translated">GetOrdinal 대/소문자 구분 조회를 먼저 수행합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it fails, a second case-insensitive search is made.</source>
          <target state="translated">실패 한 경우에 두 번째 대/소문자 구분 검색이 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method throws an <ph id="ph1">`IndexOutOfRange`</ph> exception if the zero-based column ordinal is not found.</source>
          <target state="translated">메서드에서 throw 된 <ph id="ph1">`IndexOutOfRange`</ph> 서 수는&amp;0;부터 시작 하는 열을 찾을 수 없는 경우 예외입니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>GetOrdinal is kana-width insensitive.</source>
          <target state="translated">GetOrdinal은 일본어가 나 너비 구분 하지 않는 것입니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because ordinal-based lookups are more efficient than named lookups, it is inefficient to call GetOrdinal within a loop.</source>
          <target state="translated">서 수 기반 조회가 명명 된 조회 보다 효율적 이므로 루프 내 효율적인있지 않습니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, call GetOrdinal one time and then assign the results to an integer variable for use within the loop.</source>
          <target state="translated">대신, GetOrdinal 한 번 호출 하 고 루프 내에서 사용할 정수 변수에 결과 할당 합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The name of the column.</source>
          <target state="translated">열의 이름입니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that describes the column metadata of the <bpt id="p2">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">반환 된 <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 의 열 메타 데이터를 설명 하는 <bpt id="p2">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>The GetSchemaTable method returns metadata about each column in the following order:      |DataReader column|Description|   |-----------------------|-----------------|   |ColumnName|The name of the column; this might not be unique.</source>
          <target state="translated">GetSchemaTable 메서드는 다음 순서 대로 각 열에 대 한 메타 데이터 반환: | DataReader 열 | 설명 |   |-----------------------|-----------------|   | ColumnName | 열의 이름입니다. 이 고유 아닐 수 있습니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the column name cannot be determined, a null value is returned.</source>
          <target state="translated">열 이름을 확인할 수 없으면 null 값이 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>This name always reflects the most recent naming of the column in the current view or command text.|   |ColumnOrdinal|The zero-based ordinal of the column.</source>
          <target state="translated">이 이름은 항상 현재 보기 또는 명령 텍스트에 있는 열의 최근 이름 지정을 반영 합니다. |   | ColumnOrdinal | 열의&amp;0;부터 시작 서 수입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>This column cannot contain a null value.|   |ColumnSize|The maximum possible length of a value in the column.</source>
          <target state="translated">이 열에 null 값을 포함할 수 없습니다. |   | ColumnSize | 열에 있는 값의 가능한 최대 길이입니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>For columns that use a fixed-length data type, this is the size of the data type.|   |NumericPrecision|If &lt;xref:System.Data.DbType&gt; is a numeric data type, this is the maximum precision of the column.</source>
          <target state="translated">고정 길이 데이터 형식을 사용 하는 열에 대 한 데이터 형식의 크기입니다. |   | NumericPrecision | 경우 &lt;xref:System.Data.DbType&gt;숫자 데이터 형식 열의 최대 전체 자릿수입니다.&lt;/xref:System.Data.DbType&gt;</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>The precision depends on the definition of the column.</source>
          <target state="translated">전체 자릿수는 열의 정의에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>If &lt;xref:System.Data.DbType&gt; is not a numeric data type, do not use the data in this column.</source>
          <target state="translated">경우 &lt;xref:System.Data.DbType&gt;없는 숫자 데이터 형식,이 열에 데이터를 사용 하지 마십시오.&lt;/xref:System.Data.DbType&gt;</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the underlying ODBC driver returns a precision value for a non-numeric data type, this value is used in the schema table.|   |NumericScale|If &lt;xref:System.Data.DbType&gt; is &lt;xref:System.Data.DbType&gt;, the number of digits to the right of the decimal point.</source>
          <target state="translated">기본 ODBC 드라이버에서 숫자가 아닌 데이터 형식에 대 한 전체 자릿수 값을 반환 하는 경우이 값은 스키마 테이블에 사용 합니다. |   | NumericScale | 경우 &lt;xref:System.Data.DbType&gt;은 &lt;xref:System.Data.DbType&gt;, 소수점 오른쪽 자릿수입니다.&lt;/xref:System.Data.DbType&gt; &lt;/xref:System.Data.DbType&gt;</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, this is a null value.</source>
          <target state="translated">그렇지 않으면 null 값입니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the underlying ODBC driver returns a precision value for a non-numeric data type, this value is used in the schema table.|   |DataType|Maps to the common language runtime type of &lt;xref:System.Data.DbType&gt;.|   |ProviderType|The underlying driver type.|   |IsLong|<ph id="ph1">`true`</ph> if the column contains a Binary Long Object (BLOB) that contains very long data.</source>
          <target state="translated">기본 ODBC 드라이버에서 숫자가 아닌 데이터 형식에 대 한 전체 자릿수 값을 반환 하는 경우이 값은 스키마 테이블에 사용 합니다. |   | 데이터 형식 | &lt;xref:System.Data.DbType&gt;의 공용 언어 런타임 형식에 매핑됩니다. |   | ProviderType | 기본 드라이버 형식입니다. |   | IsLong | <ph id="ph1">`true`</ph> 는 긴 BLOB (Binary Object) 매우 긴 데이터가 포함 된 열에 포함 된 경우.&lt;/xref:System.Data.DbType&gt;</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>The definition of very long data is driver-specific.|   |AllowDBNull|<ph id="ph1">`true`</ph> if the consumer can set the column to a null value or if the driver cannot determine whether the consumer can set the column to a null value.</source>
          <target state="translated">매우 긴 데이터의 정의 드라이버별. |   | AllowDBNull | <ph id="ph1">`true`</ph> 드라이버 소비자가 열을 null 값으로 설정할 수 있는지 여부를 확인할 수 없는 경우 또는 소비자를 null 값 열을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, <ph id="ph1">`false`</ph>.</source>
          <target state="translated">그렇지 않으면 <ph id="ph1">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>A column may contain null values, even if it cannot be set to a null value.|   |IsReadOnly|<ph id="ph1">`true`</ph> if the column cannot be modified; otherwise <ph id="ph2">`false`</ph>.|   |IsRowVersion|Set if the column contains a persistent row identifier that cannot be written to, and has no meaningful value except to identity the row.|   |IsUnique|<ph id="ph3">`true`</ph>: No two rows in the base table (the table returned in BaseTableName) can have the same value in this column.</source>
          <target state="translated">열은 null 값으로 설정할 수 없습니다 하는 경우에 null 값 포함 될 수 있습니다. |   | IsReadOnly | <ph id="ph1">`true`</ph> 수정 되지 않으면 열 수 없는 경우 <ph id="ph2">`false`</ph>. |   | Isrowversion은 | 열에 쓸 수 없는 영구 행 식별자를 포함 하 고 행 id에만 의미가 경우에 설정 합니다. |   | IsUnique | <ph id="ph3">`true`</ph>: 기본 테이블의 각 행이이 열에 동일한 값 가질 수 있습니다 (BaseTableName에서 반환 된 테이블).</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsUnique is guaranteed to be <ph id="ph1">`true`</ph> if the column represents a key by itself or if there is a constraint of type UNIQUE that applies only to this column.</source>
          <target state="translated">IsUnique 되도록 보장 <ph id="ph1">`true`</ph> 열 자체 키를 나타내는 경우 또는이 열에만 적용 되는 UNIQUE 유형의 제약 조건이 있는 경우.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`false`</ph>: The column can contain duplicate values in the base table.</source>
          <target state="translated"><ph id="ph1">`false`</ph>:이 열은 기본 테이블에서 중복 값을 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default for this column is <ph id="ph1">`false`</ph>.|   |IsKey|<ph id="ph2">`true`</ph>: The column is one of a set of columns in the rowset that, taken together, uniquely identify the row.</source>
          <target state="translated">이 열에 대 한 기본값은 <ph id="ph1">`false`</ph>. |   | IsKey | <ph id="ph2">`true`</ph>: 열이 행 집합의 열 집합 중 하나를 전체적으로 볼 때, 해당 행을 고유 하 게 식별 합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>The set of columns with IsKey set to <ph id="ph1">`true`</ph> must uniquely identify a row in the rowset.</source>
          <target state="translated">IsKey 된 열 집합으로 설정 <ph id="ph1">`true`</ph> 행 집합의 행을 고유 하 게 식별 해야 합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no requirement that this set of columns is a minimal set of columns.</source>
          <target state="translated">이 열 집합이 열의 최소 집합 임을 않아도가 됩니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>This set of columns may be generated from a base table primary key, a unique constraint, or a unique index.</source>
          <target state="translated">기본 테이블 기본 키, 고유 제약 조건 또는 고유 인덱스에서이 열 집합을 생성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`false`</ph>: The column is not required to uniquely identify the row.|   |IsAutoIncrement|<ph id="ph2">`true`</ph> if the column assigns values to new rows in fixed increments; otherwise <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`false`</ph>:이 열은 행을 식별할 필요가 없습니다. |   | IsAutoIncrement | <ph id="ph2">`true`</ph> 열 고정 된 증가분; 새 행에 값을 할당 하는 경우 그러지 않으면 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default for this column is <ph id="ph1">`false`</ph>.|   |BaseSchemaName|The name of the schema in the data source that contains the column.</source>
          <target state="translated">이 열에 대 한 기본값은 <ph id="ph1">`false`</ph>. |   | BaseSchemaName | 열이 포함 된 데이터 원본에 있는 스키마의 이름입니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>NULL if the base catalog name cannot be determined.</source>
          <target state="translated">기본 카탈로그 이름을 확인할 수 없는 경우 NULL입니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default for this column is a null value.|   |BaseCatalogName|The name of the catalog in the data store that contains the column.</source>
          <target state="translated">이 열에 대 한 기본값은 null 값입니다. |   | BaseCatalogName | 열이 포함 된 데이터 저장소에 있는 카탈로그의 이름입니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>NULL if the base catalog name cannot be determined.</source>
          <target state="translated">기본 카탈로그 이름을 확인할 수 없는 경우 NULL입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default for this column is a null value.|   |BaseTableName|The name of the table or view in the data store that contains the column.</source>
          <target state="translated">이 열에 대 한 기본값은 null 값입니다. |   | BaseTableName | 테이블 또는 뷰의 열이 포함 된 데이터 저장소의 이름입니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>A null value if the base table name cannot be determined.</source>
          <target state="translated">기본 테이블 이름을 확인할 수 없는 경우 null 값입니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default of this column is a null value.|   |BaseColumnName|The name of the column in the data store.</source>
          <target state="translated">이 열의 기본 null 값입니다. |   | BaseColumnName | 데이터 저장소에 있는 열의 이름입니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might be different from the column name returned in the ColumnName column if an alias was used.</source>
          <target state="translated">별칭이 사용 된 경우 열 이름 열에 반환 된 열 이름과 다를 수 있습니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>A null value if the base column name cannot be determined or if the rowset column is derived, but not identical to, a column in the data store.</source>
          <target state="translated">데이터의 열 저장소 행 집합 열이 파생 되지만 동일 하지는 않습니다, 하는 경우 또는 기본 열 이름을 확인할 수 없는 경우 null 값입니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default for this column is a null value.|       A row is returned for every column in the results set.</source>
          <target state="translated">이 열에 대 한 기본값은 null 값입니다. |       결과 집합의 모든 열에 대해 행이 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework Data Provider for ODBC assumes that metadata information is available from an ODBC driver after one of <bpt id="p1">**</bpt>SQLPrepare<ept id="p1">**</ept>, <bpt id="p2">**</bpt>SQLExecute<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>SQLExecuteDirect<ept id="p3">**</ept> functions are called.</source>
          <target state="translated">.NET Framework Data Provider for ODBC 중 한 가지 메타 데이터 정보는 ODBC 드라이버에서 사용할 수 있는 것으로 가정 <bpt id="p1">**</bpt>SQLPrepare<ept id="p1">**</ept>, <bpt id="p2">**</bpt>SQLExecute<ept id="p2">**</ept>, 또는 <bpt id="p3">**</bpt>SQLExecuteDirect<ept id="p3">**</ept> 함수가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>For "SchemaOnly" command behavior to work correctly, <bpt id="p1">**</bpt>SQLPrepare<ept id="p1">**</ept> must return the required metadata information.</source>
          <target state="translated">"SchemaOnly"에 대 한 명령을 제대로 작동 하려면 동작 <bpt id="p1">**</bpt>SQLPrepare<ept id="p1">**</ept> 필요한 메타 데이터 정보를 반환 해야 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not all ODBC drivers support this function or return metadata information.</source>
          <target state="translated">일부 ODBC 드라이버는이 기능을 지원 하거나 메타 데이터 정보를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>In these cases, part or all of the information in the SchemaTable will be missing.</source>
          <target state="translated">이 경우 일부 또는 모든 SchemaTable에 정보가 누락 됩니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>After calling <bpt id="p1">**</bpt>SQLPrepare<ept id="p1">**</ept>, The data provider calls the ODBC <bpt id="p2">**</bpt>SQLColAttribute<ept id="p2">**</ept> function to find the metadata information related to each column in the query results (for example, IsLong, IsUnique, AllowDBNull, BaseTableName, BaseColumnName).</source>
          <target state="translated">호출한 후 <bpt id="p1">**</bpt>SQLPrepare<ept id="p1">**</ept>, 데이터 공급자는 ODBC 호출 <bpt id="p2">**</bpt>SQLColAttribute<ept id="p2">**</ept> 함수 (예: IsLong, 고유, AllowDBNull, BaseTableName, BaseColumnName) 쿼리 결과의 각 열에 관한 메타 데이터 정보를 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the underlying driver does not return some of this information, the corresponding values in the SchemaTable will not be set correctly.</source>
          <target state="translated">기본 드라이버를 반환 하지 않으면이 정보 중 일부가 SchemaTable의 해당 값 올바르게 설정 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework Data Provider for ODBC also calls <bpt id="p1">**</bpt>SQLPrimaryKeys<ept id="p1">**</ept> to retrieve the key information for every table.</source>
          <target state="translated">.NET Framework Data Provider for ODBC 호출 또한 <bpt id="p1">**</bpt>SQLPrimaryKeys<ept id="p1">**</ept> 모든 테이블에 대 한 주요 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the underlying ODBC driver does not support this function, the data provider calls <bpt id="p1">**</bpt>SQLStatistics<ept id="p1">**</ept> and chooses one of the unique indexes as the primary key for the table.</source>
          <target state="translated">데이터 공급자를 호출 하는 기본 ODBC 드라이버는이 함수를 지원 하지 않습니다, <bpt id="p1">**</bpt>SQLStatistics<ept id="p1">**</ept> 고유 인덱스 중 하나는 테이블에 대 한 기본 키로 선택 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>This may not always give the results that you want.</source>
          <target state="translated">이 항상 올바르게 원하는 결과입니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Data.Odbc.OdbcCommandBuilder&gt; needs the correct identification of the primary keys of the table in order to work correctly.</source>
          <target state="translated">&lt;xref:System.Data.Odbc.OdbcCommandBuilder&gt;올바르게 작동 하려면 테이블의 기본 키를 올바로 식별을 해야 합니다.&lt;/xref:System.Data.Odbc.OdbcCommandBuilder&gt;</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the BaseTableName is not returned for every column in the query results, the .NET Framework Data Provider for ODBC tries to parse the SQL statement to find the table names involved in the query.</source>
          <target state="translated">쿼리 결과에 모든 열에 대해 BaseTableName에서 반환 되지 않으면.NET Framework Data Provider for ODBC 쿼리에 포함 된 테이블 이름을 찾으려면 SQL 문을 구문 분석 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>This works with UPDATE, INSERT, DELETE and simple SELECT statements, but not with stored procedures or SELECT statements based on joins.</source>
          <target state="translated">보안 그룹은 UPDATE, INSERT, DELETE 및 간단한 SELECT 문으로 있고 저장된 프로시저 또는 조인을 기반으로 하는 SELECT 문을 사용 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>If some or all the schema information is missing from this table, the &lt;xref:System.Data.Odbc.OdbcCommandBuilder&gt; will not work correctly, because it has insufficient schema information to automatically generate the correct INSERT, UPDATE, or DELETE statements.</source>
          <target state="translated">이 테이블에서 스키마 정보를 일부 또는 모든 없으면는 &lt;xref:System.Data.Odbc.OdbcCommandBuilder&gt;부족 하 여 스키마 정보를 올바른 INSERT, UPDATE 또는 DELETE 문을 자동으로 생성 되었기 때문에 속성이 제대로 작동 하지 것입니다.&lt;/xref:System.Data.Odbc.OdbcCommandBuilder&gt;</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>To make sure that metadata columns return the correct information, you must call &lt;xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A&gt; with the behavior parameter set to KeyInfo.</source>
          <target state="translated">올바른 정보를 반환 하는 메타 데이터 열, 호출 해야 되도록 &lt;xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A&gt;KeyInfo로 설정 동작 매개 변수를 사용 합니다.&lt;/xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A&gt;</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, some of the columns in the schema table may return default, null, or incorrect data.</source>
          <target state="translated">그렇지 않으면 스키마 테이블의 열 중 일부 기본값, null 또는 잘못 된 데이터를 반환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you use ODBC.NET to Oracle via the ODBC driver, aliased key columns are not recognized as keys.</source>
          <target state="translated">Oracle를 ODBC.NET를 사용 하 여 ODBC 드라이버를 통해 키 열 별칭이 지정 된 키로 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>This affects the IsKey and IsUnique columns in the schema table of the OdbcDataReader.</source>
          <target state="translated">이 OdbcDataReader 스키마 테이블에 IsKey 및 IsUnique 열을 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>It also affects the OdbcCommandBuilder's ability to generate updating logic.</source>
          <target state="translated">업데이트 논리를 생성 하는 OdbcCommandBuilder 능력을 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider not using an alias for a primary key column.</source>
          <target state="translated">기본 키 열에 대 한 별칭을 사용 하지 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The Microsoft Jet ODBC driver always returns unique index and primary key columns as nullable regardless of whether they are nullable or not.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; The Microsoft Jet ODBC 드라이버는 항상 고유 인덱스와 기본 키 열 null 허용 여부는 nullable 인지에 관계 없이으로 반환 합니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>The driver also does not return primary key information; it only returns a list of unique indexes and their columns, including primary key columns, without differentiating among them.</source>
          <target state="translated">드라이버도 기본 키 정보와; 반환 하지 않습니다. 고유 인덱스 및 열, 기본 키 열을 포함 하 여 이들 사이에서 구분 하지 않고의 목록을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that describes the column metadata.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 열 메타 데이터를 설명 하는 합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is closed.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 닫혀 있습니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a &lt;xref:System.String&gt;.</source>
          <target state="translated">지정 된 열의 값을 &lt;xref:System.String&gt;.&lt;/xref:System.String&gt; 가져옵니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions are performed based on the underlying capabilities of the ODBC driver.</source>
          <target state="translated">변환은은 ODBC 드라이버의 기본 기능에 따라 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is not supported, the method call fails.</source>
          <target state="translated">변환이 지원 되지 않는 경우 메서드 호출이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt; to look for null values before calling this method.</source>
          <target state="translated">호출 &lt;xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;에이 메서드를 호출 하기 전에 null 값을 찾습니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.IsDBNull%2A&gt;</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a &lt;xref:System.String&gt;.</source>
          <target state="translated">에 &lt;xref:System.String&gt;.&lt;/xref:System.String&gt; 로 지정 된 열 값</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The specified cast is not valid.</source>
          <target state="translated">지정한 캐스트가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column as a &lt;xref:System.TimeSpan&gt; object.</source>
          <target state="translated">지정 된 열의 값을 가져옵니다는 &lt;xref:System.TimeSpan&gt;개체입니다.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The value of the specified column as a &lt;xref:System.TimeSpan&gt; object.</source>
          <target state="translated">지정 된 열의 값을 &lt;xref:System.TimeSpan&gt;개체입니다.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Gets the value of the column at the specified ordinal in its native format.</source>
          <target state="translated">네이티브 형식으로 지정 된 서 수 열 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns &lt;xref:System.DBNull&gt; for null database columns.</source>
          <target state="translated">이 메서드가 반환 &lt;xref:System.DBNull&gt;null 데이터베이스 열에 대 한.&lt;/xref:System.DBNull&gt;</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The value to return.</source>
          <target state="translated">반환할 값입니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Populates an array of objects with the column values of the current row.</source>
          <target state="translated">현재 행의 열 값이 있는 개체의 배열을 채웁니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most applications, the &lt;xref:System.Data.Odbc.OdbcDataReader.GetValues%2A&gt; method provides an efficient means for retrieving all columns, instead of retrieving each column individually.</source>
          <target state="translated">대부분의 응용 프로그램에 대 한는 &lt;xref:System.Data.Odbc.OdbcDataReader.GetValues%2A&gt;메서드 각 열을 개별적으로 검색 하는 대신 모든 열을 검색 하는 효율적인 방법을 제공 합니다.&lt;/xref:System.Data.Odbc.OdbcDataReader.GetValues%2A&gt;</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass an &lt;xref:System.Object&gt; array that contains fewer than the number of columns that are contained in the resulting row.</source>
          <target state="translated">전달할 수는 &lt;xref:System.Object&gt;보다 적은 수의 결과 행에 포함 된 열에 포함 된 배열입니다.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only the amount of data the &lt;xref:System.Object&gt; array holds is copied to the array.</source>
          <target state="translated">데이터의 양만 &lt;xref:System.Object&gt;배열 저장 배열에 복사 합니다.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also pass an &lt;xref:System.Object&gt; array whose length is more than the number of columns that are contained in the resulting row.</source>
          <target state="translated">전달할 수도 있습니다는 &lt;xref:System.Object&gt;결과 행에 포함 된 열의 개수 이상의 길이가.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns &lt;xref:System.DBNull&gt; for null database columns.</source>
          <target state="translated">이 메서드가 반환 &lt;xref:System.DBNull&gt;null 데이터베이스 열에 대 한.&lt;/xref:System.DBNull&gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>An array of type &lt;xref:System.Object&gt; into which to copy the attribute columns.</source>
          <target state="translated">형식의 배열 &lt;xref:System.Object&gt;특성 열을 복사할 대상.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The number of instances of &lt;xref:System.Object&gt; in the array.</source>
          <target state="translated">인스턴스 수가 &lt;xref:System.Object&gt;배열의.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> contains one or more rows.</source>
          <target state="translated">나타내는 값을 가져옵니다 여부는 <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 하나 이상의 행을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> contains one or more rows; otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우는 <bpt id="p2">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 하나 이상의 행을 포함 하지 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Indicates whether the <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is closed.</source>
          <target state="translated">나타냅니다 여부는 <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 닫혀 있습니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsClosed and &lt;xref:System.Data.Odbc.OdbcDataReader.RecordsAffected%2A&gt; are the only properties that you can call after the &lt;xref:System.Data.Odbc.OdbcDataReader&gt; is closed.</source>
          <target state="translated">IsClosed 및 &lt;xref:System.Data.Odbc.OdbcDataReader.RecordsAffected%2A&gt;후 호출할 수 있는 속성만 &lt;xref:System.Data.Odbc.OdbcDataReader&gt;닫힙니다.&lt;/xref:System.Data.Odbc.OdbcDataReader&gt; &lt;/xref:System.Data.Odbc.OdbcDataReader.RecordsAffected%2A&gt;</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> is closed; otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우는 <bpt id="p2">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 닫혀 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the column contains nonexistent or missing values.</source>
          <target state="translated">열에 존재 하지 않거나 누락 된 값이 들어 있는지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid raising an error, call this method to look for null column values before calling the typed Get methods (for example, &lt;xref:System.Data.Odbc.OdbcDataReader.GetByte%2A&gt;, &lt;xref:System.Data.Odbc.OdbcDataReader.GetChar%2A&gt;, and so on).</source>
          <target state="translated">오류 발생을 방지 하려면이 메서드는 형식화 된를 호출 하기 전에 null 열 값 get 메서드를 호출 (예를 들어 &lt;xref:System.Data.Odbc.OdbcDataReader.GetByte%2A&gt;, &lt;xref:System.Data.Odbc.OdbcDataReader.GetChar%2A&gt;등).&lt;/xref:System.Data.Odbc.OdbcDataReader.GetChar%2A&gt; &lt;/xref:System.Data.Odbc.OdbcDataReader.GetByte%2A&gt;</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The zero-based column ordinal.</source>
          <target state="translated">서 수는&amp;0;부터 시작 열입니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the specified column value is equivalent to <bpt id="p2">&lt;xref href="System.DBNull"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>지정 된 열 값에 해당 하는 경우 <bpt id="p2">&lt;xref href="System.DBNull"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>고, 그렇지 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column in its native format given the column ordinal.</source>
          <target state="translated">열 서 수를 지정 된 네이티브 형식으로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The column ordinal.</source>
          <target state="translated">열 서 수입니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The value of the specified column in its native format.</source>
          <target state="translated">네이티브 형식으로 지정 된 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The index passed was outside the range of 0 through &lt;xref:System.Data.IDataRecord.FieldCount*&gt;.</source>
          <target state="translated">전달 된 &lt;xref:System.Data.IDataRecord.FieldCount*&gt;.&lt;/xref:System.Data.IDataRecord.FieldCount*&gt; 0k 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Gets the value of the specified column in its native format given the column name.</source>
          <target state="translated">열 이름이 지정 된 네이티브 형식으로 지정 된 열의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>A case-sensitive lookup is performed first.</source>
          <target state="translated">대/소문자 구분 조회를 먼저 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it fails, a second case-insensitive search is made.</source>
          <target state="translated">실패 한 경우에 두 번째 대/소문자 구분 검색이 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is kana-width insensitive.</source>
          <target state="translated">이 메서드는 일본어가 나 너비 구분 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The column name.</source>
          <target state="translated">열 이름입니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The value of the specified column in its native format.</source>
          <target state="translated">네이티브 형식으로 지정 된 열의 값입니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>No column with the specified name was found.</source>
          <target state="translated">지정한 이름 가진 열을 찾았습니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Advances the <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the next result when reading the results of batch SQL statements.</source>
          <target state="translated">이동의 <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 일괄 처리 SQL 문의 결과를 읽을 때 다음 결과입니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>Used to process multiple results that can be generated by executing batch SQL statements.</source>
          <target state="translated">일괄 처리 SQL 문을 실행 하 여 생성 될 수 있는 여러 결과 처리 하는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the &lt;xref:System.Data.Odbc.OdbcDataReader&gt; is positioned on the first result.</source>
          <target state="translated">기본적으로는 &lt;xref:System.Data.Odbc.OdbcDataReader&gt;첫 번째 결과에 배치 됩니다.&lt;/xref:System.Data.Odbc.OdbcDataReader&gt;</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if there are more result sets; otherwise <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>결과 집합이 더 있는 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Advances the <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the next record.</source>
          <target state="translated">이동 된 <bpt id="p1">&lt;xref href="System.Data.Odbc.OdbcDataReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 를 다음 레코드로 합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default position of the &lt;xref:System.Data.Odbc.OdbcDataReader&gt; is before the first record.</source>
          <target state="translated">기본 위치는 &lt;xref:System.Data.Odbc.OdbcDataReader&gt;첫 번째 레코드 앞입니다.&lt;/xref:System.Data.Odbc.OdbcDataReader&gt;</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call Read to start accessing any data.</source>
          <target state="translated">따라서 데이터에 액세스 하려면 Read를 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>While the &lt;xref:System.Data.Odbc.OdbcDataReader&gt; is being used, the associated &lt;xref:System.Data.Odbc.OdbcConnection&gt; is busy serving it until you call &lt;xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt;.</source>
          <target state="translated">반면는 &lt;xref:System.Data.Odbc.OdbcDataReader&gt;사용 중인 연결 &lt;xref:System.Data.Odbc.OdbcConnection&gt;중인 &lt;xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt;.&lt;/xref:System.Data.Odbc.OdbcDataReader.Close%2A&gt; 를 호출할 때까지&lt;/xref:System.Data.Odbc.OdbcConnection&gt; &lt;/xref:System.Data.Odbc.OdbcDataReader&gt;</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if there are more rows; otherwise <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>행이 더 있는 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.</source>
          <target state="translated">변경, 삽입 또는 SQL 문 실행 하 여 삭제 된 행의 수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>The RecordsAffected property is not set until all rows are read and you close the &lt;xref:System.Data.Odbc.OdbcDataReader&gt;.</source>
          <target state="translated">모든 행을 &lt;xref:System.Data.Odbc.OdbcDataReader&gt;.&lt;/xref:System.Data.Odbc.OdbcDataReader&gt; 를 닫을 때까지 RecordsAffected 속성이 설정 되지</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of this property is cumulative.</source>
          <target state="translated">이 속성의 값은 누적 합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if two records are inserted in batch mode, the value of RecordsAffected will be 2.</source>
          <target state="translated">예를 들어 일괄 처리 모드에 두 개의 레코드를 삽입 하는 경우 RecordsAffected의 값은 2가 됩니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Data.Odbc.OdbcDataReader.IsClosed%2A&gt; and RecordsAffected are the only properties that you can call after the &lt;xref:System.Data.Odbc.OdbcDataReader&gt; is closed.</source>
          <target state="translated">&lt;xref:System.Data.Odbc.OdbcDataReader.IsClosed%2A&gt;RecordsAffected 후 호출할 수 있는 유일한 속성은 및에서 &lt;xref:System.Data.Odbc.OdbcDataReader&gt;닫힙니다.&lt;/xref:System.Data.Odbc.OdbcDataReader&gt;&lt;/xref:System.Data.Odbc.OdbcDataReader.IsClosed%2A&gt;</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The number of rows changed, inserted, or deleted.</source>
          <target state="translated">변경, 삽입 또는 삭제 된 행의 수입니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>-1 for SELECT statements; 0 if no rows were affected, or the statement failed.</source>
          <target state="translated">SELECT 문의;에 대 한-1 행이 없는 영향을 받았는지 또는 문이 실패 한 경우 0입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>