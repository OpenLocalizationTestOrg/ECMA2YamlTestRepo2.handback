<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5741d0b7b3f8319453076dfdf81c13ed7570dbbc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.IO.Log.LogRecordSequence.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">60bf4df3fb0238e4a71111c3f046e03cb3f0d5b9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a776eb9144e38bb01ec6eb9e25e38c871e46170</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a record sequence stored in a <bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 저장 된 레코드 시퀀스를 나타냅니다는 <bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The LogRecordSequence class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</source>
          <target state="translated">LogRecordSequence 클래스에는 공통 로그 CLFS (File System) 로그 위에 레코드 시퀀스 인터페이스의 구현을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file.</source>
          <target state="translated">표준 레코드 기반 기능 외에도 로그 전체 상태를 방지 하 고 동일한 물리적 파일에서 클라이언트를 멀티플렉싱 하기 위한 정책 모델을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>It works with the &lt;xref:System.IO.Log.LogStore&gt; class, which provides an interface for directly manipulating and managing a CLFS log file.</source>
          <target state="translated">와 함께 작동는 &lt;xref:System.IO.Log.LogStore&gt;직접 조작 하 고 관리는 CLFS 로그 파일에 대 한 인터페이스를 제공 하는 클래스입니다.&lt;/xref:System.IO.Log.LogStore&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The relationship between the &lt;xref:System.IO.Log.LogStore&gt; class and the LogRecordSequence class is similar to the relationship between a disk file and a &lt;xref:System.IO.FileStream&gt; object.</source>
          <target state="translated">간의 관계는 &lt;xref:System.IO.Log.LogStore&gt;클래스 및 LogRecordSequence 클래스는 유사 디스크 파일 간의 관계 및 &lt;xref:System.IO.FileStream&gt;개체입니다.&lt;/xref:System.IO.FileStream&gt; &lt;/xref:System.IO.Log.LogStore&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The disk file provides the concrete storage, and has attributes such as length and last access time; while the &lt;xref:System.IO.FileStream&gt; object provides a view on the file that can be used to read from it and write to it.</source>
          <target state="translated">디스크 파일은 실제 저장소를 제공 하 고 길이 및 마지막 액세스 시간이; 같은 특성이 있으며 &lt;xref:System.IO.FileStream&gt;개체에서 읽고 쓰는.를 사용할 수 있는 파일에 대 한 뷰를 제공&lt;/xref:System.IO.FileStream&gt; 하는 동안</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, the &lt;xref:System.IO.Log.LogStore&gt; class has attributes like a policy and a collection of disk extents; and the LogRecordSequence class provides a record-oriented mechanism for reading and writing data.</source>
          <target state="translated">마찬가지로,는 &lt;xref:System.IO.Log.LogStore&gt;; 디스크 범위의 컬렉션 및 정책과 같은 특성이 클래스 및 LogRecordSequence 클래스 데이터 읽기 및 쓰기 위한 레코드 기반 메커니즘을 제공 합니다.&lt;/xref:System.IO.Log.LogStore&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified log store.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 로그 저장소를 사용 하 여 클래스입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">버퍼 크기는 추가 하거나 읽을 수 있는 레코드의 최대 크기를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this constructor, a default value of 64 is set.</source>
          <target state="translated">이 생성자에는 기본값 64 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>The desired number of buffers is set to 10.</source>
          <target state="translated">원하는 버퍼 수는 10으로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that this record sequence should use.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 레코드 시퀀스를 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;logStore&lt;/code&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;logStore&lt;/code&gt;</ph>잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified path to the log store and the access mode.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로그 저장소와 액세스 모드를 지정된 된 경로 사용 하 여 클래스입니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor initializes a new &lt;xref:System.IO.Log.LogRecordSequence&gt; on a new &lt;xref:System.IO.Log.LogStore&gt; object that it opens with the specified path and mode.</source>
          <target state="translated">이 생성자는 새 &lt;xref:System.IO.Log.LogRecordSequence&gt;에서 새로운 &lt;xref:System.IO.Log.LogStore&gt;개체는 지정 된 경로 모드를 사용 하 여.&lt;/xref:System.IO.Log.LogStore&gt; &lt;/xref:System.IO.Log.LogRecordSequence&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is given read/write access to the store, and the store is opened sharing Read access.</source>
          <target state="translated">저장소에 읽기/쓰기 액세스를 지정 하 고 읽기 권한을 공유 저장소는 열립니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values that determines how to open or create the store.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 열거나 저장소를 만들 방법을 결정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph>빈 문자열 ("").</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> contains only white space.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> 공백만 포함 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> 하나 이상의 잘못 된 문자가 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph>잘못 된 값을 포함합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The file cannot be found.</source>
          <target state="translated">파일을 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">로그 저장소를 열 때 I/O 오류가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This operation is not supported.</source>
          <target state="translated">이 작업이 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Install the CLFS component if it is available for your platform, or use the <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified log store, buffer size for each record, and buffer number.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 된 지정된 된 로그 저장소, 각 레코드에 대 한 버퍼 크기 및 버퍼 수입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this constructor if you want to specify values for <ph id="ph1">`bufferSize`</ph> and <ph id="ph2">`bufferCount`</ph> and do not want to use the default value of 64 for <ph id="ph3">`bufferSize`</ph> and 10 for <ph id="ph4">`bufferCount`</ph>.</source>
          <target state="translated">에 대 한 값을 지정 하려면이 생성자를 사용 하 여 <ph id="ph1">`bufferSize`</ph> 및 <ph id="ph2">`bufferCount`</ph> 64에 대 한 기본값을 사용 하지 않으려는 및 <ph id="ph3">`bufferSize`</ph> 및에 대 한 10 <ph id="ph4">`bufferCount`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that this record sequence should use.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 레코드 시퀀스를 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">원하는 버퍼 크기 (바이트)입니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">버퍼 크기는 추가 하거나 읽을 수 있는 레코드의 최대 크기를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The desired number of buffers.</source>
          <target state="translated">원하는 버퍼 수입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;logStore&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;logStore&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bufferSize &lt;/code&gt;</ph>is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;bufferSize &lt;/code&gt;</ph>가 음수 이거나&amp;0;입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;bufferCount&lt;/code&gt;</ph> is negative or zero.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;bufferCount&lt;/code&gt;</ph> 가 음수 이거나&amp;0;입니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified path to the log store and the access and share modes.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로그 저장소와 액세스 및 공유 모드를 지정된 된 경로 사용 하 여 클래스입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor initializes a new &lt;xref:System.IO.Log.LogRecordSequence&gt; on a new &lt;xref:System.IO.Log.LogStore&gt; object that it opens with the specified path, mode, and access.</source>
          <target state="translated">이 생성자는 새 &lt;xref:System.IO.Log.LogRecordSequence&gt;에서 새로운 &lt;xref:System.IO.Log.LogStore&gt;지정 된 경로, 모드 및 액세스를 사용 하 여 개체.&lt;/xref:System.IO.Log.LogStore&gt; &lt;/xref:System.IO.Log.LogRecordSequence&gt;</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The store is opened sharing Read access.</source>
          <target state="translated">저장소는 읽기 권한을 공유 열립니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values that determines how to open or create the store.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 열거나 저장소를 만들 방법을 결정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.IO.FileAccess"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values that determines how the file can be accessed by the <bpt id="p2">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.IO.FileAccess"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 하 여 파일에 액세스할 수 있는 방법을 결정 하는 값은 <bpt id="p2">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph>빈 문자열 ("").</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> contains only white space.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> 공백만 포함 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> 하나 이상의 잘못 된 문자가 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph>잘못 된 값을 포함합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The file cannot be found.</source>
          <target state="translated">파일을 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">로그 저장소를 열 때 I/O 오류가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This operation is not supported.</source>
          <target state="translated">이 작업이 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Install the CLFS component if it is available for your platform, or use the <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified path to the log store and the access mode.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로그 저장소와 액세스 모드를 지정된 된 경로 사용 하 여 클래스입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor initializes a new &lt;xref:System.IO.Log.LogRecordSequence&gt; on a new &lt;xref:System.IO.Log.LogStore&gt; object that it opens with the specified path, mode, and access.</source>
          <target state="translated">이 생성자는 새 &lt;xref:System.IO.Log.LogRecordSequence&gt;에서 새로운 &lt;xref:System.IO.Log.LogStore&gt;지정 된 경로, 모드 및 액세스를 사용 하 여 개체.&lt;/xref:System.IO.Log.LogStore&gt; &lt;/xref:System.IO.Log.LogRecordSequence&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>The store is opened sharing the specified access.</source>
          <target state="translated">지정 된 액세스 권한을 공유 저장소는 열립니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values that determines how to open or create the store.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 열거나 저장소를 만들 방법을 결정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.IO.FileAccess"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values that determines how the file can be accessed by the <bpt id="p2">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.IO.FileAccess"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 하 여 파일에 액세스할 수 있는 방법을 결정 하는 값은 <bpt id="p2">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.IO.FileShare"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values that determines how the log store will be shared among processes.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.IO.FileShare"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로그 저장소가 프로세스 간에 공유 될 방법을 결정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph>빈 문자열 ("").</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> contains only white space.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> 공백만 포함 합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> 하나 이상의 잘못 된 문자가 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph>잘못 된 값을 포함합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The file cannot be found.</source>
          <target state="translated">파일을 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">로그 저장소를 열 때 I/O 오류가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This operation is not supported.</source>
          <target state="translated">이 작업이 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Install the CLFS component if it is available for your platform, or use the <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로그 저장소, 파일 사용 권한, 액세스 및 공유 모드 및 버퍼 크기 및 레코드 수가 지정 된 경로 사용 하 여 클래스입니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor initializes a new &lt;xref:System.IO.Log.LogRecordSequence&gt; on a new &lt;xref:System.IO.Log.LogStore&gt; object that it opens with the specified path, mode, and access.</source>
          <target state="translated">이 생성자는 새 &lt;xref:System.IO.Log.LogRecordSequence&gt;에서 새로운 &lt;xref:System.IO.Log.LogStore&gt;지정 된 경로, 모드 및 액세스를 사용 하 여 개체.&lt;/xref:System.IO.Log.LogStore&gt; &lt;/xref:System.IO.Log.LogRecordSequence&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The store is opened sharing the specified access.</source>
          <target state="translated">지정 된 액세스 권한을 공유 저장소는 열립니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values that determines how to open or create the store.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 열거나 저장소를 만들 방법을 결정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.IO.FileAccess"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values that determines how the file can be accessed by the <bpt id="p2">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.IO.FileAccess"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 하 여 파일에 액세스할 수 있는 방법을 결정 하는 값은 <bpt id="p2">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.IO.FileShare"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values that determines how the log store will be shared among processes.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.IO.FileShare"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로그 저장소가 프로세스 간에 공유 될 방법을 결정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">원하는 버퍼 크기 (바이트)입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">버퍼 크기는 추가 하거나 읽을 수 있는 레코드의 최대 크기를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The desired number of buffers.</source>
          <target state="translated">원하는 버퍼 수입니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph>빈 문자열 ("").</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> contains only white space.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> 공백만 포함 합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> 하나 이상의 잘못 된 문자가 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph>잘못 된 값을 포함합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The file cannot be found.</source>
          <target state="translated">파일을 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">로그 저장소를 열 때 I/O 오류가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This operation is not supported.</source>
          <target state="translated">이 작업이 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Install the CLFS component if it is available for your platform, or use the <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A valid <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value that determines how to open or create the store.</source>
          <target state="translated">유효한 <bpt id="p1">&lt;xref href="System.IO.FileMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 열거나 저장소를 만들 방법을 결정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>A valid <bpt id="p1">&lt;xref href="System.IO.FileAccess"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value that determines how the log store can be accessed.</source>
          <target state="translated">유효한 <bpt id="p1">&lt;xref href="System.IO.FileAccess"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로그 저장소에 액세스할 수 있는 방법을 결정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A valid <bpt id="p1">&lt;xref href="System.IO.FileShare"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value that determines how the log store will be shared among processes.</source>
          <target state="translated">유효한 <bpt id="p1">&lt;xref href="System.IO.FileShare"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로그 저장소가 프로세스 간에 공유 될 방법을 결정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">원하는 버퍼 크기 (바이트)입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">버퍼 크기는 추가 하거나 읽을 수 있는 레코드의 최대 크기를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The desired number of buffers.</source>
          <target state="translated">원하는 버퍼 수입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>A valid <bpt id="p1">&lt;xref href="System.Security.AccessControl.FileSecurity"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value that specifies the security to set on the newly created store if the store must be created.</source>
          <target state="translated">유효한 <bpt id="p1">&lt;xref href="System.Security.AccessControl.FileSecurity"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 저장소를 만들어야 하는 경우 새로 만든된 저장소에 설정할 보안을 지정 하는 값입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">path</ph><ept id="p1">&lt;/code&gt;</ept> is not valid.</source>
          <target state="translated">지정한 파일 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">path</ph> <ept id="p1">&lt;/code&gt;</ept> 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>-or-       The specified log store file name is not valid.</source>
          <target state="translated">-또는-지정 된 로그 저장소 파일 이름이 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> has a value of <bpt id="p2">&lt;xref href="System.IO.FileMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, and cannot be used without write access.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">mode</ph> <ept id="p1">&lt;/code&gt;</ept> 값 <bpt id="p2">&lt;xref href="System.IO.FileMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>, 쓰기 권한 없이 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> has a value of <bpt id="p2">&lt;xref href="System.IO.FileMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, and cannot be used without write access.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">mode</ph> <ept id="p1">&lt;/code&gt;</ept> 값 <bpt id="p2">&lt;xref href="System.IO.FileMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>, 쓰기 권한 없이 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are out of range.</source>
          <target state="translated">인수 중 하나 이상이 범위를 벗어났습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">path</ph><ept id="p1">&lt;/code&gt;</ept> cannot be found.</source>
          <target state="translated">지정한 파일 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">path</ph> <ept id="p1">&lt;/code&gt;</ept> 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>-or-       The file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">path</ph><ept id="p1">&lt;/code&gt;</ept> cannot be accessed because it is in use by another process.</source>
          <target state="translated">-또는-지정 된 파일이 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">path</ph> <ept id="p1">&lt;/code&gt;</ept> 액세스할 수 없습니다 사용 중이기 때문에 다른 프로세스에서 합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>-or-       The file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">path</ph><ept id="p1">&lt;/code&gt;</ept> cannot be created because the file or directory already exists.</source>
          <target state="translated">-또는-지정 된 파일이 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">path</ph> <ept id="p1">&lt;/code&gt;</ept> 파일 또는 디렉터리가 이미 있기 때문에 만들 수 없습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>-or-       The log handle could not be bound to the thread pool.</source>
          <target state="translated">-또는-로그 핸들을 스레드 풀에 바인딩할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>-or-       The specified log file format or version is invalid.</source>
          <target state="translated">-또는-지정 된 로그 파일 형식이 나 버전이 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>This operation is not supported.</source>
          <target state="translated">이 작업이 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Install the CLFS component if it is available for your platform, or use the <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <bpt id="p1">&lt;xref href="System.IO.Log.FileRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Moves the base sequence number of the log forward.</source>
          <target state="translated">로그의 기준 시퀀스 번호를 앞으로 이동합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is often used with the &lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt; event to free up space in a record.</source>
          <target state="translated">이 메서드는 종종와 함께 사용 되는 &lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;레코드에 공간을 확보 하는 이벤트입니다.&lt;/xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt; event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space.</source>
          <target state="translated">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;이벤트 (즉, 기준 시퀀스 번호) 시퀀스의 테일 공간을 확보 하 앞으로 이동 해야 함을 나타냅니다.&lt;/xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>Freeing space can be done by either writing restart areas using the &lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt; method, or truncating the log and using the AdvanceBaseSequenceNumber method to advance the base sequence number of a log to the one specified by the <ph id="ph1">`newBaseSequenceNumber`</ph> parameter.</source>
          <target state="translated">공간을 확보 하거나 작성 하 여 수행할 수 있습니다 재시작 영역을 사용 하는 &lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;또는 로그를 자르는 메서드와 하 여 지정 된 로그의 기준 시퀀스 번호 이동 AdvanceBaseSequenceNumber 메서드를 사용 하는 <ph id="ph1">`newBaseSequenceNumber`</ph> 매개 변수.&lt;/xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code sample in the Example section demonstrates the second approach.</source>
          <target state="translated">"예" 섹션의 코드 예제에는 두 번째 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that calling this method is the same as setting a new base sequence number using the &lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt; method, except that no restart record is written to the log.</source>
          <target state="translated">이 메서드를 호출 하는 동일한 방식으로 한 새 기준 시퀀스 번호를 사용 하 여 설정 된 &lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;메서드를 제외 하 고 재시작 레코드를 로그에 쓰여집니다&lt;/xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Specifies the new base <bpt id="p1">&lt;xref href="System.IO.Log.SequenceNumber"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for the log.</source>
          <target state="translated">새 기본 지정 <bpt id="p1">&lt;xref href="System.IO.Log.SequenceNumber"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로그에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</source>
          <target state="translated">이 내에 있어야 현재 기준 시퀀스 번호와 로그의 마지막 시퀀스 번호 사이의 범위 까지입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;newBaseSequenceNumber&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;newBaseSequenceNumber&lt;/code&gt;</ph>이 시퀀스에 대해 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">newBaseSequenceNumber</ph><ept id="p1">&lt;/code&gt;</ept> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">newBaseSequenceNumber</ph> <ept id="p1">&lt;/code&gt;</ept> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The specified log does not have any extents.</source>
          <target state="translated">지정된 된 로그에는 범위가 없습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>One or more extents must be created before a record sequence may be used.</source>
          <target state="translated">레코드 시퀀스를 사용 하기 전에 하나 이상의 범위를 만들어야 합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Writes a log record to the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">로그 레코드를 기록 된 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">추가 된 로그 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Appends a log record to the <bpt id="p1">&lt;xref href="System.IO.Log.IRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">로그 레코드를 추가 하는 <bpt id="p1">&lt;xref href="System.IO.Log.IRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">추가 된 로그 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Appends a log record to the <bpt id="p1">&lt;xref href="System.IO.Log.IRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, using space previously reserved in the sequence.</source>
          <target state="translated">로그 레코드를 추가 하는 <bpt id="p1">&lt;xref href="System.IO.Log.IRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>, 시퀀스에서 이전에 예약 된 공간을 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">추가 된 레코드 이전에 예약 된, 변수로 지정 된 예약을 사용 하 여 공간을 사용 하면는 <ph id="ph1">`reservations`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">추가 작업이 성공 하면 및 예약 영역이 컬렉션에서 제거할 데이터를 포함 될 수 있는 가장 작은 예약 영역을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 레코드에 대해 사용 해야 하는 예약이 포함 된입니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">추가 된 로그 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>No reservation large enough to fit <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">data</ph><ept id="p1">&lt;/code&gt;</ept> can be found in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">reservations</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
          <target state="translated">에 맞게 충분히 큰 예약이 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">data</ph> <ept id="p1">&lt;/code&gt;</ept> 있습니다 <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">reservations</ph> <ept id="p2">&lt;/code&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Appends a log record to the <bpt id="p1">&lt;xref href="System.IO.Log.IRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, using space previously reserved in the sequence.</source>
          <target state="translated">로그 레코드를 추가 하는 <bpt id="p1">&lt;xref href="System.IO.Log.IRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>, 시퀀스에서 이전에 예약 된 공간을 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">추가 된 레코드 이전에 예약 된, 변수로 지정 된 예약을 사용 하 여 공간을 사용 하면는 <ph id="ph1">`reservations`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">추가 작업이 성공 하면 및 예약 영역이 컬렉션에서 제거할 데이터를 포함 될 수 있는 가장 작은 예약 영역을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.IRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 레코드에 대해 사용 해야 하는 예약이 포함 된입니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">추가 된 로그 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>No reservation large enough to fit <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">data</ph><ept id="p1">&lt;/code&gt;</ept> can be found in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">reservations</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
          <target state="translated">에 맞게 충분히 큰 예약이 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">data</ph> <ept id="p1">&lt;/code&gt;</ept> 있습니다 <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">reservations</ph> <ept id="p2">&lt;/code&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Gets the sequence number of the first valid record in the current <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">현재에서 유효한 첫 번째 레코드의 시퀀스 번호를 가져옵니다 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than &lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;.</source>
          <target state="translated">유효한 시퀀스 번호는 보다 큰가 BaseSequenceNumber 같고 &lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;.&lt;/xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt; 보다 작음</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of this property can be changed by calling the &lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt; method or &lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt; method.</source>
          <target state="translated">호출 하 여이 속성의 값을 변경할 수 있습니다는 &lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;메서드 또는 &lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt; &lt;/xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The lowest sequence number that corresponds to a valid record in the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">유효한 레코드에 해당 하는 가장 낮은 시퀀스 번호는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 속성에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">비동기 시작 작업을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">전달 해야는 &lt;xref:System.IAsyncResult&gt;에이 메서드에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.</source>
          <target state="translated">될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;메서드는 &lt;xref:System.IAsyncResult&gt;이 메서드에서 반환 된.&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">추가 완료 되 면 호출 되는 선택적 비동기 콜백.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;보류 중일 수 있는 비동기 추가 나타내는입니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;nextUndoRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;nextUndoRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;nextUndoRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;nextUndoRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">비동기 시작 작업을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">전달 해야는 &lt;xref:System.IAsyncResult&gt;에이 메서드에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.</source>
          <target state="translated">될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;메서드는 &lt;xref:System.IAsyncResult&gt;이 메서드에서 반환 된.&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">추가 완료 되 면 호출 되는 선택적 비동기 콜백.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;보류 중일 수 있는 비동기 추가 나타내는입니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">비동기 시작 작업을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">전달 해야는 &lt;xref:System.IAsyncResult&gt;에이 메서드에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.</source>
          <target state="translated">될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;메서드는 &lt;xref:System.IAsyncResult&gt;이 메서드에서 반환 된.&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">추가 된 레코드 이전에 예약 된, 변수로 지정 된 예약을 사용 하 여 공간을 사용 하면는 <ph id="ph1">`reservations`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">추가 작업이 성공 하면 및 예약 영역이 컬렉션에서 제거할 데이터를 포함 될 수 있는 가장 작은 예약 영역을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 레코드에 대해 사용 해야 하는 예약이 포함 된입니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">추가 완료 되 면 호출 되는 선택적 비동기 콜백.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;보류 중일 수 있는 비동기 추가 나타내는입니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>No reservation large enough to fit <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">data</ph><ept id="p1">&lt;/code&gt;</ept> can be found in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">reservations</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
          <target state="translated">에 맞게 충분히 큰 예약이 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">data</ph> <ept id="p1">&lt;/code&gt;</ept> 있습니다 <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">reservations</ph> <ept id="p2">&lt;/code&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">비동기 시작 작업을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">전달 해야는 &lt;xref:System.IAsyncResult&gt;에이 메서드에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.</source>
          <target state="translated">될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;메서드는 &lt;xref:System.IAsyncResult&gt;이 메서드에서 반환 된.&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">추가 된 레코드 이전에 예약 된, 변수로 지정 된 예약을 사용 하 여 공간을 사용 하면는 <ph id="ph1">`reservations`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">추가 작업이 성공 하면 및 예약 영역이 컬렉션에서 제거할 데이터를 포함 될 수 있는 가장 작은 예약 영역을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 레코드에 대해 사용 해야 하는 예약이 포함 된입니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">추가 완료 되 면 호출 되는 선택적 비동기 콜백.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;보류 중일 수 있는 비동기 추가 나타내는입니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>No reservation large enough to fit <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">data</ph><ept id="p1">&lt;/code&gt;</ept> can be found in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">reservations</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
          <target state="translated">에 맞게 충분히 큰 예약이 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">data</ph> <ept id="p1">&lt;/code&gt;</ept> 있습니다 <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">reservations</ph> <ept id="p2">&lt;/code&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous flush operation, using space previously reserved in the sequence.</source>
          <target state="translated">시퀀스에서 이전에 예약 된 공간을 사용 하 여 비동기 플러시 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should pass the &lt;xref:System.IAsyncResult&gt; returned by the current method to the &lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt; method to ensure that the flush completes and resources are freed appropriately.</source>
          <target state="translated">전달 해야는 &lt;xref:System.IAsyncResult&gt;를 현재 메서드에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;메서드 여 플러시를 완료 하 고 리소스가 적절 하 게 해제 됩니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an error occurs during an asynchronous flush, an exception is not thrown until the &lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.</source>
          <target state="translated">될 때까지 비동기 플러시 중에 오류가 발생 하는 경우 예외가 throw 되지 않습니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;메서드는 &lt;xref:System.IAsyncResult&gt;이 메서드에서 반환 된.&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method ensures that all records that have been appended to the &lt;xref:System.IO.Log.LogRecordSequence&gt; are durably written.</source>
          <target state="translated">이 메서드를 호출 하면 모든 레코드가 있는에 추가 된는 &lt;xref:System.IO.Log.LogRecordSequence&gt;영속적으로 기록 됩니다.&lt;/xref:System.IO.Log.LogRecordSequence&gt;</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt; method is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류 예를 들어 비동기 플러시 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;메서드를 호출 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">써야 하는 최신 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>If this <bpt id="p1">&lt;xref href="System.IO.Log.SequenceNumber"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is invalid, then all records must be written.</source>
          <target state="translated">이 경우 <bpt id="p1">&lt;xref href="System.IO.Log.SequenceNumber"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 유효 하지 않을 경우 모든 레코드를 써야 합니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>An optional asynchronous callback, to be called when the flush is complete.</source>
          <target state="translated">플러시가 완료 되 면 호출 되는 선택적 비동기 콜백.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous flush request from other requests.</source>
          <target state="translated">이 특정 비동기 플러시 요청을 다른 요청과 구별 하는 사용자 제공 개체입니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous flush operation, which could still be pending.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;보류할 수를 나타내는 비동기 플러시 작업, 중일 수 있습니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph>이 시퀀스에 대해 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph>이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이의 않습니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The specified log does not have any extents.</source>
          <target state="translated">지정된 된 로그에는 범위가 없습니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">레코드 시퀀스를 사용 하려면 먼저 하나 이상의 범위를 만들어야 합니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">비동기 예약 및 시작 작업을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">전달 해야는 &lt;xref:System.IAsyncResult&gt;에이 메서드에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.</source>
          <target state="translated">될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드는 &lt;xref:System.IAsyncResult&gt;이 메서드에서 반환 된.&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">추가 된 지정 된 예약은 레코드와 원자 단위 연산에서 컬렉션 추가 작업에 제공된 된 예약 합니다.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">추가 실패, 없음 공간이 예약 됩니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드를 호출 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">예약을 만들 예약 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">바이트 단위로 만들 예약 합니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">추가 완료 되 면 호출 되는 선택적 비동기 콜백.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;보류 중일 수 있는이 비동기 작업을 나타내는입니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>No reservation large enough to fit <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">data</ph><ept id="p1">&lt;/code&gt;</ept> can be found in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">reservations</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
          <target state="translated">에 맞게 충분히 큰 예약이 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">data</ph> <ept id="p1">&lt;/code&gt;</ept> 있습니다 <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">reservations</ph> <ept id="p2">&lt;/code&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">비동기 예약 및 시작 작업을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">전달 해야는 &lt;xref:System.IAsyncResult&gt;에이 메서드에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.</source>
          <target state="translated">될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드는 &lt;xref:System.IAsyncResult&gt;이 메서드에서 반환 된.&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">추가 된 지정 된 예약은 레코드와 원자 단위 연산에서 컬렉션 추가 작업에 제공된 된 예약 합니다.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">추가 실패, 없음 공간이 예약 됩니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드를 호출 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">예약을 만들 예약 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">바이트 단위로 만들 예약 합니다.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">추가 완료 되 면 호출 되는 선택적 비동기 콜백.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;보류 중일 수 있는이 비동기 작업을 나타내는입니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">인수 중 하나 이상이 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">레코드를 추가 하는 동안 I/O 오류가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">레코드 시퀀스에서 새 레코드를 포함 하거나 예약을 변경 하려면 충분 한 여유 공간을 만들지 못했습니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">시퀀스에서 이전에 예약 된 공간을 사용 하는 비동기 재시작 영역 쓰기 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt; method to ensure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">전달 해야는 &lt;xref:System.IAsyncResult&gt;에이 메서드에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;메서드 재시작 영역 쓰기 작업이 완료 되 고 리소스를 적절 하 게 해제할 수 있도록 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.</source>
          <target state="translated">될 때까지 비동기 재시작 영역 쓰기 작업 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;메서드는 &lt;xref:System.IAsyncResult&gt;이 메서드에서 반환 된.&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">작업을 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a &lt;xref:System.IO.Log.ReservationCollection&gt; is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">경우는 &lt;xref:System.IO.Log.ReservationCollection&gt;을 지정 쓴된 재시작 영역은 이전에 예약 된, 컬렉션에 포함 된 예약을 사용 하 여 공간을 사용 합니다.&lt;/xref:System.IO.Log.ReservationCollection&gt;</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">메서드가 성공 하면 예약이 컬렉션에서 제거 됩니다 및 사용자 데이터를 포함 될 수 있는 가장 작은 예약을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt; method is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;메서드를 호출 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>Byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트입니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>The new base sequence number.</source>
          <target state="translated">새 기준 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 재시작 영역에 사용 해야 하는 예약이 포함 된입니다.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">재시작 영역 쓰기가 완료 되 면 호출 되는 선택적 비동기 콜백.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">다른 요청에서 특정 비동기 재시작 영역 쓰기 요청을 구별 하는 사용자 제공 개체입니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;보류 중인 수는 비동기 재시작 영역 쓰기 작업을 나타내는 중일 수 있습니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph>이 시퀀스에 대해 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>-or-       The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">-또는-지정 된 로그 열거형 시작 시퀀스 번호가 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservation&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservation&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>One or more of the parameters is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">매개 변수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">newBaseSeqNum</ph><ept id="p1">&lt;/code&gt;</ept> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">newBaseSeqNum</ph> <ept id="p1">&lt;/code&gt;</ept> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">시퀀스에서 이전에 예약 된 공간을 사용 하는 비동기 재시작 영역 쓰기 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt; method to ensure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">전달 해야는 &lt;xref:System.IAsyncResult&gt;에이 메서드에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;메서드 재시작 영역 쓰기 작업이 완료 되 고 리소스를 적절 하 게 해제할 수 있도록 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.</source>
          <target state="translated">될 때까지 비동기 재시작 영역 쓰기 작업 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;메서드는 &lt;xref:System.IAsyncResult&gt;이 메서드에서 반환 된.&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">작업을 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a &lt;xref:System.IO.Log.ReservationCollection&gt; is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">경우는 &lt;xref:System.IO.Log.ReservationCollection&gt;을 지정 쓴된 재시작 영역은 이전에 예약 된, 컬렉션에 포함 된 예약을 사용 하 여 공간을 사용 합니다.&lt;/xref:System.IO.Log.ReservationCollection&gt;</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">메서드가 성공 하면 예약이 컬렉션에서 제거 됩니다 및 사용자 데이터를 포함 될 수 있는 가장 작은 예약을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt; method is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;메서드를 호출 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The new base sequence number.</source>
          <target state="translated">새 기준 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 재시작 영역에 사용 해야 하는 예약이 포함 된입니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">재시작 영역 쓰기가 완료 되 면 호출 되는 선택적 비동기 콜백.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">다른 요청에서 특정 비동기 재시작 영역 쓰기 요청을 구별 하는 사용자 제공 개체입니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;보류 중인 수는 비동기 재시작 영역 쓰기 작업을 나타내는 중일 수 있습니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph>이 시퀀스에 대해 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>-or-       The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">-또는-지정 된 로그 열거형 시작 시퀀스 번호가 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservationCollection&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservationCollection&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>One or more of the parameters is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">매개 변수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">newBaseSeqNum</ph><ept id="p1">&lt;/code&gt;</ept> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">newBaseSeqNum</ph> <ept id="p1">&lt;/code&gt;</ept> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>Creates a new <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">새 <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>The newly created <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">새로 만든 <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>Releases the resources used by the component.</source>
          <target state="translated">구성 요소에서 사용 하는 리소스를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>Ends an asynchronous append operation.</source>
          <target state="translated">비동기 종료 작업을 추가합니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">이 메서드는 I/O 작업이 완료 될 때까지 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.</source>
          <target state="translated">비동기 쓰기 요청 I/O 요청 중의 디스크 오류와 같은 중 발생 하는 오류 EndAppend를 호출할 때 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.LogRecordSequence.BeginAppend%2A&gt; method.</source>
          <target state="translated">이 메서드를 정확히 한 번만 호출 해야 모든 &lt;xref:System.IAsyncResult&gt;에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.BeginAppend%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.BeginAppend%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">처리 중인 비동기 I/O 요청에 대 한 참조입니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">추가 된 로그 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph>잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_End " name="End " href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>has already been called for this asynchronous operation.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_End " name="End " href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>가 이미 호출 되었습니다이 비동기 작업에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>Ends an asynchronous flush operation.</source>
          <target state="translated">비동기 플러시 작업을 끝냅니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">이 메서드는 I/O 작업이 완료 될 때까지 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류와 같은 비동기 플러시 요청 중에 발생 하는 오류 EndFlush를 호출할 때 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.LogRecordSequence.BeginFlush%2A&gt; method.</source>
          <target state="translated">이 메서드를 정확히 한 번만 호출 해야 모든 &lt;xref:System.IAsyncResult&gt;에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.BeginFlush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.BeginFlush%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">처리 중인 비동기 I/O 요청에 대 한 참조입니다.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The sequence number of the last record written.</source>
          <target state="translated">마지막으로 쓴 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph>잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_End" name="End" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> has already been called for this asynchronous operation.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_End" name="End" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>가 이미 호출 되었습니다이 비동기 작업에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>Ends an asynchronous reserve and append operation.</source>
          <target state="translated">끝 비동기 예약 및 추가 작업 합니다.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">이 메서드는 I/O 작업이 완료 될 때까지 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.</source>
          <target state="translated">비동기 쓰기 요청 I/O 요청 중의 디스크 오류와 같은 중 발생 하는 오류 EndReserveAndAppend를 호출할 때 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A&gt; method.</source>
          <target state="translated">이 메서드를 정확히 한 번만 호출 해야 모든 &lt;xref:System.IAsyncResult&gt;에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">처리 중인 비동기 I/O 요청에 대 한 참조입니다.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">추가 된 로그 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph>잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_End" name="End" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> has already been called for this asynchronous operation.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_End" name="End" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>가 이미 호출 되었습니다이 비동기 작업에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>Ends an asynchronous restart area write operation.</source>
          <target state="translated">비동기 재시작 영역 쓰기 작업을 종료합니다.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">이 메서드는 I/O 작업이 완료 될 때까지 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.</source>
          <target state="translated">비동기 쓰기 요청 I/O 요청 중의 디스크 오류와 같은 중 발생 하는 오류 EndWriteRestartArea를 호출할 때 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A&gt; method.</source>
          <target state="translated">이 메서드를 정확히 한 번만 호출 해야 모든 &lt;xref:System.IAsyncResult&gt;에서 반환 되는 &lt;xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">처리 중인 비동기 I/O 요청에 대 한 참조입니다.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>The sequence number of the written log record.</source>
          <target state="translated">쓴된 로그 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph>잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_End" name="End" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> has already been called for this asynchronous operation.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_End" name="End" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>가 이미 호출 되었습니다이 비동기 작업에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Ensures that all appended records have been written.</source>
          <target state="translated">추가 된 모든 레코드가 썼는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method ensures that all records that have been appended to the &lt;xref:System.IO.Log.LogRecordSequence&gt; have been durably written.</source>
          <target state="translated">이 메서드를 호출 하면 모든 레코드가 있는에 추가 된는 &lt;xref:System.IO.Log.LogRecordSequence&gt;영속적으로 씁니다.&lt;/xref:System.IO.Log.LogRecordSequence&gt;</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>The sequence number of the last record written.</source>
          <target state="translated">마지막으로 쓴 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>An I/O error occurred while flushing the data.</source>
          <target state="translated">데이터를 플러시하는 동안 I/O 오류가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>This operation is not supported.</source>
          <target state="translated">이 작업이 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The specified log does not have any extents.</source>
          <target state="translated">지정된 된 로그에는 범위가 없습니다.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">레코드 시퀀스를 사용 하려면 먼저 하나 이상의 범위를 만들어야 합니다.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>Ensures that all appended records up to and including the record with the specified sequence number have been durably written.</source>
          <target state="translated">추가 된 모든 레코드 및 지정 된 시퀀스 번호와 레코드까지 영속적으로 기록 되었음을 확인 합니다.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</source>
          <target state="translated">이 메서드를 사용 하면 시퀀스 번호를 모든 레코드가 최대 호출 하 고 지정 된 시퀀스 번호를 포함 하 여 영속적 기록 합니다.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">써야 하는 최신 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>If this <bpt id="p1">&lt;xref href="System.IO.Log.SequenceNumber"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is invalid, then all records must be written.</source>
          <target state="translated">이 경우 <bpt id="p1">&lt;xref href="System.IO.Log.SequenceNumber"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 유효 하지 않을 경우 모든 레코드를 써야 합니다.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>The sequence number of the last record written.</source>
          <target state="translated">마지막으로 쓴 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph>이 시퀀스에 대해 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph>이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이의 않습니다.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>The specified log does not have any extents.</source>
          <target state="translated">지정된 된 로그에는 범위가 없습니다.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">레코드 시퀀스를 사용 하려면 먼저 하나 이상의 범위를 만들어야 합니다.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>Gets the sequence number which is greater than the last record appended</source>
          <target state="translated">시퀀스 번호를 가져옵니다 마지막으로 추가 된 레코드 보다 큰</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</source>
          <target state="translated">이 속성은 반드시 큰 시퀀스 번호를 포함 추가 된 레코드의 마지막 시퀀스 번호 보다 합니다.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Valid sequence numbers are greater than or equal to &lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt; and less than LastSequenceNumber.</source>
          <target state="translated">유효한 시퀀스 번호 보다 크거나 같은 경우는 &lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;같고 LastSequenceNumber 보다.&lt;/xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>All other sequence numbers are invalid.</source>
          <target state="translated">다른 모든 시퀀스 번호가 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>A sequence number which is greater than the last record appended.</source>
          <target state="translated">마지막으로 추가 된 레코드 보다 큰 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 속성에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>Gets the <bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the data for this record sequence.</source>
          <target state="translated">가져옵니다는 <bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 레코드 시퀀스에 대 한 데이터를 포함 하 합니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the data for this record sequence.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.IO.Log.LogStore"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 레코드 시퀀스에 대 한 데이터를 포함 하 합니다.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>Gets the maximum size of a record that can be added to this record sequence.</source>
          <target state="translated">이 레코드 시퀀스에 추가할 수 있는 레코드의 최대 크기를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>The maximum size of a record that can be added to this record sequence.</source>
          <target state="translated">이 레코드 시퀀스에 추가할 수 있는 레코드의 최대 크기입니다.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>Returns an enumerable collection of records in the sequence.</source>
          <target state="translated">시퀀스에 레코드의 열거 가능 컬렉션을 반환합니다.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns an enumerable collection of records in the sequence.</source>
          <target state="translated">이 메서드는 시퀀스에 레코드의 열거 가능 컬렉션을 반환합니다.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order of the enumerated records depends on the value of the <ph id="ph1">`logRecordEnum`</ph> parameter.</source>
          <target state="translated">값에 따라 열거 되는 레코드의 순서는 <ph id="ph1">`logRecordEnum`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>The sequence number of the first record where the reading starts.</source>
          <target state="translated">읽기가 시작 되는 첫 번째 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>A valid <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordEnumeratorType"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value that specifies the manner (that is, forward or backward) in which records should be read from a <bpt id="p2">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">유효한 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordEnumeratorType"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 에서 레코드를 읽는에 (즉, 앞으로 또는 뒤로) 하는 방식을 지정 하는 값을 <bpt id="p2">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>An enumerable collection of records in the sequence.</source>
          <target state="translated">시퀀스에 있는 레코드의 열거 가능한 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>이 시퀀스에 대해 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;logRecordEnum&lt;/code&gt;</ph> is invalid.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;logRecordEnum&lt;/code&gt;</ph> 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>-or-       The specified element was not found in the collection.</source>
          <target state="translated">-또는-지정된 된 요소가 컬렉션에 없습니다.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이의 않습니다.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>-or       The buffer size used to write the log record is larger than the buffer size being used to read it.</source>
          <target state="translated">-또는 읽기에 사용 되 고 버퍼 크기 보다 큰 로그 레코드를 쓰는 데 사용 되는 버퍼 크기입니다.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>-or-       The record sequence is corrupted.</source>
          <target state="translated">-또는-레코드 시퀀스가 손상 되었습니다.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>-or-       The specified log file format or version is invalid.</source>
          <target state="translated">-또는-지정 된 로그 파일 형식이 나 버전이 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>-or-       The record was written with an incompatible version of the record sequence.</source>
          <target state="translated">-또는-호환 되지 않는 버전 레코드 시퀀스의 레코드를 작성 했습니다.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>The operation is invalid because the enumeration has not been started.</source>
          <target state="translated">열거가 시작 되지 않은 작업이 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>A call to &lt;xref:System.Collections.IEnumerator.MoveNext*&gt; must be made.</source>
          <target state="translated">에 대 한 호출 &lt;xref:System.Collections.IEnumerator.MoveNext*&gt;수 있어야 합니다.&lt;/xref:System.Collections.IEnumerator.MoveNext*&gt;</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>Returns an enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">시퀀스에 있는 재시작 영역의 열거 가능한 컬렉션을 반환합니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</source>
          <target state="translated">재시작 영역의 가장 낮은 시퀀스 번호를 시퀀스 번호가 가장 높은에서 즉, 역방향 시퀀스 번호 순서에 열거 됩니다.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</source>
          <target state="translated">마지막 시퀀스 번호 사이의 시퀀스 번호를 가진 재시작 영역만 기준 시퀀스 번호를 열거 합니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>An enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">시퀀스에 있는 재시작 영역의 열거 가능한 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이의 않습니다.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>-or       The buffer size used to write the log record is larger than the buffer size being used to read it.</source>
          <target state="translated">-또는 읽기에 사용 되 고 버퍼 크기 보다 큰 로그 레코드를 쓰는 데 사용 되는 버퍼 크기입니다.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>-or-       The record sequence is corrupted.</source>
          <target state="translated">-또는-레코드 시퀀스가 손상 되었습니다.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>-or-       The specified log file format or version is invalid.</source>
          <target state="translated">-또는-지정 된 로그 파일 형식이 나 버전이 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>-or-       The record was written with an incompatible version of the record sequence.</source>
          <target state="translated">-또는-호환 되지 않는 버전 레코드 시퀀스의 레코드를 작성 했습니다.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The operation is invalid because the enumeration has not been started.</source>
          <target state="translated">열거가 시작 되지 않은 작업이 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>A call to &lt;xref:System.Collections.IEnumerator.MoveNext*&gt; must be made.</source>
          <target state="translated">에 대 한 호출 &lt;xref:System.Collections.IEnumerator.MoveNext*&gt;수 있어야 합니다.&lt;/xref:System.Collections.IEnumerator.MoveNext*&gt;</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>-or       The enumeration has ended.</source>
          <target state="translated">-열거형이 끝난 경우 또는 합니다.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">자동으로 단일 예약을 만들고 시퀀스에 레코드를 추가 합니다.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">추가 된 지정 된 예약은 레코드와 원자 단위 연산에서 컬렉션 추가 작업에 제공된 된 예약 합니다.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">추가 실패, 없음 공간이 예약 됩니다.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the collection to make reservations in.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 예약을 만들 컬렉션이 포함 된 합니다.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">바이트 단위로 만들 예약 합니다.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">추가 된 로그 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;nextUndoRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;nextUndoRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이이 시퀀스에 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservations&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;nextUndoRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;nextUndoRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>No reservation large enough to fit <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">data</ph><ept id="p1">&lt;/code&gt;</ept> can be found in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">reservations</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
          <target state="translated">에 맞게 충분히 큰 예약이 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">data</ph> <ept id="p1">&lt;/code&gt;</ept> 있습니다 <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">reservations</ph> <ept id="p2">&lt;/code&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">자동으로 단일 예약을 만들고 시퀀스에 레코드를 추가 합니다.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">에 포함 된 데이터는 <ph id="ph1">`data`</ph> 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">추가 된 지정 된 예약은 레코드와 원자 단위 연산에서 컬렉션 추가 작업에 제공된 된 예약 합니다.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">추가 실패, 없음 공간이 예약 됩니다.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">일반적으로이 메서드는 레코드를 쓰기 전에 완료 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id="ph1">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; method.</source>
          <target state="translated">지정 하거나 기록 된 하려면는 &lt;xref:System.IO.Log.RecordAppendOptions&gt;플래그를 사용 하는 <ph id="ph1">`recordAppendOptions`</ph> 매개 변수 또는 호출의 &lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.Flush%2A&gt; &lt;/xref:System.IO.Log.RecordAppendOptions&gt;</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>A valid value of <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that specifies how the data should be written.</source>
          <target state="translated">유효한 값 <bpt id="p1">&lt;xref href="System.IO.Log.RecordAppendOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 작성 하는 방법을 지정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">예약을 만들 예약 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">바이트 단위로 만들 예약 합니다.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">추가 된 로그 레코드의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">인수 중 하나 이상이 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">레코드를 추가 하는 동안 I/O 오류가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">레코드 시퀀스에서 새 레코드를 포함 하거나 예약을 변경 하려면 충분 한 여유 공간을 만들지 못했습니다.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;userRecord&lt;/code&gt;</ph>또는 <ph id="ph2">&lt;code&gt;previousRecord&lt;/code&gt;</ph> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>No reservation large enough to fit <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">data</ph><ept id="p1">&lt;/code&gt;</ept> can be found in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">reservations</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
          <target state="translated">에 맞게 충분히 큰 예약이 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">data</ph> <ept id="p1">&lt;/code&gt;</ept> 있습니다 <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">reservations</ph> <ept id="p2">&lt;/code&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>Gets the total number of bytes that have been reserved.</source>
          <target state="translated">예약 된 바이트의 총 수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>The total size of all reservations made in this record sequence.</source>
          <target state="translated">이 레코드 시퀀스에서 만들어진 모든 예약의 총 크기입니다.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 속성에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>Gets the sequence number of the restart area closest to the end of the log.</source>
          <target state="translated">로그의 끝과 가장 가까운 재시작 영역의 시퀀스 번호를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using the &lt;xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A&gt; method, you can remove the most recently written restart area.</source>
          <target state="translated">사용 하는 &lt;xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A&gt;제거할 수, 가장 최근에 기록 된 재시작 영역의.&lt;/xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A&gt;</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The sequence number of the restart area closest to the end of the log.</source>
          <target state="translated">로그의 끝과 가장 가까운 재시작 영역의 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 속성에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</source>
          <target state="translated">나타내는 값을 가져오거나 여부 추가 로그가 꽉 찼을 경우 자동으로 다시 시도 합니다.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value of this property is <ph id="ph1">`true`</ph>, and an &lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt; call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</source>
          <target state="translated">이 속성의 값이 <ph id="ph1">`true`</ph>, 및 &lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;시퀀스에 충분 한 공간이 없기 때문에 호출이 실패 하면, 레코드 시퀀스에서 공간을 확보 하 고 추가 다시 시도 하려고 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if appends are automatically retried if the log is full; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>하는 경우 추가 로그가 꽉 경우 자동으로 다시 시도 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">기본값은 <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 속성에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>Sets the last record in the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">마지막 레코드에 설정 된 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>The specified sequence number must be larger than the base sequence number.</source>
          <target state="translated">지정 된 시퀀스 번호는 기준 시퀀스 번호 보다 커야 합니다.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible.</source>
          <target state="translated">이 메서드가 완료 되 면 이전에 추가한 지정 된 시퀀스 번호 보다 큰 시퀀스 번호를 가진 모든 레코드는 액세스할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The new last sequence number in the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 마지막 신규 시퀀스 번호는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>This should refer to a current valid record   currently in the log.</source>
          <target state="translated">이 로그에 현재 유효한 현재 레코드를 참조 해야 합니다.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph>이 시퀀스에 대해 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sequenceNumber</ph><ept id="p1">&lt;/code&gt;</ept> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">sequenceNumber</ph> <ept id="p1">&lt;/code&gt;</ept> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>-or-       The end of the log has been reached.</source>
          <target state="translated">-또는-로그의 끝에 도달 했습니다.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>-or-       The specified log file format or version is invalid.</source>
          <target state="translated">-또는-지정 된 로그 파일 형식이 나 버전이 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>Signals the need to move the tail of the sequence.</source>
          <target state="translated">시퀀스의 테일을 이동 해야 함을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can fire this event when the record sequence has run out of space.</source>
          <target state="translated">레코드 시퀀스에 공간이 부족이 이벤트를 발생 시킬 수 있습니다.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</source>
          <target state="translated">이 이벤트는 발생 하는 경우 (즉, 기준 시퀀스 번호) 시퀀스의 테일이 공간을 확보 하 앞으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>The event can be fired at any time when the record sequence decides that it must free up space, for any reason.</source>
          <target state="translated">이 이벤트는 언제 든 지 어떤 이유로 든 공간을 확보 해야 하는 레코드 시퀀스를 결정 하는 경우 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart.</source>
          <target state="translated">예를 들어, CLFS 정책 엔진은 같은 로그 파일을 공유 하는 두 로그 클라이언트의 테일은 너무 멀리 떨어져 있는지를 결정 하는 경우 이벤트를 발생 시키는 결정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source>Freeing space can be done by either writing restart areas, or truncating the log and using the &lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt; method to clear space.</source>
          <target state="translated">공간을 확보 하거나 여 수행할 수 있습니다 재시작 영역을 쓰거나 또는 로그 잘라내기 및 사용 하는 &lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;메서드 공간을 확보 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code sample in the Example section demonstrates the second approach.</source>
          <target state="translated">"예" 섹션의 코드 예제에는 두 번째 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also call the &lt;xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt; method outside of the TailPinned event to free space.</source>
          <target state="translated">호출할 수도 있습니다는 &lt;xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt;공간을 확보 하려면 TailPinned 이벤트 외부에서 메서드가.&lt;/xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt;</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area is similar to a checkpoint in other log processing systems.</source>
          <target state="translated">재시작 영역은 다른 로그 처리 시스템의에서 검사점과 비슷합니다.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends.</source>
          <target state="translated">응용 프로그램에 완벽 하 게 완료 재시작 영역 전의 모든 이전 레코드가 것으로 간주 하 고 이후 레코드에 대 한 사용 가능한 추가 나타냅니다이 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similar to any other records, the record written by this method requires actual free space in the log to function.</source>
          <target state="translated">다른 레코드와 마찬가지로,이 메서드가 기록한 레코드가 작동 하려면 로그에 실제 빈 공간이 필요 합니다.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">추가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>Writes a restart area to the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">재시작 영역을 씁니다는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area can be read using the &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt; method.</source>
          <target state="translated">사용 하 여 재시작 영역을 읽을 수는 &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>An array segment that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 배열 세그먼트입니다.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">쓴의 시퀀스 번호 영역 다시 시작합니다.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">인수 중 하나 이상이 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Writes a restart area to the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">재시작 영역을 씁니다는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area can be read using the &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt; method.</source>
          <target state="translated">사용 하 여 재시작 영역을 읽을 수는 &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">쓴의 시퀀스 번호 영역 다시 시작합니다.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">인수 중 하나 이상이 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>One or more of the arguments are <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">인수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>Writes a restart area to the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and updates the base sequence number.</source>
          <target state="translated">재시작 영역을 씁니다는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기준 시퀀스 번호를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area can be read using the &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt; method.</source>
          <target state="translated">사용 하 여 재시작 영역을 읽을 수는 &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">재시작 영역은 기록 되 면 바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">이 메서드가 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드를 호출 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>The new base sequence number.</source>
          <target state="translated">새 기준 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">쓴의 시퀀스 번호 영역 다시 시작합니다.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">인수 중 하나 이상이 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>Writes a restart area to the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and updates the base sequence number.</source>
          <target state="translated">재시작 영역을 씁니다는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기준 시퀀스 번호를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area can be read using the &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt; method.</source>
          <target state="translated">사용 하 여 재시작 영역을 읽을 수는 &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">재시작 영역은 기록 되 면 바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">이 메서드가 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드를 호출 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>The new base sequence number.</source>
          <target state="translated">새 기준 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">쓴의 시퀀스 번호 영역 다시 시작합니다.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">인수 중 하나 이상이 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>Writes a restart area to the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using a reservation, and updates the base sequence number.</source>
          <target state="translated">재시작 영역을 씁니다는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 예약을 사용 하 고 기준 시퀀스 번호를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area can be read using the &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt; method.</source>
          <target state="translated">사용 하 여 재시작 영역을 읽을 수는 &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">재시작 영역은 기록 되 면 바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">예약을 지정 하는 경우 쓴된 재시작 영역은 공간 이전에 예약 된, 컬렉션에 포함 된 예약을 사용 하 여을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">메서드가 성공 하면 예약이 컬렉션에서 제거 됩니다 및 사용자 데이터를 포함할 수 있는 가장 작은 예약을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">이 메서드가 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드를 호출 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>The new base sequence number.</source>
          <target state="translated">새 기준 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 재시작 영역에 사용 해야 하는 예약이 포함 된입니다.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">쓴의 시퀀스 번호 영역 다시 시작합니다.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">인수 중 하나 이상이 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Writes a restart area to the <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using a reservation, and updates the base sequence number.</source>
          <target state="translated">재시작 영역을 씁니다는 <bpt id="p1">&lt;xref href="System.IO.Log.LogRecordSequence"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 예약을 사용 하 고 기준 시퀀스 번호를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>This method cannot be inherited.</source>
          <target state="translated">이 메서드는 상속 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>A restart area can be read using the &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt; method.</source>
          <target state="translated">사용 하 여 재시작 영역을 읽을 수는 &lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;메서드.&lt;/xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">재시작 영역은 기록 되 면 바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">예약을 지정 하는 경우 쓴된 재시작 영역은 공간 이전에 예약 된, 컬렉션에 포함 된 예약을 사용 하 여을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">메서드가 성공 하면 예약이 컬렉션에서 제거 됩니다 및 사용자 데이터를 포함할 수 있는 가장 작은 예약을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">이 메서드가 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt; method is called.</source>
          <target state="translated">I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 &lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;메서드를 호출 합니다.&lt;/xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>The new base sequence number.</source>
          <target state="translated">새 기준 시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.IO.Log.ReservationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 재시작 영역에 사용 해야 하는 예약이 포함 된입니다.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">쓴의 시퀀스 번호 영역 다시 시작합니다.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph>이 시퀀스에 대해 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>-or-       The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">-또는-지정 된 로그 열거형 시작 시퀀스 번호가 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;data&lt;/code&gt;</ph> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;reservationCollection&lt;/code&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">-또는- <ph id="ph1">&lt;code&gt;reservationCollection&lt;/code&gt;</ph> 이 레코드 시퀀스에서 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>One or more of the parameters is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">매개 변수 중 하나 이상이 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>-or-       <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">newBaseSeqNum</ph><ept id="p1">&lt;/code&gt;</ept> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">-또는- <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">newBaseSeqNum</ph> <ept id="p1">&lt;/code&gt;</ept> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>-or-       The request could not be performed because of an I/O device error.</source>
          <target state="translated">-또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">시퀀스의 삭제 된 후 메서드가 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>The record sequence is full.</source>
          <target state="translated">레코드 시퀀스가 꽉 찼습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>