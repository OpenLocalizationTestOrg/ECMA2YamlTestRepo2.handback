<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa8d9be9bd8a6e579a04c9a6e75191b7d59e2792</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.PropertyMetadata.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e549028ed296d03d13f33fd463370a904a5b4b8a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb79b96cb966a9c981d9c339abc43bdee740d9d8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</source>
          <target state="translated">Определяет некоторые аспекты поведения свойства зависимостей применительно к определенному типу, включая условия, которые она была зарегистрирована.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property metadata can be defined and used during dependency property registration when calling the &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; method.</source>
          <target state="translated">Метаданные свойства могут быть определены и используется во время регистрации свойства зависимостей, при вызове &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;метод (или вариантов для присоединенных свойств или свойств зависимостей только для чтения) или после исходной регистрации владельца при вызове &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;метода.&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; also takes property metadata.</source>
          <target state="translated">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;Кроме того, принимает метаданные свойства.&lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>This class is a concrete base class that can be used in each of these calls.</source>
          <target state="translated">Этот класс является конкретного базового класса, который может использоваться в каждом из этих вызовов.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is very common to specify metadata using one of the derived classes such as &lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.</source>
          <target state="translated">Однако это очень часто, чтобы указать метаданные с помощью одного из производных классов, таких как &lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.&lt;/xref:System.Windows.FrameworkPropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> framework level.</source>
          <target state="translated">Эти производные классы поддерживают более подробные метаданные, передающиеся как логические значения свойств, которые полезны для определения или некоторые свойства системы и макет поведения, реализованных в <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> уровня структуры.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; or &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.</source>
          <target state="translated">Некоторые свойства этого класса, чтения и записи к объектной модели, но также могут быть записаны только до экземпляра, используемых в операции системы свойств, например &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;или &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each of these properties could also have been set by the constructor but are exposed so that &lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt; method implementations can set them.</source>
          <target state="translated">Каждое из этих свойств может также быть заданы с помощью конструктора, а предоставляются, чтобы &lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;реализации методов можно задать их.&lt;/xref:System.Windows.PropertyMetadata.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    This type, and members of this type, are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## Использование текста XAML этого типа и членов этого типа обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">Инициализирует новый экземпляр <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> класса.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified default value for the dependency property that this metadata will be applied to.</source>
          <target state="translated">Инициализирует новый экземпляр <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> класса указанное значение по умолчанию для свойства зависимостей, применяются эти метаданные.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должен соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции (несовпадение вызовет исключение во время выполнения).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">Несмотря на то, что он подразумевается по умолчанию на конструктор без параметров, <ph id="ph1">`defaultValue`</ph> из &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;не может быть указан.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Попытка выполнить такую операцию вызовет исключение.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The default value to specify for a dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">Значение по умолчанию, чтобы задать для свойства зависимостей, обычно предоставляется в качестве значения определенного типа.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>не может быть присвоено значение <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; см. заметки.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">Инициализирует новый экземпляр <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> класса с заданным <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> Справочник по реализации.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который должен вызываться в системе свойств при каждом изменении значения свойства.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">Инициализирует новый экземпляр <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> класса, используя значение заданного по умолчанию и <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> Справочник по реализации.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного <ph id="ph1">`defaultValue`</ph> должен соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции (несовпадение вызовет исключение во время выполнения).</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">Несмотря на то, что он подразумевается по умолчанию на конструктор без параметров, <ph id="ph1">`defaultValue`</ph> из &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;не может быть указан.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Попытка выполнить такую операцию вызовет исключение.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">Значение по умолчанию свойства зависимостей, обычно как значение определенного типа.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который должен вызываться в системе свойств при каждом изменении значения свойства.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>не может быть присвоено значение <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; см. заметки.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and callbacks.</source>
          <target state="translated">Инициализирует новый экземпляр <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> с указанным значением по умолчанию и обратные вызовы.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a &lt;xref:System.Windows.CoerceValueCallback&gt; but not a &lt;xref:System.Windows.PropertyChangedCallback&gt;, you can pass <ph id="ph1">`null`</ph> for the <ph id="ph2">`propertyChangedCallback`</ph> parameter.</source>
          <target state="translated">Если вы хотите указать &lt;xref:System.Windows.CoerceValueCallback&gt;, но не &lt;xref:System.Windows.PropertyChangedCallback&gt;, можно передать <ph id="ph1">`null`</ph> для <ph id="ph2">`propertyChangedCallback`</ph> параметр.&lt;/xref:System.Windows.PropertyChangedCallback&gt; &lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должен соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции (несовпадение вызовет исключение во время выполнения).</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">Несмотря на то, что он подразумевается по умолчанию на конструктор без параметров, <ph id="ph1">`defaultValue`</ph> из &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;не может быть указан.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Попытка выполнить такую операцию вызовет исключение.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">Значение по умолчанию свойства зависимостей, обычно как значение определенного типа.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который должен вызываться в системе свойств при каждом изменении значения свойства.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called whenever the property system calls &lt;xref:System.Windows.DependencyObject.CoerceValue*&gt; against this property.</source>
          <target state="translated">Ссылка на реализацию обработчика, который должен вызываться всякий раз, когда в системе свойств вызывает &lt;xref:System.Windows.DependencyObject.CoerceValue*&gt;для этого свойства.&lt;/xref:System.Windows.DependencyObject.CoerceValue*&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>не может быть присвоено значение <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; см. заметки.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">Возвращает или задает ссылку на <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> реализацию, заданную в метаданных.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">Ответы свойства метаданных не являются обычно открытых членов в содержащем типе, поэтому значение этого свойства не является важным для большинства сценариев, которые просто поглощают метаданные существующего свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.CoerceValueCallback&gt;.</source>
          <target state="translated">Является одной из причин этого свойства предоставляется, чтобы подклассы метаданных могут осуществлять необходимую логику совмещения, если основные метаданные и переопределение Добавление метаданных укажите &lt;xref:System.Windows.CoerceValueCallback&gt;.&lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the default merge logic for a CoerceValueCallback is to replace the previous one.</source>
          <target state="translated">Тем не менее логика CoerceValueCallback слияния по умолчанию — замена предыдущего.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>CoerceValueCallback is defined in the object model as read-write.</source>
          <target state="translated">CoerceValueCallback определяется в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so CoerceValueCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">Это можно изменить после инициализации CoerceValueCallback &lt;xref:System.Windows.PropertyMetadata&gt;сам объект.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Тем не менее когда метаданные используются как часть вызова &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, или &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, в системе свойств будет запечатать этот экземпляр метаданных и свойств теперь считаются неизменяемыми.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set CoerceValueCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать один раз CoerceValueCallback &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;— <ph id="ph1">`true`</ph> на эти метаданные экземпляра вызовет исключение.&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">Объект <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> Справочник по реализации.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Невозможно задать свойство метаданных после применения операции свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Gets or sets the default value of the dependency property.</source>
          <target state="translated">Возвращает или задает значение по умолчанию свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>DefaultValue is defined in the object model as read-write.</source>
          <target state="translated">Значение по умолчанию определяется в объектной модели как чтения и записи.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so DefaultValue can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">Это значение по умолчанию можно изменить после инициализации &lt;xref:System.Windows.PropertyMetadata&gt;сам объект.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Тем не менее когда метаданные используются как часть вызова &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, или &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, в системе свойств будет запечатать этот экземпляр метаданных и свойств теперь считаются неизменяемыми.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set DefaultValue once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать значение по умолчанию один раз &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;— <ph id="ph1">`true`</ph> на эти метаданные экземпляра вызовет исключение.&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be set using either DefaultValue or the constructor.</source>
          <target state="translated">Несмотря на то, что он подразумевается по умолчанию на конструктор без параметров, <ph id="ph1">`defaultValue`</ph> из &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;Невозможно задать DefaultValue или конструктора.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Попытка выполнить такую операцию вызовет исключение.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    Members of this type are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## XAML текст использования члены этого типа обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The default value of the property.</source>
          <target state="translated">Значение по умолчанию свойства.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The default value on a <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance created with the parameterless constructor will be <bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated">Значение по умолчанию <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> экземпляр, созданный с помощью конструктора без параметров будет <bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>; см. заметки.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> once created; see Remarks.</source>
          <target state="translated">Не может быть присвоено значение <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> при создании; см. заметки.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Невозможно задать свойство метаданных после применения операции свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</source>
          <target state="translated">Возвращает значение, определяющее, была ли применена метаданных свойству определенным образом, что приводит к запрету этого экземпляра метаданных.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Various properties of &lt;xref:System.Windows.PropertyMetadata&gt;, such as &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;, are defined in the object model as read-write.</source>
          <target state="translated">Различные свойства &lt;xref:System.Windows.PropertyMetadata&gt;, такие как &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;, определенные в объектной модели для чтения записи.&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; &lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so those properties can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">Поэтому эти свойства можно изменить после инициализации &lt;xref:System.Windows.PropertyMetadata&gt;сам объект.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is applied to a dependency property as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Тем не менее после применения метаданные свойства зависимостей в рамках вызова &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, или &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, в системе свойств будет запечатать этот экземпляр метаданных и свойств теперь считаются неизменяемыми.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>At the time of one of these calls, &lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt; is called, and the value of this property is set to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Во время этих вызовов &lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;вызывается, и значение этого свойства равно <ph id="ph1">`true`</ph>.&lt;/xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the metadata instance is immutable; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Если экземпляр метаданных является неизменяемым; в противном случае <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Merges this metadata with the base metadata.</source>
          <target state="translated">Объединяет эти метаданные с основными.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used internally when metadata is being overridden (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; method).</source>
          <target state="translated">Этот метод используется внутренне при переопределении метаданных (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; метода).&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The base metadata to merge with this instance's values.</source>
          <target state="translated">Базовые метаданные для слияния со значениями данного экземпляра.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The dependency property to which this metadata is being applied.</source>
          <target state="translated">Свойство зависимостей, к которому применяются эти метаданные.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">Вызывается, когда применены эти метаданные свойства, которое указывает, что метаданные запечатываются.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subclasses should assure that any mutability of the data structure of a &lt;xref:System.Windows.PropertyMetadata&gt; subclass should be marked as immutable once OnApply is called.</source>
          <target state="translated">Подклассы должны убедиться, что все изменения структуры данных &lt;xref:System.Windows.PropertyMetadata&gt;подкласс должен быть помечен как неизменяемое после вызова OnApply.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</source>
          <target state="translated">Вызывается после применения метаданных операции системы свойств (регистрация, добавление владельца, переопределения метаданных).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">Свойство зависимостей, к которому был применен метаданных.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">Тип, связанный с этими метаданными, если это метаданные определенного типа.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If this is default metadata, this value is a null reference.</source>
          <target state="translated">Если это метаданные по умолчанию, это значение является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">Возвращает или задает ссылку на <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> реализацию, заданную в метаданных.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">Обратные вызовы свойства метаданных не обычно открытых членов, определяющего типа, поэтому значение этого свойства не является важным для большинства сценариев, которые просто поглощают метаданные существующего свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.PropertyChangedCallback&gt;.</source>
          <target state="translated">Является одной из причин этого свойства предоставляется, чтобы классы метаданных могут осуществлять необходимую логику совмещения, если основные метаданные и переопределение Добавление метаданных укажите &lt;xref:System.Windows.PropertyChangedCallback&gt;.&lt;/xref:System.Windows.PropertyChangedCallback&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default merge logic for is to maintain all PropertyChangedCallback implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</source>
          <target state="translated">Логики слияния по умолчанию для является поддерживать все реализации PropertyChangedCallback в таблице и вызов каждой из них, с глубокой классом в иерархии, запуск первого установления обратных вызовов.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>PropertyChangedCallback is defined in the object model as read-write.</source>
          <target state="translated">PropertyChangedCallback определяется в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so PropertyChangedCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">Это можно изменить после инициализации PropertyChangedCallback &lt;xref:System.Windows.PropertyMetadata&gt;сам объект.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Тем не менее когда метаданные используются как часть вызова &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, или &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, в системе свойств будет запечатать этот экземпляр метаданных и свойств теперь считаются неизменяемыми.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set PropertyChangedCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать один раз PropertyChangedCallback &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;— <ph id="ph1">`true`</ph> на эти метаданные экземпляра вызовет исключение.&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">Объект <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> Справочник по реализации.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Невозможно задать свойство метаданных после применения операции свойства зависимостей.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>