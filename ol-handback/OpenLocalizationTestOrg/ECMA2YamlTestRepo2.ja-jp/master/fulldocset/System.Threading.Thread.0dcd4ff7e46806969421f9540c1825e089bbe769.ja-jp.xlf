<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e5df80f20fb8f8e9d58d7fd51e841a9b301b1bb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.Thread.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">653da93a9d042822697ec36cc7faef683efdc45f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d53c4cef63a323cfe675bb4658023858adff4b10</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">作成およびスレッドを制御、その優先順位を設定、その状態を取得します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">プロセスの開始時に、共通言語ランタイムは自動的にアプリケーション コードを実行する&amp;1; つのフォア グラウンド スレッドを作成します。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">このメインのフォア グラウンド スレッドとプロセスは、プロセスに関連付けられているプログラム コードの一部を実行する&amp;1; つまたは複数のスレッドを作成できます。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">これらのスレッドをフォア グラウンドまたはバック グラウンドで実行できます。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In addition, you can use the &lt;xref:System.Threading.ThreadPool&gt; class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">さらに、使用することができます、&lt;xref:System.Threading.ThreadPool&gt;共通言語ランタイムによって管理されるワーカー スレッドでコードを実行するクラス&lt;/xref:System.Threading.ThreadPool&gt;。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In this section       <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept>     <bpt id="p2">[</bpt>Retrieving Thread objects<ept id="p2">](#Retrieving)</ept>     <bpt id="p3">[</bpt>Foreground and background threads<ept id="p3">](#Foreground)</ept>     <bpt id="p4">[</bpt>Culture and threads<ept id="p4">](#Culture)</ept>     <bpt id="p5">[</bpt>Getting information about and controlling threads<ept id="p5">](#Properties)</ept>     <bpt id="p6">[</bpt>Accessing the source code for the Thread class<ept id="p6">](#Source)</ept>      <bpt id="p7">&lt;a name="Starting"&gt;</bpt><ept id="p7">&lt;/a&gt;</ept>    ## Starting a thread    You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">このセクションで<bpt id="p1">[</bpt>スレッドを開始<ept id="p1">](#Starting)</ept><bpt id="p2">[</bpt>を取得するスレッド オブジェクト<ept id="p2">](#Retrieving)</ept><bpt id="p3">[</bpt>フォア グラウンドとバック グラウンド スレッド<ept id="p3">](#Foreground)</ept><bpt id="p4">[</bpt>カルチャとスレッド<ept id="p4">](#Culture)</ept><bpt id="p5">[</bpt>と制御についてのスレッドの情報を取得する<ept id="p5">](#Properties)</ept><bpt id="p6">[</bpt>スレッド クラスのソース コードへのアクセス<ept id="p6">](#Source)</ept><bpt id="p7">&lt;a name="Starting"&gt;</bpt> <ept id="p7">&lt;/a&gt;</ept> ## スレッドは、そのクラス コンス トラクターで実行するメソッドを表すデリゲートを指定することによって、スレッドを開始するスレッドを開始します。                               </target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You then call the &lt;xref:System.Threading.Thread.Start%2A&gt; method to begin execution.</source>
          <target state="translated">次に呼び出し、&lt;xref:System.Threading.Thread.Start%2A&gt;実行を開始するメソッド&lt;/xref:System.Threading.Thread.Start%2A&gt;。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The Thread constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:      -   If the method has no arguments, you pass a &lt;xref:System.Threading.ThreadStart&gt; delegate to  the constructor.</source>
          <target state="translated">スレッド コンス トラクターを実行するメソッドに引数を渡すことができるかどうかに基づいて、2 つのデリゲート型のいずれかを受け取ることができます:-渡す引数を持つメソッドがない場合、&lt;xref:System.Threading.ThreadStart&gt;コンス トラクターに委任します&lt;/xref:System.Threading.ThreadStart&gt;。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph>           The following example creates and starts a thread that executes the <ph id="ph3">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">シグネチャを持つ: <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph>次の例は、作成しを実行するスレッドを開始、<ph id="ph3">`ExecuteInForeground`</ph>メソッドです。          </target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">メソッドは、一部のスレッド プロパティに関する情報を表示し、実行ループを&amp;0;.5 秒を一時停止して経過秒数を表示します。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">少なくとも&amp;5; 秒間のスレッドが実行されたときに、ループが終了し、スレッドは、実行を終了します。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept><ept id="p3">]</ept>      -   If the method has an argument, you pass a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate to the constructor.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept> <ept id="p3">]</ept> -メソッドは、引数を持つ、渡す、&lt;xref:System.Threading.ParameterizedThreadStart&gt;コンス トラクターに委任します&lt;/xref:System.Threading.ParameterizedThreadStart&gt;。      </target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph>           The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">シグネチャを持つ: <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph>デリゲートによって実行されるメソッドのキャスト (c#) または (Visual Basic) のパラメーターを適切な型に変換できますし、します。          </target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following example is identical to the previous one, except that it calls the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor.</source>
          <target state="translated">呼び出しする点を除いて、次の例は、1 つ前と同じ、&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;コンス トラクター&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; 。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">このバージョンの<ph id="ph1">`ExecuteInForeground`</ph>メソッドには、ループは、実行するミリ秒単位のおおよその数を表す&amp;1; つのパラメーターです。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept><ept id="p3">]</ept>       It is not necessary to retain a reference to a Thread object once you have started the thread.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept> <ept id="p3">]</ept>スレッドを起動した後、スレッド オブジェクトへの参照を保持する必要はありません。      </target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">スレッドは、スレッド処理が完了するまでの実行を継続します。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Retrieving Thread objects    You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## スレッドを取得するオブジェクトを静的なを使用することができます (<ph id="ph1">`Shared`</ph> Visual Basic で)&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;スレッドが実行されているコードから実行中のスレッドへの参照を取得するプロパティ&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following example uses the &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">次の例では、&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;メイン アプリケーション スレッド、もう&amp;1; つのフォア グラウンド スレッド、バック グラウンド スレッドおよびスレッド プールのスレッドに関する情報を表示するプロパティ&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Foreground"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Foreground and background threads    Instances of the Thread class represent either foreground threads or background threads.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Foreground"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> ## フォア グラウンドとバック グラウンドのスレッドのスレッドのクラスのインスタンスは、フォア グラウンド スレッドまたはバック グラウンド スレッドを表します。        </target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">バック グラウンド スレッドは同じですがフォア グラウンド スレッドを&amp;1; つの例外: すべてのフォア グラウンド スレッドが終了した場合、バック グラウンド スレッドが実行されているプロセスを維持しません。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">すべてのフォア グラウンド スレッドを停止すると、ランタイムはすべてのバック グラウンド スレッドを停止し、シャット ダウンします。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>By default, the following threads execute in the foreground:      -   The main application thread.</source>
          <target state="translated">既定では、次のスレッドをフォア グラウンドで実行します。-メイン アプリケーション スレッドです。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>-   All threads created by calling a Thread class constructor.</source>
          <target state="translated">-すべてのスレッドがスレッド クラスのコンス トラクターを呼び出すことによって作成します。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following threads execute in the background by default:      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">既定では、次のスレッドがバック グラウンドで実行します。-、ランタイムによって保守されるワーカー スレッドのプールは、プールのスレッドのスレッド。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadPool&gt;クラス&lt;/xref:System.Threading.ThreadPool&gt;を使用して、スレッド プールのスレッドでスレッド プールとスケジュールの作業を構成することができます。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; スレッド プールのスレッドで自動的にタスク ベースの非同期操作を実行します。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Task-based asynchronous operations use the &lt;xref:System.Threading.Tasks.Task&gt; and &lt;xref:System.Threading.Tasks.Task%601&gt; classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">タスク ベースの非同期操作を使用して、&lt;xref:System.Threading.Tasks.Task&gt;と&lt;xref:System.Threading.Tasks.Task%601&gt;を実装するクラス、<bpt id="p1">[</bpt>タスク ベースの非同期パターン<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>&lt;/xref:System.Threading.Tasks.Task%601&gt;&lt;/xref:System.Threading.Tasks.Task&gt;。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-すべてのスレッドをアンマネージ コードからマネージ実行環境を入力します。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You can change a thread to execute in the background by setting the &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property at any time.</source>
          <target state="translated">設定して、バック グラウンドで実行するスレッドを変更することができます、&lt;xref:System.Threading.Thread.IsBackground%2A&gt;いつでもプロパティ&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">バック グラウンド スレッドは、すべての操作を続行する限り、アプリケーションが実行しているが、終了、ファイル システムの変更またはソケットの受信接続の監視など、アプリケーションをしないようにする必要がありますを便利です。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">次の例は、フォア グラウンドとバック グラウンド スレッド間の違いを示しています。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">最初の例のようなもの、 <bpt id="p1">[</bpt>、スレッドの起動<ept id="p1">](#Starting)</ept>セクションを起動する前に、バック グラウンドで実行するスレッドを設定する点を除いて。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">出力では、5 秒間実行前に、ループが中断されました。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Culture"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Culture and threads    Each thread has a culture, represented by the &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt; property, and a UI culture, represented by the &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt; property.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Culture"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> ## 各スレッドには、カルチャ、によって表されるカルチャとスレッド、&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;によって表されるプロパティ、および UI カルチャ、&lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;プロパティ&lt;/xref:System.Threading.Thread.CurrentUICulture%2A&gt;&lt;/xref:System.Threading.Thread.CurrentCulture%2A&gt;。        </target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">現在のカルチャでは、解析および書式設定、文字列比較と並べ替えなどのカルチャに依存した操作をサポートしているしもスレッドで使用する暦、書記体系を制御します。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">現在の UI カルチャは、リソース ファイル内のリソースのカルチャに依存した検索を提供します。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">新しいスレッドがインスタンス化されるときに、によって、現在のシステム カルチャと UI カルチャ、およびカルチャと、新しいスレッドの作成元のスレッドの UI カルチャではなく、そのカルチャおよび UI カルチャが定義されました。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">つまり、たとえば、現在のシステム カルチャが英語 (米国) と、アプリケーションのプライマリ スレッドの現在のカルチャがフランス語 (フランス)、呼び出すことによって作成された新しいスレッドのカルチャの場合、&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;プライマリ スレッドからコンス トラクターは、英語 (米国) とフランス語 (フランス).&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more information, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">詳細については、の「カルチャとスレッド」セクションを参照して、&lt;xref:System.Globalization.CultureInfo&gt;クラスに関するトピック。&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; をターゲットとするアプリの非同期操作を実行するスレッドの場合は true。 これはありません、<ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph>と以降のバージョンでこのケースでは、カルチャと UI カルチャで非同期操作のコンテキストの一部です。 既定では非同期操作を実行するスレッドのカルチャおよび非同期操作の開始元のスレッドの UI カルチャを継承します。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">詳細については、の「カルチャとタスク ベースの非同期操作」セクションを参照して、&lt;xref:System.Globalization.CultureInfo&gt;クラスに関するトピック。&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:      -   You can pass a &lt;xref:System.Globalization.CultureInfo&gt; object that represents that culture to the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate or the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; method.</source>
          <target state="translated">いずれかを行うことができることのすべてのスレッドを確認するには、次は、同じカルチャおよび UI カルチャがアプリケーションで実行する共有: に渡すことができます、&lt;xref:System.Globalization.CultureInfo&gt;にカルチャを表すオブジェクト、&lt;xref:System.Threading.ParameterizedThreadStart&gt;委任または&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt;メソッド&lt;/xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt;&lt;/xref:System.Threading.ParameterizedThreadStart&gt;&lt;/xref:System.Globalization.CultureInfo&gt;。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>-   For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt; and &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; properties.</source>
          <target state="translated">-で実行されているアプリに対して、 <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> 、以降のバージョン、カルチャおよびの値を設定して、アプリケーション ドメインで作成したすべてのスレッドに割り当てられるには、UI カルチャを定義できます、&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;と&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;プロパティ&lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;&lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">これはアプリケーションごとのドメインの設定であることに注意してください。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For more information and examples, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">詳細と例については、の「カルチャとスレッド」セクションを参照して、&lt;xref:System.Globalization.CultureInfo&gt;クラスに関するトピック。&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Getting information about and controlling threads    You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## 情報を取得して、スレッドを制御するには、スレッドに関する情報を提供するプロパティの値の数を取得できます。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">場合によっては、これらのスレッドの操作を制御するプロパティの値を設定することもできます。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>These thread properties include:      -   A name.</source>
          <target state="translated">これらのスレッド プロパティを含める:-名前。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.Name%2A&gt; is a write-once property that you can use to identify a thread.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Name%2A&gt;書き込みが可能-1 回、スレッドの識別に使用できるプロパティです。&lt;/xref:System.Threading.Thread.Name%2A&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">既定値は<ph id="ph1">`null`</ph>します。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>-   A hash code, which you can retrieve by calling the &lt;xref:System.Threading.Thread.GetHashCode%2A&gt; method.</source>
          <target state="translated">ハッシュ コードを呼び出すことによって取得できます、&lt;xref:System.Threading.Thread.GetHashCode%2A&gt;メソッド&lt;/xref:System.Threading.Thread.GetHashCode%2A&gt;。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">ハッシュ コードを使用して; スレッドを一意に識別することができます。スレッドの有効期間中には、値を取得するアプリケーション ドメインに関係なく、他のスレッドからの値でそのハッシュ コードが競合するはありません。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>-   A thread ID.</source>
          <target state="translated">は、スレッド id です。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The value of the read-only &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">読み取り専用の値&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;プロパティが、ランタイムによって割り当てられるし、そのプロセス内のスレッドを一意に識別します&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; オペレーティング システム<bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept>アンマネージ ホストがマネージ コードとアンマネージ スレッド間の関係を制御できるため、マネージ スレッドを固定的な関係がありません。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">具体的には、高度なホストを使用できる、 <bpt id="p1">[</bpt>CLR ホスティング API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept>同じオペレーティング システムのスレッドに対して多数のマネージ スレッドのスケジュールを設定するか、別のオペレーティング システム スレッド間で、マネージ スレッドを移動します。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>-   The thread's current state.</source>
          <target state="translated">-スレッドの現在の状態。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the &lt;xref:System.Threading.ThreadState&gt; property.</source>
          <target state="translated">その存在の期間中、スレッドは常に&amp;1; つ以上のによって定義されている状態で、&lt;xref:System.Threading.ThreadState&gt;プロパティ&lt;/xref:System.Threading.ThreadState&gt;。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>-   A scheduling priority level, which is defined by the &lt;xref:System.Threading.ThreadPriority&gt; property.</source>
          <target state="translated">は、スケジューリング優先順位レベルで定義されている、&lt;xref:System.Threading.ThreadPriority&gt;プロパティ&lt;/xref:System.Threading.ThreadPriority&gt;。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">スレッドの優先順位を要求するには、この値を設定できますが、オペレーティング システムで受け入れられるは保証されません。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>-   The read-only &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt; property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">-読み取り専用&lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;プロパティで、スレッドがスレッド プールのスレッドであるかどうかを示す&lt;/xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>-   The &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property.</source>
          <target state="translated">-&lt;xref:System.Threading.Thread.IsBackground%2A&gt;プロパティ&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">詳細については、次を参照してください。、<bpt id="p1">[</bpt>フォア グラウンドとバック グラウンド スレッド<ept id="p1">](#Foreground)</ept>セクションです。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Accessing the source code for the Thread class    To view the .NET Framework source code for the Thread class, see the <bpt id="p2">[</bpt>Reference Source<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## スレッド クラスの .NET Framework ソース コードを表示するスレッド クラスのソース コードへのアクセスを参照してください、<bpt id="p2">[</bpt>参照ソース<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>です。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
          <target state="translated">ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください<bpt id="p1">[</bpt>指示<ept id="p1">](http://referencesource.microsoft.com/)</ept>です。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">新しいインスタンスを初期化、 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>クラス、スレッドが開始されたときに、スレッドに渡されるオブジェクトを許可するデリゲートを指定します。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">スレッドが作成されるときの実行を開始しません。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">スレッドの実行をスケジュールするには、呼び出し、&lt;xref:System.Threading.Thread.Start%2A&gt;メソッド&lt;/xref:System.Threading.Thread.Start%2A&gt;。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>To pass a data object to the thread, use the &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt; method overload.</source>
          <target state="translated">スレッドに渡すデータ オブジェクトを使用して、&lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;メソッドのオーバー ロード&lt;/xref:System.Threading.Thread.Start%28System.Object%29&gt;。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Visual Basic の場合は省略できます、&lt;xref:System.Threading.ThreadStart&gt;スレッドを作成するときにコンス トラクター&lt;/xref:System.Threading.ThreadStart&gt; 。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">使用して、<ph id="ph1">`AddressOf`</ph>演算子など、そのメソッドを渡すときに<ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>です。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic を自動的に呼び出して、&lt;xref:System.Threading.ThreadStart&gt;コンス トラクター&lt;/xref:System.Threading.ThreadStart&gt; 。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">新しいインスタンスを初期化、 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>クラスです。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">スレッドが作成されるときの実行を開始しません。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">スレッドの実行をスケジュールするには、呼び出し、&lt;xref:System.Threading.Thread.Start%2A&gt;メソッド&lt;/xref:System.Threading.Thread.Start%2A&gt;。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Visual Basic の場合は省略できます、&lt;xref:System.Threading.ThreadStart&gt;スレッドを作成するときにコンス トラクター&lt;/xref:System.Threading.ThreadStart&gt; 。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">使用して、<ph id="ph1">`AddressOf`</ph>演算子など、メソッドを渡すときに<ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>です。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic を自動的に呼び出して、&lt;xref:System.Threading.ThreadStart&gt;コンス トラクター&lt;/xref:System.Threading.ThreadStart&gt; 。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">新しいインスタンスを初期化、 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>クラス、スレッドが開始されたときに、スレッドに渡されるオブジェクトを許可するデリゲートとスレッドの最大スタック サイズを指定します。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">このコンス トラクター オーバー ロードを使用しないでください。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">によって使用される既定のスタック サイズ、&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;コンス トラクター オーバー ロードは、スレッドの推奨されるスタックのサイズ&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">スレッドでは、メモリに問題がある、最も一般的な原因は無限再帰などのエラーをプログラミングします。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; で始まる、<ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>コード設定を完全に信頼できるのみ、<ph id="ph3">`maxStackSize`</ph>が既定のスタック サイズ (1 メガバイト) より大きい値にします。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">大きい値を指定した場合<ph id="ph1">`maxStackSize`</ph>部分信頼でコードが実行されているときに<ph id="ph2">`maxStackSize`</ph>は無視されますと既定のスタック サイズを使用します。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">例外はスローされません。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">任意の信頼レベルでコードを設定できます<ph id="ph1">`maxStackSize`</ph>が既定のスタック サイズより小さい値にします。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; かどうか、部分的に信頼されたコードで使用される完全に信頼されたライブラリを開発して大きなスタックを必要とするスレッドを開始する必要があります、スレッドを作成する前に完全な信頼をアサートする必要がありますまたは既定のスタック サイズが使用されます。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">こうしないスレッド上で実行されるコードを完全に制御しない限り、します。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">場合<ph id="ph1">`maxStackSize`</ph>が小さい最小のスタック サイズよりも最小のスタック サイズを使用します。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">場合<ph id="ph1">`maxStackSize`</ph>倍数ではない場合、ページ サイズの次に大きいページ サイズの倍数に丸められます。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">たとえば、Windows Vista を .NET Framework version 2.0 を使用している場合 256 KB (262、144 バイト) が最小のスタック サイズとページ サイズは 64 KB (65,536 バイト)。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; バージョンの Windows XP および Windows Server 2003 以前の Microsoft Windows<ph id="ph2">`maxStackSize`</ph>は無視され、実行可能ファイルのヘッダーで指定されたスタック サイズが使用されます。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">スタックが深刻な制約されている場合、プローブできます自体、スタック オーバーフローが発生します。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">最大スタック サイズ (バイト単位) を実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する、スレッド、または 0 で使用します。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">重要: 部分的に信頼されているコード、<ph id="ph1">`maxStackSize`</ph>を既定のスタック サイズを超える場合は無視されます。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">例外はスローされません。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>0 未満です。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">新しいインスタンスを初期化、 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>クラス、スレッドの最大スタック サイズを指定します。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">このコンス トラクター オーバー ロードを使用しないでください。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">によって使用される既定のスタック サイズ、&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;コンス トラクター オーバー ロードは、スレッドの推奨されるスタックのサイズ&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">スレッドでは、メモリに問題がある、最も一般的な原因は無限再帰などのエラーをプログラミングします。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; で始まる、<ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>コード設定を完全に信頼できるのみ、<ph id="ph3">`maxStackSize`</ph>が既定のスタック サイズ (1 メガバイト) より大きい値にします。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">大きい値を指定した場合<ph id="ph1">`maxStackSize`</ph>部分信頼でコードが実行されているときに<ph id="ph2">`maxStackSize`</ph>は無視されますと既定のスタック サイズを使用します。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">例外はスローされません。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">任意の信頼レベルでコードを設定できます<ph id="ph1">`maxStackSize`</ph>が既定のスタック サイズより小さい値にします。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; かどうか、部分的に信頼されたコードで使用される完全に信頼されたライブラリを開発して大きなスタックを必要とするスレッドを開始する必要があります、スレッドを作成する前に完全な信頼をアサートする必要がありますまたは既定のスタック サイズが使用されます。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">こうしないスレッド上で実行されるコードを完全に制御しない限り、します。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">場合<ph id="ph1">`maxStackSize`</ph>が小さい最小のスタック サイズよりも最小のスタック サイズを使用します。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">場合<ph id="ph1">`maxStackSize`</ph>倍数ではない場合、ページ サイズの次に大きいページ サイズの倍数に丸められます。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">たとえば、Windows Vista を .NET Framework version 2.0 を使用している場合 256 KB (262、144 バイト) が最小のスタック サイズとページ サイズは 64 KB (65,536 バイト)。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; バージョンの Windows XP および Windows Server 2003 以前の Microsoft Windows<ph id="ph2">`maxStackSize`</ph>は無視され、実行可能ファイルのヘッダーで指定されたスタック サイズが使用されます。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">スタックが深刻な制約されている場合、プローブできます自体、スタック オーバーフローが発生します。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">最大スタック サイズ (バイト単位) を実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する、スレッド、または 0 で使用します。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">重要: 部分的に信頼されているコード、<ph id="ph1">`maxStackSize`</ph>を既定のスタック サイズを超える場合は無視されます。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">例外はスローされません。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>0 未満です。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">発生させる、 <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>これが呼び出される、そのスレッドの終了処理を開始するスレッドでします。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">通常、このメソッドを呼び出すと、スレッドが終了します。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">システム&lt;xref:System.Threading.ThreadAbortException&gt;それを中止するスレッドで&lt;/xref:System.Threading.ThreadAbortException&gt;スローのスレッドでこのメソッドが呼び出されると、</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>アプリケーション コードによってキャッチできる特別な例外は、最後の再スローされますが、<ph id="ph2">`catch`</ph>しない限り、ブロック&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;と呼びます&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>中止するには要求を取り消したになり、<ph id="ph2">`ThreadAbortException`</ph>がスレッドを終了します。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">実行されていない<ph id="ph1">`finally`</ph>ブロックは、スレッドが中止される前に実行されます。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; スレッドを呼び出すと<ph id="ph2">`Abort`</ph>自体で効果に似ていますが、例外をスロー、 &lt;xref:System.Threading.ThreadAbortException&gt;、即座に実行され、結果は予測可能な&lt;/xref:System.Threading.ThreadAbortException&gt;。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">ただし、1 つのスレッドを呼び出す場合<ph id="ph1">`Abort`</ph>どのようなコードが実行されているが、中止別のスレッドで中断します。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">静的コンス トラクターが中断される可能性もあります。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">まれに、原因として考えられますそのクラスのインスタンスからそのアプリケーション ドメインで作成されています。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">.NET Framework バージョン 1.0 および 1.1 では、可能性がある可能性があります、スレッドの中止中に、<ph id="ph1">`finally`</ph>ブロックが実行されている、その場合、<ph id="ph2">`finally`</ph>ブロックが中止されました。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">スレッドは、すぐに、またはまったくを中止するは保証されません。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">このような状況は、スレッドが無制限で計算の場合に発生することができます、<ph id="ph1">`finally`</ph>中止が無期限にそれによって遅れる、中止の手順の一部として呼び出されるブロック。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee the wait will end.</source>
          <target state="translated">スレッドが中止されるまで待ってを呼び出すことができます、 &lt;xref:System.Threading.Thread.Join%2A&gt;Abort メソッドの呼び出し後に、スレッドでメソッドが、待機が終了するという保証はありません&lt;/xref:System.Threading.Thread.Join%2A&gt;。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls Abort might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 中止中のスレッドが場合、コードの保護領域など Abort を呼び出すスレッドをブロックする可能性があります、<ph id="ph2">`catch`</ph>ブロック、<ph id="ph3">`finally`</ph>ブロック、または制約された実行領域。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>If the thread that calls Abort holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Abort を呼び出すスレッドは、中断されたスレッドが必要なロックを保持して、デッドロックが発生することができます。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">場合<ph id="ph1">`Abort`</ph>と呼びますが開始されていないスレッドでスレッドが中止される場合&lt;xref:System.Threading.Thread.Start%2A&gt;と呼びます&lt;/xref:System.Threading.Thread.Start%2A&gt;。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">場合<ph id="ph1">`Abort`</ph>と呼びますがブロックされているまたはスリープ状態のスレッドでスレッドが中断され、中止されました。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">場合<ph id="ph1">`Abort`</ph>が中断されているスレッドで呼び出される、&lt;xref:System.Threading.ThreadStateException&gt;を呼び出したスレッドでスローされた&lt;xref:System.Threading.Thread.Abort%2A&gt;、および&lt;xref:System.Threading.ThreadState&gt;に追加、&lt;xref:System.Threading.Thread.ThreadState%2A&gt;中止中のスレッドのプロパティ&lt;/xref:System.Threading.Thread.ThreadState%2A&gt;&lt;/xref:System.Threading.ThreadState&gt;&lt;/xref:System.Threading.Thread.Abort%2A&gt;&lt;/xref:System.Threading.ThreadStateException&gt;。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">A&lt;xref:System.Threading.ThreadAbortException&gt;まで中断されたスレッドでスローされない&lt;xref:System.Threading.Thread.Resume%2A&gt;と呼びます&lt;/xref:System.Threading.Thread.Resume%2A&gt;&lt;/xref:System.Threading.ThreadAbortException&gt;。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">場合<ph id="ph1">`Abort`</ph>、アンマネージ コードの実行中にマネージ スレッドで呼び出される、<ph id="ph2">`ThreadAbortException`</ph>スレッドがマネージ コードに返されるまではスローされません。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">2 回の呼び出しに場合<ph id="ph1">`Abort`</ph>は、同時に&amp;1; 回の呼び出しの状態情報を設定して、その他の呼び出しを実行する可能性が、<ph id="ph2">`Abort`</ph>です。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">ただし、アプリケーションは、このような状況を検出することはできません。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">後に<ph id="ph1">`Abort`</ph>が呼び出される、スレッドの状態にはスレッドで&lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;が含まれています</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">呼び出しに成功した結果として、スレッドが終了したら<ph id="ph1">`Abort`</ph>、&lt;xref:System.Threading.ThreadState&gt;&lt;/xref:System.Threading.ThreadState&gt;スレッドの状態が変更されました。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">十分なアクセス許可を持つスレッドの対象となって、<ph id="ph1">`Abort`</ph>中止を使用して、取り消すことができます、<ph id="ph2">`ResetAbort`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">呼び出すことを示す例については、<ph id="ph1">`ResetAbort`</ph>メソッドを参照してください、<ph id="ph2">`ThreadAbortException`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼び出し元には、必要なアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">中止中のスレッドは現在中断されています。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">発生させる、 <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>これが呼び出される、スレッドの終了に関する例外情報を提供する一方、スレッドを終了するプロセスを開始するスレッドでします。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">通常、このメソッドを呼び出すと、スレッドが終了します。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">システム&lt;xref:System.Threading.ThreadAbortException&gt;それを中止するスレッドで&lt;/xref:System.Threading.ThreadAbortException&gt;スローのスレッドでこのメソッドが呼び出されると、</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>アプリケーション コードによってキャッチできる特別な例外は、最後の再スローされますが、<ph id="ph2">`catch`</ph>しない限り、ブロック&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;と呼びます&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>中止するには要求を取り消したになり、<ph id="ph2">`ThreadAbortException`</ph>がスレッドを終了します。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">実行されていない<ph id="ph1">`finally`</ph>ブロックは、スレッドが中止される前に実行されます。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; スレッドを呼び出すと<ph id="ph2">`Abort`</ph>自体で効果に似ていますが、例外をスロー、 &lt;xref:System.Threading.ThreadAbortException&gt;、即座に実行され、結果は予測可能な&lt;/xref:System.Threading.ThreadAbortException&gt;。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">ただし、1 つのスレッドを呼び出す場合<ph id="ph1">`Abort`</ph>どのようなコードが実行されているが、中止別のスレッドで中断します。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">静的コンス トラクターが中断される可能性があります。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">まれに、原因として考えられますそのクラスのインスタンスからそのアプリケーション ドメインで作成されています。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">.NET Framework バージョン 1.0 および 1.1 では、可能性がある可能性があります、スレッドの中止中に、<ph id="ph1">`finally`</ph>ブロックが実行されている、その場合、<ph id="ph2">`finally`</ph>ブロックが中止されました。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">スレッドは、すぐに、またはまったくを中止するは保証されません。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">このような状況は、スレッドが無制限で計算の場合に発生することができます、<ph id="ph1">`finally`</ph>中止が無期限にそれによって遅れる、中止の手順の一部として呼び出されるブロック。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee that the wait will end.</source>
          <target state="translated">スレッドが中止されるまで待ってを呼び出すことができます、 &lt;xref:System.Threading.Thread.Join%2A&gt;Abort メソッドの呼び出し後に、スレッドでメソッドが、待機が終了されるという保証はありません&lt;/xref:System.Threading.Thread.Join%2A&gt;。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; を呼び出すスレッド&lt;xref:System.Threading.Thread.Abort%2A&gt;中止中のスレッドが場合、コードの保護領域などをブロックする可能性があります、<ph id="ph2">`catch`</ph>ブロック、<ph id="ph3">`finally`</ph>ブロック、または制約された実行領域&lt;/xref:System.Threading.Thread.Abort%2A&gt;。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If the thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">かどうか、スレッドを呼び出す&lt;xref:System.Threading.Thread.Abort%2A&gt;、デッドロックが発生する可能性が中止されたスレッドが必要なロックを保持します&lt;/xref:System.Threading.Thread.Abort%2A&gt;。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">場合<ph id="ph1">`Abort`</ph>と呼びますが開始されていないスレッドでスレッドが中止される場合&lt;xref:System.Threading.Thread.Start%2A&gt;と呼びます&lt;/xref:System.Threading.Thread.Start%2A&gt;。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">場合<ph id="ph1">`Abort`</ph>と呼びますがブロックされているまたはスリープ状態のスレッドでスレッドが中断され、中止されました。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">場合<ph id="ph1">`Abort`</ph>が中断されているスレッドで呼び出される、&lt;xref:System.Threading.ThreadStateException&gt;を呼び出したスレッドでスローされた&lt;xref:System.Threading.Thread.Abort%2A&gt;、および&lt;xref:System.Threading.ThreadState&gt;に追加、&lt;xref:System.Threading.Thread.ThreadState%2A&gt;中止中のスレッドのプロパティ&lt;/xref:System.Threading.Thread.ThreadState%2A&gt;&lt;/xref:System.Threading.ThreadState&gt;&lt;/xref:System.Threading.Thread.Abort%2A&gt;&lt;/xref:System.Threading.ThreadStateException&gt;。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">A&lt;xref:System.Threading.ThreadAbortException&gt;まで中断されたスレッドでスローされない&lt;xref:System.Threading.Thread.Resume%2A&gt;と呼びます&lt;/xref:System.Threading.Thread.Resume%2A&gt;&lt;/xref:System.Threading.ThreadAbortException&gt;。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">場合<ph id="ph1">`Abort`</ph>、アンマネージ コードの実行中にマネージ スレッドで呼び出される、<ph id="ph2">`ThreadAbortException`</ph>スレッドがマネージ コードに返されるまではスローされません。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">2 回の呼び出しに場合<ph id="ph1">`Abort`</ph>は、同時に&amp;1; 回の呼び出しの状態情報を設定して、その他の呼び出しを実行する可能性が、<ph id="ph2">`Abort`</ph>です。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">ただし、アプリケーションは、このような状況を検出することはできません。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">後に<ph id="ph1">`Abort`</ph>が呼び出される、スレッドの状態にはスレッドで&lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;が含まれています</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">呼び出しに成功した結果として、スレッドが終了したら<ph id="ph1">`Abort`</ph>、&lt;xref:System.Threading.ThreadState&gt;&lt;/xref:System.Threading.ThreadState&gt;スレッドの状態が変更されました。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">十分なアクセス許可を持つスレッドの対象となって、<ph id="ph1">`Abort`</ph>中止を使用して、取り消すことができます、<ph id="ph2">`ResetAbort`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">呼び出すことを示す例については、<ph id="ph1">`ResetAbort`</ph>メソッドを参照してください、<ph id="ph2">`ThreadAbortException`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">中止するスレッドが使用できるように状態などのアプリケーションに固有の情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼び出し元には、必要なアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">中止中のスレッドは現在中断されています。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">無名のデータ スロットをすべてのスレッドに割り当てます。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">パフォーマンス向上のためにマークされているフィールドを使用して、&lt;xref:System.ThreadStaticAttribute&gt;属性の代わりにします&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&amp;2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、&lt;xref:System.ThreadStaticAttribute&gt;属性) とデータ スロット&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">詳細については、TLS を使用して、次を参照してください。<bpt id="p1">[</bpt>スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">スロットは、すべてのスレッドに割り当てられます。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">データ スロットは、スレッドごとに一意です。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">その他のスレッド (であっても、子スレッド) はそのデータを取得できません。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">割り当て済みの名前付きデータ スロットをすべてのスレッドです。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">名前付きデータ スロットをすべてのスレッドを割り当てます。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">パフォーマンス向上のためにマークされているフィールドを使用して、&lt;xref:System.ThreadStaticAttribute&gt;属性の代わりにします&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&amp;2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、&lt;xref:System.ThreadStaticAttribute&gt;属性) とデータ スロット&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">詳細については、TLS を使用して、次を参照してください。<bpt id="p1">[</bpt>スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">データ スロットは、スレッドごとに一意です。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">その他のスレッド (であっても、子スレッド) はそのデータを取得できません。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the AllocateNamedDataSlot method to allocate a named data slot, because the &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; method allocates the slot if it has not already been allocated.</source>
          <target state="translated">メソッドを使用して AllocateNamedDataSlot 名前付きデータ スロットを割り当てるために必要はありません、&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;メソッドは、既に割り当てられていない場合に、スロットを割り当てます&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; AllocateNamedDataSlot メソッドを使用する場合に呼び出す必要があります、プログラムの起動時に、メイン スレッドで指定した名前のスロットが既に割り当てられている場合、例外をスローするためです。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">スロットが既に割り当てられているかどうかをテストする方法はありません。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Slots allocated with this method must be freed with &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;。&lt;/xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;によってこのメソッドによって割り当てられたスロットを解放する必要があります。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">割り当てられるデータ スロットの名前。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">割り当て済みの名前付きデータ スロットをすべてのスレッドです。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">指定した名前の名前付きデータ スロットは既に存在します。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">取得または、このスレッドのアパートメント状態を設定します。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>The ApartmentState property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>ApartmentState プロパティは、今後使用しません。<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The non-obsolete alternatives are the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method to retrieve the apartment state and the   &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method to set the apartment state.</source>
          <target state="translated">旧式でない代替手段は、&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;アパートメント状態を取得する方法と&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;アパートメント状態を設定するメソッド&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;&lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">.NET Framework version 1.0 および 1.1 で、<ph id="ph1">`ApartmentState`</ph>プロパティは、スレッドをシングル スレッドまたはマルチ スレッド アパートメントで実行することを示します。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">スレッドがの場合、このプロパティを設定できます、<ph id="ph1">`Unstarted`</ph>または<ph id="ph2">`Running`</ph>スレッドの状態です。 ただし、設定できます&amp;1; 回だけ、のスレッドにします。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">プロパティが設定されていないかどうかそれを返します<ph id="ph1">`Unknown`</ph>です。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>An attempt to use the ApartmentState property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">アパートメント状態が既に設定されているスレッドのアパートメント状態を設定する ApartmentState プロパティを使用する試みは無視されます。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>However, the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method throws a &lt;xref:System.InvalidOperationException&gt; in this case.</source>
          <target state="translated">ただし、&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;メソッドがスローされます、&lt;xref:System.InvalidOperationException&gt;でも&lt;/xref:System.InvalidOperationException&gt;&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  In the .NET Framework version 2.0, new threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; で .NET Framework version 2.0、として、新しいスレッドが初期化される&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;が開始される前にそのアパートメント状態が設定されていないかどうか&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">メイン アプリケーション スレッドに初期化&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;既定&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>You can no longer set the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by setting the &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; property on the first line of code.</source>
          <target state="translated">メイン アプリケーション スレッドを設定することができます不要になった&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;を設定して、&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;コードの最初の行のプロパティ&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Use the &lt;xref:System.STAThreadAttribute&gt; instead.</source>
          <target state="translated">使用して、&lt;xref:System.STAThreadAttribute&gt;代わりにします&lt;/xref:System.STAThreadAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> linker option.</source>
          <target state="translated">.NET Framework version 2.0 では、COM スレッド モデルを使用する C++ アプリケーションを指定できます、 <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (CLR スレッド属性を設定)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>リンカー オプション。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">1 つ、 <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>値。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">初期値は<bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) or multithreaded apartment (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</source>
          <target state="translated">このプロパティは有効なアパートメント状態ではない状態に設定しようとしましたが (シングル スレッド アパートメント以外の状態 (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) またはマルチ スレッド アパートメント (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>))。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">実行がコードのスレッドの中止または処理されない例外の影響がアプリケーション ドメインで他のタスクを損なう可能性の地域を入力しようとしていますが、ホストに通知します。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストには、コードの重要および重大でない領域でのエラーごとに異なるポリシーを確立できます。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">重要な領域でのスレッドの中止または処理されない例外の影響できない可能性があります、現在のタスクに限定されます。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">これに対し、中止またはエラー コードの重要ではない範囲でエラーが発生したタスクだけに影響します。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">たとえば、ロックを保持しているときにメモリを割り当てようとするタスクを検討してください。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">メモリの割り当てが失敗した場合がの安定性を確保するための十分な現在のタスクを中止していますが、&lt;xref:System.AppDomain&gt;存在できないため他のタスクは同じロックを待機しているドメイン内、&lt;/xref:System.AppDomain&gt; 。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">現在のタスクが終了した場合は、他のタスクがデッドロック可能性があります。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">重要な領域で、障害が発生したときにホスト場合、全体をアンロード&lt;xref:System.AppDomain&gt;可能性のある不安定な状態で実行を継続する危険がかかるのではなく&lt;/xref:System.AppDomain&gt;。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>To inform the host that your code is entering a critical region, call BeginCriticalRegion.</source>
          <target state="translated">重要な領域が、コードを入力することをホストに通知をするには、BeginCriticalRegion を呼び出します。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Call &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt; when execution returns to a non-critical region of code.</source>
          <target state="translated">呼び出す&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;実行が重大でない領域へのコードを返します&lt;/xref:System.Threading.Thread.EndCriticalRegion%2A&gt;。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">現在のオペレーティング システムの物理スレッドの id に依存する命令の実行をマネージ コードをホストに通知します。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Microsoft SQL Server 2005 など、共通言語ランタイムの一部のホストは、独自のスレッド管理を提供します。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">独自のスレッド管理を提供するホストに移動できます実行中のタスク&amp;1; つのオペレーティング システムの物理スレッドから別いつでも。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">ほとんどのタスクは、このを切り替えることによっては受けません。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">ただし、一部のタスクはスレッド アフィニティを持つには、オペレーティング システムの物理スレッドの id に依存します。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">これらのタスクは、切り替えてはいけないコードを実行するときをホストに通知する必要があります。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call BeginThreadAffinity before acquiring the lock, and &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt; after releasing the lock.</source>
          <target state="translated">たとえば、アプリケーションが Win32 CRITICAL_SECTION などのスレッドの関係のあるオペレーティング システムのロックを取得するシステム API を呼び出す場合は、呼び出す必要があります BeginThreadAffinity、ロックを取得する前に、&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;ロックを解除した後&lt;/xref:System.Threading.Thread.EndThreadAffinity%2A&gt;。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼び出し元には、必要なアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">スレッドを実行している現在のコンテキストを取得します。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current thread context.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>の現在のスレッド コンテキストを表すです。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼び出し元には、必要なアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">取得または現在のスレッドのカルチャを設定します。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Globalization.CultureInfo&gt; object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">&lt;xref:System.Globalization.CultureInfo&gt;に関連付けられたオブジェクトと共に、このプロパティによって返されるオブジェクトは、日付の既定の形式、時間、数値、通貨の値、テキストの順序を並べ替え、規則、大文字小文字の区別を特定し、文字列比較&lt;/xref:System.Globalization.CultureInfo&gt;。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>See the &lt;xref:System.Globalization.CultureInfo&gt; class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">参照してください、&lt;xref:System.Globalization.CultureInfo&gt;カルチャ名と識別子、インバリアント、中間色、および特定のカルチャの違いについて学習するクラスおよびスレッドおよびアプリケーション ドメインに影響を与える方法カルチャ情報&lt;/xref:System.Globalization.CultureInfo&gt;。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>See the &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt; property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">参照してください、&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;スレッドの既定のカルチャを決定する方法、およびユーザーが自分のコンピューターのカルチャ情報を設定する方法を説明するプロパティ&lt;/xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, you can set the CurrentCulture property to a neutral culture.</source>
          <target state="translated">以降で、 <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>、ニュートラル カルチャを CurrentCulture プロパティを設定することができます。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>This is because the behavior of the &lt;xref:System.Globalization.CultureInfo&gt; class has changed: When it represents a neutral culture, its property values (in particular, the &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, and &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt; properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">これは、ための動作、&lt;xref:System.Globalization.CultureInfo&gt;クラスが変更された: ときに、ニュートラル カルチャをプロパティの値を表します (具体的には、 &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;、 &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;、 &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;、 &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;、および&lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;プロパティ)、ニュートラル カルチャに関連付けられている特定のカルチャを反映します&lt;/xref:System.Globalization.CultureInfo.TextInfo%2A&gt;&lt;/xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;&lt;/xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;&lt;/xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;&lt;/xref:System.Globalization.CultureInfo.Calendar%2A&gt;&lt;/xref:System.Globalization.CultureInfo&gt;。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>In earlier versions of the .NET Framework, the CurrentCulture property threw a &lt;xref:System.NotSupportedException&gt; exception when a neutral culture was assigned.</source>
          <target state="translated">.NET Framework の以前のバージョンで CurrentCulture プロパティがスローされました、&lt;xref:System.NotSupportedException&gt;がニュートラル カルチャの割り当てに例外が発生します&lt;/xref:System.NotSupportedException&gt;。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">現在のスレッドのカルチャを表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">プロパティに設定<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">取得または (ロール ベースのセキュリティに関する、スレッドの現在のプリンシパルを設定します。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Security.Principal.IPrincipal&gt; value representing the security context.</source>
          <target state="translated">&lt;xref:System.Security.Principal.IPrincipal&gt;のセキュリティ コンテキストを表す値&lt;/xref:System.Security.Principal.IPrincipal&gt;。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">呼び出し元には、プリンシパルを設定するために必要なアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Gets the currently running thread.</source>
          <target state="translated">現在実行中のスレッドを取得します。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is the representation of the currently running thread.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>を表す、現在実行中のスレッド。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">取得またはリソース マネージャーで実行時にカルチャ固有のリソースを検索するために使用する現在のカルチャを設定します。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>An object that represents the current culture.</source>
          <target state="translated">現在のカルチャを表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">プロパティに設定<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">リソース ファイルの検索に使用できないカルチャ名に設定されます。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">リソース ファイル名には、文字、数字、ハイフンまたはアンダー スコアのみを含める必要があります。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">現在のスレッドのランタイム呼び出し可能ラッパー (RCW) の自動クリーンアップをオフにします。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">既定では、共通言語ランタイム (CLR) をクリーンアップ ランタイム呼び出し可能ラッパーに自動的にします。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:      -   The application does its own message pumping.</source>
          <target state="translated">CLR は、次の特殊な条件を満たす、いくつかのアプリケーションの再入の問題が発生する可能性があります、クリーンアップ中にメッセージをポンプ:-アプリケーションが独自のメッセージ ポンプがします。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>-   The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">-アプリケーションがメッセージ ポンプが発生したときに正確に制御する必要があります。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Such applications can use the DisableComObjectEagerCleanup method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">このようなアプリケーションでは、CLR がランタイム呼び出し可能ラッパーの自動再生を実行するを防ぐため、DisableComObjectEagerCleanup メソッドを使用できます。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">このメソッドは、スレッドで呼び出されると、自動クリーンアップがそのスレッドを再び有効にすることはできません。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>When your application is ready to clean up runtime callable wrappers, use the &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt; method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">使用して、アプリケーションのランタイム呼び出し可能ラッパーをクリーンアップする準備ができたら、&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;ランタイムが、現在のコンテキスト内のすべてのランタイム呼び出し可能ラッパーをクリーンアップするように命令する方法&lt;/xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">メッセージ ポンプは、メソッドの実行中に発生します。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">実行スレッドの中止または処理されない例外の影響が現在のタスクだけにコードの地域を入力しようとしていますが、ホストに通知します。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストには、コードの重要および重大でない領域でのエラーごとに異なるポリシーを確立できます。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">重要な領域でのスレッドの中止または処理されない例外の影響できない可能性があります、現在のタスクに限定されます。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">これに対し、中止またはエラー コードの重要ではない範囲でエラーが発生したタスクだけに影響します。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">たとえば、ロックを保持しているときにメモリを割り当てようとするタスクを検討してください。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">メモリの割り当てが失敗した場合がの安定性を確保するための十分な現在のタスクを中止していますが、&lt;xref:System.AppDomain&gt;存在できないため他のタスクは同じロックを待機しているドメイン内、&lt;/xref:System.AppDomain&gt; 。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">現在のタスクが終了した場合は、他のタスクがデッドロック可能性があります。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">重要な領域で、障害が発生したときにホスト場合、全体をアンロード&lt;xref:System.AppDomain&gt;可能性のある不安定な状態で実行を継続する危険がかかるのではなく&lt;/xref:System.AppDomain&gt;。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>To inform the host that your code is entering a critical region, call &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.</source>
          <target state="translated">重要な領域が、コードを入力することをホストに通知をするには、 &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;。&lt;/xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;を呼び出す</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Call EndCriticalRegion when execution returns to a non-critical region of code.</source>
          <target state="translated">重大でないコード領域に実行制御が戻るとき、EndCriticalRegion を呼び出します。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">現在のオペレーティング システムの物理スレッドの id に依存する命令の実行が完了したマネージ コードをホストに通知します。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Microsoft SQL Server 2005 など、共通言語ランタイムの一部のホストは、独自のスレッド管理を提供します。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">独自のスレッド管理を提供するホストに移動できます実行中のタスク&amp;1; つのオペレーティング システムの物理スレッドから別いつでも。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">ほとんどのタスクは、このを切り替えることによっては受けません。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">ただし、一部のタスクはスレッド アフィニティを持つには、オペレーティング システムの物理スレッドの id に依存します。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">これらのタスクは、切り替えてはいけないコードを実行するときをホストに通知する必要があります。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt; before acquiring the lock, and EndThreadAffinity after releasing the lock.</source>
          <target state="translated">たとえば、オペレーティング システムを取得する、アプリケーション呼び出しシステム API をロックする場合、Win32 CRITICAL_SECTION などのスレッドの関係のある呼び出す必要があります&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;ロックを解放すた後ロック、および EndThreadAffinity を取得する前にします&lt;/xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼び出し元には、必要なアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Gets an &lt;xref:System.Threading.ExecutionContext&gt; object that contains information about the various contexts of the current thread.</source>
          <target state="translated">取得、 &lt;xref:System.Threading.ExecutionContext&gt;、現在のスレッドのさまざまなコンテキストに関する情報を含むオブジェクトです&lt;/xref:System.Threading.ExecutionContext&gt;。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Threading.ExecutionContext&gt; class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">&lt;xref:System.Threading.ExecutionContext&gt;クラスは、すべての情報の論理的なスレッドに関連する実行の&amp;1; つのコンテナーを提供します&lt;/xref:System.Threading.ExecutionContext&gt;。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">これには、セキュリティ コンテキスト、呼び出しコンテキスト、同期コンテキスト、ローカリゼーション コンテキスト、およびトランザクション コンテキストが含まれます。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Threading.ExecutionContext&gt; object that consolidates context information for the current thread.</source>
          <target state="translated">&lt;xref:System.Threading.ExecutionContext&gt;、現在のスレッドのコンテキスト情報を統合するオブジェクト&lt;/xref:System.Threading.ExecutionContext&gt;。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">リソースが解放され、ガベージ コレクターがクリアするときに他のクリーンアップ操作が実行されることにより、 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>オブジェクト。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>The garbage collector calls Finalize when the current object is ready to be finalized.</source>
          <target state="translated">ガベージ コレクターは、現在のオブジェクトが完了する準備ができたとき。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">名前と、プロセスのすべてのスレッドのスロットの関連付けを解除します。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">パフォーマンス向上のためにマークされているフィールドを使用して、&lt;xref:System.ThreadStaticAttribute&gt;属性の代わりにします&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&amp;2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、&lt;xref:System.ThreadStaticAttribute&gt;属性) とデータ スロット&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">詳細については、TLS を使用して、次を参照してください。<bpt id="p1">[</bpt>スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">いずれかのスレッドの呼び出し後<ph id="ph1">`FreeNamedDataSlot`</ph>、他のスレッドを呼び出す&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;と同じ名前は、名前に関連付けられている新しいスロットを割り当てます&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">後続の呼び出し<ph id="ph1">`GetNamedDataSlot`</ph>任意のスレッドでは、新しいスロットを返します。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>However, any thread that still has a &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt; returned by an earlier call to <ph id="ph1">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">ただし、いずれかのスレッドをまだ、&lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;を以前の呼び出しによって返される<ph id="ph1">`GetNamedDataSlot`</ph>引き続き古いスロットを使用できます&lt;/xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">名前に関連付けられているスロットが解放される場合にのみすべて<ph id="ph1">`LocalDataStoreSlot`</ph>への呼び出しの前に取得された<ph id="ph2">`FreeNamedDataSlot`</ph>リリースされ、ガベージ コレクションします。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">データ スロットは、スレッドごとに一意です。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">その他のスレッド (であっても、子スレッド) はそのデータを取得できません。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">解放されるデータ スロットの名前。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value indicating the apartment state.</source>
          <target state="translated">返します、 <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>アパートメント状態を示す値。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>This method, along with the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">このメソッドと共に、&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;メソッドおよび&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;メソッド、置換、&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;プロパティ&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt;&lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt;&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the apartment state of the managed thread.</source>
          <target state="translated">1 つ、 <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>マネージ スレッドのアパートメント状態を示す値。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">既定値は<bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">返します、 <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>を現在のスレッドのスタックをキャプチャするために使用できるオブジェクト。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>This method is no longer supported.</source>
          <target state="translated">このメソッドは現在サポートされていません。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">ありません。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">すべての場合。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">指定した現在のスレッドの現在のドメイン内の現在のスレッドのスロットから値を取得します。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">パフォーマンス向上のためにマークされているフィールドを使用して、&lt;xref:System.ThreadStaticAttribute&gt;属性の代わりにします&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&amp;2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、&lt;xref:System.ThreadStaticAttribute&gt;属性) とデータ スロット&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">詳細については、TLS を使用して、次を参照してください。<bpt id="p1">[</bpt>スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">データ スロットは、スレッドごとに一意です。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">その他のスレッド (であっても、子スレッド) はそのデータを取得できません。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  GetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; GetData は、<ph id="ph2">`Shared`</ph>を別のスレッドを表す変数を使用するメソッドを呼び出す場合でも常に現在実行中のスレッドに適用するメソッド。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">混乱を避けるためには、クラス名を呼び出すときに使用<ph id="ph1">`Shared`</ph>メソッド:<ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>です。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to get the value.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>元の値を取得します。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The retrieved value.</source>
          <target state="translated">取得された値。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">現在のスレッドが実行されている現在のドメインを返します。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current application domain of the running thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>実行中のスレッドの現在のアプリケーション ドメインを表すです。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">一意のアプリケーション ドメイン識別子を返します。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">アプリケーション ドメインを一意に識別する 32 ビット符号付き整数。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">現在のスレッドのハッシュ コードを返します。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">ハッシュ コードは一意であることは保証されません。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Use the &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property if you need a unique identifier for a managed thread.</source>
          <target state="translated">使用して、&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;プロパティのマネージ スレッドの一意の識別子が必要がある場合&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>An integer hash code value.</source>
          <target state="translated">整数ハッシュ コード値。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Looks up a named data slot.</source>
          <target state="translated">名前付きデータ スロットを検索します。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">パフォーマンス向上のためにマークされているフィールドを使用して、&lt;xref:System.ThreadStaticAttribute&gt;属性の代わりにします&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&amp;2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、&lt;xref:System.ThreadStaticAttribute&gt;属性) とデータ スロット&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">詳細については、TLS を使用して、次を参照してください。<bpt id="p1">[</bpt>スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">データ スロットは、スレッドごとに一意です。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">その他のスレッド (であっても、子スレッド) はそのデータを取得できません。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">名前付きスロットが存在しない場合は、新しいスロットが割り当てられます。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">名前付きデータ スロットは、パブリックし、すべてのユーザーによって操作されることができます。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The name of the local data slot.</source>
          <target state="translated">ローカル データ スロットの名前。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> allocated for this thread.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>このスレッドに割り当てられます。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Interrupts a thread that is in the <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> thread state.</source>
          <target state="translated">内にあるスレッドに割り込む、 <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>スレッドの状態。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">このスレッドが待機、スリープ状態または結合状態で現在ブロックされていない場合は、ブロックが次で開始したときに中断されます。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ThreadInterruptedException&gt; is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadInterruptedException&gt;スレッドがブロックされるが、中断されたスレッドでスローされます。&lt;/xref:System.Threading.ThreadInterruptedException&gt;</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">スレッドがブロックされない場合、例外がスローされず、ため、スレッドが中断されることがなく完了ことがあります。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">呼び出し元は、適切なありません<bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">現在のスレッドの実行状態を示す値を取得します。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread has been started and has not terminated normally or aborted; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>このスレッドが起動していない場合、正常終了または中止されました。それ以外の場合、 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">取得またはスレッドがバック グラウンド スレッドであるかどうかどうかを示す値を設定します。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">スレッドは、バック グラウンド スレッドまたはフォア グラウンド スレッドのいずれかです。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">バック グラウンド スレッドは、バック グラウンド スレッドいなくても、プロセスが終了する点を除いて、フォア グラウンド スレッドと同じです。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">プロセスに属するすべてのフォア グラウンド スレッドが終了すると、共通言語ランタイムは、プロセスを終了します。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">残りのバック グラウンド スレッドは停止され、完了しません。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>By default, the following threads execute in the foreground (that is, their IsBackground property returns <ph id="ph1">`false`</ph>):      -   The primary thread (or main application thread).</source>
          <target state="translated">既定では、次のスレッドをフォア グラウンドで実行 (つまり、その IsBackground プロパティから返される<ph id="ph1">`false`</ph>):-プライマリ スレッド (またはメイン アプリケーション スレッド)。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>-   All threads created by calling a &lt;xref:System.Threading.Thread&gt; class constructor.</source>
          <target state="translated">-すべてのスレッドを呼び出すことによって作成された、&lt;xref:System.Threading.Thread&gt;クラスのコンス トラクター&lt;/xref:System.Threading.Thread&gt; 。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>By default, the following threads execute in the background  (that is, their IsBackground property returns <ph id="ph1">`true`</ph>):      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">既定では、次のスレッドがバック グラウンドで実行 (つまり、その IsBackground プロパティから返される<ph id="ph1">`true`</ph>): に、ランタイムによって保守されるワーカー スレッドのプールは、プールのスレッドのスレッドします。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadPool&gt;クラス&lt;/xref:System.Threading.ThreadPool&gt;を使用して、スレッド プールのスレッドでスレッド プールとスケジュールの作業を構成することができます。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; スレッド プールのスレッドで自動的にタスク ベースの非同期操作を実行します。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-すべてのスレッドをアンマネージ コードからマネージ実行環境を入力します。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread is or is to become a background thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>このスレッドがまたはには、バック グラウンド スレッドになる場合それ以外の場合、 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The thread is dead.</source>
          <target state="translated">スレッドが動作しています。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">スレッドがマネージ スレッド プールに属しているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>、マネージ スレッド プール<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread belongs to the managed thread pool; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>このスレッドがマネージ スレッド プールに属する場合それ以外の場合、 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> pumping.</source>
          <target state="translated">標準の COM の実行は継続中に、このインスタンスで表される、スレッドが終了するまで、呼び出し元のスレッドをブロックし、 <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>ポンピングです。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose Join method is called has completed.</source>
          <target state="translated">結合は、スレッドのメソッドが呼び出されたが結合が完了するまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドです。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">このメソッドを使用して、スレッドが終了したことを確認してください。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">スレッドが終了しない場合、呼び出し元が無期限にブロックされます。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the Join method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block until <ph id="ph4">`Thread2`</ph> has completed.</source>
          <target state="translated">次の例で、<ph id="ph1">`Thread1`</ph>の結合メソッドを呼び出すスレッドは<ph id="ph2">`Thread2`</ph>、これにより<ph id="ph3">`Thread1`</ph>されるまでブロックする<ph id="ph4">`Thread2`</ph>が完了しました。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept><ept id="p3">]</ept>       If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept> <ept id="p3">]</ept>場合は、スレッドが終了時に既に&lt;xref:System.Threading.Thread.Join%2A&gt;が呼び出されると、メソッドはすぐに返します&lt;/xref:System.Threading.Thread.Join%2A&gt;。  </target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!WARNING]</ph> &gt;  You should never call the Join method of the &lt;xref:System.Threading.Thread&gt; object that represents the current thread from the current thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!WARNING]</ph> &gt; の結合メソッドは呼び出さないで、&lt;xref:System.Threading.Thread&gt;を現在のスレッドから、現在のスレッドを表すオブジェクト&lt;/xref:System.Threading.Thread&gt;。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,       This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">これにより、ハング、現在のスレッド自体には無期限に待機、このメソッドが変更されたのためにアプリを&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;。&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;を含めるには、呼び出し元のスレッドの状態</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">呼び出すことはできません<ph id="ph1">`Join`</ph>内にあるスレッドで、&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;状態&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">呼び出し元スレッドを結合しようとしました。、 <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>状態です。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">スレッドは待機中に中断されました。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">このインスタンスで表される、スレッドが終了するまで呼び出し元のスレッドまたは指定された時間が経過するまで、標準の COM および SendMessage ポンピングの実行は継続のブロックです。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">結合は、いずれかのスレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドが&lt;xref:System.Threading.Thread.Join%2A&gt;メソッドが呼び出されたが完了したか、タイムアウト間隔が経過します&lt;/xref:System.Threading.Thread.Join%2A&gt;。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">次の例で、<ph id="ph1">`Thread1`</ph>スレッドの呼び出し、&lt;xref:System.Threading.Thread.Join&gt;メソッドの<ph id="ph2">`Thread2`</ph>、これにより<ph id="ph3">`Thread1`</ph>までいずれかをブロックする<ph id="ph4">`Thread2`</ph>が完了した 2 秒が経過したか&lt;/xref:System.Threading.Thread.Join&gt;。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for the <ph id="ph1">`millisecondsTimeout`</ph> parameter, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept> <ept id="p3">]</ept>場合&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;が指定されて、<ph id="ph1">`millisecondsTimeout`</ph>パラメーターでは、このメソッドの動作と同じように、&lt;xref:System.Threading.Thread.Join&gt;メソッドのオーバー ロードで戻り値を除く&lt;/xref:System.Threading.Thread.Join&gt;&lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;。  </target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">スレッドが既に終了した場合場合&lt;xref:System.Threading.Thread.Join%2A&gt;が呼び出されると、メソッドはすぐに返します&lt;/xref:System.Threading.Thread.Join%2A&gt;。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">このメソッドに含める&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;。&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;呼び出し元のスレッドの状態を変更します。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">呼び出すことはできません<ph id="ph1">`Join`</ph>内にあるスレッドで、&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;状態&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">スレッドが終了するまで待機するミリ秒数。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread has terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>場合は、スレッドが終了します。<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>スレッドがで指定された時間の経過後、終了していないかどうか、 <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p3">&lt;/code&gt;</ept>パラメーターが経過しました。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds.</source>
          <target state="translated">値<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p1">&lt;/code&gt;</ept>が負の値と等しくない<ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> (ミリ秒単位)。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The thread has not been started.</source>
          <target state="translated">スレッドが開始されていません。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">このインスタンスで表される、スレッドが終了するまで呼び出し元のスレッドまたは指定された時間が経過するまで、標準の COM および SendMessage ポンピングの実行は継続のブロックです。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">結合は、いずれかのスレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドが&lt;xref:System.Threading.Thread.Join%2A&gt;メソッドが呼び出されたが完了したか、タイムアウト間隔が経過します&lt;/xref:System.Threading.Thread.Join%2A&gt;。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">次の例で、<ph id="ph1">`Thread1`</ph>スレッドの呼び出し、&lt;xref:System.Threading.Thread.Join&gt;メソッドの<ph id="ph2">`Thread2`</ph>、これにより<ph id="ph3">`Thread1`</ph>までいずれかをブロックする<ph id="ph4">`Thread2`</ph>が完了した 2 秒が経過したか&lt;/xref:System.Threading.Thread.Join&gt;。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for <ph id="ph1">`timeout`</ph>, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept> <ept id="p3">]</ept>場合&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;が指定されて<ph id="ph1">`timeout`</ph>、このメソッドの動作と同じように、&lt;xref:System.Threading.Thread.Join&gt;メソッドのオーバー ロードで戻り値を除く&lt;/xref:System.Threading.Thread.Join&gt;&lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;。  </target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">スレッドが既に終了した場合場合&lt;xref:System.Threading.Thread.Join%2A&gt;が呼び出されると、メソッドはすぐに返します&lt;/xref:System.Threading.Thread.Join%2A&gt;。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>This method changes the state of the current thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">このメソッドを&lt;xref:System.Threading.ThreadState&gt;。&lt;/xref:System.Threading.ThreadState&gt;を含めるには、現在のスレッドの状態を変更します。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">呼び出すことはできません<ph id="ph1">`Join`</ph>内にあるスレッドで、&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;状態&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated">A&lt;xref:System.TimeSpan&gt;スレッドが終了するまで待機する時間に設定します&lt;/xref:System.TimeSpan&gt;。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>場合は、スレッドが終了します。<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>スレッドがで指定された時間の経過後、終了していないかどうか、 <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p3">&lt;/code&gt;</ept>パラメーターが経過しました。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">値<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept>が負の値と等しくない<ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> (ミリ秒単位) より大きいまたは<ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> (ミリ秒)。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">呼び出し元スレッドを結合しようとしました。、 <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>状態です。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">現在のマネージ スレッドの一意の識別子を取得します。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>A thread's ManagedThreadId property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">スレッドの ManagedThreadId プロパティの値は、そのプロセス内でそのスレッドを一意に識別するのには機能します。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>The value of the ManagedThreadId property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">ManagedThreadId プロパティの値は、共通言語ランタイムをホストするアンマネージ コードには、ファイバーとスレッドが実装されている場合でもに時間の経過と共に変わりません。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">このマネージ スレッドの一意の識別子を表す整数。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</source>
          <target state="translated">次のようにメモリ アクセスを同期: 現在のスレッドを実行中のプロセッサがなどの命令を並べ替えることはできません MemoryBarrier への呼び出しの後のメモリ アクセスより後にメモリが MemoryBarrier を呼び出す前にアクセスする方法が実行されます。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>MemoryBarrier is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated">脆弱なメモリが (たとえば、複数の Intel Itanium プロセッサを使用するシステム) の順序では、マルチプロセッサ システムでのみ MemoryBarrier が必要です。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the &lt;xref:System.Threading.Monitor&gt; class provide easier ways to synchronize data.</source>
          <target state="translated">ほとんどの目的で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、または&lt;xref:System.Threading.Monitor&gt;クラスは、データを同期する簡単な方法を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">取得またはスレッドの名前を設定します。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>This property is write-once.</source>
          <target state="translated">このプロパティは書き込みの後です。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>Because the default value of a thread's Name property is <ph id="ph1">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph2">`null`</ph>.</source>
          <target state="translated">スレッドの名前プロパティの既定値があるため<ph id="ph1">`null`</ph>、することができるかどうか、名前が既に割り当てられてを調べます明示的にスレッドと比較して<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>The string assigned to the Name property can include any Unicode character.</source>
          <target state="translated">Name プロパティに割り当てられた文字列は、任意の Unicode 文字を含めることができます。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>A string containing the name of the thread, or <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if no name was set.</source>
          <target state="translated">スレッドの名前を含む文字列または<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>名が設定されていない場合。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>A set operation was requested, but the <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> property has already been set.</source>
          <target state="translated">設定操作が要求されましたが、 <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>プロパティは既に設定されています。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">取得またはスレッドのスケジューリング優先順位を示す値を設定します。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>A thread can be assigned any one of the following priority &lt;xref:System.Threading.ThreadPriority&gt; values:      -   <ph id="ph1">`Highest`</ph><ph id="ph2">      -   </ph><ph id="ph3">`AboveNormal`</ph><ph id="ph4">      -   </ph><ph id="ph5">`Normal`</ph><ph id="ph6">      -   </ph><ph id="ph7">`BelowNormal`</ph><ph id="ph8">      -   </ph><ph id="ph9">`Lowest`</ph>       Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">次の優先度のいずれかのスレッドを割り当てることができる&lt;xref:System.Threading.ThreadPriority&gt;値:- <ph id="ph1">`Highest`</ph> <ph id="ph2">      -   </ph> <ph id="ph3">`AboveNormal`</ph> <ph id="ph4">      -   </ph> <ph id="ph5">`Normal`</ph> <ph id="ph6">      -   </ph> <ph id="ph7">`BelowNormal`</ph> <ph id="ph8">      -   </ph> <ph id="ph9">`Lowest`</ph>オペレーティング システムが、スレッドの優先度を優先する必要はありません&lt;/xref:System.Threading.ThreadPriority&gt;。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">1 つ、 <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>値。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">既定値は<bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The thread has reached a final state, such as <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">最終的な状態をなど、スレッドが<bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is not a valid <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">指定された設定操作が有効ではありません値<bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>値。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Cancels an &lt;xref:System.Threading.Thread.Abort*&gt; requested for the current thread.</source>
          <target state="translated">キャンセル、 &lt;xref:System.Threading.Thread.Abort*&gt;、現在のスレッドを要求します&lt;/xref:System.Threading.Thread.Abort*&gt;。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">このメソッドは、適切なアクセス許可を持つコードでのみ呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt;.</source>
          <target state="translated">呼び出しが行われたときに<ph id="ph1">`Abort`</ph>スレッドを終了、 &lt;xref:System.Threading.ThreadAbortException&gt;.&lt;/xref:System.Threading.ThreadAbortException&gt;がスローされます</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>特別な例外があるが、アプリケーション コードでキャッチできますが、catch ブロックの最後に再スローされる場合を除き、<ph id="ph2">`ResetAbort`</ph>と呼びます。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>中止するには要求を取り消したになり、<ph id="ph2">`ThreadAbortException`</ph>がスレッドを終了します。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>See &lt;xref:System.Threading.ThreadAbortException&gt; for an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method.</source>
          <target state="translated">参照してください&lt;xref:System.Threading.ThreadAbortException&gt;を呼び出すことを示す例については、<ph id="ph1">`ResetAbort`</ph>メソッド&lt;/xref:System.Threading.ThreadAbortException&gt;。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> was not invoked on the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>現在のスレッドで呼び出されませんでした。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">呼び出し元には、現在のスレッドの必要なセキュリティ アクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">中断されているスレッドを再開します。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">スレッドが開始されていない、または中断された状態ではありません。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">呼び出し元は、適切なありません<bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">開始される前に、スレッドのアパートメント状態を設定します。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">新しいスレッドとして初期化される&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;が開始される前にそのアパートメント状態が設定されていないかどうか&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">スレッドを開始する前に、アパートメントの状態を設定する必要があります。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; をメイン アプリケーション スレッドが初期化される&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;既定&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">アプリケーションのメイン スレッドのアパートメント状態を設定する唯一の方法&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;を適用する、&lt;xref:System.STAThreadAttribute&gt;属性をエントリ ポイント メソッドです&lt;/xref:System.STAThreadAttribute&gt;&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>The SetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">SetApartmentState メソッドと共に、&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;メソッドおよび&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;メソッド、置換、&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;プロパティ&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt;&lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt;&lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">新しいアパートメント状態。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>有効なアパートメント状態ではありません。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">スレッドは既に開始されています。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">アパートメント状態は既に初期化されています。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Applies a captured <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the current thread.</source>
          <target state="translated">キャプチャした適用<bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>現在のスレッドにします。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>This method is no longer supported.</source>
          <target state="translated">このメソッドは現在サポートされていません。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to be applied to the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>現在のスレッドに適用するオブジェクト。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">すべての場合。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">そのスレッドの現在のドメインの現在実行中のスレッドで指定されたスロット内のデータを設定します。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>For better performance, use fields marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">パフォーマンスを向上させるのでマークされたフィールドを使用して、&lt;xref:System.ThreadStaticAttribute&gt;属性の代わりにします&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&amp;2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、&lt;xref:System.ThreadStaticAttribute&gt;属性) とデータ スロット&lt;/xref:System.ThreadStaticAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">詳細については、TLS を使用して、次を参照してください。<bpt id="p1">[</bpt>スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the &lt;xref:System.Threading.Thread&gt; object has been reclaimed by garbage collection.</source>
          <target state="translated">スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッド プロシージャが終了した後、再利用するため、スロットを解放し、&lt;xref:System.Threading.Thread&gt;オブジェクトがガベージ コレクションによって解放された&lt;/xref:System.Threading.Thread&gt;。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">データ スロットは、スレッドごとに一意です。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">その他のスレッド (であっても、子スレッド) はそのデータを取得できません。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  SetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; SetData は、<ph id="ph2">`Shared`</ph>を別のスレッドを表す変数を使用するメソッドを呼び出す場合でも常に現在実行中のスレッドに適用するメソッド。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">混乱を避けるためには、クラス名を呼び出すときに使用<ph id="ph1">`Shared`</ph>メソッド:<ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>です。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in which to set the value.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>先となる値を設定します。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The value to be set.</source>
          <target state="translated">設定する値。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">指定したミリ秒数の現在のスレッドを中断します。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">スレッドは、指定した時間、オペレーティング システムでの実行スケジュールされません。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">このメソッドに含める&lt;xref:System.Threading.ThreadState&gt;。&lt;/xref:System.Threading.ThreadState&gt;スレッドの状態を変更します。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>You can specify &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; for the <ph id="ph1">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">指定できます&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;の<ph id="ph1">`millisecondsTimeout`</ph>を無期限にスレッドを中断するパラメーター&lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; 。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">ただし、使用ことお勧めするその他の&lt;xref:System.Threading?displayProperty=fullName&gt;などのクラス&lt;xref:System.Threading.Mutex&gt;、 &lt;xref:System.Threading.Monitor&gt;、 &lt;xref:System.Threading.EventWaitHandle&gt;、または&lt;xref:System.Threading.Semaphore&gt;代わりに「同期化スレッドにまたはリソースを管理します&lt;/xref:System.Threading.Semaphore&gt;&lt;/xref:System.Threading.EventWaitHandle&gt;&lt;/xref:System.Threading.Monitor&gt;&lt;/xref:System.Threading.Mutex&gt;&lt;/xref:System.Threading?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">特定のレートでシステム クロックのティックには、クロックの分解能が呼び出されます。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">実際のタイムアウトできない可能性があります正確に指定されたタイムアウト、クロックのティックと一致するように指定したタイムアウト時間が調整されるためです。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">クロックの分解能と待機時間の詳細については、次を参照してください。、<bpt id="p1">[</bpt>関数をスリープ状態<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept>トピックです。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">このメソッドは、<bpt id="p1">[</bpt>関数をスリープ状態<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept>Windows システム Api からです。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">このメソッドでは、標準の COM および&amp;1; つは実行されません。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; かどうかのあるスレッドでスリープ状態にする必要があります&lt;xref:System.STAThreadAttribute&gt;、標準の COM および&amp;1; つを実行するためのオーバー ロードのいずれかの使用を検討するが、&lt;xref:System.Threading.Thread.Join%2A&gt;タイムアウト間隔を指定するメソッド&lt;/xref:System.Threading.Thread.Join%2A&gt;&lt;/xref:System.STAThreadAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">スレッドが中断ブロックされるミリ秒数。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">場合の値、<ph id="ph1">`millisecondsTimeout`</ph>引数が&amp;0; で、スレッドが実行する準備ができている同じ優先順位のスレッドに自らのタイム スライスの残りの部分を放棄します。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">実行する準備ができている同じ優先順位の他のスレッドがない場合は、現在のスレッドの実行は中断されません。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The time-out value is negative and is not equal to &lt;xref:System.Threading.Timeout.Infinite&gt;.</source>
          <target state="translated">タイムアウト値が負の値と等しくない&lt;xref:System.Threading.Timeout.Infinite&gt;。&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">指定した時間数の現在のスレッドを中断します。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">スレッドは、指定した時間、オペレーティング システムでの実行スケジュールされません。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">このメソッドに含める&lt;xref:System.Threading.ThreadState&gt;。&lt;/xref:System.Threading.ThreadState&gt;スレッドの状態を変更します。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>You can specify &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt; for the <ph id="ph1">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">指定できます&lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;の<ph id="ph1">`timeout`</ph>を無期限にスレッドを中断するパラメーター&lt;/xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt; 。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">ただし、使用ことお勧めするその他の&lt;xref:System.Threading?displayProperty=fullName&gt;などのクラス&lt;xref:System.Threading.Mutex&gt;、 &lt;xref:System.Threading.Monitor&gt;、 &lt;xref:System.Threading.EventWaitHandle&gt;、または&lt;xref:System.Threading.Semaphore&gt;代わりに「同期化スレッドにまたはリソースを管理します&lt;/xref:System.Threading.Semaphore&gt;&lt;/xref:System.Threading.EventWaitHandle&gt;&lt;/xref:System.Threading.Monitor&gt;&lt;/xref:System.Threading.Mutex&gt;&lt;/xref:System.Threading?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>This overload of &lt;xref:System.Threading.Thread.Sleep%2A&gt; uses the total number of whole milliseconds in <ph id="ph1">`timeout`</ph>.</source>
          <target state="translated">このオーバー ロード&lt;xref:System.Threading.Thread.Sleep%2A&gt;で整数のミリ秒単位の合計数を使用して<ph id="ph1">`timeout`</ph>&lt;/xref:System.Threading.Thread.Sleep%2A&gt;。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">小数ミリ秒は破棄されます。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">このメソッドでは、標準の COM および&amp;1; つは実行されません。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; かどうかのあるスレッドでスリープ状態にする必要があります&lt;xref:System.STAThreadAttribute&gt;、標準の COM および&amp;1; つを実行するためのオーバー ロードのいずれかの使用を検討するが、&lt;xref:System.Threading.Thread.Join%2A&gt;タイムアウト間隔を指定するメソッド&lt;/xref:System.Threading.Thread.Join%2A&gt;&lt;/xref:System.STAThreadAttribute&gt;。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">スレッドが中断される時間数。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">場合の値、<ph id="ph1">`millisecondsTimeout`</ph>引数は<ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>スレッドが実行する準備ができている同じ優先順位のスレッドに自らのタイム スライスの残りの部分を放棄します。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">実行する準備ができている同じ優先順位の他のスレッドがない場合は、現在のスレッドの実行は中断されません。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">値<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept>が負の値と等しくない<ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> (ミリ秒単位) より大きいまたは<ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> (ミリ秒)。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Causes a thread to wait the number of times defined by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">iterations</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">定義される時間だけ待機するスレッド、 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">iterations</ph> <ept id="p1">&lt;/code&gt;</ept>パラメーター。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The SpinWait method is useful for implementing locks.</source>
          <target state="translated">SpinWait メソッドは、ロックを実装するために便利です。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>Classes in the .NET Framework, such as &lt;xref:System.Threading.Monitor&gt; and &lt;xref:System.Threading.ReaderWriterLock&gt;, use this method internally.</source>
          <target state="translated">などの .NET framework クラス&lt;xref:System.Threading.Monitor&gt;と&lt;xref:System.Threading.ReaderWriterLock&gt;、このメソッドを内部的に使用します&lt;/xref:System.Threading.ReaderWriterLock&gt;&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>SpinWait essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph1">`iterations`</ph> parameter.</source>
          <target state="translated">SpinWait 本質的には、プロセッサに非常に短いループで指定されたループ カウントと、<ph id="ph1">`iterations`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">そのため、待機時間は、プロセッサの速度に依存します。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Contrast this with the &lt;xref:System.Threading.Thread.Sleep%2A&gt; method.</source>
          <target state="translated">これに対し、&lt;xref:System.Threading.Thread.Sleep%2A&gt;メソッド&lt;/xref:System.Threading.Thread.Sleep%2A&gt;。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>A thread that calls &lt;xref:System.Threading.Thread.Sleep%2A&gt; yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">呼び出すスレッド&lt;xref:System.Threading.Thread.Sleep%2A&gt;、指定した間隔が&amp;0; の場合でもプロセッサ時間の現在のスライスの残りの部分が得られます&lt;/xref:System.Threading.Thread.Sleep%2A&gt;。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Specifying a non-zero interval for &lt;xref:System.Threading.Thread.Sleep%2A&gt; removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">0 以外の間隔を指定する&lt;xref:System.Threading.Thread.Sleep%2A&gt;時間間隔が経過するまで、スレッド スケジューラによって考慮の対象からスレッドを削除します&lt;/xref:System.Threading.Thread.Sleep%2A&gt;。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>SpinWait is not generally useful for ordinary applications.</source>
          <target state="translated">SpinWait は通常のアプリケーションの一般的に便利です。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; or a statement that wraps &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; (<ph id="ph1">`lock`</ph> in C# or <ph id="ph2">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">ほとんどの場合は、.NET Framework によって提供される同期クラスを使用する必要があります。たとえば、呼び出す&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;またはラップするステートメント&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;(<ph id="ph1">`lock`</ph> (C#) または<ph id="ph2">`SyncLock`</ph>Visual Basic で).&lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; &lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the SpinWait method in your loop.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; わかっている場合、状態の変更が迫っていないかなどのコンテキストの切り替えを避けるためにメリットがあるまれなケースでは、ループで SpinWait メソッドへの呼び出しを確認します。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>The code SpinWait executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">SpinWait を実行するコードは、複数のプロセッサを搭載したコンピューターで発生する可能性がある問題を防ぐために設計されています。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, SpinWait prevents processor starvation in certain situations.</source>
          <target state="translated">たとえば、ハイパー スレッディング テクノロジを採用すること、複数の Intel プロセッサを搭載したコンピューター SpinWait に特定の状況でプロセッサ スタベーションができないようにします。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">スレッドが待機する時間を定義する 32 ビット符号付き整数。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">により、オペレーティング システムに現在のインスタンスの状態を変更する<bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">スレッドが、&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;状態にある場合、オペレーティング システムを使用すると実行をスケジュールできます&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">によって表されるメソッドの最初の行で実行するスレッドを開始、&lt;xref:System.Threading.ThreadStart&gt;または&lt;xref:System.Threading.ParameterizedThreadStart&gt;スレッド コンス トラクターに渡されるデリゲート&lt;/xref:System.Threading.ParameterizedThreadStart&gt;&lt;/xref:System.Threading.ThreadStart&gt;。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">開始への呼び出しで、呼び出し元スレッドをブロックしないことに注意してください。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If this overload is used with a thread created using a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; を使用して作成されたスレッドでこのオーバー ロードが使用されるかどうか、&lt;xref:System.Threading.ParameterizedThreadStart&gt;デリゲート<ph id="ph2">`null`</ph>スレッドによって実行されるメソッドに渡されます&lt;/xref:System.Threading.ParameterizedThreadStart&gt;。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">スレッドが終了すると、別の呼び出しでは再開できません<ph id="ph1">`Start`</ph>です。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">スレッドは既に開始されています。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">このスレッドを開始するのに十分なメモリがありません。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">により、オペレーティング システムに現在のインスタンスの状態を変更する<bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>、し、必要に応じて、スレッドが実行するメソッドによって使用されるデータを格納しているオブジェクトを提供します。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">スレッドが、&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;状態にある場合、オペレーティング システムを使用すると実行をスケジュールできます&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">によって表されるメソッドの最初の行で実行するスレッドを開始、&lt;xref:System.Threading.ThreadStart&gt;または&lt;xref:System.Threading.ParameterizedThreadStart&gt;スレッド コンス トラクターに渡されるデリゲート&lt;/xref:System.Threading.ParameterizedThreadStart&gt;&lt;/xref:System.Threading.ThreadStart&gt;。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">開始への呼び出しで、呼び出し元スレッドをブロックしないことに注意してください。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">スレッドが終了すると、別の呼び出しでは再開できません<ph id="ph1">`Start`</ph>です。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>This overload and the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">このオーバー ロードおよび&lt;xref:System.Threading.ParameterizedThreadStart&gt;デリゲート簡単にデータをスレッド プロシージャに渡すは手法を使用するタイプ セーフであるため、任意のオブジェクトは、このオーバー ロードに渡すことができます&lt;/xref:System.Threading.ParameterizedThreadStart&gt;。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">データをスレッド プロシージャに渡すより堅牢な方法は、ワーカーのオブジェクトをスレッド プロシージャと、データ フィールドの両方にです。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。<bpt id="p1">[</bpt>スレッドの作成と開始時にデータを渡す<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">メソッドによって使用されるデータを格納しているオブジェクトのスレッドを実行します。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">スレッドは既に開始されています。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">このスレッドを開始するのに十分なメモリがありません。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>This thread was created using a <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate instead of a <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> delegate.</source>
          <target state="translated">このスレッドが使用して作成された、 <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>デリゲートの代わりに、 <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>を委任します。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">スレッドを中断しますか、スレッドが既に中断されている場合も何も起こりません。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">スレッドが既に中断されている場合は、このメソッドに効果がありません。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Do not use the Suspend and &lt;xref:System.Threading.Thread.Resume%2A&gt; methods to synchronize the activities of threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; サスペンドを使用しないと&lt;xref:System.Threading.Thread.Resume%2A&gt;スレッドの活動を同期する方法&lt;/xref:System.Threading.Thread.Resume%2A&gt;。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">中断した場合に実行されているコードのスレッドを知ることがあるありません。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the &lt;xref:System.AppDomain&gt; might be blocked.</source>
          <target state="translated">その他のスレッドでのセキュリティ権限の評価中にロックを保持しているスレッドを中断した場合、&lt;xref:System.AppDomain&gt;ブロックされる可能性があります&lt;/xref:System.AppDomain&gt;。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the &lt;xref:System.AppDomain&gt; that attempt to use that class are blocked.</source>
          <target state="translated">その他のスレッドでのクラスのコンス トラクターの実行中にスレッドを中断した場合、&lt;xref:System.AppDomain&gt;クラスがブロックされていることを使用しようとする&lt;/xref:System.AppDomain&gt;。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">デッドロックは、非常に簡単に発生することができます。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">スレッドは、開始されていないか、停止します。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">呼び出し元は、適切なありません<bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">一連の名前を対応する一連のディスパッチ識別子にマップします。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">将来の使用のために予約されています。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Iid_ にする必要があります。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">渡された配列名をマップできるのです。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
          <target state="translated">マップする、名前の数。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">名前を解釈するロケール コンテキスト。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">名前に対応する Id を受け取る、呼び出し元が割り当てた配列。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">COM を使用して遅延バインディング アクセス<ph id="ph1">`IDispatch`</ph>インターフェイスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">インターフェイスの型情報を取得するために使用するオブジェクトの型情報を取得します。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::GetTypeInfo`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
          <target state="translated">返される型情報。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
          <target state="translated">型情報のロケールの識別子です。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">要求された型情報オブジェクトへのポインターを受け取ります。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">COM を使用して遅延バインディング アクセス<ph id="ph1">`IDispatch`</ph>インターフェイスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">オブジェクトが (0 または 1) を提供する型情報インターフェイスの数を取得します。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">オブジェクトによって提供される型情報インターフェイスの数を受け取る場所へのポインター。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">COM を使用して遅延バインディング アクセス<ph id="ph1">`IDispatch`</ph>インターフェイスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">プロパティとオブジェクトによって公開されたメソッドへのアクセスを提供します。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::Invoke`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
          <target state="translated">メンバーを識別します。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">将来の使用のために予約されています。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Iid_ にする必要があります。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">引数を解釈する対象のロケール コンテキスト。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
          <target state="translated">呼び出しのコンテキストを記述するフラグ。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">引数の配列、名前付き引数、および各配列内の要素の数のカウントの引数 Dispid の配列を含む構造体へのポインター。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">結果が格納される場所へのポインター。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">例外情報を格納する構造体へのポインター。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">エラーが発生した最初の引数のインデックス。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">COM を使用して遅延バインディング アクセス<ph id="ph1">`IDispatch`</ph>インターフェイスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">現在のスレッドの状態を示す値を取得します。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>The ThreadState property provides more specific information than the &lt;xref:System.Threading.Thread.IsAlive%2A&gt; property.</source>
          <target state="translated">ThreadState プロパティよりも詳細な情報を提供する、&lt;xref:System.Threading.Thread.IsAlive%2A&gt;プロパティ&lt;/xref:System.Threading.Thread.IsAlive%2A&gt;。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; スレッドの状態は、デバッグ シナリオに必要になります。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">コードは、スレッドの活動を同期するためにスレッドの状態を使用する必要がありますしないでください。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the state of the current thread.</source>
          <target state="translated">1 つ、 <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>現在のスレッドの状態を示す値。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">初期値は<bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">開始される前に、スレッドのアパートメント状態を設定します。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">新しいスレッドとして初期化される&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;が開始される前にそのアパートメント状態が設定されていないかどうか&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">スレッドを開始する前に、アパートメントの状態を設定する必要があります。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; をメイン アプリケーション スレッドが初期化される&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;既定&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">アプリケーションのメイン スレッドのアパートメント状態を設定する唯一の方法&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;を適用する、&lt;xref:System.STAThreadAttribute&gt;属性をエントリ ポイント メソッドです&lt;/xref:System.STAThreadAttribute&gt;&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>The TrySetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">TrySetApartmentState メソッドと共に、&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;メソッドおよび&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;メソッド、置換、&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;プロパティ&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt;&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;&lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">新しいアパートメント状態。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the apartment state is set; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>アパートメント状態が設定されている場合それ以外の場合、 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>有効なアパートメント状態ではありません。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">スレッドは既に開始されています。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">VolatileRead と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, VolatileRead obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムでは、VolatileRead は、いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システムでは、VolatileRead 上でもと&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを VolatileRead または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;使用する必要があります。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子 VolatileRead または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">フィールドの値を読み取ります。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">読み取られるフィールド。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;VolatileWrite が同期の特殊なケース用です。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, VolatileWrite ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで VolatileWrite はメモリの場所に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;VolatileWrite ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされずします&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または VolatileWrite&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; に C# の場合を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または VolatileWrite&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;および&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;同期の特殊な場合は&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">通常の状況で、c#<ph id="ph1">`lock`</ph>ステートメントでは、Visual Basic<ph id="ph2">`SyncLock`</ph>ステートメント、および&lt;xref:System.Threading.Monitor&gt;クラスは、簡単に選択肢を提供します&lt;/xref:System.Threading.Monitor&gt;。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">マルチプロセッサ システムで&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">これにより、プロセッサ キャッシュのフラッシュが必要です。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">ユニプロセッサ システム上でも&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;と&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">フィールドの効果的な同期を提供するに&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 、フィールドへのすべてのアクセスを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; で c# を使用して、<ph id="ph2">`volatile`</ph>フィールド修飾子&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;または&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;フィールドへのすべてのアクセスを使用していることを保証</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">値を書き込むフィールド。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">書き込む値。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">現在のプロセッサで実行する準備が整っている別のスレッドに実行を譲渡して呼び出し元のスレッドをによりします。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">オペレーティング システムでは、切り替え先のスレッドを選択します。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">このメソッドが成功した場合、スレッドの現在のタイム スライスの残りの部分が返されます。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">オペレーティング システムでは、その優先順位と実行に使用できるその他のスレッドのステータスに応じて、別のタイム スライスの呼び出し元のスレッドをスケジュールします。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">応答は、呼び出し元のスレッドを実行しているプロセッサに制限されます。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">プロセッサがアイドル状態または優先順位の低いスレッドが実行されている場合でも、オペレーティング システムは、別のプロセッサに実行を切り替えられません。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">現在のプロセッサで実行する準備ができている他のスレッドが存在しないかどうかは、オペレーティング システムでは、実行を生成しませんし、このメソッドが戻る<ph id="ph1">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">このメソッドは、ネイティブ Win32 プラットフォームを使用して呼び出し<ph id="ph1">`SwitchToThread`</ph>関数。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>You should call the Yield method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">呼び出す必要がありますプラットフォームを使用する代わりにメソッドを呼び出す、Yield プラットフォーム呼び出しのバイパスのため、ホストが要求したカスタム スレッドの動作です。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the operating system switched execution to another thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>オペレーティング システムによって実行を別のスレッドに切り替えられた場合それ以外の場合、 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>