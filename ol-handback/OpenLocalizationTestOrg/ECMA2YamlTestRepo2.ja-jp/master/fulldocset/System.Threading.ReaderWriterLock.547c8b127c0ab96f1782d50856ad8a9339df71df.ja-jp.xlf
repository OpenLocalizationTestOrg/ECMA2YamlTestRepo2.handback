<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ec4eb6abc1cdf4de3aec918a6749eb637feb389</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.ReaderWriterLock.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa260b1ec5f3c114c5ac5367d66c001eda77b1ee</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc33aa4e80118dfe4cd1a4cad4ba16b2cf1248f7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines a lock that supports single writers and multiple readers.</source>
          <target state="translated">単一ライターと複数の読み取りをサポートするロックを定義します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The <ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph> has two reader-writer locks, &lt;xref:System.Threading.ReaderWriterLockSlim&gt; and ReaderWriterLock.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;、<ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph>が&amp;2; つのリーダー ライター ロック&lt;xref:System.Threading.ReaderWriterLockSlim&gt;と ReaderWriterLock&lt;/xref:System.Threading.ReaderWriterLockSlim&gt; 。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is recommended for all new development.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;すべての新しい開発をお勧めします。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;ReaderWriterLock に似ていますが、再帰、アップグレード、およびロックの状態をダウン グレードの規則が簡素化されますがします。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; avoids many cases of potential deadlock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;多くの場合の潜在的なデッドロックを回避できます。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In addition, the performance of &lt;xref:System.Threading.ReaderWriterLockSlim&gt; is significantly better than ReaderWriterLock.</source>
          <target state="translated">さらに、パフォーマンスの&lt;xref:System.Threading.ReaderWriterLockSlim&gt;は ReaderWriterLock よりも大幅に向上します&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ReaderWriterLock is used to synchronize access to a resource.</source>
          <target state="translated">ReaderWriterLock がリソースへのアクセスを同期するために使用されます。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</source>
          <target state="translated">任意の時点で、いずれかの複数のスレッドの同時実行の読み取りアクセスまたは単一のスレッドの書き込みアクセスできます。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In a situation where a resource is changed infrequently, a <ph id="ph1">`ReaderWriterLock`</ph> provides better throughput than a simple one-at-a-time lock, such as &lt;xref:System.Threading.Monitor&gt;.</source>
          <target state="translated">まれに、リソースが変更されている状況では、 <ph id="ph1">`ReaderWriterLock`</ph> &lt;xref:System.Threading.Monitor&gt;.&lt;/xref:System.Threading.Monitor&gt;など、単純な時間での&amp;1; つロックよりスループットの向上を提供します。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ReaderWriterLock`</ph> works best where most accesses are reads, while writes are infrequent and of short duration.</source>
          <target state="translated"><ph id="ph1">`ReaderWriterLock`</ph>多くのアクセスは読み取り、書き込みは頻繁には、および短い期間の最適なは。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</source>
          <target state="translated">複数のリーダーの代替と単一ライターは、リーダーでもライターが長時間にわたってブロックできるようにします。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Holding reader locks or writer locks for long periods will starve other threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 長期間には、他のスレッドがによってが阻害のロックのリーダーまたはライター ロックを保持します。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For best performance, consider restructuring your application to minimize the duration of writes.</source>
          <target state="translated">最適なパフォーマンスは、書き込みの時間を最小限に抑える、アプリケーションを再構築を検討してください。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>A thread can hold a reader lock or a writer lock, but not both at the same time.</source>
          <target state="translated">ロックまたはライター ロックでは、両方ではなく、同時に、スレッドは、リーダーを保持できます。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Instead of releasing a reader lock in order to acquire the writer lock, you can use &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;.</source>
          <target state="translated">ライター ロックを取得するために、リーダー ロックを解放するのではなく&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;を使用することができます。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Recursive lock requests increase the lock count on a lock.</source>
          <target state="translated">再帰的なロックの要求は、ロックのロック カウントを増やします。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Readers and writers are queued separately.</source>
          <target state="translated">リーダーとライターとは別にキューにあります。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</source>
          <target state="translated">スレッドがライター ロックを解放すると、その時点で、リーダーのキューで待機しているすべてのスレッドは、リーダー ロックが許可されます。ときにリーダー ロックをすべてがリリースされた、次のスレッドで待機している、ライター、ライター ロックが許可された場合、キューに表示され、します。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In other words, <ph id="ph1">`ReaderWriterLock`</ph> alternates between a collection of readers, and one writer.</source>
          <target state="translated">つまり、<ph id="ph1">`ReaderWriterLock`</ph>リーダーのコレクションと&amp;1; つのライターの代替です。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</source>
          <target state="translated">ライター キュー内のスレッドが待機中のアクティブ リーダー ロックが解放されるため、新しいリーダー ロックを要求するスレッドは、リーダーのキューに蓄積されます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</source>
          <target state="translated">自身の要求が与えられていない場合でも、者既存リーダー ロック; への同時アクセスを共有する可能性があります。これにより、リーダーによって無期限進行を妨げているに対してライターを保護します。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Most methods for acquiring locks on a <ph id="ph1">`ReaderWriterLock`</ph> accept time-out values.</source>
          <target state="translated">ほとんどのメソッドでロックの獲得、<ph id="ph1">`ReaderWriterLock`</ph>タイムアウト値をそのまま使用します。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Use time-outs to avoid deadlocks in your application.</source>
          <target state="translated">アプリケーションでデッドロックを回避するのにには、タイムアウトを使用します。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</source>
          <target state="translated">たとえば、スレッドが&amp;1; つのリソースにライター ロックを取得し、2 番目のリソースで、リーダー ロックを要求可能性があります。その間は、別のスレッドは、2 番目のリソースにライター ロックを取得し、最初のリーダー ロックを要求します。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Unless time-outs are used, the threads deadlock.</source>
          <target state="translated">タイムアウトを使用しない場合、スレッドのデッドロック。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">メソッドが、 &lt;xref:System.ApplicationException&gt;。&lt;/xref:System.ApplicationException&gt;スローすることによって、呼び出し元スレッドにコントロールを返します、タイムアウト期限が切れた場合、ロック要求が許可されていません</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A thread can catch this exception and determine what action to take next.</source>
          <target state="translated">スレッドは、この例外をキャッチし、[次へ] を実行するアクションを決定できます。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Time-outs are expressed in milliseconds.</source>
          <target state="translated">タイムアウトはミリ秒単位で表されます。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you use a &lt;xref:System.TimeSpan?displayProperty=fullName&gt; to specify the time-out, the value used is the total number of whole milliseconds represented by the &lt;xref:System.TimeSpan&gt;.</source>
          <target state="translated">&lt;xref:System.TimeSpan?displayProperty=fullName&gt;使用される値ではタイムアウトを指定する、 &lt;xref:System.TimeSpan&gt;。&lt;/xref:System.TimeSpan&gt;によって表される整数のミリ秒単位の合計数&lt;/xref:System.TimeSpan?displayProperty=fullName&gt;を使用する場合</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following table shows the valid time-out values in milliseconds.</source>
          <target state="translated">次の表は、ミリ秒単位で有効なタイムアウト値を示します。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>|Value|Description|   |-----------|-----------------|   |-1|The thread waits until the lock is acquired, regardless of how long it takes.</source>
          <target state="translated">|値 |説明 |  |-----------|-----------------|  |-1 |スレッドは、所要時間に関係なく、ロックが取得されるまで待機します。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For methods that specify integer time-outs, the constant &lt;xref:System.Threading.Timeout.Infinite&gt; can be used.|   |0|The thread does not wait to acquire the lock.</source>
          <target state="translated">整数のタイムアウトを指定する方法、&lt;xref:System.Threading.Timeout.Infinite&gt;定数を使用できます |。  |&amp;0; |スレッドが、ロックの取得を待機しません&lt;/xref:System.Threading.Timeout.Infinite&gt;。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If the lock cannot be acquired immediately, the method returns.|   |&gt;0|The number of milliseconds to wait.|       With the exception of -1, negative time-out values are not allowed.</source>
          <target state="translated">かどうか、ロックをすぐに取得できない、メソッドが返されます |。  | &gt;&amp;0; |待機するミリ秒数です |。      -1 以外の負の値のタイムアウト値は許可されません。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you specify a negative integer other than -1, a time-out value of zero is used instead.</source>
          <target state="translated">-1 以外の負の整数を指定すると、0 のタイムアウト値が代わりに使用されます。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a &lt;xref:System.TimeSpan&gt; that represents a negative number of milliseconds other than -1, &lt;xref:System.ArgumentOutOfRangeException&gt; is thrown.</source>
          <target state="translated">(つまり、メソッドを返します、待機せず、ロックをすぐに取得できない場合。)指定した場合、 &lt;xref:System.TimeSpan&gt;、負の値を-1 以外のミリ秒数を表す&lt;xref:System.ArgumentOutOfRangeException&gt;がスローされます&lt;/xref:System.ArgumentOutOfRangeException&gt;&lt;/xref:System.TimeSpan&gt;。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">新しいインスタンスを初期化、 <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>クラスです。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">リーダーの取得を使用してロック、&lt;xref:System.Int32&gt;のタイムアウト値&lt;/xref:System.Int32&gt;。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>AcquireReaderLock blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">別のスレッドがあるライター ロック場合、または少なくとも&amp;1; つのスレッドがライター ロックを待機している場合、AcquireReaderLock がブロックされます。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;、現在のスレッドは、ライター ロックを既に持っている場合は、リーダー ロックは取得されません。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">代わりに、ライター ロックのロック カウントがインクリメントされます。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">これは、スレッドがライター ロックでブロックすることを防ぎます。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">結果は、呼び出した場合と同じでは正確に&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;、および呼び出しを&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;はライター ロックを解放する場合に必要です&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>再帰的なリーダー ロック要求をサポートしています。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">スレッドできます AcquireReaderLock を複数回呼び出し、毎回ロック カウントをインクリメントします。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">呼び出す必要があります&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;を呼び出すたびに&amp;1; 回<ph id="ph1">`AcquireReaderLock`</ph>&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">代わりに、呼び出すことができます&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;、すぐにゼロにロックの数を減らします&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">再帰的なロックの要求は必ずリーダー キューに要求元のスレッドをかけることがなく、すぐに許可されます。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">注意、して再帰的なロックを使用して、長期にわたってライター ロック要求がブロックされないようにします。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有効なタイムアウト値&lt;xref:System.Threading.ReaderWriterLock&gt;。&lt;/xref:System.Threading.ReaderWriterLock&gt;を参照してください。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">ミリ秒単位のタイムアウト。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>ロック要求を許可する前に期限が切れます。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">リーダーの取得を使用してロック、&lt;xref:System.TimeSpan&gt;のタイムアウト値&lt;/xref:System.TimeSpan&gt;。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt; blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;少なくとも&amp;1; つのスレッドがライター ロックを待機している場合または別のスレッドがライター ロックをブロックします。&lt;/xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;、現在のスレッドは、ライター ロックを既に持っている場合は、リーダー ロックは取得されません。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">代わりに、ライター ロックのロック カウントがインクリメントされます。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">これは、スレッドがライター ロックでブロックすることを防ぎます。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">結果は、呼び出した場合と同じでは正確に&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;、および呼び出しを&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;はライター ロックを解放する場合に必要です&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>再帰的なリーダー ロック要求をサポートしています。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">スレッドできます AcquireReaderLock を複数回呼び出し、毎回ロック カウントをインクリメントします。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">呼び出す必要があります&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;を呼び出すたびに&amp;1; 回<ph id="ph1">`AcquireReaderLock`</ph>&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">代わりに、呼び出すことができます&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;、すぐにゼロにロックの数を減らします&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">再帰的なロックの要求は必ずリーダー キューに要求元のスレッドをかけることがなく、すぐに許可されます。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">注意、して再帰的なロックを使用して、長期にわたってライター ロック要求がブロックされないようにします。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有効なタイムアウト値&lt;xref:System.Threading.ReaderWriterLock&gt;。&lt;/xref:System.Threading.ReaderWriterLock&gt;を参照してください。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated">A <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>タイムアウト期間を指定します。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>ロック要求を許可する前に期限が切れます。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>-1 ミリ秒以外の負の値を指定します。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">ライターの取得を使用してロック、&lt;xref:System.Int32&gt;のタイムアウト値&lt;/xref:System.Int32&gt;。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">このメソッドは、別のスレッドがリーダー ロックまたは書き込みロックをブロックします。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">方法の詳細については、複数の同時実行リーダー ロックをライター ロック代替は、&lt;xref:System.Threading.ReaderWriterLock&gt;クラス&lt;/xref:System.Threading.ReaderWriterLock&gt;を参照してください。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">既にリーダー ロックを保持しているスレッドが&amp;2; つの方法のいずれかでライター ロックを取得できます: しているを呼び出す前に、リーダー ロックを解放するか、 &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;を呼び出すことによって</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; スレッドが呼び出す場合<ph id="ph2">`AcquireWriterLock`</ph>リーダー ロックがまだあるときに、リーダー ロックでブロック以外の場合は、スレッドはデッドロック状態無限のタイムアウトが指定されている場合。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">このようなデッドロックを避けるためには、次のように使用します&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;を現在のスレッドがリーダー ロックを既にかどうかを判断します。&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; 。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>再帰的なライター ロック要求をサポートしています。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">スレッドを呼び出すことができます、 <ph id="ph1">`AcquireWriterLock`</ph> 、複数回これロック カウントをインクリメントするたびにします。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">呼び出す必要があります&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;を呼び出すたびに&amp;1; 回<ph id="ph1">`AcquireWriterLock`</ph>&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">代わりに、呼び出すことができます&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;、すぐにゼロにロックの数を減らします&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">再帰的なロックの要求は必ずライター キューに要求元のスレッドをかけることがなく、すぐに許可されます。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有効なタイムアウト値&lt;xref:System.Threading.ReaderWriterLock&gt;。&lt;/xref:System.Threading.ReaderWriterLock&gt;を参照してください。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">ミリ秒単位のタイムアウト。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>ロック要求を許可する前に期限が切れます。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">ライターの取得を使用してロック、&lt;xref:System.TimeSpan&gt;のタイムアウト値&lt;/xref:System.TimeSpan&gt;。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">このメソッドは、別のスレッドがリーダー ロックまたは書き込みロックをブロックします。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">方法の詳細については、複数の同時実行リーダー ロックをライター ロック代替は、&lt;xref:System.Threading.ReaderWriterLock&gt;クラス&lt;/xref:System.Threading.ReaderWriterLock&gt;を参照してください。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">既にリーダー ロックを保持しているスレッドが&amp;2; つの方法のいずれかでライター ロックを取得できます: を呼び出す前に、リーダー ロックを解放&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;、または&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;を呼び出すことによって&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; スレッドが呼び出す場合<ph id="ph2">`AcquireWriterLock`</ph>リーダー ロックがまだあるときに、リーダー ロックでブロック以外の場合は、スレッドはデッドロック状態無限のタイムアウトが指定されている場合。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">このようなデッドロックを避けるためには、次のように使用します&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;を現在のスレッドがリーダー ロックを既にかどうかを判断します。&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; 。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>再帰的なライター ロック要求をサポートしています。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">スレッドを呼び出すことができます、 <ph id="ph1">`AcquireWriterLock`</ph> 、複数回これロック カウントをインクリメントするたびにします。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">呼び出す必要があります&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;を呼び出すたびに&amp;1; 回<ph id="ph1">`AcquireWriterLock`</ph>&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">代わりに、呼び出すことができます&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;、すぐにゼロにロックの数を減らします&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">再帰的なロックの要求は必ずライター キューに要求元のスレッドをかけることがなく、すぐに許可されます。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有効なタイムアウト値&lt;xref:System.Threading.ReaderWriterLock&gt;。&lt;/xref:System.Threading.ReaderWriterLock&gt;を参照してください。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>タイムアウト期間を指定します。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>ロック要求を許可する前に期限が切れます。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>-1 ミリ秒以外の負の値を指定します。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</source>
          <target state="translated">シーケンス番号を取得してから、任意のスレッドにライター ロックを付与されているかどうかを示します。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You can use &lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt; and <ph id="ph1">`AnyWritersSince`</ph> to improve application performance.</source>
          <target state="translated">使用することができます&lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;と<ph id="ph1">`AnyWritersSince`</ph>アプリケーションのパフォーマンスを向上させるためにします&lt;/xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">たとえば、スレッドがリーダー ロックを保持しているときに取得した情報をキャッシュする可能性があります。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>After releasing and later reacquiring the lock, the thread can use <ph id="ph1">`AnyWritersSince`</ph> to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</source>
          <target state="translated">解放した後、ロックを取得した場合、スレッドを使用できる<ph id="ph1">`AnyWritersSince`</ph>を決定するかどうか他のスレッドがリソース以外に、一時的に書き込まれたかどうか、キャッシュされた情報を使用できます。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">この手法は、高価です。 ここでは、ロックで保護された情報を読み取る役立ちますたとえば、データベース クエリを実行しています。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">呼び出し元は、シーケンス番号を使用するために、リーダー ロックまたは書き込みロック保持する必要があります。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The sequence number.</source>
          <target state="translated">シーケンス番号。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>ライター ロックは、シーケンス番号が取得された; してから、任意のスレッドに付与されている場合それ以外の場合、 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt; was called.</source>
          <target state="translated">前に、のスレッドのロックの状態に復元&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;が呼び出されました&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>DowngradeFromWriterLock releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</source>
          <target state="translated">DowngradeFromWriterLock は再帰的なロック数に関係なく、ライター ロックを解放し、リーダー ロックをライター ロックにアップグレードする前に、スレッドによって保持されたを復元します。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The lock count on the reader lock is restored.</source>
          <target state="translated">リーダー ロックのロック カウントが復元されます。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph><ph id="ph2"> &gt;  </ph><ph id="ph3">`DowngradeFromWriterLock`</ph> accepts a &lt;xref:System.Threading.LockCookie&gt; obtained by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> <ph id="ph2"> &gt;  </ph> <ph id="ph3">`DowngradeFromWriterLock`</ph> &lt;xref:System.Threading.LockCookie&gt; &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;を呼び出すことによって取得&lt;/xref:System.Threading.LockCookie&gt;を受け入れる</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Do not use a <ph id="ph1">`LockCookie`</ph> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">使用しないで、 <ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;によって返される</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</source>
          <target state="translated">スレッドをブロックしませんライター ロックからダウン グレードするとき、ライター ロックが解放されるときに、すべてのリーダー ロック要求が与えられているために、他のスレッドがライター ロックを待機している場合でも。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;によって返される</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">スレッドには、ライター ロックはありません。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">アドレス<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept> null ポインターです。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">リソースが解放され、ガベージ コレクターがクリアするときに他のクリーンアップ操作が実行されることにより、 <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>オブジェクト。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The garbage collector calls Finalize when the current &lt;xref:System.Threading.ReaderWriterLock&gt; object is ready to be finalized.</source>
          <target state="translated">ガベージ コレクターの呼び出しの最終処理時に現在&lt;xref:System.Threading.ReaderWriterLock&gt;オブジェクトが完了する準備ができています&lt;/xref:System.Threading.ReaderWriterLock&gt;。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds a reader lock.</source>
          <target state="translated">現在のスレッドがリーダー ロックを保持しているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds a reader lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>現在のスレッドがリーダー ロックを保持している場合それ以外の場合、 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds the writer lock.</source>
          <target state="translated">現在のスレッドがライター ロックを保持しているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds the writer lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>現在のスレッドがライター ロックを保持している場合それ以外の場合、 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>です。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Releases the lock, regardless of the number of times the thread acquired the lock.</source>
          <target state="translated">スレッドがロックを取得した回数に関係なく、ロックを解放します。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count.</source>
          <target state="translated">ReleaseLock は、リーダー ロックまたは再帰的なロック数に関係なく、ライター ロックを解放します。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>To restore the state of the lock, including the lock count, pass the &lt;xref:System.Threading.LockCookie&gt; to &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">ロック数など、ロックの状態を復元するには渡す&lt;xref:System.Threading.LockCookie&gt;&lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt; &lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value representing the released lock.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>解放されたロックを表す値です。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Decrements the lock count.</source>
          <target state="translated">ロック カウントをデクリメントします。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>ReleaseReaderLock decrements the lock count.</source>
          <target state="translated">ロック カウントを ReleaseReaderLock デクリメントします。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>When the count reaches zero, the lock is released.</source>
          <target state="translated">カウントが&amp;0; になったときに、ロックが解放されます。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has the writer lock, calling <ph id="ph2">`ReleaseReaderLock`</ph> has the same effect as calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; スレッドにライター ロックがある場合は、呼び出す<ph id="ph2">`ReleaseReaderLock`</ph> &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;を呼び出す場合と同じ効果</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If a thread has no locks, calling <ph id="ph1">`ReleaseReaderLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">ロックがスレッドがない場合は、呼び出す<ph id="ph1">`ReleaseReaderLock`</ph> &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;がスローされます</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The thread does not have any reader or writer locks.</source>
          <target state="translated">スレッドには、すべてのリーダーまたはライター ロックはありません。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Decrements the lock count on the writer lock.</source>
          <target state="translated">ライター ロックのロックをカウントをデクリメントします。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>ReleaseWriterLock decrements the writer lock count.</source>
          <target state="translated">ライター ロック カウントを保持デクリメントします。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When the count reaches zero, the writer lock is released.</source>
          <target state="translated">カウントには、ゼロに達すると、ライター ロックは解放されます。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has a reader lock, or no locks, calling <ph id="ph2">`ReleaseWriterLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; スレッドに、リーダー ロックまたはロックしない場合は、呼び出す<ph id="ph2">`ReleaseWriterLock`</ph> &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;がスローされます</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">スレッドには、ライター ロックはありません。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;を呼び出す前に、スレッドのロックの状態を復元します。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The state restored by <ph id="ph1">`RestoreLock`</ph> includes the recursive lock count.</source>
          <target state="translated">によって復元状態<ph id="ph1">`RestoreLock`</ph>再帰的なロック数が含まれています。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</source>
          <target state="translated">スレッドがブロックを別のスレッドがライター ロックを取得した後、または別のスレッドがリーダー ロックまたは書き込みロックが取得した後にライター ロックを復元しようとすると、リーダー ロックを復元しようとするとします。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`RestoreLock`</ph> does not accept a time-out, you should take care to avoid possible deadlocks.</source>
          <target state="translated"><ph id="ph1">`RestoreLock`</ph>タイムアウトを受け入れません。 可能なデッドロックを回避するように注意する必要があります。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Before calling <ph id="ph2">`RestoreLock`</ph>, make sure you have released all locks acquired since the call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 呼び出す前に<ph id="ph2">`RestoreLock`</ph>、 &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;への呼び出し以降取得したすべてのロックを解放することを確認してください</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</source>
          <target state="translated">たとえば、スレッドはデッドロック状態リーダー ロックを取得し、以前のライター ロックの復元を試みます。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; to detect such additional locks.</source>
          <target state="translated">使用して&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;と&lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt;をこのようなその他のロックを検出します&lt;/xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt;&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Do not use a &lt;xref:System.Threading.LockCookie&gt; returned from &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Threading.LockCookie&gt; &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;から返された&lt;/xref:System.Threading.LockCookie&gt;を使用しないでください。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;によって返される</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">アドレス<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept> null ポインターです。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using an <bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">アップグレード、リーダー ロックをライター ロックを使用して、 <bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>のタイムアウト値。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">スレッドを呼び出すと<ph id="ph1">`UpgradeToWriterLock`</ph>ロック カウントに関係なく、リーダー ロックが解放され、スレッドがライター ロックをキューの末尾に移動します。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">したがって、他のスレッドがライター ロックが許可されるは、アップグレードを要求したスレッドの前に、リソースに書き込むことがあります。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 保持メソッドを呼び出したスレッドがリーダー ロックを再取得できるまでタイムアウト例外はスローされません。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">ライター ロックを待機している他のスレッドがない場合は、この直ちに行われます。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>However, if another thread is queued for the writer lock, the thread that called the UpgradeToWriterLock method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">ただし、別のスレッドがライター ロックをキューに配置される場合保持メソッドを呼び出したスレッドことはできません再取得リーダー ロック解放されるまで現在のすべての読み込みが、ロックが&amp;1; つのスレッドを取得およびライター ロックを解放します。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the UpgradeToWriterLock method.</source>
          <target state="translated">これは、機能は、ライター ロックを要求したその他のスレッドを要求して、現在のスレッドに保持メソッドが呼び出された後に場合でも同様です。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">ロックの状態を復元するには、呼び出す&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;を使用して、&lt;xref:System.Threading.LockCookie&gt;によって返される<ph id="ph1">`UpgradeToWriterLock`</ph>&lt;/xref:System.Threading.LockCookie&gt;&lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">これを使用しないでください<ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt; 。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">スレッドがリーダー ロックを持たない場合は使用しないで<ph id="ph1">`UpgradeToWriterLock`</ph>です。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">使用して&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;代わりにします&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有効なタイムアウト値&lt;xref:System.Threading.ReaderWriterLock&gt;。&lt;/xref:System.Threading.ReaderWriterLock&gt;を参照してください。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">ミリ秒単位のタイムアウト。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>ロック要求を許可する前に期限が切れます。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using a <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">アップグレード、リーダー ロックをライター ロックを使用して、 <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>のタイムアウト値。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">スレッドを呼び出すと<ph id="ph1">`UpgradeToWriterLock`</ph>ロック カウントに関係なく、リーダー ロックが解放され、スレッドがライター ロックをキューの末尾に移動します。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">したがって、他のスレッドがライター ロックが許可されるは、アップグレードを要求したスレッドの前に、リソースに書き込むことがあります。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method can reacquire the reader lock.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; を呼び出したスレッドまでタイムアウト例外はスローされません、&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;メソッドは、リーダー ロックを取得できます&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">ライター ロックを待機している他のスレッドがない場合は、この直ちに行われます。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>However, if another thread is queued for the writer lock, the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">ただし、別のスレッドがライター ロックをキューに登録する場合、スレッドを呼び出した関数、&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;すべて現在リーダーが、ロックを解放し、1 つのスレッドが取得およびライター ロックを解放するまで、メソッドがリーダー ロックを再取得できません&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method.</source>
          <target state="translated">これは、true の場合でも、ライター ロックを要求したその他のスレッドを要求して、現在のスレッドが呼び出された後に、&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;メソッド&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">ロックの状態を復元するには、呼び出す&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;を使用して、&lt;xref:System.Threading.LockCookie&gt;によって返される<ph id="ph1">`UpgradeToWriterLock`</ph>&lt;/xref:System.Threading.LockCookie&gt;&lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">これを使用しないでください<ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt; 。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">スレッドがリーダー ロックを持たない場合は使用しないで<ph id="ph1">`UpgradeToWriterLock`</ph>です。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">使用して&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;代わりにします&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有効なタイムアウト値&lt;xref:System.Threading.ReaderWriterLock&gt;。&lt;/xref:System.Threading.ReaderWriterLock&gt;を参照してください。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>タイムアウト期間を指定します。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>ロック要求を許可する前に期限が切れます。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>-1 ミリ秒以外の負の値を指定します。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Gets the current sequence number.</source>
          <target state="translated">現在のシーケンス番号を取得します。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The sequence number increases whenever a thread acquires the writer lock.</source>
          <target state="translated">シーケンス番号は、スレッドがライター ロックを取得するたびに増加します。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>You can save the sequence number and pass it to &lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt; at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</source>
          <target state="translated">シーケンス番号を保存してに渡す&lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;は後で、他のスレッドがライター ロックを当面の間に取得したかどうかを判断する場合&lt;/xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`WriterSeqNum`</ph> to improve application performance.</source>
          <target state="translated">使用することができます<ph id="ph1">`WriterSeqNum`</ph>アプリケーションのパフォーマンスを向上させるためにします。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">たとえば、スレッドがリーダー ロックを保持しているときに取得した情報をキャッシュする可能性があります。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling <ph id="ph1">`AnyWritersSince`</ph>; if not, the cached information can be used.</source>
          <target state="translated">スレッドを解放した後、ロックを取得した場合、呼び出すことで、他のスレッドがリソースに書き込まれたかどうかを決定できます<ph id="ph1">`AnyWritersSince`</ph>以外の場合は、キャッシュされた情報を使用できます。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">ロックで保護されている情報の読み取りが高価です。 この手法が有用です。たとえば、データベース クエリを実行しています。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">呼び出し元は、シーケンス番号を使用するために、リーダー ロックまたは書き込みロック保持する必要があります。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The current sequence number.</source>
          <target state="translated">現在のシーケンス番号。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>