<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e5df80f20fb8f8e9d58d7fd51e841a9b301b1bb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.Thread.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">836a4a28ca4635685ece20dbbe7b56da6a73e287</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d53c4cef63a323cfe675bb4658023858adff4b10</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">Cria e controla um thread, define sua prioridade e obtém seu status.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">Quando um processo é iniciado, o common language runtime cria automaticamente um thread único em primeiro plano para executar o código do aplicativo.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">Junto com este thread principal do primeiro plano, um processo pode criar um ou mais threads para executar uma parte do código do programa associado ao processo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">Esses threads podem executar em primeiro plano ou no plano de fundo.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, you can use the &lt;xref:System.Threading.ThreadPool&gt; class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">Além disso, você pode usar o &lt;xref:System.Threading.ThreadPool&gt;classe para executar código em threads de trabalho que são gerenciados pelo common language runtime.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section       <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept>     <bpt id="p2">[</bpt>Retrieving Thread objects<ept id="p2">](#Retrieving)</ept>     <bpt id="p3">[</bpt>Foreground and background threads<ept id="p3">](#Foreground)</ept>     <bpt id="p4">[</bpt>Culture and threads<ept id="p4">](#Culture)</ept>     <bpt id="p5">[</bpt>Getting information about and controlling threads<ept id="p5">](#Properties)</ept>     <bpt id="p6">[</bpt>Accessing the source code for the Thread class<ept id="p6">](#Source)</ept>      <bpt id="p7">&lt;a name="Starting"&gt;</bpt><ept id="p7">&lt;/a&gt;</ept>    ## Starting a thread    You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">Nesta seção <bpt id="p1">[</bpt>iniciar um thread<ept id="p1">](#Starting)</ept><bpt id="p2">[</bpt>objetos Thread recuperando<ept id="p2">](#Retrieving)</ept><bpt id="p3">[</bpt>threads de primeiro plano e plano de fundo<ept id="p3">](#Foreground)</ept><bpt id="p4">[</bpt>cultura e threads<ept id="p4">](#Culture)</ept><bpt id="p5">[</bpt>Obtendo informações sobre e controlar threads<ept id="p5">](#Properties)</ept><bpt id="p6">[</bpt>acessar o código-fonte para a classe Thread<ept id="p6">](#Source)</ept> <bpt id="p7">&lt;a name="Starting"&gt;</bpt> <ept id="p7">&lt;/a&gt;</ept> # # iniciar um thread iniciar um thread, fornecendo um delegado que representa o método que o thread é executar o construtor de classe.                               </target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>You then call the &lt;xref:System.Threading.Thread.Start%2A&gt; method to begin execution.</source>
          <target state="translated">Em seguida, chamar o &lt;xref:System.Threading.Thread.Start%2A&gt;método para começar a execução.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Thread constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:      -   If the method has no arguments, you pass a &lt;xref:System.Threading.ThreadStart&gt; delegate to  the constructor.</source>
          <target state="translated">Os construtores de Thread podem ter um delegado de dois tipos, dependendo se você pode passar um argumento para o método a ser executado:-se o método não possui argumentos, você passar um &lt;xref:System.Threading.ThreadStart&gt;delegar para o construtor.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph>           The following example creates and starts a thread that executes the <ph id="ph3">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">Ele tem a assinatura: <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph> o exemplo a seguir cria e inicia um thread que executa o <ph id="ph3">`ExecuteInForeground`</ph> método.          </target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">O método exibe informações sobre algumas propriedades de thread e, em seguida, executa um loop no qual ele pausa por meio segundo e exibe o número decorrido de segundos.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">Quando o thread de execução pelo menos cinco segundos, o loop é encerrado e o thread finaliza a execução.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept><ept id="p3">]</ept>      -   If the method has an argument, you pass a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate to the constructor.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept> <ept id="p3">]</ept> -se o método tem um argumento, você passar um &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegar para o construtor.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;      </target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph>           The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">Ele tem a assinatura: <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph> o método executado pelo delegado pode, em seguida, converta (em c#) ou converter o parâmetro (no Visual Basic) para o tipo apropriado.          </target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example is identical to the previous one, except that it calls the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor.</source>
          <target state="translated">O exemplo a seguir é idêntico ao anterior, exceto que ele chama o &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;construtor.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">Esta versão do <ph id="ph1">`ExecuteInForeground`</ph> método tem um único parâmetro que representa o número aproximado de milissegundos que o loop é executado.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept><ept id="p3">]</ept>       It is not necessary to retain a reference to a Thread object once you have started the thread.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept> <ept id="p3">]</ept> não é necessário manter uma referência a um objeto de Thread depois de iniciar o thread.      </target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">O thread continua a executar até concluir o procedimento de thread.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Retrieving Thread objects    You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # Recuperar Thread objetos que você pode usar o static (<ph id="ph1">`Shared`</ph> no Visual Basic) &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;propriedade para recuperar uma referência para o thread em execução no momento do código que o thread está em execução.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">O exemplo a seguir usa o &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;propriedade para exibir informações sobre o thread principal do aplicativo, outro thread de primeiro plano, um thread em segundo plano e um pool de threads.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Foreground"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Foreground and background threads    Instances of the Thread class represent either foreground threads or background threads.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Foreground"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> # # instâncias da classe do Thread de threads de primeiro plano e plano de fundo representam threads de primeiro plano ou threads em segundo plano.        </target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">Threads em segundo plano são idênticos aos threads de primeiro plano com uma exceção: um thread em segundo plano não manter um processo em execução se todos os threads de primeiro plano tem sido encerrado.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">Depois que todos os threads de primeiro plano foram interrompidos, o tempo de execução interrompe todos os threads em segundo plano e desligado.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground:      -   The main application thread.</source>
          <target state="translated">Por padrão, os seguintes threads executam em primeiro plano:-o thread principal do aplicativo.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a Thread class constructor.</source>
          <target state="translated">-Todos os threads criados chamando um construtor de classe Thread.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following threads execute in the background by default:      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Os seguintes threads são executados em segundo plano por padrão:-Thread do pool de threads, que são um pool de threads de trabalho mantida pelo tempo de execução.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">Você pode configurar o trabalho de threads de pool e agenda em threads de pool usando a &lt;xref:System.Threading.ThreadPool&gt;classe.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Baseado em tarefas de operações assíncronas são executados automaticamente em threads de pool.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Task-based asynchronous operations use the &lt;xref:System.Threading.Tasks.Task&gt; and &lt;xref:System.Threading.Tasks.Task%601&gt; classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Usam operações assíncronas baseado em tarefas de &lt;xref:System.Threading.Tasks.Task&gt;e &lt;xref:System.Threading.Tasks.Task%601&gt;classes para implementar o <bpt id="p1">[</bpt>padrão assíncrono baseado em tarefa<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.&lt;/xref:System.Threading.Tasks.Task%601&gt; &lt;/xref:System.Threading.Tasks.Task&gt;</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-Todos os threads que insira o ambiente de execução gerenciado de código não gerenciado.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can change a thread to execute in the background by setting the &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property at any time.</source>
          <target state="translated">Você pode alterar um segmento a ser executado em segundo plano, definindo a &lt;xref:System.Threading.Thread.IsBackground%2A&gt;propriedade a qualquer momento.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">Threads em segundo plano são úteis para qualquer operação que deve continuar enquanto um aplicativo está em execução, mas não deve impedir que o aplicativo finalizando, como monitoramento de alterações do sistema de arquivos ou conexões de soquete de entrada.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">O exemplo a seguir ilustra a diferença entre os threads de primeiro plano e plano de fundo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">É como o primeiro exemplo de <bpt id="p1">[</bpt>iniciar um thread<ept id="p1">](#Starting)</ept> seção, exceto que ele define o thread seja executado em segundo plano antes de iniciá-lo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">Como mostra a saída, o loop é interrompido antes de ele ser executado por cinco segundos.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Culture"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Culture and threads    Each thread has a culture, represented by the &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt; property, and a UI culture, represented by the &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt; property.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Culture"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> # # cultura e threads cada thread tem uma cultura, representada pelo &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;propriedade e uma cultura de interface do usuário, representado pelo &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.CurrentUICulture%2A&gt; &lt;/xref:System.Threading.Thread.CurrentCulture%2A&gt;        </target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">A cultura atual oferece suporte a operações sensíveis à cultura como analisar e formatação, cadeia de caracteres de comparação e ordenação e também controla o sistema de escrita e o calendário usado por um thread.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">Fornece a cultura de interface do usuário atual para a recuperação sensíveis à cultura de recursos em arquivos de recurso.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">Quando um novo segmento é instanciado, sua cultura e cultura da interface do usuário são definidos pela cultura do sistema atual e cultura da interface do usuário e não pela cultura e cultura da interface do usuário do thread do qual o novo thread é criado.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">Isso significa que, por exemplo, que se a cultura atual do sistema for inglês (Estados Unidos) e a cultura atual do thread principal do aplicativo é francês (França), a cultura de um novo thread criado chamando o &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;construtor do thread principal é inglês (Estados Unidos) e francês (França).&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Para obter mais informações, consulte a seção "Cultura e threads" do &lt;xref:System.Globalization.CultureInfo&gt;tópico sobre a classe.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Isso não é possível de threads que executam operações assíncronas para aplicativos que têm como destino o <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> e versões posteriores, no caso, a cultura e cultura da interface do usuário é parte do contexto de um operações assíncronas; o thread em que uma operação assíncrona é executado por padrão herda a cultura e cultura da interface do usuário do thread do qual a operação assíncrona foi iniciada.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Para obter mais informações, consulte a seção "Cultura e baseado em tarefas de operações assíncronas" do &lt;xref:System.Globalization.CultureInfo&gt;tópico sobre a classe.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:      -   You can pass a &lt;xref:System.Globalization.CultureInfo&gt; object that represents that culture to the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate or the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; method.</source>
          <target state="translated">Você pode fazer o seguinte para garantir que todos os threads de execução em um aplicativo compartilham a mesma cultura e cultura da interface do usuário:-você pode passar um &lt;xref:System.Globalization.CultureInfo&gt;objeto que representa a cultura ao &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegar ou &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt;método.&lt;/xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; &lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt; and &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; properties.</source>
          <target state="translated">-Para aplicativos executados no <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> e versões posteriores, você pode definir a cultura e cultura da interface do usuário que deve ser atribuído a todos os threads criados em um domínio de aplicativo, definindo o valor da &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;e &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;Propriedades.&lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; &lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">Observe que essa é uma configuração de domínio de aplicativo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information and examples, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Para obter mais informações e exemplos, consulte a seção "Cultura e threads" do &lt;xref:System.Globalization.CultureInfo&gt;tópico sobre a classe.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Getting information about and controlling threads    You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # Obtendo informações sobre e controlando threads, você pode recuperar um número de valores de propriedade que fornecem informações sobre um segmento.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">Em alguns casos, você também pode definir esses valores de propriedade para controlar a operação do thread.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>These thread properties include:      -   A name.</source>
          <target state="translated">Essas propriedades de thread incluem:-um nome.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.Name%2A&gt; is a write-once property that you can use to identify a thread.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Name%2A&gt;é uma gravação-uma vez a propriedade que você pode usar para identificar um thread.&lt;/xref:System.Threading.Thread.Name%2A&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">O valor padrão é <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A hash code, which you can retrieve by calling the &lt;xref:System.Threading.Thread.GetHashCode%2A&gt; method.</source>
          <target state="translated">-Um código de hash, que você pode recuperar chamando o &lt;xref:System.Threading.Thread.GetHashCode%2A&gt;método.&lt;/xref:System.Threading.Thread.GetHashCode%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">O código hash pode ser usado para identificar exclusivamente um thread; para o tempo de vida do seu thread, seu código de hash não coincidirá com o valor de qualquer outro thread, independentemente do domínio de aplicativo do qual você pode obter o valor.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A thread ID.</source>
          <target state="translated">-A ID do thread.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the read-only &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">O valor de somente leitura &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;propriedade é atribuída pelo tempo de execução e identifica exclusivamente um thread dentro de seu processo.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Um sistema operacional <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> não tem nenhuma relação fixa a um thread gerenciado, como um host não gerenciado pode controlar a relação entre os threads gerenciados e não gerenciados.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">Especificamente, um host sofisticado pode usar o <bpt id="p1">[</bpt>API de hospedagem de CLR<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> para agendar muitos threads gerenciados no mesmo thread do sistema operacional, ou para mover um thread gerenciado entre threads diferentes do sistema operacional.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The thread's current state.</source>
          <target state="translated">-O estado do segmento atual.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the &lt;xref:System.Threading.ThreadState&gt; property.</source>
          <target state="translated">Durante sua existência, um thread é sempre em uma ou mais os estados definidos pelo &lt;xref:System.Threading.ThreadState&gt;propriedade.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A scheduling priority level, which is defined by the &lt;xref:System.Threading.ThreadPriority&gt; property.</source>
          <target state="translated">-Um nível de prioridade do agendamento, que é definido como o &lt;xref:System.Threading.ThreadPriority&gt;propriedade.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">Embora você possa definir esse valor para solicitar a prioridade do thread, não é garantido que ele ser respeitado pelo sistema operacional.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The read-only &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt; property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">-O somente leitura &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;propriedade, que indica se um thread é um pool de threads.&lt;/xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property.</source>
          <target state="translated">-A &lt;xref:System.Threading.Thread.IsBackground%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">Para obter mais informações, consulte o <bpt id="p1">[</bpt>threads de primeiro plano e plano de fundo<ept id="p1">](#Foreground)</ept> seção.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Accessing the source code for the Thread class    To view the .NET Framework source code for the Thread class, see the <bpt id="p2">[</bpt>Reference Source<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # Acessando o código-fonte para a classe do Thread para exibir o código-fonte do .NET Framework para a classe de Thread, consulte o <bpt id="p2">[</bpt>fonte de referência<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
          <target state="translated">Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte <bpt id="p1">[</bpt>instruções<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe, especificando um delegado que permite que um objeto a serem passados para o thread quando o thread foi iniciado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Um thread não começar a execução quando ele é criado.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">Para agendar o thread de execução, chame o &lt;xref:System.Threading.Thread.Start%2A&gt;método.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>To pass a data object to the thread, use the &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt; method overload.</source>
          <target state="translated">Para passar um objeto de dados para o thread, use o &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;sobrecarga de método.&lt;/xref:System.Threading.Thread.Start%28System.Object%29&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Usuários do Visual Basic podem omitir o &lt;xref:System.Threading.ThreadStart&gt;construtor ao criar um thread.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">`AddressOf`</ph> operador ao passar o método, por exemplo <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic chama automaticamente o &lt;xref:System.Threading.ThreadStart&gt;construtor.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Um delegado que representa os métodos a ser invocado quando esse thread começa a executar.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Um thread não começar a execução quando ele é criado.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">Para agendar o thread de execução, chame o &lt;xref:System.Threading.Thread.Start%2A&gt;método.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Usuários do Visual Basic podem omitir o &lt;xref:System.Threading.ThreadStart&gt;construtor ao criar um thread.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">`AddressOf`</ph> operador ao passar o método como <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic chama automaticamente o &lt;xref:System.Threading.ThreadStart&gt;construtor.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegado que representa os métodos a ser invocado quando esse thread começa a executar.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe, especificando um delegado que permite que um objeto a serem passados para o thread quando o thread foi iniciado e especificando o tamanho máximo da pilha do thread.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Evite usar essa sobrecarga de construtor.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">O tamanho da pilha padrão usado pelo &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;sobrecarga de construtor é o tamanho da pilha recomendados para threads.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Começando com o <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>somente totalmente confiáveis código pode definir <ph id="ph3">`maxStackSize`</ph> para um valor maior que o tamanho da pilha padrão (1 megabyte).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Se for especificado um valor maior para <ph id="ph1">`maxStackSize`</ph> quando o código está sendo executado com confiança parcial, <ph id="ph2">`maxStackSize`</ph> será ignorado e o tamanho da pilha padrão é usado.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">Nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Código em qualquer nível de confiança pode definir <ph id="ph1">`maxStackSize`</ph> para um valor menor que o tamanho da pilha padrão.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se você estiver desenvolvendo uma biblioteca totalmente confiável que será usada por código parcialmente confiável e é necessário iniciar um thread que requer uma pilha de grande, você deve declarar confiança total antes de criar o thread ou o tamanho da pilha padrão será usado.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Não faça isso, a menos que você controlar totalmente o código que é executado no thread.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Se <ph id="ph1">`maxStackSize`</ph> é menor que o tamanho mínimo de pilha, o tamanho da pilha mínimo é usado.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Se <ph id="ph1">`maxStackSize`</ph> não é um múltiplo do tamanho da página, ele será arredondado para o múltiplo mais próximo do tamanho da página.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Por exemplo, se você estiver usando o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha de mínimo e o tamanho da página é 64KB (65.536 bytes).</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em versões do Microsoft Windows anteriores ao Windows XP e Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> é ignorado, e o tamanho da pilha especificado no cabeçalho do executável é usado.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Se você especificar um tamanho de pilha muito pequeno, talvez seja necessário desabilitar a sondagem de estouro de pilha.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Quando a pilha severos é restrito, a sondagem pode próprio causar um estouro de pilha.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Para desabilitar a sondagem de estouro de pilha, adicione o seguinte arquivo de configuração de aplicativo.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegado que representa os métodos a ser invocado quando esse thread começa a executar.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">O tamanho máximo da pilha, em bytes, para ser usado por thread ou 0 para usar o tamanho máximo da pilha do padrão especificado no cabeçalho do executável.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Importante para ao código parcialmente confiável, <ph id="ph1">`maxStackSize`</ph> será ignorado se for maior que o tamanho da pilha padrão.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">Nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>é menor que zero.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe, especificando o tamanho máximo da pilha do thread.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Evite usar essa sobrecarga de construtor.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">O tamanho da pilha padrão usado pelo &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;sobrecarga de construtor é o tamanho da pilha recomendados para threads.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Começando com o <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>somente totalmente confiáveis código pode definir <ph id="ph3">`maxStackSize`</ph> para um valor maior que o tamanho da pilha padrão (1 megabyte).</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Se for especificado um valor maior para <ph id="ph1">`maxStackSize`</ph> quando o código está sendo executado com confiança parcial, <ph id="ph2">`maxStackSize`</ph> será ignorado e o tamanho da pilha padrão é usado.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">Nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Código em qualquer nível de confiança pode definir <ph id="ph1">`maxStackSize`</ph> para um valor menor que o tamanho da pilha padrão.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se você estiver desenvolvendo uma biblioteca totalmente confiável que será usada por código parcialmente confiável e é necessário iniciar um thread que requer uma pilha de grande, você deve declarar confiança total antes de criar o thread ou o tamanho da pilha padrão será usado.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Não faça isso, a menos que você controlar totalmente o código que é executado no thread.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Se <ph id="ph1">`maxStackSize`</ph> é menor que o tamanho mínimo de pilha, o tamanho da pilha mínimo é usado.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Se <ph id="ph1">`maxStackSize`</ph> não é um múltiplo do tamanho da página, ele será arredondado para o múltiplo mais próximo do tamanho da página.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Por exemplo, se você estiver usando o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha de mínimo e o tamanho da página é 64KB (65.536 bytes).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em versões do Microsoft Windows anteriores ao Windows XP e Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> é ignorado, e o tamanho da pilha especificado no cabeçalho do executável é usado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Se você especificar um tamanho de pilha muito pequeno, talvez seja necessário desabilitar a sondagem de estouro de pilha.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Quando a pilha severos é restrito, a sondagem pode próprio causar um estouro de pilha.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Para desabilitar a sondagem de estouro de pilha, adicione o seguinte arquivo de configuração de aplicativo.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegado que representa os métodos a ser invocado quando esse thread começa a executar.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">O tamanho máximo da pilha, em bytes, para ser usado por thread ou 0 para usar o tamanho máximo da pilha do padrão especificado no cabeçalho do executável.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Importante para ao código parcialmente confiável, <ph id="ph1">`maxStackSize`</ph> será ignorado se for maior que o tamanho da pilha padrão.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">Nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>é menor que zero.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Gera um <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> no thread no qual ele é chamado, para iniciar o processo de encerramento do thread.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Chamar esse método normalmente finaliza o thread.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">Quando esse método é chamado em um thread, o sistema gera um &lt;xref:System.Threading.ThreadAbortException&gt;thread para anular o proprietário.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final do <ph id="ph2">`catch`</ph> impedir a menos que &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Cancelar a solicitação para anular e impede que o <ph id="ph2">`ThreadAbortException`</ph> de finalizar o thread.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Não executadas <ph id="ph1">`finally`</ph> blocos são executados antes do thread foi anulado.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Quando um thread chama <ph id="ph2">`Abort`</ph> em si mesmo, o efeito é semelhante ao lançar uma exceção; o &lt;xref:System.Threading.ThreadAbortException&gt;acontece imediatamente, e o resultado é previsível.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">No entanto, se um thread chama <ph id="ph1">`Abort`</ph> em outro thread, a anulação interrupções de qualquer código está sendo executado.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">Também há uma possibilidade de que um construtor estático pode ser anulado.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">Em casos raros, isso pode impedir instâncias dessa classe que está sendo criado no domínio de aplicativo.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">Nas versões do .NET Framework 1.0 e 1.1, há uma possibilidade pode anular o thread enquanto um <ph id="ph1">`finally`</ph> bloco está em execução, caso em que o <ph id="ph2">`finally`</ph> bloco será anulado.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">O thread não é garantido para anular imediatamente ou em todos os.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Essa situação pode ocorrer se um thread faz uma quantidade ilimitada de computação no <ph id="ph1">`finally`</ph> blocos que são chamados como parte do procedimento de anulação, atrasando indefinidamente, assim, a anulação.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee the wait will end.</source>
          <target state="translated">Para aguardar até que um thread foi anulada, você pode chamar o &lt;xref:System.Threading.Thread.Join%2A&gt;método no thread depois de chamar o método de anulação, mas não há nenhuma garantia que a espera terminará.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls Abort might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Pode impedir que o thread que chama a anulação se o thread que está sendo anulado estiver em uma área protegida do código, como um <ph id="ph2">`catch`</ph> bloco, <ph id="ph3">`finally`</ph> bloco ou região de execução restrita.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls Abort holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Se o thread que chama a anulação mantém um bloqueio que exige que o thread anulado, pode ocorrer um deadlock.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado em um thread que não tenha sido iniciado, o thread será anulada quando &lt;xref:System.Threading.Thread.Start%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado em um thread que está bloqueado ou está em suspensão, o thread é interrompido e, em seguida, anulado.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado em um thread que foi suspenso, um &lt;xref:System.Threading.ThreadStateException&gt;é gerada no thread de chamada &lt;xref:System.Threading.Thread.Abort%2A&gt;, e &lt;xref:System.Threading.ThreadState&gt;é adicionada para o &lt;xref:System.Threading.Thread.ThreadState%2A&gt;propriedade do thread que está sendo anulada.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">Um &lt;xref:System.Threading.ThreadAbortException&gt;não é gerada no thread suspenso até &lt;xref:System.Threading.Thread.Resume%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado em um thread gerenciado durante a execução de código não gerenciado, um <ph id="ph2">`ThreadAbortException`</ph> não é lançada até que o thread retorna para código gerenciado.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Se duas chamadas para <ph id="ph1">`Abort`</ph> vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e outra chamada para executar o <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">No entanto, um aplicativo não pode detectar essa situação.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Depois de <ph id="ph1">`Abort`</ph> é invocado em um thread, o estado do thread inclui &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Depois que o thread foi encerrado como resultado de uma chamada bem-sucedida para <ph id="ph1">`Abort`</ph>, o estado do thread é alterado para &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Com permissões suficientes, um thread que é o destino de uma <ph id="ph1">`Abort`</ph> pode cancelar a anulação usando o <ph id="ph2">`ResetAbort`</ph> método.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Para obter um exemplo que demonstra a chamada a <ph id="ph1">`ResetAbort`</ph> método, consulte o <ph id="ph2">`ThreadAbortException`</ph> classe.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">O thread que está sendo anulado está suspensa no momento.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">Gera um <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> no thread no qual ele é chamado, para iniciar o processo de encerrar o thread enquanto também fornece informações sobre o encerramento do thread de exceção.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Chamar esse método normalmente finaliza o thread.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">Quando esse método é chamado em um thread, o sistema gera um &lt;xref:System.Threading.ThreadAbortException&gt;thread para anular o proprietário.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final do <ph id="ph2">`catch`</ph> impedir a menos que &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Cancelar a solicitação para anular e impede que o <ph id="ph2">`ThreadAbortException`</ph> de finalizar o thread.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Não executadas <ph id="ph1">`finally`</ph> blocos são executados antes do thread foi anulado.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Quando um thread chama <ph id="ph2">`Abort`</ph> em si mesmo, o efeito é semelhante ao lançar uma exceção; o &lt;xref:System.Threading.ThreadAbortException&gt;acontece imediatamente, e o resultado é previsível.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">No entanto, se um thread chama <ph id="ph1">`Abort`</ph> em outro thread, a anulação interrupções de qualquer código está sendo executado.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">Há uma possibilidade de que um construtor estático pode ser anulado.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">Em casos raros, isso pode impedir instâncias dessa classe que está sendo criado no domínio de aplicativo.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">Nas versões do .NET Framework 1.0 e 1.1, há uma possibilidade pode anular o thread enquanto um <ph id="ph1">`finally`</ph> bloco está em execução, caso em que o <ph id="ph2">`finally`</ph> bloco será anulado.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">O thread não é garantido para anular imediatamente ou em todos os.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Essa situação pode ocorrer se um thread faz uma quantidade ilimitada de computação no <ph id="ph1">`finally`</ph> blocos que são chamados como parte do procedimento de anulação, atrasando indefinidamente, assim, a anulação.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee that the wait will end.</source>
          <target state="translated">Para aguardar até que um thread foi anulada, você pode chamar o &lt;xref:System.Threading.Thread.Join%2A&gt;método no thread depois de chamar o método de anulação, mas não há nenhuma garantia de que a espera terminará.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; O thread que chama &lt;xref:System.Threading.Thread.Abort%2A&gt;podem bloquear se o thread que está sendo anulado estiver em uma área protegida do código, como um <ph id="ph2">`catch`</ph> bloco, <ph id="ph3">`finally`</ph> bloco ou região de execução restrita.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Se o thread que chama &lt;xref:System.Threading.Thread.Abort%2A&gt;mantém um bloqueio que exige que o thread anulado, pode ocorrer um deadlock.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado em um thread que não tenha sido iniciado, o thread será anulada quando &lt;xref:System.Threading.Thread.Start%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado em um thread que está bloqueado ou está em suspensão, o thread é interrompido e, em seguida, anulado.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado em um thread que foi suspenso, um &lt;xref:System.Threading.ThreadStateException&gt;é gerada no thread de chamada &lt;xref:System.Threading.Thread.Abort%2A&gt;, e &lt;xref:System.Threading.ThreadState&gt;é adicionada para o &lt;xref:System.Threading.Thread.ThreadState%2A&gt;propriedade do thread que está sendo anulada.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">Um &lt;xref:System.Threading.ThreadAbortException&gt;não é gerada no thread suspenso até &lt;xref:System.Threading.Thread.Resume%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado em um thread gerenciado durante a execução de código não gerenciado, um <ph id="ph2">`ThreadAbortException`</ph> não é lançada até que o thread retorna para código gerenciado.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Se duas chamadas para <ph id="ph1">`Abort`</ph> vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e outra chamada para executar o <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">No entanto, um aplicativo não pode detectar essa situação.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Depois de <ph id="ph1">`Abort`</ph> é invocado em um thread, o estado do thread inclui &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Depois que o thread foi encerrado como resultado de uma chamada bem-sucedida para <ph id="ph1">`Abort`</ph>, o estado do thread é alterado para &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Com permissões suficientes, um thread que é o destino de uma <ph id="ph1">`Abort`</ph> pode cancelar a anulação usando o <ph id="ph2">`ResetAbort`</ph> método.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Para obter um exemplo que demonstra a chamada a <ph id="ph1">`ResetAbort`</ph> método, consulte o <ph id="ph2">`ThreadAbortException`</ph> classe.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">Um objeto que contém informações específicas do aplicativo, como estado, o que pode ser usado pelo thread que está sendo anulada.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">O thread que está sendo anulado está suspensa no momento.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">Aloca um slot de dados sem nome em todos os threads.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para obter melhor desempenho, use os campos marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e slots de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre como usar o TLS, consulte <bpt id="p1">[</bpt>armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">O slot é alocado em todos os threads.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Slots de dados são exclusivos por thread.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">O alocado denominado slot de dados em todos os threads.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">Aloca um slot de dados nomeado em todos os threads.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para obter melhor desempenho, use os campos marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e slots de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre como usar o TLS, consulte <bpt id="p1">[</bpt>armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Slots de dados são exclusivos por thread.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not necessary to use the AllocateNamedDataSlot method to allocate a named data slot, because the &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; method allocates the slot if it has not already been allocated.</source>
          <target state="translated">Não é necessário usar o método AllocateNamedDataSlot para alocar um slot de dados nomeada, porque o &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;método aloca o slot se ele já não foi alocado.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se o método AllocateNamedDataSlot é usado, ele deve ser chamado no thread principal na inicialização do programa, porque ele lança uma exceção se um slot com o nome especificado já foi alocado.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">Não há nenhuma maneira de testar se um slot já foi alocado.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Slots allocated with this method must be freed with &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.</source>
          <target state="translated">Slots alocados com esse método devem ser liberados com &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.&lt;/xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">O nome do slot de dados a ser alocada.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">O alocado denominado slot de dados em todos os threads.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">Um slot de dados nomeada com o nome especificado já existe.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">Obtém ou define o estado de apartment deste thread.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>The ApartmentState property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>A propriedade ApartmentState está obsoleta.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>The non-obsolete alternatives are the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method to retrieve the apartment state and the   &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method to set the apartment state.</source>
          <target state="translated">As alternativas não obsoleto são o &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;método para recuperar o estado de apartment e &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;método para definir o estado de apartment.&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">Nas versões do .NET Framework 1.0 e 1.1, o <ph id="ph1">`ApartmentState`</ph> propriedade marca um thread para indicar que ela será executada em um apartment do thread único ou vários.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">Essa propriedade pode ser definida quando o thread está no <ph id="ph1">`Unstarted`</ph> ou <ph id="ph2">`Running`</ph> thread estado; no entanto, ela pode ser definida apenas uma vez por um thread.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">Se a propriedade não foi definida, retornará <ph id="ph1">`Unknown`</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to use the ApartmentState property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">Uma tentativa de usar a propriedade ApartmentState para definir o estado de apartment de thread cujo estado apartment já foi definido é ignorada.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method throws a &lt;xref:System.InvalidOperationException&gt; in this case.</source>
          <target state="translated">No entanto, o &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;método lança um &lt;xref:System.InvalidOperationException&gt;nesse caso.&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  In the .NET Framework version 2.0, new threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; No .NET Framework versão 2.0, os novos segmentos são inicializados como &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;se seu estado de apartment não foi definido antes de iniciarem.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">O thread principal do aplicativo é inicializado como &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;por padrão.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can no longer set the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by setting the &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; property on the first line of code.</source>
          <target state="translated">Não é possível definir o thread principal do aplicativo para &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;Definindo o &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;propriedade na primeira linha de código.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.STAThreadAttribute&gt; instead.</source>
          <target state="translated">Use o &lt;xref:System.STAThreadAttribute&gt;em vez disso.&lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> linker option.</source>
          <target state="translated">No .NET Framework versão 2.0, você pode especificar o threading de modelo para um aplicativo C++ usando COM o <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Definir Thread atributo CLR)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> opção de vinculador.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">Uma da <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valores.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O valor inicial é <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) or multithreaded apartment (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</source>
          <target state="translated">É feita uma tentativa de definir esta propriedade para um estado que não é um estado de apartment válido (um estado diferente de STA (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) ou o multi-threaded apartment (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">Notifica um host que a execução está prestes a entrar em uma região de código em que os efeitos de uma exceção sem tratamento ou a anulação de thread podem comprometer a outras tarefas no domínio do aplicativo.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Hosts do common language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer políticas diferentes para falhas em não-críticas e regiões de código.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Uma região crítica é um em que os efeitos de uma anulação de thread ou uma exceção sem tratamento não podem ser limitados à tarefa atual.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Por outro lado, uma falha em uma região não críticos do código ou anular afeta apenas a tarefa na qual o erro ocorrer.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Por exemplo, considere uma tarefa que tenta alocar memória mantendo um bloqueio.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Se a alocação de memória falhar, anulando a tarefa atual não é suficiente para garantir a estabilidade do &lt;xref:System.AppDomain&gt;, pois pode haver outras tarefas no domínio aguardando o bloqueio mesmo.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Se a tarefa atual for encerrada, outras tarefas podem ser bloqueadas.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Quando ocorre uma falha em uma região crítica, o host pode decidir descarregar todo o &lt;xref:System.AppDomain&gt;em vez de correr o risco de continuando a execução em um estado instável.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call BeginCriticalRegion.</source>
          <target state="translated">Para informar o host que seu código está inserindo uma região crítica, chame BeginCriticalRegion.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt; when execution returns to a non-critical region of code.</source>
          <target state="translated">Chamar &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;quando a execução retorna para uma região não críticos do código.&lt;/xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Notifica um host que o código gerenciado está prestes a executar instruções que dependam da identidade do thread atual do sistema operacional físico.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Alguns dos hosts do common language runtime, como o Microsoft SQL Server 2005, fornecem seu próprio gerenciamento de threads.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Um host que fornece seu próprio gerenciamento de threads pode mover uma tarefa de execução de um thread de sistema operacional físico para outro a qualquer momento.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">A maioria das tarefas não são afetados por essa alternância.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">No entanto, algumas tarefas têm afinidade de thread - ou seja, eles dependem da identidade de um thread de sistema operacional físico.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Essas tarefas devem informar o host quando eles executar código que não deve ser ativado.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call BeginThreadAffinity before acquiring the lock, and &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt; after releasing the lock.</source>
          <target state="translated">Por exemplo, se o aplicativo chama uma API para adquirir um bloqueio de sistema operacional com afinidade de thread, como CRITICAL_SECTION Win32, do sistema você deve chamar BeginThreadAffinity antes de adquirir o bloqueio e &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;depois de liberar o bloqueio.&lt;/xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">Obtém o contexto atual no qual o thread está em execução.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current thread context.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> que representa o contexto do thread atual.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">Obtém ou define a cultura do thread atual.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Globalization.CultureInfo&gt; object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">O &lt;xref:System.Globalization.CultureInfo&gt;objeto retornado por essa propriedade, junto com seus objetos associados, determinar o formato padrão para datas, horas, números, valores de moeda, a ordenação de texto, convenções de maiusculas e minúsculas e comparações de cadeia de caracteres.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo&gt; class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">Consulte o &lt;xref:System.Globalization.CultureInfo&gt;de classe para saber mais sobre nomes de cultura e identificadores, as diferenças entre culturas invariáveis, neutras e específicas, e as informações de cultura de maneira afetam threads e domínios de aplicativo.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt; property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">Consulte o &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;propriedade para saber como a cultura padrão de um thread é determinada, e como os usuários definir informações de cultura para seus computadores.&lt;/xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, you can set the CurrentCulture property to a neutral culture.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, você pode definir a propriedade CurrentCulture para uma cultura neutra.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the behavior of the &lt;xref:System.Globalization.CultureInfo&gt; class has changed: When it represents a neutral culture, its property values (in particular, the &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, and &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt; properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">Isso ocorre porque o comportamento do &lt;xref:System.Globalization.CultureInfo&gt;classe mudou: quando ele representa uma cultura neutra, seus valores de propriedade (em particular, o &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, e &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;Propriedades) agora refletem a cultura específica que está associada com a cultura neutra.&lt;/xref:System.Globalization.CultureInfo.TextInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.NumberFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.CompareInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.Calendar%2A&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>In earlier versions of the .NET Framework, the CurrentCulture property threw a &lt;xref:System.NotSupportedException&gt; exception when a neutral culture was assigned.</source>
          <target state="translated">Em versões anteriores do .NET Framework, a propriedade CurrentCulture gerou um &lt;xref:System.NotSupportedException&gt;exceção quando foi atribuída a uma cultura neutra.&lt;/xref:System.NotSupportedException&gt;</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">Um objeto que representa a cultura do thread atual.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A propriedade é definida como <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">Obtém ou define a entidade atual do thread (para segurança baseada em função).</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Security.Principal.IPrincipal&gt; value representing the security context.</source>
          <target state="translated">Um &lt;xref:System.Security.Principal.IPrincipal&gt;valor que representa o contexto de segurança.&lt;/xref:System.Security.Principal.IPrincipal&gt;</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">O chamador não tem a permissão necessária para definir a entidade.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Gets the currently running thread.</source>
          <target state="translated">Obtém o thread em execução no momento.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is the representation of the currently running thread.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> que é a representação do thread em execução no momento.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">Obtém ou define a cultura atual usada pelo Gerenciador de recursos para pesquisar recursos específicos de cultura em tempo de execução.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>An object that represents the current culture.</source>
          <target state="translated">Um objeto que representa a cultura atual.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A propriedade é definida como <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">A propriedade é definida como um nome de cultura que não pode ser usado para localizar um arquivo de recurso.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">Nomes de arquivo de recurso devem incluir somente letras, números, hífens ou sublinhados.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">Desativa a limpeza automática de runtime callable wrappers (RCW) para o thread atual.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">Por padrão, o common language runtime (CLR) limpa callable wrappers do tempo de execução automaticamente.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:      -   The application does its own message pumping.</source>
          <target state="translated">O CLR bomba de mensagens durante a limpeza, o que pode causar problemas de reentrada para alguns aplicativos que atendem aos seguintes critérios comuns:-o aplicativo faz sua própria bombeamento de mensagens.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">-O aplicativo precisa controlar com precisão ao bombeamento de mensagens ocorre.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such applications can use the DisableComObjectEagerCleanup method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">Esses aplicativos podem usar o método DisableComObjectEagerCleanup para impedir que o CLR fazendo a recuperação automática da callable wrappers do tempo de execução.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">Quando esse método for chamado em um thread, a limpeza automática não pode ser habilitada novamente para esse thread.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application is ready to clean up runtime callable wrappers, use the &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt; method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">Quando seu aplicativo está pronto para limpar callable wrappers do tempo de execução, use o &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;método para instruir o tempo de execução para limpar todos os runtime callable wrappers no contexto atual.&lt;/xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">Bombeamento de mensagens ocorre durante a execução do método.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">Notifica um host que a execução está prestes a entrar em uma região de código em que os efeitos de uma exceção sem tratamento ou a anulação de thread são limitados à tarefa atual.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Hosts do common language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer políticas diferentes para falhas em não-críticas e regiões de código.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Uma região crítica é um em que os efeitos de uma anulação de thread ou uma exceção sem tratamento não podem ser limitados à tarefa atual.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Por outro lado, uma falha em uma região não críticos do código ou anular afeta apenas a tarefa na qual o erro ocorrer.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Por exemplo, considere uma tarefa que tenta alocar memória mantendo um bloqueio.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Se a alocação de memória falhar, anulando a tarefa atual não é suficiente para garantir a estabilidade do &lt;xref:System.AppDomain&gt;, pois pode haver outras tarefas no domínio aguardando o bloqueio mesmo.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Se a tarefa atual for encerrada, outras tarefas podem ser bloqueadas.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Quando ocorre uma falha em uma região crítica, o host pode decidir descarregar todo o &lt;xref:System.AppDomain&gt;em vez de correr o risco de continuando a execução em um estado instável.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.</source>
          <target state="translated">Para informar o host que seu código está inserindo uma região crítica, chame &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.&lt;/xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call EndCriticalRegion when execution returns to a non-critical region of code.</source>
          <target state="translated">Chame EndCriticalRegion quando a execução retorna a uma região não críticos do código.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Notifica um host que o código gerenciado concluiu a execução de instruções que dependam da identidade do thread atual do sistema operacional físico.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Alguns dos hosts do common language runtime, como o Microsoft SQL Server 2005, fornecem seu próprio gerenciamento de threads.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Um host que fornece seu próprio gerenciamento de threads pode mover uma tarefa de execução de um thread de sistema operacional físico para outro a qualquer momento.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">A maioria das tarefas não são afetados por essa alternância.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">No entanto, algumas tarefas têm afinidade de thread - ou seja, eles dependem da identidade de um thread de sistema operacional físico.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Essas tarefas devem informar o host quando eles executar código que não deve ser ativado.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt; before acquiring the lock, and EndThreadAffinity after releasing the lock.</source>
          <target state="translated">Por exemplo, se seu aplicativo chama uma API de sistema para adquirir um sistema operacional de bloqueio com afinidade de thread, como CRITICAL_SECTION Win32, você deve chamar &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;antes de adquirir o bloqueio e EndThreadAffinity depois de liberar o bloqueio.&lt;/xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Gets an &lt;xref:System.Threading.ExecutionContext&gt; object that contains information about the various contexts of the current thread.</source>
          <target state="translated">Obtém um &lt;xref:System.Threading.ExecutionContext&gt;objeto que contém informações sobre os vários contextos do thread atual.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Threading.ExecutionContext&gt; class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">O &lt;xref:System.Threading.ExecutionContext&gt;classe fornece um único contêiner para todas as informações relevantes para um segmento lógico de execução.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">Isso inclui o contexto de segurança, o contexto de chamada, contexto de sincronização, o contexto de localização e o contexto de transação.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Threading.ExecutionContext&gt; object that consolidates context information for the current thread.</source>
          <target state="translated">Um &lt;xref:System.Threading.ExecutionContext&gt;objeto que consolida as informações de contexto para o thread atual.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">Garante que os recursos são liberados e outras operações de limpeza são realizadas quando o coletor de lixo recupera o <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objeto.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector calls Finalize when the current object is ready to be finalized.</source>
          <target state="translated">O coletor de lixo chama Finalize quando o objeto atual está pronto para ser finalizado.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">Elimina a associação entre um nome e um slot, para todos os threads do processo.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para obter melhor desempenho, use os campos marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e slots de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre como usar o TLS, consulte <bpt id="p1">[</bpt>armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">Depois de qualquer thread chamadas <ph id="ph1">`FreeNamedDataSlot`</ph>, outro thread que chama &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;com o mesmo nome alocará um novo slot associado com o nome.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">As chamadas subsequentes para <ph id="ph1">`GetNamedDataSlot`</ph> por qualquer thread retornará o novo slot.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, any thread that still has a &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt; returned by an earlier call to <ph id="ph1">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">No entanto, qualquer thread que ainda tem um &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;retornado por uma chamada anterior para <ph id="ph1">`GetNamedDataSlot`</ph> pode continuar a usar o slot antigo.&lt;/xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">Um slot que tenha sido associado um nome é liberado apenas quando cada <ph id="ph1">`LocalDataStoreSlot`</ph> que foi obtido antes da chamada para <ph id="ph2">`FreeNamedDataSlot`</ph> foi liberado e coleta de lixo.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Slots de dados são exclusivos por thread.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">O nome do slot de dados a ser liberado.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value indicating the apartment state.</source>
          <target state="translated">Retorna um <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valor que indica o estado de apartment.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method, along with the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">Esse método, juntamente com o &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;método e o &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;substitui o método, o &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the apartment state of the managed thread.</source>
          <target state="translated">Uma da <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valores que indica o estado de apartment do thread gerenciado.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O padrão é <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">Retorna um <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objeto que pode ser usado para capturar a pilha do thread atual.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">Não há suporte para esse método.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">Nenhuma.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">Em todos os casos.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">Recupera o valor do slot especificado no thread atual, no domínio atual do thread atual.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para obter melhor desempenho, use os campos marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e slots de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre como usar o TLS, consulte <bpt id="p1">[</bpt>armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Slots de dados são exclusivos por thread.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  GetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; GetData é um <ph id="ph2">`Shared`</ph> método que sempre se aplica ao thread em execução no momento, mesmo se você chamá-lo usando uma variável que faz referência a outro thread.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">Para evitar confusão, use o nome de classe ao chamar <ph id="ph1">`Shared`</ph> métodos: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to get the value.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> da qual obter o valor.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The retrieved value.</source>
          <target state="translated">O valor a ser recuperado.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">Retorna o domínio atual no qual o thread atual está em execução.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current application domain of the running thread.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> que representa o domínio de aplicativo atual do thread em execução.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">Retorna um identificador de domínio de aplicativo único.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">Um inteiro assinado de 32 bits identifica exclusivamente o domínio de aplicativo.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">Retorna um código hash para o thread atual.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">O código de hash não é garantido como sendo exclusivo.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property if you need a unique identifier for a managed thread.</source>
          <target state="translated">Use o &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;propriedade se precisar de um identificador exclusivo para um thread gerenciado.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>An integer hash code value.</source>
          <target state="translated">Um valor de código de hash de inteiro.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Looks up a named data slot.</source>
          <target state="translated">Procura um slot de dados nomeado.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para obter melhor desempenho, use os campos marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e slots de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre como usar o TLS, consulte <bpt id="p1">[</bpt>armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Slots de dados são exclusivos por thread.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">Se o slot nomeado não existir, um novo slot é alocado.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">Slots de dados nomeada são públicos e podem ser manipulados por qualquer pessoa.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The name of the local data slot.</source>
          <target state="translated">O nome do slot de dados local.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> allocated for this thread.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> alocado para esse thread.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Interrupts a thread that is in the <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> thread state.</source>
          <target state="translated">Interrompe um thread que está no <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> estado de thread.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">Se esse thread não está bloqueado no momento em um estado de junção, de modo de suspensão ou de espera, ele será interrompido quando ele lado começa a bloquear.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ThreadInterruptedException&gt; is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadInterruptedException&gt;será lançada no thread interrompido, mas não até que os blocos de thread.&lt;/xref:System.Threading.ThreadInterruptedException&gt;</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">Se o thread nunca bloqueado, a exceção nunca é gerada e, portanto, o thread pode ser concluída sem nunca sejam interrompidos.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O chamador não tem apropriada <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">Obtém um valor que indica o status de execução do thread atual.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread has been started and has not terminated normally or aborted; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se esse thread foi iniciado e não foi encerrado normalmente ou anulada; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">Obtém ou define um valor que indica se um thread é um thread em segundo plano.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">Um thread é um thread em segundo plano ou em um thread de primeiro plano.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">Threads em segundo plano são idênticos aos threads de primeiro plano, exceto que os threads em segundo plano não impedem que um processo de encerramento.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">Depois de tem terminado e todos os threads de primeiro plano que pertencem a um processo, o common language runtime finaliza o processo.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">Qualquer threads em segundo plano restantes são interrompidos e não são concluídos.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground (that is, their IsBackground property returns <ph id="ph1">`false`</ph>):      -   The primary thread (or main application thread).</source>
          <target state="translated">Por padrão, os seguintes threads executam em primeiro plano (ou seja, sua propriedade IsBackground retorna <ph id="ph1">`false`</ph>):-o thread principal (ou o thread principal do aplicativo).</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a &lt;xref:System.Threading.Thread&gt; class constructor.</source>
          <target state="translated">-Todos os threads criados chamando um &lt;xref:System.Threading.Thread&gt;Construtor de classe.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the background  (that is, their IsBackground property returns <ph id="ph1">`true`</ph>):      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Por padrão, os seguintes threads executam em segundo plano (ou seja, sua propriedade IsBackground retorna <ph id="ph1">`true`</ph>):-Thread do pool de threads, que são um pool de threads de trabalho mantida pelo tempo de execução.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">Você pode configurar o trabalho de threads de pool e agenda em threads de pool usando a &lt;xref:System.Threading.ThreadPool&gt;classe.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Baseado em tarefas de operações assíncronas são executados automaticamente em threads de pool.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-Todos os threads que insira o ambiente de execução gerenciado de código não gerenciado.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread is or is to become a background thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se esse thread for ou se tornará um thread em segundo plano; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The thread is dead.</source>
          <target state="translated">O thread está inativo.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">Obtém um valor que indica se um thread pertence ao pool de threads gerenciados ou não.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>o Thread Pool gerenciado<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread belongs to the managed thread pool; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se esse thread pertence ao pool de threads gerenciados; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> pumping.</source>
          <target state="translated">Bloqueia o thread de chamada até que o thread representado por esta instância é encerrado, enquanto continua a executar COM padrão e <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> bombeamento.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose Join method is called has completed.</source>
          <target state="translated">Junção é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cuja método é chamado de junção foi concluída.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">Use esse método para garantir que um thread foi encerrado.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">O chamador bloqueará indefinidamente, se o thread não terminar.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the Join method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block until <ph id="ph4">`Thread2`</ph> has completed.</source>
          <target state="translated">No exemplo a seguir, o <ph id="ph1">`Thread1`</ph> thread chama o método de associação de <ph id="ph2">`Thread2`</ph>, que faz com que <ph id="ph3">`Thread1`</ph> para bloquear até <ph id="ph4">`Thread2`</ph> foi concluída.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept><ept id="p3">]</ept>       If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept> <ept id="p3">]</ept> se o thread já foi encerrado quando &lt;xref:System.Threading.Thread.Join%2A&gt;é chamado, o método retorna imediatamente.&lt;/xref:System.Threading.Thread.Join%2A&gt;  </target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!WARNING]</ph> &gt;  You should never call the Join method of the &lt;xref:System.Threading.Thread&gt; object that represents the current thread from the current thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!WARNING]</ph> &gt; Você nunca deve chamar o método de associação do &lt;xref:System.Threading.Thread&gt;objeto que representa o thread atual do thread atual.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,       This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">Isso faz com que seu aplicativo travar porque o thread atual espera em si alterações esse método indefinidamente, o estado do thread de chamada para incluir &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Não é possível invocar <ph id="ph1">`Join`</ph> em um thread que está no &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;estado.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">O chamador tentou ingressar em um thread que está no <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> estado.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">O thread será interrompido enquanto aguardava.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">O thread de chamada até que o thread representado por esta instância finaliza ou o tempo especificado expira, enquanto continua a executar COM padrão e SendMessage bombeamento de blocos.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">Junção é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cujo &lt;xref:System.Threading.Thread.Join%2A&gt;é chamado de método foi concluída ou o intervalo de tempo limite expirou.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">No exemplo a seguir, o <ph id="ph1">`Thread1`</ph> chamadas de threads a &lt;xref:System.Threading.Thread.Join&gt;método <ph id="ph2">`Thread2`</ph>, que faz com que <ph id="ph3">`Thread1`</ph> para bloquear até que <ph id="ph4">`Thread2`</ph> foi concluída ou 2 segundos decorridos.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for the <ph id="ph1">`millisecondsTimeout`</ph> parameter, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept> <ept id="p3">]</ept> se &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;for especificado para o <ph id="ph1">`millisecondsTimeout`</ph> parâmetro, que esse método se comporta de forma idêntica ao &lt;xref:System.Threading.Thread.Join&gt;sobrecarga do método, exceto para o valor de retorno.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">Se o thread já foi encerrado quando &lt;xref:System.Threading.Thread.Join%2A&gt;é chamado, o método retorna imediatamente.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">Esse método altera o estado do thread de chamada para incluir &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Não é possível invocar <ph id="ph1">`Join`</ph> em um thread que está no &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;estado.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">O número de milissegundos para aguardar o thread seja finalizado.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread has terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o thread foi encerrado; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> se o thread não foi encerrado após o período de tempo especificado pelo <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p3">&lt;/code&gt;</ept> parâmetro tiver decorrido.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds.</source>
          <target state="translated">O valor de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p1">&lt;/code&gt;</ept> é negativa e não é igual a <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> em milissegundos.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The thread has not been started.</source>
          <target state="translated">O thread não foi iniciado.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">O thread de chamada até que o thread representado por esta instância finaliza ou o tempo especificado expira, enquanto continua a executar COM padrão e SendMessage bombeamento de blocos.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">Junção é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cujo &lt;xref:System.Threading.Thread.Join%2A&gt;é chamado de método foi concluída ou o intervalo de tempo limite expirou.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">No exemplo a seguir, o <ph id="ph1">`Thread1`</ph> chamadas de threads a &lt;xref:System.Threading.Thread.Join&gt;método <ph id="ph2">`Thread2`</ph>, que faz com que <ph id="ph3">`Thread1`</ph> para bloquear até que <ph id="ph4">`Thread2`</ph> foi concluída ou 2 segundos decorridos.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for <ph id="ph1">`timeout`</ph>, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept> <ept id="p3">]</ept> se &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;for especificado para <ph id="ph1">`timeout`</ph>, esse método se comporta de forma idêntica ao &lt;xref:System.Threading.Thread.Join&gt;sobrecarga do método, exceto para o valor de retorno.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">Se o thread já foi encerrado quando &lt;xref:System.Threading.Thread.Join%2A&gt;é chamado, o método retorna imediatamente.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the current thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Esse método altera o estado do thread atual para incluir &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Não é possível invocar <ph id="ph1">`Join`</ph> em um thread que está no &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;estado.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated">Um &lt;xref:System.TimeSpan&gt;definido como a quantidade de tempo de espera para o thread encerrar.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o thread foi encerrado; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> se o thread não foi encerrado após o período de tempo especificado pelo <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p3">&lt;/code&gt;</ept> parâmetro tiver decorrido.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">O valor de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> é negativa e não é igual a <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> em milissegundos, ou é maior do que <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milissegundos.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">O chamador tentou ingressar em um thread que está no <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> estado.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">Obtém um identificador exclusivo para o thread gerenciado atual.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread's ManagedThreadId property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">O valor da propriedade do thread ManagedThreadId serve para identificar exclusivamente o thread dentro de seu processo.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the ManagedThreadId property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">O valor da propriedade ManagedThreadId não varia ao longo do tempo, mesmo se o código não gerenciado que hospeda o common language runtime implementa o thread como uma fibra.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">Um inteiro que representa um identificador exclusivo para esse thread gerenciado.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</source>
          <target state="translated">Sincroniza o acesso de memória da seguinte maneira: O processador de execução do thread atual não é possível reorganizar as instruções de tal forma que os acessos de memória antes da chamada para MemoryBarrier executar depois de acessos de memória que segue a chamada para MemoryBarrier.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>MemoryBarrier is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated">MemoryBarrier é necessária somente em sistemas de multiprocessador com memória fraca ordenação (por exemplo, um sistema utilizar vários processadores Intel Itanium).</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the &lt;xref:System.Threading.Monitor&gt; class provide easier ways to synchronize data.</source>
          <target state="translated">Para a maioria das finalidades, c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução, ou o &lt;xref:System.Threading.Monitor&gt;classe fornecem maneiras mais fáceis para sincronizar os dados.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">Obtém ou define o nome do thread.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is write-once.</source>
          <target state="translated">Esta propriedade é gravação-depois.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the default value of a thread's Name property is <ph id="ph1">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Como o valor padrão da propriedade de nome do thread é <ph id="ph1">`null`</ph>, você pode determinar se um nome tem já foram explicitamente atribuído para o thread, comparando-o com <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string assigned to the Name property can include any Unicode character.</source>
          <target state="translated">A cadeia de caracteres atribuída à propriedade nome pode incluir qualquer caractere Unicode.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>A string containing the name of the thread, or <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if no name was set.</source>
          <target state="translated">Uma cadeia de caracteres que contém o nome do segmento, ou <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> se nenhum nome foi definido.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>A set operation was requested, but the <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> property has already been set.</source>
          <target state="translated">Uma operação de definição foi solicitada, mas o <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> propriedade já foi definida.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">Obtém ou define um valor que indica a prioridade de agendamento de thread.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can be assigned any one of the following priority &lt;xref:System.Threading.ThreadPriority&gt; values:      -   <ph id="ph1">`Highest`</ph><ph id="ph2">      -   </ph><ph id="ph3">`AboveNormal`</ph><ph id="ph4">      -   </ph><ph id="ph5">`Normal`</ph><ph id="ph6">      -   </ph><ph id="ph7">`BelowNormal`</ph><ph id="ph8">      -   </ph><ph id="ph9">`Lowest`</ph>       Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">Um thread pode ser atribuído a qualquer um dos seguinte prioridade &lt;xref:System.Threading.ThreadPriority&gt;valores:- <ph id="ph1">`Highest`</ph> <ph id="ph2">      -   </ph> <ph id="ph3">`AboveNormal`</ph> <ph id="ph4">      -   </ph> <ph id="ph5">`Normal`</ph> <ph id="ph6">      -   </ph> <ph id="ph7">`BelowNormal`</ph> <ph id="ph8">      -   </ph> <ph id="ph9">`Lowest`</ph> sistemas operacionais não precisam cumprir a prioridade de thread.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">Uma da <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valores.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O valor padrão é <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The thread has reached a final state, such as <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O thread atingiu um estado final, tais como <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is not a valid <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">O valor especificado para uma operação definida não é válido <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valor.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Cancels an &lt;xref:System.Threading.Thread.Abort*&gt; requested for the current thread.</source>
          <target state="translated">Cancela um &lt;xref:System.Threading.Thread.Abort*&gt;solicitada para o thread atual.&lt;/xref:System.Threading.Thread.Abort*&gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">Esse método só pode ser chamado por código com as permissões adequadas.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt;.</source>
          <target state="translated">Quando é feita uma chamada para <ph id="ph1">`Abort`</ph> para encerrar um thread, o sistema gera um &lt;xref:System.Threading.ThreadAbortException&gt;.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final do bloco catch, a menos que <ph id="ph2">`ResetAbort`</ph> é chamado.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Cancelar a solicitação para anular e impede que o <ph id="ph2">`ThreadAbortException`</ph> de finalizar o thread.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>See &lt;xref:System.Threading.ThreadAbortException&gt; for an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method.</source>
          <target state="translated">Consulte &lt;xref:System.Threading.ThreadAbortException&gt;para obter um exemplo que demonstra a chamar o <ph id="ph1">`ResetAbort`</ph> método.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> was not invoked on the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>não foi invocado no thread atual.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">O chamador não tem a permissão de segurança necessárias para o thread atual.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">Retoma um thread que foi suspenso.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">O thread não foi iniciado, está inativo ou não está no estado suspenso.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O chamador não tem apropriada <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Define o estado de apartment de um thread antes de ser iniciado.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">Novos threads são inicializados como &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;se seu estado de apartment não foi definido antes de iniciarem.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Estado de apartment deve ser definido antes que um thread é iniciado.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; O thread principal do aplicativo é inicializado como &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;por padrão.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">A única maneira de definir o estado apartment do thread principal do aplicativo para &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;é aplicar o &lt;xref:System.STAThreadAttribute&gt;atributo ao método de ponto de entrada.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">O método SetApartmentState, juntamente com o &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;método e o &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;substitui o método, o &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">O novo estado de apartment.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>não é um estado de apartment válido.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">O thread já foi iniciado.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">O estado de apartment já foi inicializado.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Applies a captured <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the current thread.</source>
          <target state="translated">Aplica um capturada <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> para o thread atual.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">Não há suporte para esse método.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to be applied to the current thread.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objeto a ser aplicado ao segmento atual.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">Em todos os casos.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">Define os dados no slot especificado no thread em execução no momento, para o domínio atual do thread.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>For better performance, use fields marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para obter melhor desempenho, use os campos marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e slots de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre como usar o TLS, consulte <bpt id="p1">[</bpt>armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the &lt;xref:System.Threading.Thread&gt; object has been reclaimed by garbage collection.</source>
          <target state="translated">O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização após a conclusão do procedimento de thread e o &lt;xref:System.Threading.Thread&gt;objeto tiver sido recuperado pela coleta de lixo.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Slots de dados são exclusivos por thread.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  SetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; SetData é um <ph id="ph2">`Shared`</ph> método que sempre se aplica ao thread em execução no momento, mesmo se você chamá-lo usando uma variável que faz referência a outro thread.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">Para evitar confusão, use o nome de classe ao chamar <ph id="ph1">`Shared`</ph> métodos: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in which to set the value.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> no qual definir o valor.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The value to be set.</source>
          <target state="translated">O valor a ser definido.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">Suspende o thread atual para o número especificado de milissegundos.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">O thread não será agendado para execução pelo sistema operacional para a quantidade de tempo especificado.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Esse método altera o estado do thread para incluir &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; for the <ph id="ph1">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Você pode especificar &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;para o <ph id="ph1">`millisecondsTimeout`</ph> parâmetro para suspender o thread indefinidamente.&lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">No entanto, recomendamos que você use outro &lt;xref:System.Threading?displayProperty=fullName&gt;classes como &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, ou &lt;xref:System.Threading.Semaphore&gt;em vez disso, para sincronizar threads ou gerenciar recursos.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">Os pulsos de relógio do sistema em uma taxa específica chamada a resolução do relógio.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">O tempo limite real pode não ser exatamente o tempo limite especificado, porque o tempo limite especificado será ajustado para coincidir com tiques do relógio.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">Para obter mais informações sobre resolução de relógio e o tempo de espera, consulte o <bpt id="p1">[</bpt>suspensão função<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> tópico.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">Este método chama o <bpt id="p1">[</bpt>suspensão função<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> de APIs do sistema do Windows.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Este método não executa SendMessage bombeamento e COM padrão.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se você precisa de suspensão em um thread que tenha &lt;xref:System.STAThreadAttribute&gt;, mas você deseja executar COM e SendMessage bombeamento padrão, considere usar uma das sobrecargas do &lt;xref:System.Threading.Thread.Join%2A&gt;método que especifica um intervalo de tempo limite.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">O número de milissegundos para o qual o thread está suspenso.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Se o valor de <ph id="ph1">`millisecondsTimeout`</ph> argumento for zero, o thread abandona o restante de seu intervalo de tempo para qualquer thread de prioridade igual que está pronta para executar.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Se não houver nenhum outro thread de prioridade igual que estão pronto para ser executado, a execução do thread atual não está suspenso.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The time-out value is negative and is not equal to &lt;xref:System.Threading.Timeout.Infinite&gt;.</source>
          <target state="translated">O valor de tempo limite é negativo e não é igual a &lt;xref:System.Threading.Timeout.Infinite&gt;.&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Suspende o thread atual para o período de tempo especificado.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">O thread não será agendado para execução pelo sistema operacional para a quantidade de tempo especificado.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Esse método altera o estado do thread para incluir &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt; for the <ph id="ph1">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Você pode especificar &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;para o <ph id="ph1">`timeout`</ph> parâmetro para suspender o thread indefinidamente.&lt;/xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">No entanto, recomendamos que você use outro &lt;xref:System.Threading?displayProperty=fullName&gt;classes como &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, ou &lt;xref:System.Threading.Semaphore&gt;em vez disso, para sincronizar threads ou gerenciar recursos.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload of &lt;xref:System.Threading.Thread.Sleep%2A&gt; uses the total number of whole milliseconds in <ph id="ph1">`timeout`</ph>.</source>
          <target state="translated">Essa sobrecarga de &lt;xref:System.Threading.Thread.Sleep%2A&gt;usa o número total de milissegundos em <ph id="ph1">`timeout`</ph>.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">Milissegundos fracionários são descartados.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Este método não executa SendMessage bombeamento e COM padrão.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se você precisa de suspensão em um thread que tenha &lt;xref:System.STAThreadAttribute&gt;, mas você deseja executar COM e SendMessage bombeamento padrão, considere usar uma das sobrecargas do &lt;xref:System.Threading.Thread.Join%2A&gt;método que especifica um intervalo de tempo limite.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">A quantidade de tempo para o qual o thread está suspenso.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Se o valor da <ph id="ph1">`millisecondsTimeout`</ph> argumento é <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, o thread abandona o restante de seu intervalo de tempo para qualquer thread de prioridade igual que está pronta para executar.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Se não houver nenhum outro thread de prioridade igual que estão pronto para ser executado, a execução do thread atual não está suspenso.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">O valor de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> é negativa e não é igual a <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> em milissegundos, ou é maior do que <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milissegundos.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Causes a thread to wait the number of times defined by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">iterations</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">Faz com que um thread para aguardar o número de horas definidas pelo <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">iterations</ph> <ept id="p1">&lt;/code&gt;</ept> parâmetro.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SpinWait method is useful for implementing locks.</source>
          <target state="translated">O método SpinWait é útil para a implementação de bloqueios.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes in the .NET Framework, such as &lt;xref:System.Threading.Monitor&gt; and &lt;xref:System.Threading.ReaderWriterLock&gt;, use this method internally.</source>
          <target state="translated">Classes do .NET Framework, como &lt;xref:System.Threading.Monitor&gt;e &lt;xref:System.Threading.ReaderWriterLock&gt;, use esse método internamente.&lt;/xref:System.Threading.ReaderWriterLock&gt; &lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph1">`iterations`</ph> parameter.</source>
          <target state="translated">SpinWait basicamente coloca o processador de um loop estreito muito, com a contagem de loop especificada pelo <ph id="ph1">`iterations`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">A duração da espera, portanto, depende da velocidade do processador.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contrast this with the &lt;xref:System.Threading.Thread.Sleep%2A&gt; method.</source>
          <target state="translated">Compare isso com o &lt;xref:System.Threading.Thread.Sleep%2A&gt;método.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that calls &lt;xref:System.Threading.Thread.Sleep%2A&gt; yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">Um thread que chama &lt;xref:System.Threading.Thread.Sleep%2A&gt;produz o restante do seu fatia atual de tempo do processador, mesmo se o intervalo especificado for zero.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying a non-zero interval for &lt;xref:System.Threading.Thread.Sleep%2A&gt; removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">Especificar um intervalo diferente de zero para &lt;xref:System.Threading.Thread.Sleep%2A&gt;Remove o thread de consideração pelo Agendador de thread até que o intervalo de tempo decorrido.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait is not generally useful for ordinary applications.</source>
          <target state="translated">SpinWait não geralmente é útil para aplicativos comuns.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; or a statement that wraps &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; (<ph id="ph1">`lock`</ph> in C# or <ph id="ph2">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">Na maioria dos casos, você deve usar as classes de sincronização fornecidas pelo .NET Framework. Por exemplo, chamar &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;ou uma instrução que encapsula &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;(<ph id="ph1">`lock`</ph> em c# ou <ph id="ph2">`SyncLock`</ph> no Visual Basic).&lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; &lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the SpinWait method in your loop.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; Em casos raros em que é vantajoso para evitar uma alternância de contexto, como quando você sabe que uma alteração de estado é iminente, fazer uma chamada ao método SpinWait em seu loop.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code SpinWait executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">O código que executa SpinWait é projetado para evitar problemas que podem ocorrer em computadores com vários processadores.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, SpinWait prevents processor starvation in certain situations.</source>
          <target state="translated">Por exemplo, em computadores com vários processadores Intel utilizar a tecnologia Hyper-Threading, SpinWait evita a privação de processador em determinadas situações.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">Um inteiro assinado de 32 bits que define quanto tempo é de um thread de espera.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Faz com que o sistema operacional alterar o estado da instância atual para <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">Quando um thread estiver no &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;de estado, o sistema operacional pode agendá-lo para execução.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">O thread de início da execução na primeira linha do método representado pelo &lt;xref:System.Threading.ThreadStart&gt;ou &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegado fornecido para o construtor de thread.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">Observe que a chamada inicial não bloqueia o thread de chamada.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If this overload is used with a thread created using a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se essa sobrecarga é usada com um thread criado usando um &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegado, <ph id="ph2">`null`</ph> é passado para o método executado pelo thread.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Depois que o thread termina, ele não pode ser reiniciado com outra chamada para <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">O thread já foi iniciado.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Não há memória suficiente iniciar este thread.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">Faz com que o sistema operacional alterar o estado da instância atual para <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>e, opcionalmente, fornece um objeto que contém dados a serem usados pelo método o thread é executado.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">Quando um thread estiver no &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;de estado, o sistema operacional pode agendá-lo para execução.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">O thread de início da execução na primeira linha do método representado pelo &lt;xref:System.Threading.ThreadStart&gt;ou &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegado fornecido para o construtor de thread.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">Observe que a chamada inicial não bloqueia o thread de chamada.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Depois que o thread termina, ele não pode ser reiniciado com outra chamada para <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload and the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">Essa sobrecarga e a &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegado facilitam passar dados para um procedimento de thread, mas a técnica não é tipo seguro porque qualquer objeto pode ser passado para essa sobrecarga.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">Uma maneira mais robusta para passar dados para um procedimento de thread é colocar o procedimento de thread e os campos de dados em um objeto de trabalho.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>criando Threads e passando dados na hora de início<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">O segmento de um objeto que contém dados a serem usados pelo método Execute.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">O thread já foi iniciado.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Não há memória suficiente iniciar este thread.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>This thread was created using a <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate instead of a <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> delegate.</source>
          <target state="translated">Este thread foi criado usando um <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegado em vez de um <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> delegate.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">O suspende o thread ou se o thread já está suspenso, não tem nenhum efeito.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">Se o thread já está suspenso, esse método não terá efeito.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Do not use the Suspend and &lt;xref:System.Threading.Thread.Resume%2A&gt; methods to synchronize the activities of threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; Não usam a suspensão e &lt;xref:System.Threading.Thread.Resume%2A&gt;métodos para sincronizar as atividades de threads.&lt;/xref:System.Threading.Thread.Resume%2A&gt;</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">Você não tem como saber qual código de um thread está em execução quando você suspende a ele.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the &lt;xref:System.AppDomain&gt; might be blocked.</source>
          <target state="translated">Se você suspender um thread enquanto ele mantém o bloqueio durante a avaliação de permissão de segurança, outros threads de &lt;xref:System.AppDomain&gt;pode estar bloqueada.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the &lt;xref:System.AppDomain&gt; that attempt to use that class are blocked.</source>
          <target state="translated">Se você suspender um thread enquanto ele está em execução em um construtor de classe, outros threads de &lt;xref:System.AppDomain&gt;que tentar usar que classe estão bloqueadas.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Os deadlocks podem ocorrer facilmente.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">O thread não foi iniciado ou está inativo.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O chamador não tem apropriada <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Um conjunto de nomes é mapeado para um conjunto correspondente de identificadores de expedição.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consulte a biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">No passado a matriz de nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Contagem dos nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">O contexto de localidade no qual os nomes de interpretar.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz alocada pelo chamador que recebe as IDs correspondentes aos nomes.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Acesso de associação tardia usando o COM <ph id="ph1">`IDispatch`</ph> interface não é suportada.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera as informações de tipo para um objeto, o que pode ser usada para obter as informações de tipo para uma interface.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consulte a biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
          <target state="translated">As informações de tipo para retornar.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
          <target state="translated">O identificador de localidade para o tipo de informação.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recebe um ponteiro para o objeto de informações do tipo solicitado.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Acesso de associação tardia usando o COM <ph id="ph1">`IDispatch`</ph> interface não é suportada.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera o número de interfaces de informações de tipo que um objeto fornece (0 ou 1).</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consulte a biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Acesso de associação tardia usando o COM <ph id="ph1">`IDispatch`</ph> interface não é suportada.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornece acesso às propriedades e métodos expostos por um objeto.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::Invoke`</ph>, consulte a biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
          <target state="translated">Identifica o membro.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">O contexto de localidade na qual interpretar argumentos.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Sinalizadores que descrevem o contexto da chamada.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ponteiro para uma estrutura que contém uma matriz de argumentos, uma matriz de argumento DISPIDs para argumentos nomeados e contas para o número de elementos nas matrizes.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ponteiro para o local onde o resultado a ser armazenado.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ponteiro para uma estrutura que contém informações de exceção.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">O índice do primeiro argumento que tem um erro.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Acesso de associação tardia usando o COM <ph id="ph1">`IDispatch`</ph> interface não é suportada.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">Obtém um valor que contém os estados do thread atual.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ThreadState property provides more specific information than the &lt;xref:System.Threading.Thread.IsAlive%2A&gt; property.</source>
          <target state="translated">A propriedade ThreadState fornece informações mais específicas do que o &lt;xref:System.Threading.Thread.IsAlive%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.IsAlive%2A&gt;</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Estado de thread só tem interesse em cenários de depuração.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">O código nunca deve usar o estado de thread para sincronizar as atividades de threads.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the state of the current thread.</source>
          <target state="translated">Uma da <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valores que indica o estado do thread atual.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O valor inicial é <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Define o estado de apartment de um thread antes de ser iniciado.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">Novos threads são inicializados como &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;se seu estado de apartment não foi definido antes de iniciarem.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Estado de apartment deve ser definido antes que um thread é iniciado.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; O thread principal do aplicativo é inicializado como &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;por padrão.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">A única maneira de definir o estado apartment do thread principal do aplicativo para &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;é aplicar o &lt;xref:System.STAThreadAttribute&gt;atributo ao método de ponto de entrada.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The TrySetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">O método TrySetApartmentState, juntamente com o &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;método e o &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;substitui o método, o &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">O novo estado de apartment.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the apartment state is set; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o estado de apartment está definido; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>não é um estado de apartment válido.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">O thread já foi iniciado.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">VolatileRead e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileRead obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, VolatileRead obtém o valor mais recente gravado em um local de memória por qualquer processador.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, VolatileRead e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar VolatileRead ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa VolatileRead ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor mais recente gravado em um local de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo a ser lido.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente gravado para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e VolatileWrite para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileWrite ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, VolatileWrite garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e VolatileWrite Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> instrução e o &lt;xref:System.Threading.Monitor&gt;classe fornecem alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Em um sistema multiprocessador, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isso pode exigir a liberação de caches de processador.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo em um sistema de processador único, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar esse método afeta apenas um acesso de memória único.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; No c#, usando o <ph id="ph2">`volatile`</ph> modificador em um campo garante que todo o acesso a esse campo usa &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor é a serem gravados.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser gravado.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">Faz com que o thread de chamada gerar outro thread está pronto para execução no processador atual da execução.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">O sistema operacional seleciona o thread para produzir a.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">Se esse método for bem-sucedido, o restante da fração de tempo atual do thread é produzido.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">O sistema operacional agenda o thread de chamada para outro intervalo de tempo, de acordo com sua prioridade e o status de outros threads que estão disponíveis para executar.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">Gerando é limitado para o processador que está executando o thread de chamada.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">O sistema operacional não mudará execução a outro processador, mesmo se que o processador está ocioso ou estiver executando um thread de prioridade mais baixa.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se não houver nenhum outro thread está pronto para executar o processador atual, o sistema operacional não gera a execução e esse método retorna <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">Esse método é equivalente a usando invocação de plataforma para chamar o Win32 nativo <ph id="ph1">`SwitchToThread`</ph> função.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should call the Yield method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">Você deve chamar o rendimento invocação de método em vez de usar a plataforma porque ignora de invocação de plataforma qualquer comportamento de threading personalizado que solicitou que o host.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the operating system switched execution to another thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o sistema operacional execução tiver alternado para outro thread; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>