<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7d86a014a28c7d85d71d3be809df53d48b1c0214</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Collections.Stack.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">90ed17a4862ac4e84d8d89967db114dbed325069</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7cb911518e52431583334a585119d2d8e10ee71f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a simple last-in-first-out (LIFO) non-generic collection of objects.</source>
          <target state="translated">Representa uma coleção simples último a entrar, primeiro a sair (UEPS) não genérica de objetos.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the generic version of this collection, see &lt;xref:System.Collections.Generic.Stack%601?displayProperty=fullName&gt;.</source>
          <target state="translated">Para obter a versão genérica dessa coleção, consulte &lt;xref:System.Collections.Generic.Stack%601?displayProperty=fullName&gt;.&lt;/xref:System.Collections.Generic.Stack%601?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity of a Stack is the number of elements the Stack can hold.</source>
          <target state="translated">A capacidade de uma pilha é o número de elementos que a pilha pode conter.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a Stack, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">À medida que elementos são adicionados a uma pilha, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>If &lt;xref:System.Collections.Stack.Count%2A&gt; is less than the capacity of the stack, &lt;xref:System.Collections.Stack.Push%2A&gt; is an O(1) operation.</source>
          <target state="translated">Se &lt;xref:System.Collections.Stack.Count%2A&gt;é menor que a capacidade da pilha, &lt;xref:System.Collections.Stack.Push%2A&gt;é uma operação de (1).&lt;/xref:System.Collections.Stack.Push%2A&gt; &lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the capacity needs to be increased to accommodate the new element, &lt;xref:System.Collections.Stack.Push%2A&gt; becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Stack.Count%2A&gt;.</source>
          <target state="translated">Se a capacidade precisa ser aumentado para acomodar o novo elemento, &lt;xref:System.Collections.Stack.Push%2A&gt;se torna um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é &lt;xref:System.Collections.Stack.Count%2A&gt;.&lt;/xref:System.Collections.Stack.Count%2A&gt; &lt;/xref:System.Collections.Stack.Push%2A&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.Stack.Pop%2A&gt; is an O(1) operation.</source>
          <target state="translated">&lt;xref:System.Collections.Stack.Pop%2A&gt;é uma operação de (1).&lt;/xref:System.Collections.Stack.Pop%2A&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stack accepts <ph id="ph1">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated">Pilha aceita <ph id="ph1">`null`</ph> como um valor válido e permite que os elementos duplicados.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class that is empty and has the default initial capacity.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe que está vazia e tem a capacidade inicial padrão.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity of a &lt;xref:System.Collections.Stack&gt; is the number of elements that the &lt;xref:System.Collections.Stack&gt; can hold.</source>
          <target state="translated">A capacidade de um &lt;xref:System.Collections.Stack&gt;é o número de elementos que o &lt;xref:System.Collections.Stack&gt;pode conter.&lt;/xref:System.Collections.Stack&gt; &lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a &lt;xref:System.Collections.Stack&gt;, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um &lt;xref:System.Collections.Stack&gt;, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the &lt;xref:System.Collections.Stack&gt;.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos de &lt;xref:System.Collections.Stack&gt;.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Este construtor é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class that contains elements copied from the specified collection and has the same initial capacity as the number of elements copied.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe que contém os elementos copiados da coleção especificada e tem a mesma capacidade inicial como o número de elementos copiados.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity of a &lt;xref:System.Collections.Stack&gt; is the number of elements that the &lt;xref:System.Collections.Stack&gt; can hold.</source>
          <target state="translated">A capacidade de um &lt;xref:System.Collections.Stack&gt;é o número de elementos que o &lt;xref:System.Collections.Stack&gt;pode conter.&lt;/xref:System.Collections.Stack&gt; &lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a &lt;xref:System.Collections.Stack&gt;, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um &lt;xref:System.Collections.Stack&gt;, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the &lt;xref:System.Collections.Stack&gt;.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos de &lt;xref:System.Collections.Stack&gt;.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied onto the &lt;xref:System.Collections.Stack&gt; in the same order they are read by the &lt;xref:System.Collections.IEnumerator&gt; of the &lt;xref:System.Collections.ICollection&gt;.</source>
          <target state="translated">Os elementos são copiados para o &lt;xref:System.Collections.Stack&gt;na mesma ordem em que são lidas pela &lt;xref:System.Collections.IEnumerator&gt;de &lt;xref:System.Collections.ICollection&gt;.&lt;/xref:System.Collections.ICollection&gt; &lt;/xref:System.Collections.IEnumerator&gt; &lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`col`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos em <ph id="ph3">`col`</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.ICollection&gt; to copy elements from.</source>
          <target state="translated">O &lt;xref:System.Collections.ICollection&gt;copiar elementos de.&lt;/xref:System.Collections.ICollection&gt;</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;col&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;col&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class that is empty and has the specified initial capacity or the default initial capacity, whichever is greater.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe que está vazia e tem a capacidade inicial especificada ou a capacidade inicial padrão, o que for maior.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity of a &lt;xref:System.Collections.Stack&gt; is the number of elements that the &lt;xref:System.Collections.Stack&gt; can hold.</source>
          <target state="translated">A capacidade de um &lt;xref:System.Collections.Stack&gt;é o número de elementos que o &lt;xref:System.Collections.Stack&gt;pode conter.&lt;/xref:System.Collections.Stack&gt; &lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a &lt;xref:System.Collections.Stack&gt;, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um &lt;xref:System.Collections.Stack&gt;, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the &lt;xref:System.Collections.Stack&gt;.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos de &lt;xref:System.Collections.Stack&gt;.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`initialCapacity`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">`initialCapacity`</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The initial number of elements that the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> can contain.</source>
          <target state="translated">O número inicial de elementos que o <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> pode conter.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;initialCapacity&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;initialCapacity&lt;/code&gt;</ph>é menor que zero.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Removes all objects from the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Remove todos os objetos do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.Stack.Count%2A&gt; is set to zero, and references to other objects from elements of the collection are also released.</source>
          <target state="translated">&lt;xref:System.Collections.Stack.Count%2A&gt;é definido como zero, e referências a outros objetos de elementos da coleção também são liberadas.&lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Stack.Count%2A&gt;.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é &lt;xref:System.Collections.Stack.Count%2A&gt;.&lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Creates a shallow copy of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Cria uma cópia superficial do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Uma cópia superficial de uma coleção copia apenas os elementos da coleção, se eles são tipos de referência ou tipos de valor, mas não copia os objetos que se referem as referências a.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">As referências na nova coleção apontam para os mesmos objetos que as referências na coleção original apontem para.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Em contraste, uma cópia profunda de uma coleção copia os elementos e tudo direta ou indiretamente referenciado por elementos.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Stack.Count%2A&gt;.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é &lt;xref:System.Collections.Stack.Count%2A&gt;.&lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A shallow copy of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Uma cópia superficial do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Determines whether an element is in the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Determina se um elemento está no <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality by calling the &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt; method.</source>
          <target state="translated">Este método determina a igualdade chamando o &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;método.&lt;/xref:System.Object.Equals%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Stack.Count%2A&gt;.</source>
          <target state="translated">Esse método executa uma pesquisa linear; Portanto, esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é &lt;xref:System.Collections.Stack.Count%2A&gt;.&lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the .NET Framework 2.0, this method tests for equality by passing the <ph id="ph1">`obj`</ph> argument to the &lt;xref:System.Object.Equals%2A&gt; method of individual objects in the collection.</source>
          <target state="translated">Começando com o .NET Framework 2.0, este método testa a igualdade passando o <ph id="ph1">`obj`</ph> argumento para o &lt;xref:System.Object.Equals%2A&gt;método objetos individuais na coleção.&lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using passing the individual items in the collection to the &lt;xref:System.Object.Equals%2A&gt; method of the <ph id="ph1">`obj`</ph> argument.</source>
          <target state="translated">Nas versões anteriores do .NET Framework, isso foi feito usando passando os itens individuais na coleção para o &lt;xref:System.Object.Equals%2A&gt;método o <ph id="ph1">`obj`</ph> argumento.&lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The object to locate in the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O objeto a ser localizado no <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The value can be <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O valor pode ser <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p2">&lt;/code&gt;</ept> is found in the <bpt id="p3">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>; otherwise, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p2">&lt;/code&gt;</ept> is found in the <bpt id="p3">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>; otherwise, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Copies the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to an existing one-dimensional &lt;xref:System.Array&gt;, starting at the specified array index.</source>
          <target state="translated">Copia o <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> para uma dimensão existente &lt;xref:System.Array&gt;, começando no índice de matriz especificado.&lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied onto the array in last-in-first-out (LIFO) order, similar to the order of the elements returned by a succession of calls to &lt;xref:System.Collections.Stack.Pop%2A&gt;.</source>
          <target state="translated">Os elementos são copiados para a matriz na ordem do último a entrar, primeiro a sair (UEPS), semelhante à ordem dos elementos retornados por uma sucessão de chamadas para &lt;xref:System.Collections.Stack.Pop%2A&gt;.&lt;/xref:System.Collections.Stack.Pop%2A&gt;</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Stack.Count%2A&gt;.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é &lt;xref:System.Collections.Stack.Count%2A&gt;.&lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The one-dimensional &lt;xref:System.Array&gt; that is the destination of the elements copied from <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O unidimensional &lt;xref:System.Array&gt;que é o destino dos elementos copiados de <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Array&gt; must have zero-based indexing.</source>
          <target state="translated">O &lt;xref:System.Array&gt;devem ter a indexação com base em zero.&lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The zero-based index in <ph id="ph1">`array`</ph> at which copying begins.</source>
          <target state="translated">O índice de base zero no <ph id="ph1">`array`</ph> no qual a cópia começa.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph>é menor que zero.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph>é multidimensional.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>-or-       The number of elements in the source <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is greater than the available space from <ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> to the end of the destination <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
          <target state="translated">o número de elementos na origem - ou - <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> é maior que o espaço disponível do <ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> até o final do destino <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The type of the source <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> cannot be cast automatically to the type of the destination <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
          <target state="translated">O tipo da fonte de <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> não pode ser convertido automaticamente para o tipo de destino <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph1">array</ph> <ept id="p2">&lt;/code&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Gets the number of elements contained in the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Obtém o número de elementos contidos no <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity is the number of elements that the &lt;xref:System.Collections.Stack&gt; can store.</source>
          <target state="translated">A capacidade é o número de elementos que o &lt;xref:System.Collections.Stack&gt;pode armazenar.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Count is the number of elements that are actually in the &lt;xref:System.Collections.Stack&gt;.</source>
          <target state="translated">Contagem é o número de elementos que estão realmente em &lt;xref:System.Collections.Stack&gt;.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity is always greater than or equal to Count.</source>
          <target state="translated">A capacidade é sempre maior que ou igual à contagem.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>If Count exceeds the capacity while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Se a contagem exceder a capacidade durante a adição de elementos, a capacidade é aumentada automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Recuperar o valor dessa propriedade é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The number of elements contained in the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O número de elementos contidos no <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Returns an &lt;xref:System.Collections.IEnumerator&gt; for the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Retorna um &lt;xref:System.Collections.IEnumerator&gt;para o <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IEnumerator&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>[Visual Basic, C#]       The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">[Visual Basic, c#]       O <ph id="ph1">`foreach`</ph> instrução de linguagem c# (<ph id="ph2">`for each`</ph> no Visual Basic) oculta a complexidade dos enumeradores.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Portanto, usando <ph id="ph1">`foreach`</ph> é recomendada, em vez de manipulação direta do enumerador.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Enumeradores podem ser usados para ler os dados na coleção, mas eles não podem ser usados para modificar a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inicialmente, o enumerador está posicionado antes do primeiro elemento na coleção.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.IEnumerator.Reset%2A&gt; also brings the enumerator back to this position.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;também traz o enumerador de volta para essa posição.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>At this position, &lt;xref:System.Collections.IEnumerator.Current%2A&gt; is undefined.</source>
          <target state="translated">Nesta posição, &lt;xref:System.Collections.IEnumerator.Current%2A&gt;é indefinido.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; to advance the enumerator to the first element of the collection before reading the value of &lt;xref:System.Collections.IEnumerator.Current%2A&gt;.</source>
          <target state="translated">Portanto, você deve chamar &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;para avançar o enumerador para o primeiro elemento da coleção antes de ler o valor de &lt;xref:System.Collections.IEnumerator.Current%2A&gt;.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.IEnumerator.Current%2A&gt; returns the same object until either &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; or &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; is called.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;Retorna o mesmo objeto até que o &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;ou &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;é chamado.&lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; sets &lt;xref:System.Collections.IEnumerator.Current%2A&gt; to the next element.</source>
          <target state="translated">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;define &lt;xref:System.Collections.IEnumerator.Current%2A&gt;para o próximo elemento.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>If &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; passes the end of the collection, the enumerator is positioned after the last element in the collection and &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;passa o final da coleção, o enumerador está posicionado após o último elemento da coleção e &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;retorna <ph id="ph1">`false`</ph>.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the enumerator is at this position, subsequent calls to &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; also return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Quando o enumerador está nessa posição, chamadas subsequentes para &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;também retornam <ph id="ph1">`false`</ph>.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the last call to &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; returned <ph id="ph1">`false`</ph>, &lt;xref:System.Collections.IEnumerator.Current%2A&gt; is undefined.</source>
          <target state="translated">Se a última chamada &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;retornado <ph id="ph1">`false`</ph>, &lt;xref:System.Collections.IEnumerator.Current%2A&gt;é indefinido.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>To set &lt;xref:System.Collections.IEnumerator.Current%2A&gt; to the first element of the collection again, you can call &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; followed by &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;.</source>
          <target state="translated">Definir &lt;xref:System.Collections.IEnumerator.Current%2A&gt;para o primeiro elemento da coleção novamente, você pode chamar &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;seguido pelo &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.IEnumerator.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Um enumerador permanece válido desde que a coleção permaneça inalterada.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Se forem feitas alterações à coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado irrecuperavelmente e seu comportamento é indefinido.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">O enumerador não tem acesso exclusivo à coleção; Portanto, enumerando através de uma coleção intrinsecamente não é um procedimento de thread-safe.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Esse método é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Collections.IEnumerator&gt; for the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">An &lt;xref:System.Collections.IEnumerator&gt; for the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Collections.IEnumerator&gt;</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether access to the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is synchronized (thread safe).</source>
          <target state="translated">Obtém um valor que indica se o acesso para o <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> é sincronizado (thread-safe).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee the thread safety of the &lt;xref:System.Collections.Stack&gt;, all operations must be done through the wrapper returned by the &lt;xref:System.Collections.Stack.Synchronized%2A&gt; method.</source>
          <target state="translated">Para garantir a segurança de thread do &lt;xref:System.Collections.Stack&gt;, todas as operações devem ser feitas por meio do wrapper retornado pelo &lt;xref:System.Collections.Stack.Synchronized%2A&gt;método.&lt;/xref:System.Collections.Stack.Synchronized%2A&gt; &lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar através de uma coleção intrinsecamente não é um procedimento de thread-safe.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção é sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração ou capture as exceções resultante de alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example shows how to lock the collection using the &lt;xref:System.Collections.Stack.SyncRoot%2A&gt; during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o &lt;xref:System.Collections.Stack.SyncRoot%2A&gt;durante toda a enumeração.&lt;/xref:System.Collections.Stack.SyncRoot%2A&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Classic Stack.IsSynchronized Example#2<ept id="p2">](~/add/codesnippet/cpp/p-system.collections.sta_0_1.cpp)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>Classic Stack.IsSynchronized Example#2<ept id="p4">](~/add/codesnippet/csharp/p-system.collections.sta_0_1.cs)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Classic Stack.IsSynchronized Example#2<ept id="p6">](~/add/codesnippet/visualbasic/p-system.collections.sta_0_1.vb)</ept><ept id="p5">]</ept>       Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated"><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Clássico Stack.IsSynchronized exemplo n º&amp;2;<ept id="p2">](~/add/codesnippet/cpp/p-system.collections.sta_0_1.cpp)</ept><ept id="p1">]</ept><bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>clássico Stack.IsSynchronized exemplo n º&amp;2;<ept id="p4">](~/add/codesnippet/csharp/p-system.collections.sta_0_1.cs)</ept><ept id="p3">]</ept><bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>clássico Stack.IsSynchronized exemplo n º&amp;2;<ept id="p6">](~/add/codesnippet/visualbasic/p-system.collections.sta_0_1.vb)</ept> <ept id="p5">]</ept> recuperar o valor dessa propriedade é uma operação de (1).    </target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, if access to the <bpt id="p2">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> is synchronized (thread safe); otherwise, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, se acesse o <bpt id="p2">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> é sincronizado (thread-safe); caso contrário, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O padrão é <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Returns the object at the top of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> without removing it.</source>
          <target state="translated">Retorna o objeto no topo do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> sem removê-lo.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is similar to the &lt;xref:System.Collections.Stack.Pop%2A&gt; method, but Peek does not modify the &lt;xref:System.Collections.Stack&gt;.</source>
          <target state="translated">Esse método é semelhante do &lt;xref:System.Collections.Stack.Pop%2A&gt;método, mas inspeção não modifica o &lt;xref:System.Collections.Stack&gt;.&lt;/xref:System.Collections.Stack&gt; &lt;/xref:System.Collections.Stack.Pop%2A&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can be pushed onto the &lt;xref:System.Collections.Stack&gt; as a placeholder, if needed.</source>
          <target state="translated"><ph id="ph1">`null`</ph>pode ser enviado para o &lt;xref:System.Collections.Stack&gt;como um espaço reservado, se necessário.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>To distinguish between a null value and the end of the stack, check the &lt;xref:System.Collections.Stack.Count%2A&gt; property or catch the &lt;xref:System.InvalidOperationException&gt;, which is thrown when the &lt;xref:System.Collections.Stack&gt; is empty.</source>
          <target state="translated">Para distinguir entre um valor nulo e o fim da pilha, verifique o &lt;xref:System.Collections.Stack.Count%2A&gt;catch ou propriedade de &lt;xref:System.InvalidOperationException&gt;, que é gerado quando o &lt;xref:System.Collections.Stack&gt;está vazio.&lt;/xref:System.Collections.Stack&gt; &lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Esse método é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Object&gt; at the top of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O &lt;xref:System.Object&gt;na parte superior do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is empty.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> está vazio.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Removes and returns the object at the top of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Remove e retorna o objeto no topo do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is similar to the &lt;xref:System.Collections.Stack.Peek%2A&gt; method, but &lt;xref:System.Collections.Stack.Peek%2A&gt; does not modify the &lt;xref:System.Collections.Stack&gt;.</source>
          <target state="translated">Esse método é semelhante ao &lt;xref:System.Collections.Stack.Peek%2A&gt;método, mas &lt;xref:System.Collections.Stack.Peek%2A&gt;não modifica o &lt;xref:System.Collections.Stack&gt;.&lt;/xref:System.Collections.Stack&gt; &lt;/xref:System.Collections.Stack.Peek%2A&gt; &lt;/xref:System.Collections.Stack.Peek%2A&gt;</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can be pushed onto the &lt;xref:System.Collections.Stack&gt; as a placeholder, if needed.</source>
          <target state="translated"><ph id="ph1">`null`</ph>pode ser enviado para o &lt;xref:System.Collections.Stack&gt;como um espaço reservado, se necessário.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>To distinguish between a null value and the end of the stack, check the &lt;xref:System.Collections.Stack.Count%2A&gt; property or catch the &lt;xref:System.InvalidOperationException&gt;, which is thrown when the &lt;xref:System.Collections.Stack&gt; is empty.</source>
          <target state="translated">Para distinguir entre um valor nulo e o fim da pilha, verifique o &lt;xref:System.Collections.Stack.Count%2A&gt;catch ou propriedade de &lt;xref:System.InvalidOperationException&gt;, que é gerado quando o &lt;xref:System.Collections.Stack&gt;está vazio.&lt;/xref:System.Collections.Stack&gt; &lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Esse método é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Object&gt; removed from the top of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O &lt;xref:System.Object&gt;removidos da parte superior do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is empty.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> está vazio.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Inserts an object at the top of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Insere um objeto no topo do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>If &lt;xref:System.Collections.Stack.Count%2A&gt; already equals the capacity, the capacity of the &lt;xref:System.Collections.Stack&gt; is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Se &lt;xref:System.Collections.Stack.Count%2A&gt;já for igual à capacidade, a capacidade do &lt;xref:System.Collections.Stack&gt;é aumentado, automaticamente realocando matriz interna, e os elementos existentes são copiados para a nova matriz antes de adicionar o novo elemento.&lt;/xref:System.Collections.Stack&gt; &lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can be pushed onto the &lt;xref:System.Collections.Stack&gt; as a placeholder, if needed.</source>
          <target state="translated"><ph id="ph1">`null`</ph>pode ser enviado para o &lt;xref:System.Collections.Stack&gt;como um espaço reservado, se necessário.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>It occupies a slot in the stack and is treated like any object.</source>
          <target state="translated">Ele ocupa um slot da pilha e é tratado como qualquer objeto.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If &lt;xref:System.Collections.Stack.Count%2A&gt; is less than the capacity of the stack, Push is an O(1) operation.</source>
          <target state="translated">Se &lt;xref:System.Collections.Stack.Count%2A&gt;é menor que a capacidade da pilha, Push é uma operação de (1).&lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the capacity needs to be increased to accommodate the new element, Push becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Stack.Count%2A&gt;.</source>
          <target state="translated">Se a capacidade precisa ser aumentado para acomodar o novo elemento, Push se torna um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é &lt;xref:System.Collections.Stack.Count%2A&gt;.&lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Object&gt; to push onto the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O &lt;xref:System.Object&gt;para enviar por push para o <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The value can be <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O valor pode ser <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Returns a synchronized (thread safe) wrapper for the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Retorna um sincronizado wrapper (thread-safe) para o <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee the thread safety of the &lt;xref:System.Collections.Stack&gt;, all operations must be done through this wrapper.</source>
          <target state="translated">Para garantir a segurança de thread do &lt;xref:System.Collections.Stack&gt;, todas as operações devem ser feitas por meio desse wrapper.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar através de uma coleção intrinsecamente não é um procedimento de thread-safe.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção é sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração ou capture as exceções resultante de alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example shows how to lock the collection using the &lt;xref:System.Collections.Stack.SyncRoot%2A&gt; during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o &lt;xref:System.Collections.Stack.SyncRoot%2A&gt;durante toda a enumeração.&lt;/xref:System.Collections.Stack.SyncRoot%2A&gt;</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Classic Stack.IsSynchronized Example#2<ept id="p2">](~/add/codesnippet/cpp/m-system.collections.sta_3_1.cpp)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>Classic Stack.IsSynchronized Example#2<ept id="p4">](~/add/codesnippet/csharp/m-system.collections.sta_3_1.cs)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Classic Stack.IsSynchronized Example#2<ept id="p6">](~/add/codesnippet/visualbasic/m-system.collections.sta_3_1.vb)</ept><ept id="p5">]</ept>       This method is an O(1) operation.</source>
          <target state="translated"><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Clássico Stack.IsSynchronized exemplo n º&amp;2;<ept id="p2">](~/add/codesnippet/cpp/m-system.collections.sta_3_1.cpp)</ept><ept id="p1">]</ept><bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>clássico Stack.IsSynchronized exemplo n º&amp;2;<ept id="p4">](~/add/codesnippet/csharp/m-system.collections.sta_3_1.cs)</ept><ept id="p3">]</ept><bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>clássico Stack.IsSynchronized exemplo n º&amp;2;<ept id="p6">](~/add/codesnippet/visualbasic/m-system.collections.sta_3_1.vb)</ept> <ept id="p5">]</ept> esse método é uma operação de (1).    </target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to synchronize.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> para sincronizar.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A synchronized wrapper around the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Um wrapper sincronizado em torno de <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;stack&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;stack&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Gets an object that can be used to synchronize access to the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Obtém um objeto que pode ser usado para sincronizar o acesso a <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a synchronized version of the &lt;xref:System.Collections.Stack&gt;, use the &lt;xref:System.Collections.Stack.Synchronized%2A&gt; method.</source>
          <target state="translated">Para criar uma versão sincronizada do &lt;xref:System.Collections.Stack&gt;, use o &lt;xref:System.Collections.Stack.Synchronized%2A&gt;método.&lt;/xref:System.Collections.Stack.Synchronized%2A&gt; &lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, derived classes can provide their own synchronized version of the &lt;xref:System.Collections.Stack&gt; using the SyncRoot property.</source>
          <target state="translated">No entanto, as classes derivadas podem fornecer sua própria versão sincronizada de &lt;xref:System.Collections.Stack&gt;usando a propriedade SyncRoot.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>The synchronizing code must perform operations on the SyncRoot of the &lt;xref:System.Collections.Stack&gt;, not directly on the &lt;xref:System.Collections.Stack&gt;.</source>
          <target state="translated">O código de sincronização deve executar operações no SyncRoot do &lt;xref:System.Collections.Stack&gt;, não diretamente no &lt;xref:System.Collections.Stack&gt;.&lt;/xref:System.Collections.Stack&gt; &lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Isso garante que a operação correta de coleções que são derivados de outros objetos.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the &lt;xref:System.Collections.Stack&gt; object.</source>
          <target state="translated">Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificando o &lt;xref:System.Collections.Stack&gt;objeto.&lt;/xref:System.Collections.Stack&gt;</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar através de uma coleção intrinsecamente não é um procedimento de thread-safe.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção é sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração ou capture as exceções resultante de alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example shows how to lock the collection using the SyncRoot during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o SyncRoot durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Classic Stack.IsSynchronized Example#2<ept id="p2">](~/add/codesnippet/cpp/p-system.collections.sta_1_1.cpp)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>Classic Stack.IsSynchronized Example#2<ept id="p4">](~/add/codesnippet/csharp/p-system.collections.sta_1_1.cs)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Classic Stack.IsSynchronized Example#2<ept id="p6">](~/add/codesnippet/visualbasic/p-system.collections.sta_1_1.vb)</ept><ept id="p5">]</ept>       Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated"><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Clássico Stack.IsSynchronized exemplo n º&amp;2;<ept id="p2">](~/add/codesnippet/cpp/p-system.collections.sta_1_1.cpp)</ept><ept id="p1">]</ept><bpt id="p3">[!code-cs</bpt><bpt id="p4">[</bpt>clássico Stack.IsSynchronized exemplo n º&amp;2;<ept id="p4">](~/add/codesnippet/csharp/p-system.collections.sta_1_1.cs)</ept><ept id="p3">]</ept><bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>clássico Stack.IsSynchronized exemplo n º&amp;2;<ept id="p6">](~/add/codesnippet/visualbasic/p-system.collections.sta_1_1.vb)</ept> <ept id="p5">]</ept> recuperar o valor dessa propriedade é uma operação de (1).    </target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Object&gt; that can be used to synchronize access to the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Um &lt;xref:System.Object&gt;que pode ser usado para sincronizar o acesso a <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Object&gt;</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Copies the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to a new array.</source>
          <target state="translated">Copia o <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> para uma nova matriz.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied onto the array in last-in-first-out (LIFO) order, similar to the order of the elements returned by a succession of calls to &lt;xref:System.Collections.Stack.Pop%2A&gt;.</source>
          <target state="translated">Os elementos são copiados para a matriz na ordem do último a entrar, primeiro a sair (UEPS), semelhante à ordem dos elementos retornados por uma sucessão de chamadas para &lt;xref:System.Collections.Stack.Pop%2A&gt;.&lt;/xref:System.Collections.Stack.Pop%2A&gt;</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is &lt;xref:System.Collections.Stack.Count%2A&gt;.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é &lt;xref:System.Collections.Stack.Count%2A&gt;.&lt;/xref:System.Collections.Stack.Count%2A&gt;</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>A new array containing copies of the elements of the <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Uma nova matriz que contém cópias dos elementos do <bpt id="p1">&lt;xref href="System.Collections.Stack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>