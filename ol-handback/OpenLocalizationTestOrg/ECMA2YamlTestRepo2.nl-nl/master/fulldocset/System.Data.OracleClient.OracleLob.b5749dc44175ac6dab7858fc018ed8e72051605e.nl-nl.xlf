<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="nl-nl">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0bd7caa82ae55a2966b763cc4755cdcf6036f053</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Data.OracleClient.OracleLob.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9d055d8097daf143388e9c7df491824734cadd80</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3edd14644522bf37966b2bf30006e36d5df4e8ea</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a large object binary (<bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) data type stored on an Oracle server.</source>
          <target state="translated">Hiermee geeft u een binaire large object (<bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) gegevenstype dat is opgeslagen op een Oracle-server.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This class cannot be inherited.</source>
          <target state="translated">Deze klasse kan niet worden overgenomen.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>An OracleLob differs from an &lt;xref:System.Data.OracleClient.OracleBFile&gt; in that the data is stored on the server instead of in a physical file in the operating system.</source>
          <target state="translated">Een OracleLob wijkt af van een &lt;xref:System.Data.OracleClient.OracleBFile&gt;in dat de gegevens worden opgeslagen op de server in plaats van in een fysiek bestand in het besturingssysteem.&lt;/xref:System.Data.OracleClient.OracleBFile&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can also be a read-write object, unlike an &lt;xref:System.Data.OracleClient.OracleBFile&gt;, which is always read-only.</source>
          <target state="translated">Het kan ook worden veroorzaakt een lezen / schrijven-object, in tegenstelling tot een &lt;xref:System.Data.OracleClient.OracleBFile&gt;, die altijd is alleen-lezen.&lt;/xref:System.Data.OracleClient.OracleBFile&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>An OracleLob may be one of these &lt;xref:System.Data.OracleClient.OracleType&gt; data types.</source>
          <target state="translated">Een OracleLob mogelijk een van deze &lt;xref:System.Data.OracleClient.OracleType&gt;gegevenstypen.&lt;/xref:System.Data.OracleClient.OracleType&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>|OracleType data type|Description|   |--------------------------|-----------------|   |<ph id="ph1">`Blob`</ph>|An Oracle <ph id="ph2">`BLOB`</ph> data type that contains binary data with a maximum size of 4 gigabytes (GB).</source>
          <target state="translated">| Het gegevenstype OracleType | Beschrijving |   |--------------------------|-----------------|   | <ph id="ph1">`Blob`</ph>| Een Oracle <ph id="ph2">`BLOB`</ph> gegevenstype met binaire gegevens met een maximale grootte van 4 gigabyte (GB).</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>This maps to an &lt;xref:System.Array&gt; of type &lt;xref:System.Byte&gt;.|   |<ph id="ph1">`Clob`</ph>|An Oracle <ph id="ph2">`CLOB`</ph> data type that contains character data, based on the default character set on the server, with a maximum size of 4 GB.</source>
          <target state="translated">Dit wordt toegewezen aan een &lt;xref:System.Array&gt;van het type &lt;xref:System.Byte&gt;. |   | <ph id="ph1">`Clob`</ph>| Een Oracle <ph id="ph2">`CLOB`</ph> gegevenstype met tekengegevens, op basis van het standaardteken ingesteld op de server, met een maximale grootte van 4 GB.&lt;/xref:System.Byte&gt; &lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>This maps to &lt;xref:System.String&gt;.|   |<ph id="ph1">`NClob`</ph>|An Oracle <ph id="ph2">`NCLOB`</ph> data type that contains character data, based on the national character set on the server with a maximum size of 4 GB.</source>
          <target state="translated">Dit wordt toegewezen aan &lt;xref:System.String&gt;. |   | <ph id="ph1">`NClob`</ph>| Een Oracle <ph id="ph2">`NCLOB`</ph> gegevenstype met tekengegevens, op basis van de national tekenset op de server met een maximale grootte van 4 GB.&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>This maps to &lt;xref:System.String&gt;.|       A .NET application developer can retrieve the Oracle <ph id="ph1">`LOB`</ph> values into basic .NET data types, such as &lt;xref:System.Array&gt; of type &lt;xref:System.Byte&gt; and &lt;xref:System.String&gt;, or the specialized OracleLob data type.</source>
          <target state="translated">Dit wordt toegewezen aan &lt;xref:System.String&gt;. |       Een ontwikkelaar van de .NET-toepassingen kan de Oracle ophalen <ph id="ph1">`LOB`</ph> waarden in basic .NET-gegevenstypen, zoals &lt;xref:System.Array&gt;van het type &lt;xref:System.Byte&gt;en &lt;xref:System.String&gt;, of het gespecialiseerde OracleLob-gegevenstype.&lt;/xref:System.String&gt; &lt;/xref:System.Byte&gt; &lt;/xref:System.Array&gt; &lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The OracleLob class supports reading data from and writing to the Oracle <ph id="ph1">`LOB`</ph> in the Oracle database.</source>
          <target state="translated">De OracleLob klasse ondersteunt lezen van gegevens van en schrijven naar de Oracle <ph id="ph1">`LOB`</ph> in de Oracle-database.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are the main characteristics of an OracleLob data type that distinguish it from basic .NET data types:      -   After you retrieve the Oracle <ph id="ph1">`LOB`</ph> value from the Oracle database into the OracleLob class, you can change the <ph id="ph2">`LOB`</ph> data in an open transaction and your changes are directly reflected to the database.</source>
          <target state="translated">Hieronder volgen de belangrijkste kenmerken van een gegevenstype OracleLob die deze van basic .NET-gegevenstypen onderscheidt:: nadat u de Oracle ophalen <ph id="ph1">`LOB`</ph> waarde van de Oracle-database in de klasse OracleLob, kunt u de <ph id="ph2">`LOB`</ph> gegevens in een geopende transactie en uw wijzigingen rechtstreeks naar de database worden doorgevoerd.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you retrieve the Oracle <ph id="ph1">`LOB`</ph> value into an &lt;xref:System.Array&gt; of type &lt;xref:System.Byte&gt; or &lt;xref:System.String&gt; and update these arrays, your changes are not reflected to the database.</source>
          <target state="translated">Als u de Oracle ophaalt <ph id="ph1">`LOB`</ph> waarde in een &lt;xref:System.Array&gt;van het type &lt;xref:System.Byte&gt;of &lt;xref:System.String&gt;en deze matrices, werk uw wijzigingen worden niet weergegeven in de database.&lt;/xref:System.String&gt; &lt;/xref:System.Byte&gt; &lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   When you use the OracleLob class to access a chunk of a <ph id="ph1">`LOB`</ph> value, only that chunk is passed from the Oracle database to the client.</source>
          <target state="translated">-Wanneer u de klasse OracleLob gebruiken voor toegang tot een deel van een <ph id="ph1">`LOB`</ph> , alleen die chunk is doorgegeven vanuit de Oracle-database naar de client.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you use the &lt;xref:System.Data.OracleClient.OracleDataReader.GetChars%2A&gt; method to access a chunk of a <ph id="ph1">`LOB`</ph> value, the entire contents of the value are passed from the Oracle database to the client.</source>
          <target state="translated">Wanneer u gebruikt de &lt;xref:System.Data.OracleClient.OracleDataReader.GetChars%2A&gt;methode voor toegang tot een deel van een <ph id="ph1">`LOB`</ph> waarde, de volledige inhoud van de waarde worden doorgegeven vanuit de Oracle-database naar de client.&lt;/xref:System.Data.OracleClient.OracleDataReader.GetChars%2A&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>To obtain an OracleLob object, call the &lt;xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A&gt; method.</source>
          <target state="translated">Aanroepen voor een object OracleLob de &lt;xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A&gt;methode.&lt;/xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can construct an OracleLob that is NULL using this format:      <ph id="ph1">```   OracleLob myLob = OracleLob.Null;   ```</ph>       This technique is used primarily to test whether a <ph id="ph2">`LOB`</ph> returned from the server is NULL, as this example illustrates:      <ph id="ph3">```   If(myLob == OracleLob.Null)   ```</ph>       A NULL <ph id="ph4">`LOB`</ph> behaves similarly to a zero-byte <ph id="ph5">`LOB`</ph> in that &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt; succeeds and always returns zero bytes.</source>
          <target state="translated">U kunt een OracleLob die met deze indeling NULL opstellen: <ph id="ph1">```   OracleLob myLob = OracleLob.Null;   ```</ph> deze techniek wordt gebruikt voor het testen of een <ph id="ph2">`LOB`</ph> geretourneerd vanaf de server is NULL, zoals in dit voorbeeld te zien: <ph id="ph3">```   If(myLob == OracleLob.Null)   ```</ph> A NULL <ph id="ph4">`LOB`</ph> gedraagt zich op dezelfde manier naar een nul-byte <ph id="ph5">`LOB`</ph> in dat &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt;is gelukt en retourneert altijd nul bytes.&lt;/xref:System.Data.OracleClient.OracleLob.Read%2A&gt;</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>Selecting a <ph id="ph1">`LOB`</ph> column that contains a null value returns &lt;xref:System.Data.OracleClient.OracleLob.Null&gt;.</source>
          <target state="translated">Als u een <ph id="ph1">`LOB`</ph> kolom met een null-waarde als resultaat gegeven &lt;xref:System.Data.OracleClient.OracleLob.Null&gt;.&lt;/xref:System.Data.OracleClient.OracleLob.Null&gt;</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must begin a transaction before obtaining a temporary <ph id="ph1">`LOB`</ph>.</source>
          <target state="translated">U moet beginnen met een transactie voordat het verkrijgen van een tijdelijke <ph id="ph1">`LOB`</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the &lt;xref:System.Data.OracleClient.OracleDataReader&gt; may fail to obtain data later.</source>
          <target state="translated">Anders wordt de &lt;xref:System.Data.OracleClient.OracleDataReader&gt;mislukken mogelijk om gegevens te verkrijgen later.&lt;/xref:System.Data.OracleClient.OracleDataReader&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also open a temporary <ph id="ph1">`LOB`</ph> in Oracle by calling the DBMS_LOB.CREATETEMPORARY system stored procedure and binding a <ph id="ph2">`LOB`</ph> output parameter.</source>
          <target state="translated">U kunt ook een tijdelijke openen <ph id="ph1">`LOB`</ph> in Oracle door het aanroepen van de DBMS_LOB. CREATETEMPORARY systeem opgeslagen procedure en de binding een <ph id="ph2">`LOB`</ph> uitvoerparameter.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the client side, a temporary <ph id="ph1">`LOB`</ph> behaves like a table-based <ph id="ph2">`LOB`</ph>.</source>
          <target state="translated">Aan de clientzijde, een tijdelijke <ph id="ph1">`LOB`</ph> gedraagt zich als een tabel op basis van <ph id="ph2">`LOB`</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, to update the temporary <ph id="ph1">`LOB`</ph>, it must be enclosed in a transaction.</source>
          <target state="translated">Bijvoorbeeld, om het bijwerken van de tijdelijke <ph id="ph1">`LOB`</ph>, deze moet worden ingesloten in een transactie.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following C# example demonstrates how to open a temporary <ph id="ph1">`LOB`</ph>.</source>
          <target state="translated">De volgende C#-voorbeeld toont hoe een tijdelijke openen <ph id="ph1">`LOB`</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");   connection.Open();   OracleTransaction transaction = connection.BeginTransaction();   OracleCommand command = connection.CreateCommand();   command.Transaction = transaction;   command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";   command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;   command.ExecuteNonQuery();   OracleLob tempLob = (OracleLob)command.Parameters[0].Value;   byte[] tempbuff = new byte[10000];   tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);   tempLob.Write(tempbuff,0,tempbuff.Length);   tempLob.EndBatch();   command.Parameters.Clear();   command.CommandText = "MyTable.MyProc";   command.CommandType = CommandType.StoredProcedure;     command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;   command.ExecuteNonQuery();   transaction.Commit();   connection.Close   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  The inherited &lt;xref:System.IO.Stream.WriteByte%2A&gt; method fails if used with character data, and an &lt;xref:System.InvalidOperationException&gt; is thrown.</source>
          <target state="translated"><ph id="ph1">```   OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");   connection.Open();   OracleTransaction transaction = connection.BeginTransaction();   OracleCommand command = connection.CreateCommand();   command.Transaction = transaction;   command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";   command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;   command.ExecuteNonQuery();   OracleLob tempLob = (OracleLob)command.Parameters[0].Value;   byte[] tempbuff = new byte[10000];   tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);   tempLob.Write(tempbuff,0,tempbuff.Length);   tempLob.EndBatch();   command.Parameters.Clear();   command.CommandText = "MyTable.MyProc";   command.CommandType = CommandType.StoredProcedure;     command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;   command.ExecuteNonQuery();   transaction.Commit();   connection.Close   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph>&gt; De overgenomen &lt;xref:System.IO.Stream.WriteByte%2A&gt;methode mislukt als met tekengegevens, gebruikt en een &lt;xref:System.InvalidOperationException&gt;gegenereerd.&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.IO.Stream.WriteByte%2A&gt;</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Data.OracleClient.OracleLob.Write%2A&gt; method instead.</source>
          <target state="translated">Gebruik de &lt;xref:System.Data.OracleClient.OracleLob.Write%2A&gt;methode in plaats daarvan.&lt;/xref:System.Data.OracleClient.OracleLob.Write%2A&gt;</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt;    &gt;  Temporary <ph id="ph1">`LOB`</ph>s are only closed when the connection is closed, but with pooling and under load, temporary <ph id="ph2">`LOB`</ph>s do not close.</source>
          <target state="translated">&gt;&gt; Tijdelijke <ph id="ph1">`LOB`</ph>s zijn alleen gesloten wanneer de verbinding is gesloten, maar met groeperen en belast, tijdelijke <ph id="ph2">`LOB`</ph>s niet sluiten.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can be resolved by disposing the temporary <ph id="ph1">`LOB`</ph>, by invoking <ph id="ph2">`tempLob.Dispose()`</ph>.</source>
          <target state="translated">Dit kan worden opgelost door de verwijdering van de tijdelijke <ph id="ph1">`LOB`</ph>, door aan te roepen <ph id="ph2">`tempLob.Dispose()`</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Appends data from the specified <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the current <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Gegevens uit de opgegeven voegt <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> naar het huidige <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>All data from the source <ph id="ph1">`LOB`</ph> is appended to the end of the current <ph id="ph2">`LOB`</ph>.</source>
          <target state="translated">Alle gegevens van de bron <ph id="ph1">`LOB`</ph> wordt toegevoegd aan het einde van de huidige <ph id="ph2">`LOB`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>The position of neither <ph id="ph1">`LOB`</ph> is evaluated or changed during this process.</source>
          <target state="translated">De positie van geen van beide <ph id="ph1">`LOB`</ph> wordt geëvalueerd of gewijzigd tijdens dit proces.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The underlying data types must always be the same.</source>
          <target state="translated">De onderliggende gegevenstypen moet altijd hetzelfde.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are appending from an &lt;xref:System.Data.OracleClient.OracleType&gt;, the destination &lt;xref:System.Data.OracleClient.OracleLob&gt; must also be an &lt;xref:System.Data.OracleClient.OracleType&gt;.</source>
          <target state="translated">Bijvoorbeeld, als u van een &lt;xref:System.Data.OracleClient.OracleType&gt;het doel &lt;xref:System.Data.OracleClient.OracleLob&gt;moet ook een &lt;xref:System.Data.OracleClient.OracleType&gt;.&lt;/xref:System.Data.OracleClient.OracleType&gt; &lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleType&gt; toevoegt</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In this release, a write operation to a read-only <ph id="ph2">`LOB`</ph> might succeed, but does not update the <ph id="ph3">`LOB`</ph> on the server.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; In deze release een schrijfbewerking naar een alleen-lezen <ph id="ph2">`LOB`</ph> mogelijk wel, maar werkt niet bij de <ph id="ph3">`LOB`</ph> op de server.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, however, the local copy of the <ph id="ph1">`LOB`</ph> is updated.</source>
          <target state="translated">In dit geval echter de lokale kopie van de <ph id="ph1">`LOB`</ph> wordt bijgewerkt.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, later read operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt; object might return the results of the write operation.</source>
          <target state="translated">Daarom later leesbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;object kan het resultaat van de schrijfbewerking.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to append data.</source>
          <target state="translated">De <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> waaruit u gegevens toevoegt.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The source <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is null.</source>
          <target state="translated">De bron <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> is null.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The source <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is null, or the connection is closed.</source>
          <target state="translated">De bron <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> is leeg, of de verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The source <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object was closed or disposed.</source>
          <target state="translated">De bron <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Prevents server-side triggers from firing while performing multiple read operations.</source>
          <target state="translated">Voorkomt dat de triggers-serverzijde starten tijdens het uitvoeren van meerdere leesbewerkingen.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Opens the <ph id="ph1">`LOB`</ph> in &lt;xref:System.Data.OracleClient.OracleLobOpenMode&gt; mode; therefore, the <ph id="ph2">`LOB`</ph> can only be read from, not written to, until the corresponding call to &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt;.</source>
          <target state="translated">Hiermee opent u de <ph id="ph1">`LOB`</ph> in &lt;xref:System.Data.OracleClient.OracleLobOpenMode&gt;modus; daarom de <ph id="ph2">`LOB`</ph> kunnen alleen worden gelezen vanaf, niet worden geschreven, totdat de bijbehorende aanroep &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt;.&lt;/xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt; &lt;/xref:System.Data.OracleClient.OracleLobOpenMode&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform batch writes to the <ph id="ph1">`LOB`</ph>, call &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch%2A&gt; with &lt;xref:System.Data.OracleClient.OracleLobOpenMode&gt;.</source>
          <target state="translated">Uitvoeren van batch schrijfbewerkingen naar de <ph id="ph1">`LOB`</ph>, roept &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch%2A&gt;met &lt;xref:System.Data.OracleClient.OracleLobOpenMode&gt;.&lt;/xref:System.Data.OracleClient.OracleLobOpenMode&gt; &lt;/xref:System.Data.OracleClient.OracleLob.BeginBatch%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling BeginBatch more than one time within the same transaction currently throws the Oracle "ORA-22293: LOB already opened in the same transaction" error.</source>
          <target state="translated">De Oracle BeginBatch binnen dezelfde transactie momenteel meer dan één keer aanroepen genereert ' ORA&amp;22293;: LOB al geopend in dezelfde transactie ' fout.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, if you obtain the <ph id="ph1">`LOB`</ph> using another &lt;xref:System.Data.OracleClient.OracleDataReader&gt;, and the original caller has not called the &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt; method, the same error is generated.</source>
          <target state="translated">Als u bovendien de <ph id="ph1">`LOB`</ph> met behulp van een andere &lt;xref:System.Data.OracleClient.OracleDataReader&gt;, en de oorspronkelijke aanroeper is niet aangeroepen de &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt;methode wordt dezelfde fout wordt gegenereerd.&lt;/xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt; &lt;/xref:System.Data.OracleClient.OracleDataReader&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call the &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt; method when you are finished using the &lt;xref:System.Data.OracleClient.OracleLob&gt;.</source>
          <target state="translated">Daarom moet u de &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt;methode wanneer u klaar bent met de &lt;xref:System.Data.OracleClient.OracleLob&gt;.&lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt; aanroepen</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The connection is closed.</source>
          <target state="translated">De verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Prevents server-side triggers from firing while performing multiple read and write operations in the specified access mode.</source>
          <target state="translated">Voorkomt u dat de triggers-serverzijde wordt dan tijdens het uitvoeren van meerdere lezen- en schrijfbewerkingen in de opgegeven toegangsmodus.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch%2A&gt; more than one time within the same transaction currently throws the Oracle "ORA-22293: LOB already opened in the same transaction" error.</source>
          <target state="translated">Het aanroepen van &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch%2A&gt;binnen dezelfde transactie momenteel meer dan één keer genereert de Oracle ' ORA&amp;22293;: LOB al geopend in dezelfde transactie ' fout.&lt;/xref:System.Data.OracleClient.OracleLob.BeginBatch%2A&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, if you obtain the <ph id="ph1">`LOB`</ph> using another &lt;xref:System.Data.OracleClient.OracleDataReader&gt;, and the original caller has not called the &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt; method, the same error is generated.</source>
          <target state="translated">Als u bovendien de <ph id="ph1">`LOB`</ph> met behulp van een andere &lt;xref:System.Data.OracleClient.OracleDataReader&gt;, en de oorspronkelijke aanroeper is niet aangeroepen de &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt;methode wordt dezelfde fout wordt gegenereerd.&lt;/xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt; &lt;/xref:System.Data.OracleClient.OracleDataReader&gt;</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call the &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt; method when you are finished using the &lt;xref:System.Data.OracleClient.OracleLob&gt;.</source>
          <target state="translated">Daarom moet u de &lt;xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt;methode wanneer u klaar bent met de &lt;xref:System.Data.OracleClient.OracleLob&gt;.&lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleLob.EndBatch%2A&gt; aanroepen</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Mode (one of the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLobOpenMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values) in which the <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> can be accessed between this BeginBatch call and the corresponding &lt;xref:System.Data.OracleClient.OracleLob.EndBatch*&gt; call.</source>
          <target state="translated">Modus (een van de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLobOpenMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> waarden) waarin de <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> toegankelijk zijn tussen deze aanroep BeginBatch en de bijbehorende &lt;xref:System.Data.OracleClient.OracleLob.EndBatch*&gt;aanroepen.&lt;/xref:System.Data.OracleClient.OracleLob.EndBatch*&gt;</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The connection is closed.</source>
          <target state="translated">De verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> stream can be read.</source>
          <target state="translated">Haalt een waarde die aangeeft of de <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> stroom kan worden gelezen.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> stream supports reading, otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> if a <bpt id="p4">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept> is closed or disposed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Als de <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> stroom ondersteunt lezen, anders <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> als een <bpt id="p4">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept> is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether forward and backward seek operations can be performed.</source>
          <target state="translated">Haalt een waarde die aangeeft of voorwaarts en achterwaarts zoekbewerkingen kunnen worden uitgevoerd.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if a <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> is closed or disposed, otherwise <bpt id="p3">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Als een <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> is gesloten of verwijderd, anders <bpt id="p3">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Always <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob.Null"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Always <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob.Null"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Always returns true, regardless of whether the <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> supports writing or not.</source>
          <target state="translated">Altijd ' true ' geretourneerd, ongeacht of de <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> schrijven of niet ondersteunt.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have started a local transaction.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet zijn gestart een lokale transactie.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Always returns <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, regardless of whether an opened or undisposed <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> supports writing or not, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> if a <bpt id="p4">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept> is closed or disposed.</source>
          <target state="translated">Retourneert altijd <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>, ongeacht of u een geopende of undisposed <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> ondersteunt ook het schrijven of niet, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> als een <bpt id="p4">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept> is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the minimum number of bytes to retrieve from or send to the server during a read/write operation.</source>
          <target state="translated">Haalt een waarde die aangeeft het minimum aantal bytes ophalen uit of tijdens een bewerking lezen/schrijven naar de server stuurt.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value returned by the ChunkSize property is not a setting of the .NET Framework Data Provider for Oracle.</source>
          <target state="translated">De waarde die is geretourneerd door de eigenschap ChunkSize is niet een instelling van de .NET Framework-gegevensprovider voor Oracle.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it is the value that the Oracle Call Interface (OCI) uses when communicating with the server.</source>
          <target state="translated">Het is in plaats daarvan de waarde die Oracle aanroepen Interface (OCI) gebruikt om te communiceren met de server.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use ChunkSize to ensure that client-side chunks are the same size.</source>
          <target state="translated">Gebruik ChunkSize om ervoor te zorgen dat aan de clientzijde segmenten even groot zijn.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading or writing in smaller chunks does not cache data, and causes a less-optimized round trip to the server, because a full packet is not received or sent.</source>
          <target state="translated">Lezen of schrijven in kleinere reeksen geen gegevens in de cache en zorgt ervoor dat een minder geoptimaliseerd retouren naar de server, omdat een volledige pakket is niet ontvangen of verzonden.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The minimum number of bytes to retrieve or send.</source>
          <target state="translated">Het minimale aantal bytes worden verzonden of ontvangen.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The connection is closed.</source>
          <target state="translated">De verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Creates a new <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that references the same Oracle <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> as the original <bpt id="p3">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">Maakt een nieuw <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object dat verwijst naar dezelfde Oracle <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> als de oorspronkelijke <bpt id="p3">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> object.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>The properties of the new &lt;xref:System.Data.OracleClient.OracleLob&gt; object initially have the same values as those of the original object.</source>
          <target state="translated">De eigenschappen van de nieuwe &lt;xref:System.Data.OracleClient.OracleLob&gt;object in eerste instantie hebben dezelfde waarden als die van het oorspronkelijke object.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, after the Clone is complete, each &lt;xref:System.Data.OracleClient.OracleLob&gt; object is independent from the other.</source>
          <target state="translated">Echter, nadat het klonen voltooid, elke is &lt;xref:System.Data.OracleClient.OracleLob&gt;object is niet afhankelijk van de andere.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, changing the value of the &lt;xref:System.Data.OracleClient.OracleLob.Position%2A&gt; property on the original &lt;xref:System.Data.OracleClient.OracleLob&gt; does not change the value of &lt;xref:System.Data.OracleClient.OracleLob.Position%2A&gt; on the copy.</source>
          <target state="translated">Als u bijvoorbeeld de waarde van de &lt;xref:System.Data.OracleClient.OracleLob.Position%2A&gt;eigenschap op de oorspronkelijke &lt;xref:System.Data.OracleClient.OracleLob&gt;verandert niet de waarde van &lt;xref:System.Data.OracleClient.OracleLob.Position%2A&gt;op de kopie.&lt;/xref:System.Data.OracleClient.OracleLob.Position%2A&gt; &lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleLob.Position%2A&gt;</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>A new <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that references the same Oracle <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> as the original <bpt id="p3">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">Een nieuwe <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object dat verwijst naar dezelfde Oracle <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> als de oorspronkelijke <bpt id="p3">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> object.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The connection is closed.</source>
          <target state="translated">De verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Gets the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleConnection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used by this instance of the <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Haalt de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleConnection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> gebruikt door dit exemplaar van de <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The connection to a data source.</source>
          <target state="translated">De verbinding met een gegevensbron.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Copies from this <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to a destination <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Exemplaren van deze <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> naar een bestemming <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>The underlying data types must always be the same.</source>
          <target state="translated">De onderliggende gegevenstypen moet altijd hetzelfde.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are copying from an &lt;xref:System.Data.OracleClient.OracleType&gt;, the destination &lt;xref:System.Data.OracleClient.OracleLob&gt; must also be an &lt;xref:System.Data.OracleClient.OracleType&gt;.</source>
          <target state="translated">Bijvoorbeeld, als u wilt kopiëren uit een &lt;xref:System.Data.OracleClient.OracleType&gt;het doel &lt;xref:System.Data.OracleClient.OracleLob&gt;moet ook een &lt;xref:System.Data.OracleClient.OracleType&gt;.&lt;/xref:System.Data.OracleClient.OracleType&gt; &lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleType&gt;</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the destination offset is beyond the end of destination <ph id="ph1">`LOB`</ph>, the <ph id="ph2">`LOB`</ph> to which the data is being copied is extended.</source>
          <target state="translated">Als de doel-offset voorbij het einde van bestemming is <ph id="ph1">`LOB`</ph>, wordt de <ph id="ph2">`LOB`</ph> die de gegevens wordt gekopieerd wordt uitgebreid.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>The space between the end of the <ph id="ph1">`LOB`</ph> and the destination offset beyond the end is padded with zeros for <ph id="ph2">`BLOB`</ph> data types and spaces for <ph id="ph3">`CLOB`</ph> and <ph id="ph4">`NCLOB`</ph> data types.</source>
          <target state="translated">De afstand tussen het einde van de <ph id="ph1">`LOB`</ph> en de verschuiving voorbij het einde van de bestemming opgevuld met nullen voor <ph id="ph2">`BLOB`</ph> gegevenstypen en spaties voor <ph id="ph3">`CLOB`</ph> en <ph id="ph4">`NCLOB`</ph> gegevenstypen.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In this release, a write operation to a read-only <ph id="ph2">`LOB`</ph> might succeed, but not update the <ph id="ph3">`LOB`</ph> on the server.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; In deze release een schrijfbewerking naar een alleen-lezen <ph id="ph2">`LOB`</ph> mogelijk slagen, maar niet bijgewerkt de <ph id="ph3">`LOB`</ph> op de server.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, however, the local copy of the <ph id="ph1">`LOB`</ph> will be updated.</source>
          <target state="translated">In dit geval echter de lokale kopie van de <ph id="ph1">`LOB`</ph> wordt bijgewerkt.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, later read operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt; object might return the results of the write operation.</source>
          <target state="translated">Daarom later leesbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;object kan het resultaat van de schrijfbewerking.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt;    &gt;  The <ph id="ph1">`CopyTo`</ph> method does not clear the contents of the destination <ph id="ph2">`OracleLob`</ph> before performing the copy operation.</source>
          <target state="translated">&gt;&gt; De <ph id="ph1">`CopyTo`</ph> methode wist u de inhoud van de bestemming niet <ph id="ph2">`OracleLob`</ph> voordat de kopieerbewerking wordt uitgevoerd.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The destination <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">De bestemming <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The number of bytes copied.</source>
          <target state="translated">Het aantal bytes dat wordt gekopieerd.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This excludes any padded bytes.</source>
          <target state="translated">Dit omvat niet alle gevuld bytes.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specified in the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">destination</ph><ept id="p2">&lt;/code&gt;</ept> parameter is null.</source>
          <target state="translated">De <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> opgegeven in de <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph1">destination</ph> <ept id="p2">&lt;/code&gt;</ept> -parameter is null.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The operation is not within a transaction, the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is null, or the connection is closed.</source>
          <target state="translated">De bewerking is niet binnen een transactie de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object is null of de verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Copies from this <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to a destination <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> with the specified amount of data.</source>
          <target state="translated">Exemplaren van deze <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> naar een bestemming <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> met de opgegeven hoeveelheid gegevens.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>The underlying data types must always be the same.</source>
          <target state="translated">De onderliggende gegevenstypen moet altijd hetzelfde.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are copying from an &lt;xref:System.Data.OracleClient.OracleType&gt;, the destination &lt;xref:System.Data.OracleClient.OracleLob&gt; must also be an &lt;xref:System.Data.OracleClient.OracleType&gt;.</source>
          <target state="translated">Bijvoorbeeld, als u wilt kopiëren uit een &lt;xref:System.Data.OracleClient.OracleType&gt;het doel &lt;xref:System.Data.OracleClient.OracleLob&gt;moet ook een &lt;xref:System.Data.OracleClient.OracleType&gt;.&lt;/xref:System.Data.OracleClient.OracleType&gt; &lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleType&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the destination offset is beyond the end of destination <ph id="ph1">`LOB`</ph>, the <ph id="ph2">`LOB`</ph> to which the data is being copied is extended.</source>
          <target state="translated">Als de doel-offset voorbij het einde van bestemming is <ph id="ph1">`LOB`</ph>, wordt de <ph id="ph2">`LOB`</ph> die de gegevens wordt gekopieerd wordt uitgebreid.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>The space between the end of <ph id="ph1">`LOB`</ph> and destination offset beyond the end is padded with zeros for <ph id="ph2">`BLOB`</ph> data types and spaces for <ph id="ph3">`CLOB`</ph> and <ph id="ph4">`NCLOB`</ph> data types.</source>
          <target state="translated">De afstand tussen het einde van <ph id="ph1">`LOB`</ph> en verschuiving voorbij het einde van de bestemming opgevuld met nullen voor <ph id="ph2">`BLOB`</ph> gegevenstypen en spaties voor <ph id="ph3">`CLOB`</ph> en <ph id="ph4">`NCLOB`</ph> gegevenstypen.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In this release, a write operation to a read-only <ph id="ph2">`LOB`</ph> might succeed, but does not update the <ph id="ph3">`LOB`</ph> on the server.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; In deze release een schrijfbewerking naar een alleen-lezen <ph id="ph2">`LOB`</ph> mogelijk wel, maar werkt niet bij de <ph id="ph3">`LOB`</ph> op de server.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, however, the local copy of the <ph id="ph1">`LOB`</ph> is updated.</source>
          <target state="translated">In dit geval echter de lokale kopie van de <ph id="ph1">`LOB`</ph> wordt bijgewerkt.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, later read operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt; object might return the results of the write operation.</source>
          <target state="translated">Daarom later leesbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;object kan het resultaat van de schrijfbewerking.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt;    &gt;  The <ph id="ph1">`CopyTo`</ph> method does not clear the contents of the destination <ph id="ph2">`OracleLob`</ph> before performing the copy operation.</source>
          <target state="translated">&gt;&gt; De <ph id="ph1">`CopyTo`</ph> methode wist u de inhoud van de bestemming niet <ph id="ph2">`OracleLob`</ph> voordat de kopieerbewerking wordt uitgevoerd.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The destination <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept></source>
          <target state="translated">De bestemming<bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The offset to which to copy.</source>
          <target state="translated">De offset waarnaar u wilt kopiëren.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number of bytes.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even aantal bytes.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The number of bytes copied.</source>
          <target state="translated">Het aantal bytes dat wordt gekopieerd.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This excludes any padded bytes.</source>
          <target state="translated">Dit omvat niet alle gevuld bytes.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specified in the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">destination</ph><ept id="p2">&lt;/code&gt;</ept> parameter is full.</source>
          <target state="translated">De <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> opgegeven in de <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph1">destination</ph> <ept id="p2">&lt;/code&gt;</ept> parameter vol is.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>A value specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">destinationOffset</ph><ept id="p1">&lt;/code&gt;</ept> parameter is less than zero or greater than 4 gigabytes.</source>
          <target state="translated">Een waarde die is opgegeven de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">destinationOffset</ph> <ept id="p1">&lt;/code&gt;</ept> parameter is kleiner dan nul of groter zijn dan 4 GB.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>-or-       A value specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">destinationOffset</ph><ept id="p1">&lt;/code&gt;</ept> parameter for a <bpt id="p2">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> or <bpt id="p3">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> data type is not even.</source>
          <target state="translated">- of - waarde is opgegeven in de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">destinationOffset</ph> <ept id="p1">&lt;/code&gt;</ept> parameter voor een <bpt id="p2">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> of <bpt id="p3">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> gegevenstype is nog niet.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>-or-       You must specify <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types as an even number of bytes.</source>
          <target state="translated">- of - u moet opgeven <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen als een even getal bytes.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The operation is not within a transaction, the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is null, or the connection is closed.</source>
          <target state="translated">De bewerking is niet binnen een transactie de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object is null of de verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Copies from this <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to a destination <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> with the specified amount of data, and the source offset.</source>
          <target state="translated">Exemplaren van deze <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> naar een bestemming <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> met de opgegeven hoeveelheid gegevens en de verschuiving van de bron.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>The underlying data types must always be the same.</source>
          <target state="translated">De onderliggende gegevenstypen moet altijd hetzelfde.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are copying from an &lt;xref:System.Data.OracleClient.OracleType&gt;, the destination &lt;xref:System.Data.OracleClient.OracleLob&gt; must also be an &lt;xref:System.Data.OracleClient.OracleType&gt;.</source>
          <target state="translated">Bijvoorbeeld, als u wilt kopiëren uit een &lt;xref:System.Data.OracleClient.OracleType&gt;het doel &lt;xref:System.Data.OracleClient.OracleLob&gt;moet ook een &lt;xref:System.Data.OracleClient.OracleType&gt;.&lt;/xref:System.Data.OracleClient.OracleType&gt; &lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleType&gt;</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the destination offset is beyond the end of destination <ph id="ph1">`LOB`</ph>, the <ph id="ph2">`LOB`</ph> to which the data is being copied is extended.</source>
          <target state="translated">Als de doel-offset voorbij het einde van bestemming is <ph id="ph1">`LOB`</ph>, wordt de <ph id="ph2">`LOB`</ph> die de gegevens wordt gekopieerd wordt uitgebreid.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>The space between the end of <ph id="ph1">`LOB`</ph> and destination offset beyond the end is padded with zeros for <ph id="ph2">`BLOB`</ph> data types and spaces for <ph id="ph3">`CLOB`</ph> and <ph id="ph4">`NCLOB`</ph> data types.</source>
          <target state="translated">De afstand tussen het einde van <ph id="ph1">`LOB`</ph> en verschuiving voorbij het einde van de bestemming opgevuld met nullen voor <ph id="ph2">`BLOB`</ph> gegevenstypen en spaties voor <ph id="ph3">`CLOB`</ph> en <ph id="ph4">`NCLOB`</ph> gegevenstypen.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In this release, a write operation to a read-only <ph id="ph2">`LOB`</ph> might succeed, but does not update the <ph id="ph3">`LOB`</ph> on the server.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; In deze release een schrijfbewerking naar een alleen-lezen <ph id="ph2">`LOB`</ph> mogelijk wel, maar werkt niet bij de <ph id="ph3">`LOB`</ph> op de server.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, however, the local copy of the <ph id="ph1">`LOB`</ph> is updated.</source>
          <target state="translated">In dit geval echter de lokale kopie van de <ph id="ph1">`LOB`</ph> wordt bijgewerkt.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, later read operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt; object might return the results of the write operation.</source>
          <target state="translated">Daarom later leesbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;object kan het resultaat van de schrijfbewerking.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt;    &gt;  The <ph id="ph1">`CopyTo`</ph> method does not clear the contents of the destination <ph id="ph2">`OracleLob`</ph> before performing the copy operation.</source>
          <target state="translated">&gt;&gt; De <ph id="ph1">`CopyTo`</ph> methode wist u de inhoud van de bestemming niet <ph id="ph2">`OracleLob`</ph> voordat de kopieerbewerking wordt uitgevoerd.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The offset from which to copy.</source>
          <target state="translated">De offset waaruit u wilt kopiëren.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The destination <bpt id="p1">&lt;xref uid="langword_csharp_OracleLob" name="OracleLob" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept><bpt id="p2">&lt;xref href="System.Data.OracleClient"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The destination <bpt id="p1">&lt;xref uid="langword_csharp_OracleLob" name="OracleLob" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept><bpt id="p2">&lt;xref href="System.Data.OracleClient"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The destination offset to which to copy.</source>
          <target state="translated">De verschuiving van de bestemming waarnaar u wilt kopiëren.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The quantity of data, in bytes, to copy.</source>
          <target state="translated">De hoeveelheid gegevens, in bytes, te kopiëren.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The number of bytes copied.</source>
          <target state="translated">Het aantal bytes dat wordt gekopieerd.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>This excludes any padded bytes.</source>
          <target state="translated">Dit omvat niet alle gevuld bytes.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specified in the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">destination</ph><ept id="p2">&lt;/code&gt;</ept> parameter is full.</source>
          <target state="translated">De <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> opgegeven in de <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph1">destination</ph> <ept id="p2">&lt;/code&gt;</ept> parameter vol is.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>A value specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">amount</ph><ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">sourceOffset</ph><ept id="p2">&lt;/code&gt;</ept>, or <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">destinationOffset</ph><ept id="p3">&lt;/code&gt;</ept> parameter is less than zero or greater than 4 gigabytes.</source>
          <target state="translated">Een waarde die is opgegeven de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">amount</ph> <ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">sourceOffset</ph> <ept id="p2">&lt;/code&gt;</ept>, of <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph3">destinationOffset</ph> <ept id="p3">&lt;/code&gt;</ept> parameter is kleiner dan nul of groter zijn dan 4 GB.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>-or-       A value specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">amount</ph><ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">sourceOffset</ph><ept id="p2">&lt;/code&gt;</ept>, or <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">destinationOffset</ph><ept id="p3">&lt;/code&gt;</ept> parameter for a <bpt id="p4">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept> or <bpt id="p5">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p5">&lt;/xref&gt;</ept> data type is not even.</source>
          <target state="translated">-or-       A value specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">amount</ph><ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">sourceOffset</ph><ept id="p2">&lt;/code&gt;</ept>, or <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">destinationOffset</ph><ept id="p3">&lt;/code&gt;</ept> parameter for a <bpt id="p4">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept> or <bpt id="p5">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p5">&lt;/xref&gt;</ept> data type is not even.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The operation is not within a transaction, the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is null, or the connection is closed.</source>
          <target state="translated">De bewerking is niet binnen een transactie de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object is null of de verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">Moet worden toegevoegd.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Allows server-side triggers to resume firing after performing multiple write operations.</source>
          <target state="translated">Kan de triggers-serverzijde starten na het uitvoeren van meerdere schrijfbewerkingen hervatten.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch%2A&gt; method before you begin performing write operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt;.</source>
          <target state="translated">Roep de &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch%2A&gt;methode voordat u begint met het uitvoeren van schrijfbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;.&lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleLob.BeginBatch%2A&gt;</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The connection is closed.</source>
          <target state="translated">De verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Erases all data from this <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Hiermee wist u alle gegevens van dit <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Erase does not truncate data.</source>
          <target state="translated">Wissen komt niet afkappen van gegevens.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`LOB`</ph> length remains the same for a <ph id="ph2">`BLOB`</ph> data type, and the erased data is replaced by 0x00.</source>
          <target state="translated">De <ph id="ph1">`LOB`</ph> lengte blijft hetzelfde zijn voor een <ph id="ph2">`BLOB`</ph> gegevenstype, en de gewiste gegevens wordt vervangen door 0x00.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data types are replaced by spaces.</source>
          <target state="translated"><ph id="ph1">`CLOB`</ph>en <ph id="ph2">`NCLOB`</ph> gegevenstypen worden vervangen door spaties.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In this release, a write operation to a read-only <ph id="ph2">`LOB`</ph> might succeed, but does not update the <ph id="ph3">`LOB`</ph> on the server.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; In deze release een schrijfbewerking naar een alleen-lezen <ph id="ph2">`LOB`</ph> mogelijk wel, maar werkt niet bij de <ph id="ph3">`LOB`</ph> op de server.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, however, the local copy of the <ph id="ph1">`LOB`</ph> is updated.</source>
          <target state="translated">In dit geval echter de lokale kopie van de <ph id="ph1">`LOB`</ph> wordt bijgewerkt.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, later read operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt; object might return the results of the write operation.</source>
          <target state="translated">Daarom later leesbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;object kan het resultaat van de schrijfbewerking.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The number of bytes erased.</source>
          <target state="translated">Het aantal bytes gewist.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The operation is not within a transaction, the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is null, or the connection is closed.</source>
          <target state="translated">De bewerking is niet binnen een transactie de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object is null of de verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Erases the specified amount of data from this <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Hiermee wist u de opgegeven hoeveelheid gegevens van deze <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sum of the values in the <ph id="ph1">`offset`</ph> and <ph id="ph2">`amount`</ph> parameters can be greater than that of the size of the &lt;xref:System.Data.OracleClient.OracleLob&gt;.</source>
          <target state="translated">De som van de waarden in de <ph id="ph1">`offset`</ph> en <ph id="ph2">`amount`</ph> parameters kunnen niet groter zijn dan die van de grootte van de &lt;xref:System.Data.OracleClient.OracleLob&gt;.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, specifying a value greater than that returned by the &lt;xref:System.Data.OracleClient.OracleLob.Length%2A&gt; property succeeds; however &lt;xref:System.Data.OracleClient.OracleLob.Erase%2A&gt; only erases to the end of the &lt;xref:System.Data.OracleClient.OracleLob&gt;.</source>
          <target state="translated">Daarom geven een waarde die groter is dan die wordt geretourneerd door de &lt;xref:System.Data.OracleClient.OracleLob.Length%2A&gt;eigenschap slaagt; echter &lt;xref:System.Data.OracleClient.OracleLob.Erase%2A&gt;alleen worden gewist met het einde van de &lt;xref:System.Data.OracleClient.OracleLob&gt;.&lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleLob.Erase%2A&gt; &lt;/xref:System.Data.OracleClient.OracleLob.Length%2A&gt;</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Similarly, if a negative value is passed to <ph id="ph1">`offset`</ph>, &lt;xref:System.Data.OracleClient.OracleLob.Erase%2A&gt; will succeed, but only erase starting from the beginning of the &lt;xref:System.Data.OracleClient.OracleLob&gt;.) This behavior is different from that of the &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt; and &lt;xref:System.Data.OracleClient.OracleLob.Write%2A&gt; methods, and offers the advantage of being able to erase all data from the value specified by <ph id="ph2">`offset`</ph> without making an additional roundtrip to the server to verify the actual size.</source>
          <target state="translated">(Op dezelfde manier als een negatieve waarde wordt doorgegeven aan <ph id="ph1">`offset`</ph>, &lt;xref:System.Data.OracleClient.OracleLob.Erase%2A&gt;slagen, maar alleen wissen vanaf het begin van de &lt;xref:System.Data.OracleClient.OracleLob&gt;.)&lt;/xref:System.Data.OracleClient.OracleLob&gt; &lt;/xref:System.Data.OracleClient.OracleLob.Erase%2A&gt; Dit gedrag is anders dan die van de &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt;en &lt;xref:System.Data.OracleClient.OracleLob.Write%2A&gt;methoden en biedt het voordeel van te wissen van alle gegevens van de waarde die is opgegeven door <ph id="ph2">`offset`</ph> zonder dat een extra retour naar de server om te controleren of de werkelijke grootte.&lt;/xref:System.Data.OracleClient.OracleLob.Write%2A&gt; &lt;/xref:System.Data.OracleClient.OracleLob.Read%2A&gt;</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Data.OracleClient.OracleLob.Erase%2A&gt; does not truncate data.</source>
          <target state="translated">&lt;xref:System.Data.OracleClient.OracleLob.Erase%2A&gt;biedt gegevens niet afkappen.&lt;/xref:System.Data.OracleClient.OracleLob.Erase%2A&gt;</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`LOB`</ph> length remains the same for a <ph id="ph2">`BLOB`</ph> data type, and the erased data is replaced by 0x00.</source>
          <target state="translated">De <ph id="ph1">`LOB`</ph> lengte blijft hetzelfde zijn voor een <ph id="ph2">`BLOB`</ph> gegevenstype, en de gewiste gegevens wordt vervangen door 0x00.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data types are replaced by spaces.</source>
          <target state="translated"><ph id="ph1">`CLOB`</ph>en <ph id="ph2">`NCLOB`</ph> gegevenstypen worden vervangen door spaties.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In this release, a write operation to a read-only <ph id="ph2">`LOB`</ph> might succeed, but does not update the <ph id="ph3">`LOB`</ph> on the server.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; In deze release een schrijfbewerking naar een alleen-lezen <ph id="ph2">`LOB`</ph> mogelijk wel, maar werkt niet bij de <ph id="ph3">`LOB`</ph> op de server.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, however, the local copy of the <ph id="ph1">`LOB`</ph> is updated.</source>
          <target state="translated">In dit geval echter de lokale kopie van de <ph id="ph1">`LOB`</ph> wordt bijgewerkt.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, later read operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt; object might return the results of the write operation.</source>
          <target state="translated">Daarom later leesbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;object kan het resultaat van de schrijfbewerking.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The offset from which to erase.</source>
          <target state="translated">De offset waaruit u wilt wissen.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The quantity of data, in bytes, to erase.</source>
          <target state="translated">De hoeveelheid gegevens, in bytes, om te wissen.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The number of bytes erased.</source>
          <target state="translated">Het aantal bytes gewist.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The operation is not within a transaction, the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is null, or the connection is closed.</source>
          <target state="translated">De bewerking is niet binnen een transactie de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object is null of de verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Not currently supported.</source>
          <target state="translated">Momenteel niet ondersteund.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this release, this method is not functional.</source>
          <target state="translated">In deze release is deze methode niet functioneel.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether an application called the &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch*&gt; method.</source>
          <target state="translated">Hiermee wordt een waarde die aangeeft of een toepassing aangeroepen de &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch*&gt;methode.&lt;/xref:System.Data.OracleClient.OracleLob.BeginBatch*&gt;</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>When using an Oracle 8.0.5 server, an Oracle "ORA-00600: internal error code" exception is thrown.</source>
          <target state="translated">Wanneer een 8.0.5 Oracle-server, een Oracle ' ORA 00600: interne foutcode ' uitzondering gegenereerd.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if application called the &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch*&gt; method, otherwise <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Als de naam van de toepassing de &lt;xref:System.Data.OracleClient.OracleLob.BeginBatch*&gt;methode, anders <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.&lt;/xref:System.Data.OracleClient.OracleLob.BeginBatch*&gt;</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is a <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleBFile.Null"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> stream.</source>
          <target state="translated">Hiermee wordt een waarde die aangeeft of de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> is een <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleBFile.Null"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> stroom.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> is a <bpt id="p3">&lt;xref href="System.Data.OracleClient.OracleBFile.Null"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> stream, otherwise <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>if the <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> is a <bpt id="p3">&lt;xref href="System.Data.OracleClient.OracleBFile.Null"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> stream, otherwise <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is a temporary <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Haalt een waarde die aangeeft of de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> is een tijdelijke <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example demonstrates how to create a temporary <ph id="ph1">`LOB`</ph>.</source>
          <target state="translated">Het volgende voorbeeld toont het maken van een tijdelijke <ph id="ph1">`LOB`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> is a temporary <bpt id="p3">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>, otherwise <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Als de <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> is een tijdelijke <bpt id="p3">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>, anders <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The connection is closed.</source>
          <target state="translated">De verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Gets a value that returns the size of the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Hiermee wordt een waarde die als resultaat de grootte van geeft de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>The size of the &lt;xref:System.Data.OracleClient.OracleLob&gt; is always returned in bytes for all data types.</source>
          <target state="translated">De grootte van de &lt;xref:System.Data.OracleClient.OracleLob&gt;altijd wordt geretourneerd in bytes voor alle gegevenstypen.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The size of the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in bytes.</source>
          <target state="translated">De grootte van de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> in bytes.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The connection is closed.</source>
          <target state="translated">De verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Gets a value that returns the <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> data type.</source>
          <target state="translated">Hiermee wordt een waarde die als resultaat geeft de <bpt id="p1">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> gegevenstype.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>An &lt;xref:System.Data.OracleClient.OracleLob&gt; may be one of the following &lt;xref:System.Data.OracleClient.OracleType&gt; data types.</source>
          <target state="translated">Een &lt;xref:System.Data.OracleClient.OracleLob&gt;mogelijk een van de volgende &lt;xref:System.Data.OracleClient.OracleType&gt;gegevenstypen.&lt;/xref:System.Data.OracleClient.OracleType&gt; &lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>|OracleType data type|Description|   |--------------------------|-----------------|   |<ph id="ph1">`Blob`</ph>|An Oracle <ph id="ph2">`BLOB`</ph> data type that contains binary data with a maximum size of 4 gigabytes.</source>
          <target state="translated">| Het gegevenstype OracleType | Beschrijving |   |--------------------------|-----------------|   | <ph id="ph1">`Blob`</ph>| Een Oracle <ph id="ph2">`BLOB`</ph> gegevenstype met binaire gegevens met een maximale grootte van 4 GB.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>This maps to an &lt;xref:System.Array&gt; of type &lt;xref:System.Byte&gt;.|   |<ph id="ph1">`Clob`</ph>|An Oracle <ph id="ph2">`CLOB`</ph> data type that contains character data, based on the default character set on the server, with a maximum size of 4 gigabytes.</source>
          <target state="translated">Dit wordt toegewezen aan een &lt;xref:System.Array&gt;van het type &lt;xref:System.Byte&gt;. |   | <ph id="ph1">`Clob`</ph>| Een Oracle <ph id="ph2">`CLOB`</ph> gegevenstype met tekengegevens, op basis van het standaardteken ingesteld op de server, met een maximale grootte van 4 gigabyte.&lt;/xref:System.Byte&gt; &lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>This maps to &lt;xref:System.String&gt;.|   |<ph id="ph1">`NClob`</ph>|An Oracle <ph id="ph2">`NCLOB`</ph> data type that contains character data, based on the national character set on the server with a maximum size of 4 gigabytes.</source>
          <target state="translated">Dit wordt toegewezen aan &lt;xref:System.String&gt;. |   | <ph id="ph1">`NClob`</ph>| Een Oracle <ph id="ph2">`NCLOB`</ph> gegevenstype met tekengegevens, op basis van de national tekenset op de server met een maximale grootte van 4 gigabyte.&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>This maps to &lt;xref:System.String&gt;.|</source>
          <target state="translated">Dit wordt toegewezen aan &lt;xref:System.String&gt;. |&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleType"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept><bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types.</source>
          <target state="translated">Een van de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleType"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> <bpt id="p2">&lt;xref uid="langword_csharp_LOB" name="LOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Represents a null <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">Hiermee geeft u een null <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> object.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can construct an &lt;xref:System.Data.OracleClient.OracleLob&gt; that is NULL using this format:      <ph id="ph1">```   OracleLob myLob = OracleLOB.Null;   ```</ph>       This technique is used primarily to test whether a <ph id="ph2">`LOB`</ph> returned from the server is NULL, as this example illustrates:      <ph id="ph3">```   If(myLob == OracleLob.Null)   ```</ph>       A NULL <ph id="ph4">`LOB`</ph> behaves similarly to a zero byte <ph id="ph5">`LOB`</ph> in that &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt; succeeds and always returns zero bytes.</source>
          <target state="translated">U kunt samenstellen een &lt;xref:System.Data.OracleClient.OracleLob&gt;die NULL met deze indeling is: <ph id="ph1">```   OracleLob myLob = OracleLOB.Null;   ```</ph> deze techniek wordt gebruikt voor het testen of een <ph id="ph2">`LOB`</ph> geretourneerd vanaf de server is NULL, zoals in dit voorbeeld te zien: <ph id="ph3">```   If(myLob == OracleLob.Null)   ```</ph> A NULL <ph id="ph4">`LOB`</ph> gedraagt zich op dezelfde manier naar een nul byte <ph id="ph5">`LOB`</ph> in dat &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt;is gelukt en retourneert altijd nul bytes.&lt;/xref:System.Data.OracleClient.OracleLob.Read%2A&gt; &lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">Moet worden toegevoegd.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Gets the current read position in the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> stream.</source>
          <target state="translated">De huidige positie in lezen opgehaald de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> stroom.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stream must support seeking to get or set the position.</source>
          <target state="translated">De stroom moet ondersteuning voor zoekbewerkingen ophalen of instellen van de positie.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Data.OracleClient.OracleLob.CanSeek%2A&gt; property to determine whether the stream supports seeking.</source>
          <target state="translated">Gebruik de &lt;xref:System.Data.OracleClient.OracleLob.CanSeek%2A&gt;eigenschap om te bepalen of de stroom zoekbewerkingen ondersteunt.&lt;/xref:System.Data.OracleClient.OracleLob.CanSeek%2A&gt;</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">Zoeken naar andere locaties dan de lengte van de stroom wordt ondersteund.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>Seeking to an odd position for <ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data types is also supported.</source>
          <target state="translated">De positie van een oneven voor willen <ph id="ph1">`CLOB`</ph> en <ph id="ph2">`NCLOB`</ph> gegevenstypen wordt ook ondersteund.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the Remarks section of the &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt; property.</source>
          <target state="translated">Zie voor meer informatie de sectie met opmerkingen van de &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt;eigenschap.&lt;/xref:System.Data.OracleClient.OracleLob.Read%2A&gt;</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Position property does not keep track of the number of bytes from the stream that have been consumed, skipped, or both.</source>
          <target state="translated">De eigenschap Position wordt niet bijhouden van het aantal bytes uit de stroom die is verbruikt, overgeslagen, of beide.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The current position within the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> stream.</source>
          <target state="translated">De huidige positie binnen de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> stroom.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The connection is closed.</source>
          <target state="translated">De verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Reads a sequence of bytes from the current <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> stream and advances the position within the stream by the number of bytes read.</source>
          <target state="translated">Een reeks bytes leest uit de huidige <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> stream en ontwikkelingen de positie binnen de stroom door het aantal bytes gelezen.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Read method reads a maximum of <ph id="ph1">`count`</ph> bytes from the current stream and stores them in <ph id="ph2">`buffer`</ph> beginning at <ph id="ph3">`offset`</ph>.</source>
          <target state="translated">De methode Read leest maximaal <ph id="ph1">`count`</ph> bytes uit de huidige stream en slaat ze op in <ph id="ph2">`buffer`</ph> beginnen bij <ph id="ph3">`offset`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</source>
          <target state="translated">De huidige positie in de stroom is geavanceerde door het aantal gelezen bytes. echter, als een uitzondering optreedt, de huidige positie in de stroom blijft ongewijzigd.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>Read returns the number of bytes read.</source>
          <target state="translated">Lees retourneert het aantal bytes dat is gelezen.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is zero only if the position is currently at the end of the stream.</source>
          <target state="translated">De geretourneerde waarde gelijk is aan nul alleen als de positie momenteel aan het einde van de stroom is.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>Read will block until at least one byte of data can be read, in the event that no data is available.Read returns 0 if you attempt to read from a <ph id="ph1">`LOB`</ph> when the current position is at the end of <ph id="ph2">`LOB`</ph>.</source>
          <target state="translated">Lezen wordt geblokkeerd totdat ten minste één byte aan gegevens kan worden gelezen in het geval dat gegevens niet beschikbaar. Lezen van retourneert 0 als u probeert te lezen uit een <ph id="ph1">`LOB`</ph> wanneer de huidige positie is aan het einde van <ph id="ph2">`LOB`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>Read can return fewer bytes than requested even if the end of the stream has not been reached.</source>
          <target state="translated">Lees kan minder bytes dan de aangevraagde geretourneerd, zelfs als het einde van de stroom niet is bereikt.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework Data Provider for Oracle handles all <ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data as Unicode.</source>
          <target state="translated">De .NET Framework-gegevensprovider voor Oracle handelt alle <ph id="ph1">`CLOB`</ph> en <ph id="ph2">`NCLOB`</ph> gegevens als Unicode.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, when accessing <ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data types, you are always dealing with the number of bytes, where each character is 2 bytes.</source>
          <target state="translated">Daarom bij het openen van <ph id="ph1">`CLOB`</ph> en <ph id="ph2">`NCLOB`</ph> gegevenstypen, werkt u altijd met het aantal bytes, waarbij elk teken 2 bytes is.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if a string of text containing three characters is saved as an <ph id="ph1">`NCLOB`</ph> on an Oracle server where the character set is 4 bytes per character, and you perform a <ph id="ph2">`Read`</ph> operation, you specify the length of the string as 6 bytes, although it is stored as 12 bytes on the server.</source>
          <target state="translated">Bijvoorbeeld, als een tekenreeks met drie tekens wordt opgeslagen als een <ph id="ph1">`NCLOB`</ph> op Oracle-server waar de tekenset is 4 bytes per teken en u uitvoeren een <ph id="ph2">`Read`</ph> bewerking, u de lengte van de tekenreeks opgeven als 6 bytes, hoewel deze 12 bytes op de server is opgeslagen.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following C# example demonstrates how to read &lt;xref:System.Data.OracleClient.OracleLob&gt; objects.</source>
          <target state="translated">De volgende C#-voorbeeld toont hoe lezen &lt;xref:System.Data.OracleClient.OracleLob&gt;objecten.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   public static void ReadLobExample(OracleCommand command)   {      int actual = 0;         //Select some data.      // Table Schema:      //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";      //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";      command.CommandText = "SELECT * FROM TableWithLobs";      OracleDataReader reader = command.ExecuteReader();      using(reader)      {         //Obtain the first row of data.         reader.Read();         //Obtain the LOBs (all 3 varieties).         OracleLob BLOB = reader.GetOracleLob(1);         OracleLob CLOB  = reader.GetOracleLob(2);         OracleLob NCLOB = reader.GetOracleLob(3);            //Example - Reading binary data (in chunks).         byte[] buffer = new byte[100];         while((actual = BLOB.Read(buffer, 0, buffer.Length)) &gt;0)            Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") =&gt; " + actual);            //Example - Reading CLOB/NCLOB data (in chunks).         //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).         //However, because the OracleLob object inherits directly from the.NET stream object,          //all the existing classes that manipluate streams can also be used. For example, the          //.NET StreamReader makes converting the raw bytes into actual characters easier.         StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);         char[] cbuffer = new char[100];         while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) &gt;0)            Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") =&gt; " + actual);            //Example - Reading data (all at once).         //You could use StreamReader.ReadToEnd to obtain all the string data,or simply         //call OracleLob.Value to obtain a contiguous allocation of all the data.         Console.WriteLine(NCLOB.LobType + ".Value =&gt; " + NCLOB.Value);      }   }   ```</ph>       You can construct an &lt;xref:System.Data.OracleClient.OracleLob&gt; that is NULL using this format:      <ph id="ph2">```   OracleLob myLob = OracleLob.Null;   ```</ph>       This technique is used primarily to test whether a <ph id="ph3">`LOB`</ph> returned from the server is NULL, as the following example illustrates.</source>
          <target state="translated"><ph id="ph1">```   public static void ReadLobExample(OracleCommand command)   {      int actual = 0;         //Select some data.      // Table Schema:      //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";      //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";      command.CommandText = "SELECT * FROM TableWithLobs";      OracleDataReader reader = command.ExecuteReader();      using(reader)      {         //Obtain the first row of data.         reader.Read();         //Obtain the LOBs (all 3 varieties).         OracleLob BLOB = reader.GetOracleLob(1);         OracleLob CLOB  = reader.GetOracleLob(2);         OracleLob NCLOB = reader.GetOracleLob(3);            //Example - Reading binary data (in chunks).         byte[] buffer = new byte[100];         while((actual = BLOB.Read(buffer, 0, buffer.Length)) &gt;0)            Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") =&gt; " + actual);            //Example - Reading CLOB/NCLOB data (in chunks).         //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).         //However, because the OracleLob object inherits directly from the.NET stream object,          //all the existing classes that manipluate streams can also be used. For example, the          //.NET StreamReader makes converting the raw bytes into actual characters easier.         StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);         char[] cbuffer = new char[100];         while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) &gt;0)            Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") =&gt; " + actual);            //Example - Reading data (all at once).         //You could use StreamReader.ReadToEnd to obtain all the string data,or simply         //call OracleLob.Value to obtain a contiguous allocation of all the data.         Console.WriteLine(NCLOB.LobType + ".Value =&gt; " + NCLOB.Value);      }   }   ```</ph>U kunt samenstellen een &lt;xref:System.Data.OracleClient.OracleLob&gt;die NULL met deze indeling is: <ph id="ph2">```   OracleLob myLob = OracleLob.Null;   ```</ph> deze techniek wordt gebruikt voor het testen of een <ph id="ph3">`LOB`</ph> geretourneerd vanaf de server is NULL, zoals in het volgende voorbeeld te zien.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   If(myLob == OracleLob.Null)   ```</ph>       A NULL <ph id="ph2">`LOB`</ph> behaves similarly to a zero byte <ph id="ph3">`LOB`</ph> in that Read succeeds and always returns zero bytes.</source>
          <target state="translated"><ph id="ph1">```   If(myLob == OracleLob.Null)   ```</ph>Een NULL <ph id="ph2">`LOB`</ph> gedraagt zich op dezelfde manier naar een nul byte <ph id="ph3">`LOB`</ph> in dat alleen kan worden uitgevoerd en altijd geeft nul bytes.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>An array of bytes.</source>
          <target state="translated">Een matrix met bytes.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>When this method returns, the buffer contains the specified byte array with the values between <ph id="ph1">`offset`</ph> and (<ph id="ph2">`offset`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph>) replaced by the bytes read from the current source.</source>
          <target state="translated">Wanneer deze methode retourneert, de buffer bevat de opgegeven byte-matrix met de waarden tussen <ph id="ph1">`offset`</ph> en (<ph id="ph2">`offset`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph>) vervangen door het aantal bytes lezen uit de huidige bron.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The zero-based byte offset in <ph id="ph1">`buffer`</ph> at which to begin storing the data read from the current stream.</source>
          <target state="translated">De op nul gebaseerde byte-offset in <ph id="ph1">`buffer`</ph> waarop u wilt beginnen met opslaan van de gegevens uit de huidige stroom lezen.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes to be read from the current stream.</source>
          <target state="translated">Het maximum aantal bytes dat moet worden gelezen uit de huidige stroom.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The total number of bytes read into the buffer.</source>
          <target state="translated">Het totale aantal bytes in de buffer gelezen.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>This may be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</source>
          <target state="translated">Dit kan zijn dat kleiner is dan het aantal bytes aangevraagd als dat veel bytes momenteel niet beschikbaar zijn, of nul (0) als het einde van de stroom is bereikt.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> is a null reference (<bpt id="p2">&lt;xref uid="langword_csharp_Nothing" name="Nothing" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> in Visual Basic).</source>
          <target state="translated">De <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">buffer</ph> <ept id="p1">&lt;/code&gt;</ept> is een null-verwijzing (<bpt id="p2">&lt;xref uid="langword_csharp_Nothing" name="Nothing" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>A value in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">offset</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p2">&lt;/code&gt;</ept> parameter is not positive.</source>
          <target state="translated">Een waarde in de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">offset</ph> <ept id="p1">&lt;/code&gt;</ept> of <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">count</ph> <ept id="p2">&lt;/code&gt;</ept> parameter is niet positief.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>-or-       The sum of the offset and count parameters is larger than the buffer length.</source>
          <target state="translated">- of - de som van de offset en het aantal parameters is groter dan de bufferlengte.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>-or-       A value specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">amount</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">offset</ph><ept id="p2">&lt;/code&gt;</ept> parameter is less than zero or greater than 4 gigabytes.</source>
          <target state="translated">- of - waarde is opgegeven in de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">amount</ph> <ept id="p1">&lt;/code&gt;</ept> of <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">offset</ph> <ept id="p2">&lt;/code&gt;</ept> parameter is kleiner dan nul of groter zijn dan 4 GB.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The operation is not within a transaction, the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is null, or the connection is closed.</source>
          <target state="translated">De bewerking is niet binnen een transactie de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object is null of de verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Sets the position on the current <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> stream.</source>
          <target state="translated">Hiermee stelt u de positie op de huidige <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> stroom.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`offset`</ph> is negative, the new position must precede the position specified by <ph id="ph2">`origin`</ph> by the number of bytes specified by <ph id="ph3">`offset`</ph>.</source>
          <target state="translated">Als <ph id="ph1">`offset`</ph> is negatief, de nieuwe positie moet worden voorafgegaan door de positie die is opgegeven door <ph id="ph2">`origin`</ph> door het aantal bytes dat is opgegeven door <ph id="ph3">`offset`</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`offset`</ph> is zero, the new position must be the position specified by <ph id="ph2">`origin`</ph>.</source>
          <target state="translated">Als <ph id="ph1">`offset`</ph> gelijk is aan nul, de nieuwe positie moet de positie die is opgegeven door <ph id="ph2">`origin`</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`offset`</ph> is positive, the new position must follow the position specified by <ph id="ph2">`origin`</ph> by the number of bytes specified by <ph id="ph3">`offset`</ph>.</source>
          <target state="translated">Als <ph id="ph1">`offset`</ph> positief is, de nieuwe positie moet volgen op de positie die is opgegeven door <ph id="ph2">`origin`</ph> door het aantal bytes dat is opgegeven door <ph id="ph3">`offset`</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">Zoeken naar andere locaties dan de lengte van de stroom wordt ondersteund.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>Seeking to an odd position for <ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data types is also supported.</source>
          <target state="translated">De positie van een oneven voor willen <ph id="ph1">`CLOB`</ph> en <ph id="ph2">`NCLOB`</ph> gegevenstypen wordt ook ondersteund.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the Remarks section of the &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt; property.</source>
          <target state="translated">Zie voor meer informatie de sectie met opmerkingen van de &lt;xref:System.Data.OracleClient.OracleLob.Read%2A&gt;eigenschap.&lt;/xref:System.Data.OracleClient.OracleLob.Read%2A&gt;</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>A byte offset relative to origin.</source>
          <target state="translated">Een byte-offset ten opzichte van oorsprong.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`offset`</ph> is negative, the new position precedes the position specified by <ph id="ph2">`origin`</ph> by the number of bytes specified by <ph id="ph3">`offset`</ph>.</source>
          <target state="translated">Als <ph id="ph1">`offset`</ph> is negatief, de nieuwe positie lager is dan de positie die is opgegeven door <ph id="ph2">`origin`</ph> door het aantal bytes dat is opgegeven door <ph id="ph3">`offset`</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`offset`</ph> is zero, the new position is the position specified by <ph id="ph2">`origin`</ph>.</source>
          <target state="translated">Als <ph id="ph1">`offset`</ph> gelijk is aan nul, vormt de positie die is opgegeven door de nieuwe positie <ph id="ph2">`origin`</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`offset`</ph> is positive, the new position follows the position specified by <ph id="ph2">`origin`</ph> by the number of bytes specified by <ph id="ph3">`offset`</ph>.</source>
          <target state="translated">Als <ph id="ph1">`offset`</ph> positief is, de nieuwe positie volgt de positie die is opgegeven door <ph id="ph2">`origin`</ph> door het aantal bytes dat is opgegeven door <ph id="ph3">`offset`</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>A value of type &lt;xref:System.IO.SeekOrigin&gt; indicating the reference point used to obtain the new position.</source>
          <target state="translated">Een waarde van het type &lt;xref:System.IO.SeekOrigin&gt;die wijzen op het referentiepunt gebruikt voor het verkrijgen van de nieuwe positie.&lt;/xref:System.IO.SeekOrigin&gt;</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The new position within the current stream.</source>
          <target state="translated">De nieuwe positie binnen de huidige stroom.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">origin</ph><ept id="p1">&lt;/code&gt;</ept> parameter does not contain a valid value.</source>
          <target state="translated">De <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">origin</ph> <ept id="p1">&lt;/code&gt;</ept> parameter bevat geen geldige waarde.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The resulting position is beyond the length of the value.</source>
          <target state="translated">De resulterende positie valt buiten de lengte van de waarde.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object was closed or disposed.</source>
          <target state="translated">De <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Sets the length of the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> stream to a value less than the current length.</source>
          <target state="translated">Hiermee stelt u de lengte van de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> stream naar een waarde lager dan de huidige lengte.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to increase the length of the &lt;xref:System.Data.OracleClient.OracleLob&gt; stream fails, and returns "Message: ORA-22926: specified trim length is greater than current LOB value's length" from the Oracle server.</source>
          <target state="translated">Een poging tot het verhogen van de lengte van de &lt;xref:System.Data.OracleClient.OracleLob&gt;stroom mislukt en retourneert ' bericht: ORA&amp;22926;: opgegeven trim lengte is groter dan de lengte van de huidige LOB-waarde ' van de Oracle-server.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>A stream must support both writing and seeking for SetLength to function.</source>
          <target state="translated">Een stroom moet ondersteunen zowel schrijven en de functie voor SetLength willen.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework Data Provider for Oracle handles all <ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data as Unicode.</source>
          <target state="translated">De .NET Framework-gegevensprovider voor Oracle handelt alle <ph id="ph1">`CLOB`</ph> en <ph id="ph2">`NCLOB`</ph> gegevens als Unicode.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, when accessing <ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data types, you are always dealing with the number of bytes, where each character is 2 bytes.</source>
          <target state="translated">Daarom bij het openen van <ph id="ph1">`CLOB`</ph> en <ph id="ph2">`NCLOB`</ph> gegevenstypen, werkt u altijd met het aantal bytes, waarbij elk teken 2 bytes is.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if a string of text containing three characters is saved as an <ph id="ph1">`NCLOB`</ph> on an Oracle server where the character set is 4 bytes per character, and you perform a <ph id="ph2">`SetLength`</ph> operation, you specify the length of the string as 6 bytes, although it is stored as 12 bytes on the server.</source>
          <target state="translated">Bijvoorbeeld, als een tekenreeks met drie tekens wordt opgeslagen als een <ph id="ph1">`NCLOB`</ph> op Oracle-server waar de tekenset is 4 bytes per teken en u uitvoeren een <ph id="ph2">`SetLength`</ph> bewerking, u de lengte van de tekenreeks opgeven als 6 bytes, hoewel deze 12 bytes op de server is opgeslagen.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  A write operation to a read-only <ph id="ph2">`LOB`</ph> might succeed, but does not update the <ph id="ph3">`LOB`</ph> on the server.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Een schrijfbewerking naar een alleen-lezen <ph id="ph2">`LOB`</ph> mogelijk wel, maar werkt niet bij de <ph id="ph3">`LOB`</ph> op de server.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, however, the local copy of the <ph id="ph1">`LOB`</ph> is updated.</source>
          <target state="translated">In dit geval echter de lokale kopie van de <ph id="ph1">`LOB`</ph> wordt bijgewerkt.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, later read operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt; object might return the results of the write operation.</source>
          <target state="translated">Daarom later leesbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;object kan het resultaat van de schrijfbewerking.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The desired length of the current <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> stream in bytes.</source>
          <target state="translated">De gewenste lengte van de huidige <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> stream in bytes.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>A value specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter for a <bpt id="p2">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> or <bpt id="p3">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> data type is not even.</source>
          <target state="translated">Een waarde die is opgegeven de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">value</ph> <ept id="p1">&lt;/code&gt;</ept> parameter voor een <bpt id="p2">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> of <bpt id="p3">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> gegevenstype is nog niet.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>-or-       A value specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter is less than zero or greater than 4 gigabytes.</source>
          <target state="translated">- of - waarde is opgegeven in de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">value</ph> <ept id="p1">&lt;/code&gt;</ept> parameter is kleiner dan nul of groter zijn dan 4 GB.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>The operation is not within a transaction, the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is null, or the connection is closed.</source>
          <target state="translated">De bewerking is niet binnen een transactie de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object is null of de verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Gets the common language runtime stream value equivalent of the underlying value.</source>
          <target state="translated">Hiermee haalt de common language runtime stroom waarde equivalent van de onderliggende waarde.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>For &lt;xref:System.Data.OracleClient.OracleType&gt; data types, Value returns the entire underlying data as a contiguous array of type <ph id="ph1">`Byte[]`</ph>.</source>
          <target state="translated">Voor &lt;xref:System.Data.OracleClient.OracleType&gt;gegevenstypen, waarde retourneert het gehele onderliggende gegevens als een aaneengesloten matrix van het type <ph id="ph1">`Byte[]`</ph>.&lt;/xref:System.Data.OracleClient.OracleType&gt;</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>For &lt;xref:System.Data.OracleClient.OracleType&gt; and &lt;xref:System.Data.OracleClient.OracleType&gt; data types, Value returns all the data as a <ph id="ph1">`String`</ph> data type.</source>
          <target state="translated">Voor &lt;xref:System.Data.OracleClient.OracleType&gt;en &lt;xref:System.Data.OracleClient.OracleType&gt;gegevenstypen, waarde retourneert de gegevens als een <ph id="ph1">`String`</ph> gegevenstype.&lt;/xref:System.Data.OracleClient.OracleType&gt; &lt;/xref:System.Data.OracleClient.OracleType&gt;</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>For null data, Value returns &lt;xref:System.DBNull&gt;.</source>
          <target state="translated">Voor null-gegevens retourneert de waarde &lt;xref:System.DBNull&gt;.&lt;/xref:System.DBNull&gt;</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>By comparing the returned values, you can distinguish among empty data, null data, and data.</source>
          <target state="translated">Door de geretourneerde waarden te vergelijken, kunt u onderscheid maken tussen leeg gegevens null-gegevens en gegevens.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  A benefit of using <ph id="ph2">`LOB`</ph> data types is the capability to retrieve large amounts of data in chunks at the client.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Voordeel van het gebruik <ph id="ph2">`LOB`</ph> gegevenstypen is de mogelijkheid om op te halen van grote hoeveelheden gegevens in reeksen op de client.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, when you use Value, you obtain all the data for the <ph id="ph1">`LOB`</ph> column as one contiguous chunk, which can significantly increase application overhead.</source>
          <target state="translated">Echter, als u waarde gebruikt, krijgt u de gegevens voor de <ph id="ph1">`LOB`</ph> kolom als een aaneengesloten chunk die kan toepassing overhead aanzienlijk verhogen.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleType"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, an array of type <bpt id="p2">&lt;xref uid="langword_csharp_Byte[]" name="Byte[]" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">For <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleType"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, an array of type <bpt id="p2">&lt;xref uid="langword_csharp_Byte[]" name="Byte[]" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleType"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleType"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, a <bpt id="p3">&lt;xref uid="langword_csharp_String" name="String" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated">For <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleType"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref href="System.Data.OracleClient.OracleType"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, a <bpt id="p3">&lt;xref uid="langword_csharp_String" name="String" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>For null data, <bpt id="p1">&lt;xref href="System.DBNull"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Voor null gegevens <bpt id="p1">&lt;xref href="System.DBNull"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to the current <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> stream, and advances the current position within this stream by the number of bytes written.</source>
          <target state="translated">Een reeks bytes geschreven naar het huidige <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> stream en de huidige positie binnen deze stroom wordt bestuurd door het aantal geschreven bytes.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the write operation is successful, the position within the stream advances by the number of bytes written.</source>
          <target state="translated">Als de write-bewerking geslaagd is, wordt de positie binnen de stroom gaat door het aantal geschreven bytes.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exception occurs, the position within the stream remains unchanged.</source>
          <target state="translated">Als u een uitzondering optreedt, wordt de positie binnen de stroom ongewijzigd.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing beyond the end of <ph id="ph1">`LOB`</ph> is allowed and enlarges the <ph id="ph2">`LOB`</ph> by the number of bytes written.</source>
          <target state="translated">Schrijven van voorbij het einde van <ph id="ph1">`LOB`</ph> is toegestaan en vergroot de <ph id="ph2">`LOB`</ph> door het aantal geschreven bytes.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework Data Provider for Oracle handles all <ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data as Unicode.</source>
          <target state="translated">De .NET Framework-gegevensprovider voor Oracle handelt alle <ph id="ph1">`CLOB`</ph> en <ph id="ph2">`NCLOB`</ph> gegevens als Unicode.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, when accessing <ph id="ph1">`CLOB`</ph> and <ph id="ph2">`NCLOB`</ph> data types, you are always dealing with the number of bytes, where each character is 2 bytes.</source>
          <target state="translated">Daarom bij het openen van <ph id="ph1">`CLOB`</ph> en <ph id="ph2">`NCLOB`</ph> gegevenstypen, werkt u altijd met het aantal bytes, waarbij elk teken 2 bytes is.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if a string of text containing three characters is saved as an <ph id="ph1">`NCLOB`</ph> on an Oracle server where the character set is 4 bytes per character, and you perform a <ph id="ph2">`Write`</ph> operation, you specify the length of the string as 6 bytes, although it is stored as 12 bytes on the server.</source>
          <target state="translated">Bijvoorbeeld, als een tekenreeks met drie tekens wordt opgeslagen als een <ph id="ph1">`NCLOB`</ph> op Oracle-server waar de tekenset is 4 bytes per teken en u uitvoeren een <ph id="ph2">`Write`</ph> bewerking, u de lengte van de tekenreeks opgeven als 6 bytes, hoewel deze 12 bytes op de server is opgeslagen.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following C# example demonstrates how to write to &lt;xref:System.Data.OracleClient.OracleLob&gt; objects.</source>
          <target state="translated">De volgende C#-voorbeeld toont hoe om te schrijven naar &lt;xref:System.Data.OracleClient.OracleLob&gt;objecten.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   public static void WriteLobExample(OracleCommand command)   {      //Note: Updating LOB data requires a transaction.      command.Transaction = command.Connection.BeginTransaction();      //Select some data.      //    Table Schema:      //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";      //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";      command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";      OracleDataReader reader = command.ExecuteReader();      using(reader)      {         //Obtain the first row of data.         reader.Read();         //Obtain both LOBs.         OracleLob BLOB1    = reader.GetOracleLob(1);         OracleLob BLOB2    = reader.GetOracleLob(2);         //Perform any desired operations on the LOB, (read, position, and so on).         //...         //Example - Writing binary data (directly to the backend).         //To write, you can use any of the stream classes, or write raw binary data using          //the OracleLob write method. Writing character vs. binary is the same;         //however note that character is always in terms of Unicode byte counts         //(for example: even number of bytes - 2 bytes for every Unicode character).         byte[] buffer = new byte[100];         buffer[0] = 0xCC;         buffer[1] = 0xDD;         BLOB1.Write(buffer, 0, 2);         BLOB1.Position = 0;         Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) =&gt; " + BLOB1.Value);            //Example - Copying data into another LOB.         long actual = BLOB1.CopyTo(BLOB2);         Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") =&gt; " + actual);            //Commit the transaction now that everything succeeded.         //Note: On error, Transaction.Dispose is called (from the using statement)         //and will automatically roll-back the pending transaction.         command.Transaction.Commit();      }   }   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  A write operation to a read-only <ph id="ph4">`LOB`</ph> might succeed, but does not update the <ph id="ph5">`LOB`</ph> on the server.</source>
          <target state="translated"><ph id="ph1">```   public static void WriteLobExample(OracleCommand command)   {      //Note: Updating LOB data requires a transaction.      command.Transaction = command.Connection.BeginTransaction();      //Select some data.      //    Table Schema:      //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";      //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";      command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";      OracleDataReader reader = command.ExecuteReader();      using(reader)      {         //Obtain the first row of data.         reader.Read();         //Obtain both LOBs.         OracleLob BLOB1    = reader.GetOracleLob(1);         OracleLob BLOB2    = reader.GetOracleLob(2);         //Perform any desired operations on the LOB, (read, position, and so on).         //...         //Example - Writing binary data (directly to the backend).         //To write, you can use any of the stream classes, or write raw binary data using          //the OracleLob write method. Writing character vs. binary is the same;         //however note that character is always in terms of Unicode byte counts         //(for example: even number of bytes - 2 bytes for every Unicode character).         byte[] buffer = new byte[100];         buffer[0] = 0xCC;         buffer[1] = 0xDD;         BLOB1.Write(buffer, 0, 2);         BLOB1.Position = 0;         Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) =&gt; " + BLOB1.Value);            //Example - Copying data into another LOB.         long actual = BLOB1.CopyTo(BLOB2);         Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") =&gt; " + actual);            //Commit the transaction now that everything succeeded.         //Note: On error, Transaction.Dispose is called (from the using statement)         //and will automatically roll-back the pending transaction.         command.Transaction.Commit();      }   }   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph>&gt; Een schrijfbewerking naar een alleen-lezen <ph id="ph4">`LOB`</ph> mogelijk wel, maar werkt niet bij de <ph id="ph5">`LOB`</ph> op de server.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, however, the local copy of the <ph id="ph1">`LOB`</ph> is updated.</source>
          <target state="translated">In dit geval echter de lokale kopie van de <ph id="ph1">`LOB`</ph> wordt bijgewerkt.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, later read operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt; object might return the results of the write operation.</source>
          <target state="translated">Daarom later leesbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;object kan het resultaat van de schrijfbewerking.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>An array of bytes.</source>
          <target state="translated">Een matrix met bytes.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>This method copies the number of bytes specified in <ph id="ph1">`count`</ph> from <ph id="ph2">`buffer`</ph> to the current stream.</source>
          <target state="translated">Deze methode wordt gekopieerd van het aantal bytes dat is opgegeven <ph id="ph1">`count`</ph> van <ph id="ph2">`buffer`</ph> naar de huidige stroom.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>The zero-based byte offset in <ph id="ph1">`buffer`</ph> at which to begin copying bytes to the current stream.</source>
          <target state="translated">De op nul gebaseerde byte-offset in <ph id="ph1">`buffer`</ph> waarop u wilt beginnen met het kopiëren van bytes naar de huidige stroom.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>The number of bytes to be written to the current stream.</source>
          <target state="translated">Het aantal bytes dat moet worden geschreven naar de huidige stroom.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types, this must be an even number.</source>
          <target state="translated">Voor <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen, dit moet een even getal zijn.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter is a null reference (<bpt id="p2">&lt;xref uid="langword_csharp_Nothing" name="Nothing" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> in Visual Basic).</source>
          <target state="translated">De <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">buffer</ph> <ept id="p1">&lt;/code&gt;</ept> -parameter is een null-verwijzing (<bpt id="p2">&lt;xref uid="langword_csharp_Nothing" name="Nothing" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>A value in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">offset</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p2">&lt;/code&gt;</ept> parameter is not positive.</source>
          <target state="translated">Een waarde in de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">offset</ph> <ept id="p1">&lt;/code&gt;</ept> of <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">count</ph> <ept id="p2">&lt;/code&gt;</ept> parameter is niet positief.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>-or-       The sum of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">offset</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p2">&lt;/code&gt;</ept> parameters is larger than the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">buffer</ph><ept id="p3">&lt;/code&gt;</ept> length.</source>
          <target state="translated">- of - de som van de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">offset</ph> <ept id="p1">&lt;/code&gt;</ept> en <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">count</ph> <ept id="p2">&lt;/code&gt;</ept> parameters is groter dan de <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph3">buffer</ph> <ept id="p3">&lt;/code&gt;</ept> lengte.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>-or-       A value specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">count</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">offset</ph><ept id="p2">&lt;/code&gt;</ept> parameter is less than zero or greater than 4 gigabytes.</source>
          <target state="translated">- of - waarde is opgegeven in de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">count</ph> <ept id="p1">&lt;/code&gt;</ept> of <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph2">offset</ph> <ept id="p2">&lt;/code&gt;</ept> parameter is kleiner dan nul of groter zijn dan 4 GB.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>-or-       You must specify <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> data types as an even number of bytes.</source>
          <target state="translated">- of - u moet opgeven <bpt id="p1">&lt;xref uid="langword_csharp_CLOB" name="CLOB" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> en <bpt id="p2">&lt;xref uid="langword_csharp_NCLOB" name="NCLOB" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> gegevenstypen als een even getal bytes.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The operation is not within a transaction, the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is null, or the connection is closed.</source>
          <target state="translated">De bewerking is niet binnen een transactie de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> -object is null of de verbinding is gesloten.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>The object was closed or disposed.</source>
          <target state="translated">Het object is gesloten of verwijderd.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>An Oracle error has occurred.</source>
          <target state="translated">Er is een Oracle-fout opgetreden.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Writes a byte to the current position in the <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> stream, and advances the position within the stream by one byte.</source>
          <target state="translated">Een byte schrijft naar de huidige positie in de <bpt id="p1">&lt;xref href="System.Data.OracleClient.OracleLob"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> stream en verplaatst u de positie binnen de stroom van één byte.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the write operation is successful, the position within the stream advances by one byte.</source>
          <target state="translated">Als de write-bewerking geslaagd is, gaat de positie binnen de stroom van één byte.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exception occurs, the position within the stream remains unchanged.</source>
          <target state="translated">Als u een uitzondering optreedt, wordt de positie binnen de stroom ongewijzigd.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing beyond the end of the <ph id="ph1">`LOB`</ph> is allowed and enlarges the <ph id="ph2">`LOB`</ph> by one byte.</source>
          <target state="translated">Schrijven van voorbij het einde van de <ph id="ph1">`LOB`</ph> is toegestaan en vergroot de <ph id="ph2">`LOB`</ph> door één byte.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write to the <ph id="ph1">`LOB`</ph>, you must have retrieved the <ph id="ph2">`LOB`</ph> using the FOR UPDATE clause in the SQL SELECT statement, and you must have a local transaction started.</source>
          <target state="translated">Schrijven naar de <ph id="ph1">`LOB`</ph>, moet u hebt opgehaald de <ph id="ph2">`LOB`</ph> met de component FOR UPDATE in de SELECT-instructie en u moet een lokale transactie is gestart.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  A write operation to a read-only <ph id="ph2">`LOB`</ph> might succeed, but does not update the <ph id="ph3">`LOB`</ph> on the server.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Een schrijfbewerking naar een alleen-lezen <ph id="ph2">`LOB`</ph> mogelijk wel, maar werkt niet bij de <ph id="ph3">`LOB`</ph> op de server.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, however, the local copy of the <ph id="ph1">`LOB`</ph> is updated.</source>
          <target state="translated">In dit geval echter de lokale kopie van de <ph id="ph1">`LOB`</ph> wordt bijgewerkt.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, later read operations on the &lt;xref:System.Data.OracleClient.OracleLob&gt; object might return the results of the write operation.</source>
          <target state="translated">Daarom later leesbewerkingen op de &lt;xref:System.Data.OracleClient.OracleLob&gt;object kan het resultaat van de schrijfbewerking.&lt;/xref:System.Data.OracleClient.OracleLob&gt;</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>The byte to write to the stream.</source>
          <target state="translated">De byte schrijven naar de stroom.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>