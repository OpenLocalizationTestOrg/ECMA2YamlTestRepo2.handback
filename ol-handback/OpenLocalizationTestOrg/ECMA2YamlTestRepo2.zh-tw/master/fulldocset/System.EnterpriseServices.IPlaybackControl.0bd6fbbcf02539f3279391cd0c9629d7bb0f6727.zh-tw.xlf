<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ee634ddf2e70e13eaf848262fa211ff6f3de6658</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.EnterpriseServices.IPlaybackControl.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0f639375332d0a733c11bb64c49ee429875c8d3b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f0eaf0e8b91ab41a16371307438159c713a6199b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Functions in Queued Components in the abnormal handling of server-side playback errors and client-side failures of the Message Queuing delivery mechanism.</source>
          <target state="translated">中的函式中排入佇列元件異常的伺服器端播放錯誤處理和用戶端失敗的訊息佇列的傳遞機制。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>The exception class defined for the component in the COM+ catalog implements both IPlaybackControl and the interface for the original class.</source>
          <target state="translated">COM + 目錄中的元件定義的例外狀況類別會實作 IPlaybackControl 和原始類別的介面。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself.</source>
          <target state="translated">原始的類別介面方法的實作用來執行的例外狀況處理類別本身中失敗的方法。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>They will be called after &lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt; or &lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt; to process exceptions for the method originally called.</source>
          <target state="translated">將會呼叫之後&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;或&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;處理初次呼叫方法的例外狀況。&lt;/xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt; &lt;/xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The Queued Components Player calls the methods of IPlaybackControl to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue.</source>
          <target state="translated">排入佇列元件播放程式會呼叫 IPlaybackControl 通知訊息即將置於最終或是寄不出信件佇列的例外狀況處理常式物件的方法。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call.</source>
          <target state="translated">排入佇列元件播放程式依序呼叫原始方法呼叫中失敗的例外狀況處理常式物件相同的方法。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem.</source>
          <target state="translated">例外狀況處理常式物件可以實作的替代方式，例如收集問題的診斷資訊，或產生物件或訊息，通知用戶端的問題。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If the application does not implement IPlaybackControl, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.</source>
          <target state="translated">如果應用程式不會實作 IPlaybackControl，有害訊息會放在最終或是寄不出信件佇列中，當排入佇列元件播放程式耗盡所有重試。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system.</source>
          <target state="translated">有害訊息是無法處理的某些原因，可能是因為有問題的伺服器或佇列的系統訊息。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The transaction is rolled back, and the poison message goes to the top of the queue.</source>
          <target state="translated">交易已回復，而且有害訊息會進入佇列的上方。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When the message is dequeued again, the same condition occurs.</source>
          <target state="translated">當訊息從佇列中清除一次時，就會發生同樣的狀況。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This message can continue looping indefinitely until something is done to correct the problem.</source>
          <target state="translated">這則訊息可以繼續迴圈直到設法修正問題。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The Queued Components service handles the poison message by using a series of retries.</source>
          <target state="translated">排入佇列元件服務會使用一系列的重試次數，以處理有害訊息。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>After several unsuccessful retries, the message is moved to a final resting queue.</source>
          <target state="translated">數個失敗的重試之後, 的訊息移到最後靜止佇列。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.</source>
          <target state="translated">有害訊息保留在休止的佇列，直到以手動方式移動是利用排入佇列的元件訊息 Mover 工具。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The poison message situation can also be resolved programmatically, using the &lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt; method, which informs the server-side component author that all attempts to play back the deferred activation have failed.</source>
          <target state="translated">有害訊息的情況下可以也使用來解決程式設計角度而言，&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;方法，它會通知播放延後的啟動的所有嘗試都失敗，伺服器端元件作者。&lt;/xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>If you discover a poison message, you might be able to solve the underlying cause of the problem quickly.</source>
          <target state="translated">如果您發現有害訊息時，您可以快速解決問題的根本原因。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example, if the server was offline for some reason, you can bring the server back online.</source>
          <target state="translated">比方說，如果基於某些原因，伺服器已離線，您可以讓伺服器重新在線上。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur.</source>
          <target state="translated">如果您不能快速解決問題，您可以自動產生的通知要求者的交易不會發生另一個交易。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.</source>
          <target state="translated">要求者來進行補償交易的回復已經認可的交易造成影響。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Informs the client-side exception-handling component that all Message Queuing attempts to deliver the message to the server were rejected, and the message ended up on the client-side Xact Dead Letter queue.</source>
          <target state="translated">通知用戶端例外狀況處理元件，將訊息傳遞至伺服器的所有訊息佇列嘗試遭到都拒絕，訊息最後在用戶端能肯定的交易的寄不出信件佇列。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification.</source>
          <target state="translated">當訊息送達 Xact 寄不出的信件佇列中時，COM + 嘗試叫用與伺服器類別，來傳遞此通知相關的用戶端例外狀況處理常式。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>It does so by first calling FinalClientRetry, then calling the exception-handling version of the failed method in the exception-handler object.</source>
          <target state="translated">它會先呼叫 FinalClientRetry，然後呼叫該例外狀況處理版本的失敗的方法中的例外狀況處理常式物件。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</source>
          <target state="translated">這個例外狀況的方法可以採取例外狀況動作，例如記錄失敗、 郵件訊息傳送給系統管理員，或採取任何行動用戶端補償 （反向先前交易的效果）。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If the exception method is not successful, the message is left on the Xact Dead Letter queue.</source>
          <target state="translated">如果不成功的例外狀況的方法時，訊息就能肯定的交易的寄不出信件佇列中。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.</source>
          <target state="translated">在 Microsoft Message Queue (MSMQ) 總管 中，您可以檢視能肯定的交易的寄不出信件佇列。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Informs the server-side exception class implementation that all attempts to play back the deferred activation to the server have failed, and the message is about to be moved to its final resting queue.</source>
          <target state="translated">通知伺服器端例外狀況類別實作，播放伺服器延後的啟動的所有嘗試都失敗，訊息會移至其最終休止的佇列。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification.</source>
          <target state="translated">當訊息到達 Xact 寄不出的信件佇列，COM + 嘗試叫用與伺服器類別，來傳遞此通知相關的伺服器端例外狀況處理常式。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>It does so by first calling FinalServerRetry, then calling the exception handling version of the failed method in the exception handler object.</source>
          <target state="translated">它會先呼叫 FinalServerRetry，然後呼叫例外狀況處理失敗的方法中的例外狀況處理常式物件的版本。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</source>
          <target state="translated">這個例外狀況的方法可以採取例外狀況動作，例如記錄失敗、 郵件訊息傳送給系統管理員，或採取任何行動用戶端補償 （反向先前交易的效果）。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The server object should make every effort to complete this transaction successfully.</source>
          <target state="translated">伺服器物件應該請致力將順利完成此交易。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Otherwise, manual intervention is required to reprocess the message.</source>
          <target state="translated">否則，需要手動介入，重新處理訊息。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If the exception method is not successful, the message is moved to the final resting queue.</source>
          <target state="translated">如果不成功的例外狀況的方法時，訊息會移到最後靜止的佇列。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>