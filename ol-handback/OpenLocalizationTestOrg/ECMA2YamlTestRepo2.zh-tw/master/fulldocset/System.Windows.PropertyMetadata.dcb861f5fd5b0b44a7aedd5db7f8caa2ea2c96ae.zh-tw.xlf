<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa8d9be9bd8a6e579a04c9a6e75191b7d59e2792</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.PropertyMetadata.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff40b04314562dceced1eca41762d8f11e0b2d05</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb79b96cb966a9c981d9c339abc43bdee740d9d8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</source>
          <target state="translated">定義相依性屬性的特定行為方面，因為它會套用到特定的類型，包括註冊與條件。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Property metadata can be defined and used during dependency property registration when calling the &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; method.</source>
          <target state="translated">屬性中繼資料可以定義，以及呼叫時，在相依性屬性註冊期間使用&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;方法 （或附加的屬性或唯讀相依性屬性的變體），或之後呼叫時的原始擁有者登錄&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;方法。&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; also takes property metadata.</source>
          <target state="translated">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;也會採用屬性中繼資料。&lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This class is a concrete base class that can be used in each of these calls.</source>
          <target state="translated">這個類別是可用於每個這些呼叫的具象基底類別。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>However, it is very common to specify metadata using one of the derived classes such as &lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.</source>
          <target state="translated">不過，是很常見，指定使用其中一種衍生的類別，例如&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.&lt;/xref:System.Windows.FrameworkPropertyMetadata&gt;的中繼資料</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> framework level.</source>
          <target state="translated">這些衍生的類別支援更詳細的中繼資料做為布林屬性值，可用於偵測或啟用只在實作某些屬性系統和配置行為執行<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>架構層級。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; or &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.</source>
          <target state="translated">這個類別的一些屬性，以讀寫物件模型，但只能用於屬性&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;或&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;&lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;等系統作業的執行個體之前寫入</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Each of these properties could also have been set by the constructor but are exposed so that &lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt; method implementations can set them.</source>
          <target state="translated">每一個屬性可能也已設定的建構函式，但會公開讓&lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;方法實作可以設定它們。&lt;/xref:System.Windows.PropertyMetadata.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    This type, and members of this type, are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # XAML 文字使用這個型別和成員，這種不通常會以<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified default value for the dependency property that this metadata will be applied to.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>使用指定的預設值為這個中繼資料將會套用至相依性屬性的類別。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">提供值的型別<ph id="ph1">`defaultValue`</ph>必須相符或相關的原始註冊相依性屬性會套用這個中繼資料中指定的型別。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">因為 （不符項目會引發執行階段例外狀況） 的編譯期間未偵測到不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">雖然它是預設的無參數建構函式每<ph id="ph1">`defaultValue`</ph>的&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;不指定。&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">嘗試這麼做的話，將會引發例外狀況。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The default value to specify for a dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">若要指定相依性屬性，通常會提供一些特定類型的值為預設值。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>無法設定為值<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; 請參閱 &lt; 備註 &gt;。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別具有指定<bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>實作參考。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">有效的屬性值變更時要呼叫屬性系統的處理常式實作的參考。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別，而指定的預設值和<bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>實作參考。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The type of the value provided <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">提供值的型別<ph id="ph1">`defaultValue`</ph>必須相符或相關的原始註冊相依性屬性會套用這個中繼資料中指定的型別。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">因為 （不符項目會引發執行階段例外狀況） 的編譯期間未偵測到不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">雖然它是預設的無參數建構函式每<ph id="ph1">`defaultValue`</ph>的&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;不指定。&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">嘗試這麼做的話，將會引發例外狀況。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">相依性屬性，通常會提供一些特定類型的值為預設值。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">有效的屬性值變更時要呼叫屬性系統的處理常式實作的參考。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>無法設定為值<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; 請參閱 &lt; 備註 &gt;。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and callbacks.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>具有指定的預設值和回呼類別。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you want to specify a &lt;xref:System.Windows.CoerceValueCallback&gt; but not a &lt;xref:System.Windows.PropertyChangedCallback&gt;, you can pass <ph id="ph1">`null`</ph> for the <ph id="ph2">`propertyChangedCallback`</ph> parameter.</source>
          <target state="translated">如果您想要指定&lt;xref:System.Windows.CoerceValueCallback&gt;但不是&lt;xref:System.Windows.PropertyChangedCallback&gt;，您可以傳遞<ph id="ph1">`null`</ph>如<ph id="ph2">`propertyChangedCallback`</ph>參數。&lt;/xref:System.Windows.PropertyChangedCallback&gt; &lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">提供值的型別<ph id="ph1">`defaultValue`</ph>必須相符或相關的原始註冊相依性屬性會套用這個中繼資料中指定的型別。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">因為 （不符項目會引發執行階段例外狀況） 的編譯期間未偵測到不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">雖然它是預設的無參數建構函式每<ph id="ph1">`defaultValue`</ph>的&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;不指定。&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">嘗試這麼做的話，將會引發例外狀況。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">相依性屬性，通常會提供一些特定類型的值為預設值。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">有效的屬性值變更時要呼叫屬性系統的處理常式實作的參考。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called whenever the property system calls &lt;xref:System.Windows.DependencyObject.CoerceValue*&gt; against this property.</source>
          <target state="translated">每當對屬性系統呼叫時要呼叫的處理常式實作的參考&lt;xref:System.Windows.DependencyObject.CoerceValue*&gt;針對這個屬性。&lt;/xref:System.Windows.DependencyObject.CoerceValue*&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>無法設定為值<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; 請參閱 &lt; 備註 &gt;。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">取得或設定參考<bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>此中繼資料中指定的實作。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">屬性中繼資料中的回呼不包含的類型，通常是公用成員，因此這個屬性的值並不重要，在大部分情況下，只要使用 現有相依性屬性的中繼資料。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.CoerceValueCallback&gt;.</source>
          <target state="translated">這個屬性會公開的其中一個原因是，讓中繼資料的子類別可以執行他們想要的合併的邏輯，如果基底中繼資料和覆寫或加入的中繼資料指定&lt;xref:System.Windows.CoerceValueCallback&gt;.&lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>However, the default merge logic for a CoerceValueCallback is to replace the previous one.</source>
          <target state="translated">不過，CoerceValueCallback 預設的合併邏輯是以取代先前的密碼。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>CoerceValueCallback is defined in the object model as read-write.</source>
          <target state="translated">CoerceValueCallback 物件模型中定義為讀寫。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This is so CoerceValueCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">這是讓初始化之後，可以調整 CoerceValueCallback&lt;xref:System.Windows.PropertyMetadata&gt;物件本身。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">不過，一旦一部分的呼叫會使用中繼資料&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;， &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;，或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;、 對屬性系統將密封該中繼資料執行個體和內容現在會被視為不變。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Attempting to set CoerceValueCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">嘗試一次設定 CoerceValueCallback&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;是<ph id="ph1">`true`</ph>此中繼資料執行個體將會引發例外狀況。&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>實作參考。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">套用至相依性屬性作業之後，無法設定中繼資料屬性。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Gets or sets the default value of the dependency property.</source>
          <target state="translated">取得或設定相依性屬性的預設值。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>DefaultValue is defined in the object model as read-write.</source>
          <target state="translated">預設值是物件模型中定義為讀寫。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This is so DefaultValue can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">這是讓初始化之後，可以調整 DefaultValue&lt;xref:System.Windows.PropertyMetadata&gt;物件本身。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">不過，一旦一部分的呼叫會使用中繼資料&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;， &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;，或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;、 對屬性系統將密封該中繼資料執行個體和內容現在會被視為不變。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Attempting to set DefaultValue once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">嘗試一次設定 DefaultValue&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;是<ph id="ph1">`true`</ph>此中繼資料執行個體將會引發例外狀況。&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be set using either DefaultValue or the constructor.</source>
          <target state="translated">雖然它是預設的無參數建構函式每<ph id="ph1">`defaultValue`</ph>的&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;無法使用預設值或建構函式設定。&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">嘗試這麼做的話，將會引發例外狀況。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    Members of this type are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # XAML 文字使用這個類型的成員不通常會以<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The default value of the property.</source>
          <target state="translated">屬性的預設值。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The default value on a <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance created with the parameterless constructor will be <bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated">上的預設值<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>具有無參數建構函式所建立的執行個體將會<bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>; 請參閱 &lt; 備註 &gt;。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> once created; see Remarks.</source>
          <target state="translated">無法設定為值<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>一旦建立，請參閱 &lt; 備註 &gt;。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">套用至相依性屬性作業之後，無法設定中繼資料屬性。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</source>
          <target state="translated">取得值，可判斷中繼資料是否已套用至以某種方式，產生的不可變的狀態，該中繼資料執行個體的屬性。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Various properties of &lt;xref:System.Windows.PropertyMetadata&gt;, such as &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;, are defined in the object model as read-write.</source>
          <target state="translated">各種屬性&lt;xref:System.Windows.PropertyMetadata&gt;，例如&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;，為讀寫物件模型中定義。&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; &lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This is so those properties can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">這是可以初始化之後調整這些屬性，因此&lt;xref:System.Windows.PropertyMetadata&gt;物件本身。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>However, once the metadata is applied to a dependency property as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">不過，一旦中繼資料套用至相依性屬性來呼叫過程&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;， &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;，或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;、 對屬性系統將密封該中繼資料執行個體和內容現在會被視為不變。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>At the time of one of these calls, &lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt; is called, and the value of this property is set to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">在這些呼叫，其中的階段&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;呼叫，且這個屬性的值設定為<ph id="ph1">`true`</ph>。&lt;/xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the metadata instance is immutable; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果中繼資料執行個體是不可變的;否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Merges this metadata with the base metadata.</source>
          <target state="translated">合併此中繼資料與基底中繼資料。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This method is used internally when metadata is being overridden (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; method).</source>
          <target state="translated">這個方法用在內部中繼資料覆寫時 (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;方法)。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The base metadata to merge with this instance's values.</source>
          <target state="translated">要與這個執行個體的值合併的基底中繼資料。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The dependency property to which this metadata is being applied.</source>
          <target state="translated">要套用這個中繼資料相依性屬性。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">此中繼資料已套用至屬性，指出密封的中繼資料時呼叫。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Subclasses should assure that any mutability of the data structure of a &lt;xref:System.Windows.PropertyMetadata&gt; subclass should be marked as immutable once OnApply is called.</source>
          <target state="translated">子類別應該確保任何可變動性的資料結構的&lt;xref:System.Windows.PropertyMetadata&gt;子類別應該標示為不可變一旦呼叫 OnApply。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</source>
          <target state="translated">這會呼叫中繼資料套用至屬性系統作業之後 （登錄、 將擁有者新增、 覆寫中繼資料）。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">相依性屬性中繼資料套用。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">如果這是特定類型的中繼資料，此中繼資料與相關聯的類型。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If this is default metadata, this value is a null reference.</source>
          <target state="translated">如果這是預設的中繼資料時，這個值是 null 參考。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">取得或設定參考<bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>此中繼資料中指定的實作。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">屬性中繼資料中的回呼不上定義的類型，通常是公用成員，因此這個屬性的值並不重要，在大部分情況下，只要使用 現有相依性屬性的中繼資料。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.PropertyChangedCallback&gt;.</source>
          <target state="translated">這個屬性會公開的其中一個原因是，讓中繼資料類別可以執行他們想要的合併的邏輯，如果基底中繼資料和覆寫或加入的中繼資料指定&lt;xref:System.Windows.PropertyChangedCallback&gt;.&lt;/xref:System.Windows.PropertyChangedCallback&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The default merge logic for is to maintain all PropertyChangedCallback implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</source>
          <target state="translated">預設合併邏輯是維護表格中的所有 PropertyChangedCallback 實作和呼叫每個項目，執行第一個階層中最深層的類別所建立的回呼。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>PropertyChangedCallback is defined in the object model as read-write.</source>
          <target state="translated">PropertyChangedCallback 物件模型中定義為讀寫。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This is so PropertyChangedCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">這是讓初始化之後，可以調整 PropertyChangedCallback&lt;xref:System.Windows.PropertyMetadata&gt;物件本身。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">不過，一旦一部分的呼叫會使用中繼資料&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;， &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;，或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;、 對屬性系統將密封該中繼資料執行個體和內容現在會被視為不變。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Attempting to set PropertyChangedCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">嘗試一次設定 PropertyChangedCallback&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;是<ph id="ph1">`true`</ph>此中繼資料執行個體將會引發例外狀況。&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>實作參考。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">套用至相依性屬性作業之後，無法設定中繼資料屬性。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>