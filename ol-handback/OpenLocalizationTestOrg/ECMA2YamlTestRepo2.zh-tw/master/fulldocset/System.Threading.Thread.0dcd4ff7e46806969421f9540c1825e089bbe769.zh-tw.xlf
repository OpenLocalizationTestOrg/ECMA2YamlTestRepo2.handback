<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e5df80f20fb8f8e9d58d7fd51e841a9b301b1bb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.Thread.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">653da93a9d042822697ec36cc7faef683efdc45f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d53c4cef63a323cfe675bb4658023858adff4b10</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">建立和控制執行緒，設定其優先權，並取得其狀態。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">當處理程序啟動時，common language runtime 會自動建立單一前景執行緒來執行應用程式程式碼。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">這個主要前景執行緒，以及處理序可建立一或多個執行緒來執行此程序相關聯的程式碼的一部分。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">這些執行緒可以執行在前景或背景。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In addition, you can use the &lt;xref:System.Threading.ThreadPool&gt; class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">此外，您可以使用&lt;xref:System.Threading.ThreadPool&gt;common language runtime 所管理的背景工作執行緒上執行程式碼的類別。&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In this section       <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept>     <bpt id="p2">[</bpt>Retrieving Thread objects<ept id="p2">](#Retrieving)</ept>     <bpt id="p3">[</bpt>Foreground and background threads<ept id="p3">](#Foreground)</ept>     <bpt id="p4">[</bpt>Culture and threads<ept id="p4">](#Culture)</ept>     <bpt id="p5">[</bpt>Getting information about and controlling threads<ept id="p5">](#Properties)</ept>     <bpt id="p6">[</bpt>Accessing the source code for the Thread class<ept id="p6">](#Source)</ept>      <bpt id="p7">&lt;a name="Starting"&gt;</bpt><ept id="p7">&lt;/a&gt;</ept>    ## Starting a thread    You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">本章節內容<bpt id="p1">[</bpt>啟動執行緒<ept id="p1">](#Starting)</ept><bpt id="p2">[</bpt>擷取執行緒物件<ept id="p2">](#Retrieving)</ept><bpt id="p3">[</bpt>前景和背景執行緒<ept id="p3">](#Foreground)</ept><bpt id="p4">[</bpt>文化特性和執行緒<ept id="p4">](#Culture)</ept><bpt id="p5">[</bpt>取得的資訊關於和控制執行緒<ept id="p5">](#Properties)</ept><bpt id="p6">[</bpt>存取執行緒類別的原始程式碼<ept id="p6">](#Source)</ept><bpt id="p7">&lt;a name="Starting"&gt;</bpt> <ept id="p7">&lt;/a&gt;</ept> # # 啟動執行緒藉由提供委派，表示要在其類別建構函式中執行執行緒的方法啟動執行緒。                               </target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You then call the &lt;xref:System.Threading.Thread.Start%2A&gt; method to begin execution.</source>
          <target state="translated">然後呼叫&lt;xref:System.Threading.Thread.Start%2A&gt;方法開始執行。&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The Thread constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:      -   If the method has no arguments, you pass a &lt;xref:System.Threading.ThreadStart&gt; delegate to  the constructor.</source>
          <target state="translated">執行緒建構函式可以採用兩個委派類型，根據是否將引數傳遞至方法，以執行其中一項:-如果方法沒有引數，傳遞&lt;xref:System.Threading.ThreadStart&gt;委派建構函式。&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph>           The following example creates and starts a thread that executes the <ph id="ph3">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">簽章︰ <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph>下列範例會建立並開始執行的執行緒<ph id="ph3">`ExecuteInForeground`</ph>方法。          </target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">方法會顯示一些執行緒屬性的相關資訊，然後執行的迴圈，它會暫停半秒並會顯示經過的秒數。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">當執行緒已執行至少五秒時，則迴圈結束，且在執行緒結束執行。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept><ept id="p3">]</ept>      -   If the method has an argument, you pass a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate to the constructor.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept> <ept id="p3">]</ept> -如果方法沒有引數，傳遞&lt;xref:System.Threading.ParameterizedThreadStart&gt;委派建構函式。&lt;/xref:System.Threading.ParameterizedThreadStart&gt;      </target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph>           The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">簽章︰ <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph>委派所執行的方法可以再轉型 （C# 中） 或 （在 Visual Basic) 參數轉換成適當的型別。          </target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following example is identical to the previous one, except that it calls the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor.</source>
          <target state="translated">下列範例等同於前一個，不同之處在於它會呼叫&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;建構函式。&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">這個版本的<ph id="ph1">`ExecuteInForeground`</ph>方法具有單一參數來表示近似的迴圈是執行的毫秒數。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept><ept id="p3">]</ept>       It is not necessary to retain a reference to a Thread object once you have started the thread.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept> <ept id="p3">]</ept>則不需要保留執行緒物件的參考，一旦您已經啟動執行緒。      </target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">執行緒會繼續執行直到完成為止，執行緒程序。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Retrieving Thread objects    You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # 您可以使用靜態擷取執行緒物件 (<ph id="ph1">`Shared`</ph>在 Visual Basic 中)&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;屬性，以擷取目前執行中執行緒的執行緒正在執行的程式碼中的參考。&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following example uses the &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">下列範例會使用&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;屬性來顯示主應用程式執行緒、 另一個前景執行緒，背景執行緒和執行緒集區執行緒的相關資訊。&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Foreground"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Foreground and background threads    Instances of the Thread class represent either foreground threads or background threads.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Foreground"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> # # 前景和背景執行緒的執行緒類別的執行個體代表前景執行緒或背景執行緒。        </target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">背景執行緒會與相同前景執行緒有一個例外狀況︰ 背景執行緒不會保存執行的處理序，如果所有的前景執行緒已經終止。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">一旦所有的前景執行緒都已停止，執行階段會停止所有的背景執行緒，並關閉。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>By default, the following threads execute in the foreground:      -   The main application thread.</source>
          <target state="translated">依預設，下列的執行緒執行在前景:-主應用程式執行緒。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>-   All threads created by calling a Thread class constructor.</source>
          <target state="translated">的藉由呼叫執行緒類別建構函式建立所有執行緒。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following threads execute in the background by default:      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">下列執行緒在背景執行預設:-執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">您可以在執行緒集區執行緒上設定執行緒集區和排程工作，使用&lt;xref:System.Threading.ThreadPool&gt;類別。&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在執行緒集區執行緒上自動執行工作為基礎的非同步作業。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Task-based asynchronous operations use the &lt;xref:System.Threading.Tasks.Task&gt; and &lt;xref:System.Threading.Tasks.Task%601&gt; classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">以工作為基礎的非同步作業會使用&lt;xref:System.Threading.Tasks.Task&gt;和&lt;xref:System.Threading.Tasks.Task%601&gt;類別以實作<bpt id="p1">[</bpt>工作架構非同步模式<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。&lt;/xref:System.Threading.Tasks.Task%601&gt; &lt;/xref:System.Threading.Tasks.Task&gt;</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-所有執行緒從 unmanaged 程式碼進入 managed 的執行環境。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You can change a thread to execute in the background by setting the &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property at any time.</source>
          <target state="translated">您可以變更執行緒在背景中執行，藉由設定&lt;xref:System.Threading.Thread.IsBackground%2A&gt;隨時屬性。&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">背景執行緒可用於任何作業，應該只要應用程式正在執行，但應該不會防止應用程式終止，例如監視檔案系統變更或連入通訊端連線。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">下列範例說明前景和背景執行緒之間的差異。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">就像中的第一個範例<bpt id="p1">[</bpt>啟動執行緒<ept id="p1">](#Starting)</ept>區段中，不同之處在於它會設定執行緒在背景執行前啟動它。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">如輸出所示，它會執行五秒前中斷迴圈。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Culture"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Culture and threads    Each thread has a culture, represented by the &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt; property, and a UI culture, represented by the &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt; property.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Culture"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> # # 每個執行緒的文化特性和執行緒有所代表的文化特性，&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;屬性和 UI 文化特性所表示&lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;屬性。&lt;/xref:System.Threading.Thread.CurrentUICulture%2A&gt; &lt;/xref:System.Threading.Thread.CurrentCulture%2A&gt;        </target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">目前的文化特性支援剖析和格式、 字串比較和排序，這類區分文化特性的作業，而且也會控制執行緒使用的行事曆與書寫系統。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">目前 UI 文化特性提供區分文化特性擷取資源檔中的資源。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">新的執行緒會具現化，其文化特性和 UI 文化特性定義的目前系統文化特性和 UI 文化特性，而不是文化特性和 UI 文化特性建立新的執行緒的執行緒。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">這表示，例如，如果目前的系統文化特性是英文 （美國） 和主要的應用程式執行緒的目前文化特性為法文 （法國），藉由呼叫建立新執行緒的文化特性&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;建構函式從主執行緒是英文 （美國） 和法文 （法國）。&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more information, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">如需詳細資訊，請參閱 &lt; 文化特性和執行緒 」 一節&lt;xref:System.Globalization.CultureInfo&gt;類別主題。&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 這不是執行非同步作業的應用程式為目標的執行緒，則為 true<ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph>和更新版本中的，在此情況下，文化特性和 UI 文化特性是非同步作業的內容的一部分，則為預設非同步作業所執行的執行緒繼承的文化特性和 UI 文化特性的非同步作業已啟動執行緒。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">如需詳細資訊，請參閱"文化特性和以工作為基礎的非同步作業 &gt; 一節&lt;xref:System.Globalization.CultureInfo&gt;類別主題。&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:      -   You can pass a &lt;xref:System.Globalization.CultureInfo&gt; object that represents that culture to the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate or the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; method.</source>
          <target state="translated">您可以執行下列動作，以確保所有的執行緒執行的應用程式中共用相同的文化特性和 UI 文化特性:-您可以傳遞&lt;xref:System.Globalization.CultureInfo&gt;物件，代表該文化特性&lt;xref:System.Threading.ParameterizedThreadStart&gt;委派或&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt;方法。&lt;/xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; &lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>-   For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt; and &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; properties.</source>
          <target state="translated">-若為應用程式上執行<ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph>和更新版本中，您可以定義的文化特性和 UI 文化特性所要指派給所設定的值建立應用程式定義域中的所有執行緒&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;和&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;屬性。&lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; &lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">請注意，這是每個應用程式網域設定。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For more information and examples, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">如需詳細資訊與範例，請參閱 &lt; 文化特性和執行緒 &gt; 一節&lt;xref:System.Globalization.CultureInfo&gt;類別主題。&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Getting information about and controlling threads    You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # 取得相關資訊和控制執行緒，您可以擷取提供執行緒的相關資訊的屬性值的數目。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">在某些情況下，您也可以設定這些屬性值來控制執行緒的作業。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>These thread properties include:      -   A name.</source>
          <target state="translated">這些執行緒屬性包括:-名稱。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.Name%2A&gt; is a write-once property that you can use to identify a thread.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Name%2A&gt;會寫入-一次可用來識別在執行緒中的屬性。&lt;/xref:System.Threading.Thread.Name%2A&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">預設值是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>-   A hash code, which you can retrieve by calling the &lt;xref:System.Threading.Thread.GetHashCode%2A&gt; method.</source>
          <target state="translated">-A 雜湊碼，您可以藉由呼叫擷取&lt;xref:System.Threading.Thread.GetHashCode%2A&gt;方法。&lt;/xref:System.Threading.Thread.GetHashCode%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">雜湊程式碼可以用來唯一識別執行緒;在執行緒的存留期間，其雜湊程式碼不會與任何其他執行緒，不論應用程式定義域取得此值的值相衝突。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>-   A thread ID.</source>
          <target state="translated">-執行緒識別碼。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The value of the read-only &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">唯讀值&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;屬性由執行階段所指派，並且唯一地識別其處理程序中的執行緒。&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 作業系統<bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept>有沒有固定的關係，managed 執行緒，因為受管理的主機可控制 managed 和 unmanaged 執行緒之間的關聯性。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">具體來說，精密的主機可以使用<bpt id="p1">[</bpt>CLR 裝載 API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept>排程許多 managed 的執行緒，對相同的作業系統執行緒，或是不同的作業系統執行緒之間移動 managed 的執行緒。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>-   The thread's current state.</source>
          <target state="translated">-執行緒的目前狀態。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the &lt;xref:System.Threading.ThreadState&gt; property.</source>
          <target state="translated">它的存在時間，執行緒一律是在一或多個定義的狀態&lt;xref:System.Threading.ThreadState&gt;屬性。&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>-   A scheduling priority level, which is defined by the &lt;xref:System.Threading.ThreadPriority&gt; property.</source>
          <target state="translated">的所定義排程優先權等級&lt;xref:System.Threading.ThreadPriority&gt;屬性。&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">雖然您可以設定此值，以要求執行緒的優先權，其不一定適用於作業系統。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>-   The read-only &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt; property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">-唯讀&lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;屬性，指出執行緒是否是在執行緒集區執行緒。&lt;/xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>-   The &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property.</source>
          <target state="translated">-&lt;xref:System.Threading.Thread.IsBackground%2A&gt;屬性。&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>前景和背景執行緒<ept id="p1">](#Foreground)</ept>&gt; 一節。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Accessing the source code for the Thread class    To view the .NET Framework source code for the Thread class, see the <bpt id="p2">[</bpt>Reference Source<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # 存取要檢視執行緒類別的.NET Framework 原始碼的執行緒類別的原始程式碼請參閱<bpt id="p2">[</bpt>參考來源<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
          <target state="translated">您可以瀏覽原始碼、 下載的參考，離線檢視，並逐步執行原始程式碼 （包含修補程式和更新），在偵錯;請參閱<bpt id="p1">[</bpt>指示<ept id="p1">](http://referencesource.microsoft.com/)</ept>。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別，指定委派，讓物件可以在執行緒啟動時傳遞到執行緒。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">執行緒不會開始執行時建立。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">若要排程執行的執行緒，呼叫&lt;xref:System.Threading.Thread.Start%2A&gt;方法。&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>To pass a data object to the thread, use the &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt; method overload.</source>
          <target state="translated">若要將資料物件傳遞到執行緒，使用&lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;方法多載。&lt;/xref:System.Threading.Thread.Start%28System.Object%29&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 可以省略 Visual Basic 使用者&lt;xref:System.Threading.ThreadStart&gt;建構函式建立執行緒時。&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">使用<ph id="ph1">`AddressOf`</ph>運算子時傳遞您的方法，例如<ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic 會自動呼叫&lt;xref:System.Threading.ThreadStart&gt;建構函式。&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">委派，表示這個執行緒開始執行時要叫用的方法。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">執行緒不會開始執行時建立。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">若要排程執行的執行緒，呼叫&lt;xref:System.Threading.Thread.Start%2A&gt;方法。&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 可以省略 Visual Basic 使用者&lt;xref:System.Threading.ThreadStart&gt;建構函式建立執行緒時。&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">使用<ph id="ph1">`AddressOf`</ph>運算子，例如傳遞方法時<ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic 會自動呼叫&lt;xref:System.Threading.ThreadStart&gt;建構函式。&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>委派，表示這個執行緒開始執行時要叫用的方法。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別，指定委派，讓物件可以在執行緒啟動時傳遞到執行緒，並指定執行緒的最大堆疊大小。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">請避免使用這個建構函式多載。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">所使用的預設堆疊大小&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;建構函式多載是建議的堆疊大小執行緒。&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">如果執行緒有記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 開頭<ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>、 只有完全受信任的程式碼可以設定<ph id="ph3">`maxStackSize`</ph>大於預設堆疊大小 (1 mb) 的值。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">如果指定較大的值<ph id="ph1">`maxStackSize`</ph>以部分信任，請在執行程式碼時<ph id="ph2">`maxStackSize`</ph>會被忽略，而且是預設堆疊大小。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">擲不回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">任何信任層級的程式碼可以設定<ph id="ph1">`maxStackSize`</ph>小於預設堆疊大小的值。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 如果您正在開發完全受信任的程式庫，供部分信任的程式碼，且您要啟動的執行緒需要大型堆疊、 您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">不要這樣除非您完全控制的執行緒執行的程式碼。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">如果<ph id="ph1">`maxStackSize`</ph>小於最小的堆疊大小，使用最小的堆疊大小。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">如果<ph id="ph1">`maxStackSize`</ph>不多的頁面大小會四捨五入為下一個較大頁面大小的倍數。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">例如，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 位元組） 是最小的堆疊大小，和頁面大小是 64 KB （65536 個位元組）。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 上的 Microsoft Windows Windows XP 和 Windows Server 2003 之前, 的版本<ph id="ph2">`maxStackSize`</ph>會被忽略，而且是可執行檔的標頭中指定的堆疊大小。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">若要停用堆疊探查，加入下列應用程式組態檔。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>委派，表示這個執行緒開始執行時要叫用的方法。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">最大堆疊大小，以位元組為單位，執行緒，或是 0 用於使用可執行檔標頭中指定的預設最大堆疊大小。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">重要資訊︰ 對於部分信任程式碼，<ph id="ph1">`maxStackSize`</ph>會被忽略，如果大於預設堆疊大小。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">擲不回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>小於零。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別，並指定執行緒的最大堆疊大小。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">請避免使用這個建構函式多載。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">所使用的預設堆疊大小&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;建構函式多載是建議的堆疊大小執行緒。&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">如果執行緒有記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 開頭<ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>、 只有完全受信任的程式碼可以設定<ph id="ph3">`maxStackSize`</ph>大於預設堆疊大小 (1 mb) 的值。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">如果指定較大的值<ph id="ph1">`maxStackSize`</ph>以部分信任，請在執行程式碼時<ph id="ph2">`maxStackSize`</ph>會被忽略，而且是預設堆疊大小。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">擲不回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">任何信任層級的程式碼可以設定<ph id="ph1">`maxStackSize`</ph>小於預設堆疊大小的值。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 如果您正在開發完全受信任的程式庫，供部分信任的程式碼，且您要啟動的執行緒需要大型堆疊、 您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">不要這樣除非您完全控制的執行緒執行的程式碼。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">如果<ph id="ph1">`maxStackSize`</ph>小於最小的堆疊大小，使用最小的堆疊大小。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">如果<ph id="ph1">`maxStackSize`</ph>不多的頁面大小會四捨五入為下一個較大頁面大小的倍數。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">例如，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 位元組） 是最小的堆疊大小，和頁面大小是 64 KB （65536 個位元組）。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 上的 Microsoft Windows Windows XP 和 Windows Server 2003 之前, 的版本<ph id="ph2">`maxStackSize`</ph>會被忽略，而且是可執行檔的標頭中指定的堆疊大小。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">若要停用堆疊探查，加入下列應用程式組態檔。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>委派，表示這個執行緒開始執行時要叫用的方法。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">最大堆疊大小，以位元組為單位，執行緒，或是 0 用於使用可執行檔標頭中指定的預設最大堆疊大小。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">重要資訊︰ 對於部分信任程式碼，<ph id="ph1">`maxStackSize`</ph>會被忽略，如果大於預設堆疊大小。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">擲不回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>小於零。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">引發<bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>執行緒被叫用，開始結束執行緒的程序中。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">呼叫這個方法通常會結束執行緒。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">在執行緒上叫用這個方法時，系統會&lt;xref:System.Threading.ThreadAbortException&gt;中止該執行緒中&lt;/xref:System.Threading.ThreadAbortException&gt;擲回</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>是特殊的例外狀況可以攔截的應用程式程式碼，但是會重新擲回的結尾<ph id="ph2">`catch`</ph>封鎖除非&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;稱為。&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>取消要求中止，並防止<ph id="ph2">`ThreadAbortException`</ph>終止執行緒。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">未執行<ph id="ph1">`finally`</ph>區塊會執行已中止的執行緒之前。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 當一個執行緒呼叫<ph id="ph2">`Abort`</ph>效果是類似於擲回例外狀況; 本身，&lt;xref:System.Threading.ThreadAbortException&gt;時會立即，且結果為可預測。&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">不過，如果一個執行緒呼叫<ph id="ph1">`Abort`</ph>，另一個執行緒上中斷執行任何程式碼中止。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">此外，也可能已中止的靜態建構函式有機會。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">在罕見的情況下，這可能導致無法建立應用程式定義域中的類別的執行個體。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">在.NET framework 1.0 和 1.1 版中，的可能會無法中止執行緒時<ph id="ph1">`finally`</ph>執行的區塊，在此情況下<ph id="ph2">`finally`</ph>區塊就會中止。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">執行緒中止立即，或完全不保證。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下<ph id="ph1">`finally`</ph>稱為中止程序，藉此無限延遲中止的區塊。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee the wait will end.</source>
          <target state="translated">若要等候，直到執行緒已中止，您可以呼叫&lt;xref:System.Threading.Thread.Join%2A&gt;方法之後呼叫中止之方法的執行緒上但不保證將會結束等待。&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls Abort might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 呼叫中止執行緒可能封鎖，是否要中止的執行緒中受保護的區域，程式碼，例如<ph id="ph2">`catch`</ph>區塊，<ph id="ph3">`finally`</ph>區塊或限制的執行區域。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>If the thread that calls Abort holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">如果呼叫中止的執行緒掌握已中止的執行緒要求的鎖定，便會發生死結。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">如果<ph id="ph1">`Abort`</ph>稱為上尚未啟動的執行緒，執行緒將會中止時&lt;xref:System.Threading.Thread.Start%2A&gt;稱為。&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">如果<ph id="ph1">`Abort`</ph>呼叫執行緒時遭到封鎖或睡眠中的執行緒上中斷，並再中止。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">如果<ph id="ph1">`Abort`</ph>已暫停的執行緒上呼叫&lt;xref:System.Threading.ThreadStateException&gt;呼叫的執行緒中擲回&lt;xref:System.Threading.Thread.Abort%2A&gt;，和&lt;xref:System.Threading.ThreadState&gt;加入至&lt;xref:System.Threading.Thread.ThreadState%2A&gt;正在中止的執行緒屬性。&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">A&lt;xref:System.Threading.ThreadAbortException&gt;才會擲回在暫停的執行緒，直到&lt;xref:System.Threading.Thread.Resume%2A&gt;稱為。&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">如果<ph id="ph1">`Abort`</ph>執行 unmanaged 程式碼時，在 managed 執行緒上呼叫<ph id="ph2">`ThreadAbortException`</ph>傳回給 managed 程式碼的執行緒之前不會擲回。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">如果兩個呼叫會以<ph id="ph1">`Abort`</ph>出現在相同的時間，它是一個設定的狀態資訊的呼叫和其他執行的呼叫可能<ph id="ph2">`Abort`</ph>。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">不過，應用程式無法偵測這種情況。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">之後<ph id="ph1">`Abort`</ph>叫用執行緒上、 執行緒的狀態包括&lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">執行緒已經終止由於成功呼叫之後<ph id="ph1">`Abort`</ph>，執行緒的狀態變更為&lt;xref:System.Threading.ThreadState&gt;。&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">具有足夠的權限的執行緒，做為目標的<ph id="ph1">`Abort`</ph>可以取消中止使用<ph id="ph2">`ResetAbort`</ph>方法。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">如需範例，示範如何呼叫<ph id="ph1">`ResetAbort`</ph>方法，請參閱<ph id="ph2">`ThreadAbortException`</ph>類別。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼叫端沒有必要的權限。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">正在中止的執行緒目前已暫停。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">引發<bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>執行緒被叫用，開始結束執行緒，同時也提供有關執行緒終止的例外狀況資訊的程序中。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">呼叫這個方法通常會結束執行緒。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">在執行緒上叫用這個方法時，系統會&lt;xref:System.Threading.ThreadAbortException&gt;中止該執行緒中&lt;/xref:System.Threading.ThreadAbortException&gt;擲回</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>是特殊的例外狀況可以攔截的應用程式程式碼，但是會重新擲回的結尾<ph id="ph2">`catch`</ph>封鎖除非&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;稱為。&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>取消要求中止，並防止<ph id="ph2">`ThreadAbortException`</ph>終止執行緒。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">未執行<ph id="ph1">`finally`</ph>區塊會執行已中止的執行緒之前。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 當一個執行緒呼叫<ph id="ph2">`Abort`</ph>效果是類似於擲回例外狀況; 本身，&lt;xref:System.Threading.ThreadAbortException&gt;時會立即，且結果為可預測。&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">不過，如果一個執行緒呼叫<ph id="ph1">`Abort`</ph>，另一個執行緒上中斷執行任何程式碼中止。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">沒有靜態建構函式可能會中止的機率。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">在罕見的情況下，這可能導致無法建立應用程式定義域中的類別的執行個體。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">在.NET framework 1.0 和 1.1 版中，的可能會無法中止執行緒時<ph id="ph1">`finally`</ph>執行的區塊，在此情況下<ph id="ph2">`finally`</ph>區塊就會中止。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">執行緒中止立即，或完全不保證。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下<ph id="ph1">`finally`</ph>稱為中止程序，藉此無限延遲中止的區塊。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee that the wait will end.</source>
          <target state="translated">若要等候，直到執行緒已中止，您可以呼叫&lt;xref:System.Threading.Thread.Join%2A&gt;方法之後呼叫中止之方法的執行緒上但不保證會結束等待。&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 呼叫的執行緒&lt;xref:System.Threading.Thread.Abort%2A&gt;是否要中止的執行緒中受保護的區域，程式碼，例如，可能會封鎖<ph id="ph2">`catch`</ph>區塊，<ph id="ph3">`finally`</ph>區塊或限制的執行區域。&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If the thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">如果執行緒呼叫&lt;xref:System.Threading.Thread.Abort%2A&gt;鎖定要求已中止的執行緒，便會發生死結。&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">如果<ph id="ph1">`Abort`</ph>稱為上尚未啟動的執行緒，執行緒將會中止時&lt;xref:System.Threading.Thread.Start%2A&gt;稱為。&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">如果<ph id="ph1">`Abort`</ph>呼叫執行緒時遭到封鎖或睡眠中的執行緒上中斷，並再中止。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">如果<ph id="ph1">`Abort`</ph>已暫停的執行緒上呼叫&lt;xref:System.Threading.ThreadStateException&gt;呼叫的執行緒中擲回&lt;xref:System.Threading.Thread.Abort%2A&gt;，和&lt;xref:System.Threading.ThreadState&gt;加入至&lt;xref:System.Threading.Thread.ThreadState%2A&gt;正在中止的執行緒屬性。&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">A&lt;xref:System.Threading.ThreadAbortException&gt;才會擲回在暫停的執行緒，直到&lt;xref:System.Threading.Thread.Resume%2A&gt;稱為。&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">如果<ph id="ph1">`Abort`</ph>執行 unmanaged 程式碼時，在 managed 執行緒上呼叫<ph id="ph2">`ThreadAbortException`</ph>傳回給 managed 程式碼的執行緒之前不會擲回。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">如果兩個呼叫會以<ph id="ph1">`Abort`</ph>出現在相同的時間，它是一個設定的狀態資訊的呼叫和其他執行的呼叫可能<ph id="ph2">`Abort`</ph>。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">不過，應用程式無法偵測這種情況。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">之後<ph id="ph1">`Abort`</ph>叫用執行緒上、 執行緒的狀態包括&lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">執行緒已經終止由於成功呼叫之後<ph id="ph1">`Abort`</ph>，執行緒的狀態變更為&lt;xref:System.Threading.ThreadState&gt;。&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">具有足夠的權限的執行緒，做為目標的<ph id="ph1">`Abort`</ph>可以取消中止使用<ph id="ph2">`ResetAbort`</ph>方法。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">如需範例，示範如何呼叫<ph id="ph1">`ResetAbort`</ph>方法，請參閱<ph id="ph2">`ThreadAbortException`</ph>類別。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">物件，包含應用程式特定資訊，例如可供正在中止的執行緒的狀態。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼叫端沒有必要的權限。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">正在中止的執行緒目前已暫停。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">配置所有執行緒上未命名的資料位置。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">為提升效能，使用與標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性，屬性。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性) 和資料位置。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需有關如何使用 TLS 的詳細資訊，請參閱<bpt id="p1">[</bpt>執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">在所有執行緒上配置的位置。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">資料位置是每個執行緒的唯一的。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">已配置的具名資料位置，所有執行緒上。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">配置所有執行緒上的具名的資料位置。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">為提升效能，使用與標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性，屬性。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性) 和資料位置。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需有關如何使用 TLS 的詳細資訊，請參閱<bpt id="p1">[</bpt>執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">資料位置是每個執行緒的唯一的。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the AllocateNamedDataSlot method to allocate a named data slot, because the &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; method allocates the slot if it has not already been allocated.</source>
          <target state="translated">不需要使用 AllocateNamedDataSlot 方法配置的具名的資料位置，因為&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;方法配置位置，如果它不已配置。&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; AllocateNamedDataSlot 方法使用時，如果它中應該呼叫主執行緒在程式啟動時，因為它會擲回例外狀況，如果已配置具有指定名稱的位置。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">沒有任何方法來測試是否已配置的位置。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Slots allocated with this method must be freed with &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.</source>
          <target state="translated">以這個方法所配置的位置必須釋放與&lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.&lt;/xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">要配置之資料插槽的名稱。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">已配置的具名資料位置，所有執行緒上。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">具有指定名稱的具名的資料位置已存在。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">取得或設定這個執行緒的 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>The ApartmentState property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>ApartmentState 屬性已經過時。<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The non-obsolete alternatives are the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method to retrieve the apartment state and the   &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method to set the apartment state.</source>
          <target state="translated">非過時的替代方式為&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;方法來擷取的 apartment 狀態和&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;方法，以設定 apartment 狀態。&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">在.NET framework 1.0 和 1.1 版，<ph id="ph1">`ApartmentState`</ph>屬性標記，表示它會在單一執行緒或多執行緒 apartment 中執行的執行緒。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">可以設定這個屬性，當執行緒處於<ph id="ph1">`Unstarted`</ph>或<ph id="ph2">`Running`</ph>執行緒狀態; 不過，它可以只能設定一次的執行緒。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">如果尚未設定屬性，它會傳回<ph id="ph1">`Unknown`</ph>。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>An attempt to use the ApartmentState property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">嘗試使用 ApartmentState 屬性來設定其 apartment 狀態已設定執行緒的 apartment 狀態會被忽略。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>However, the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method throws a &lt;xref:System.InvalidOperationException&gt; in this case.</source>
          <target state="translated">不過，&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;方法會擲回&lt;xref:System.InvalidOperationException&gt;在此情況下。&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  In the .NET Framework version 2.0, new threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; In the.NET Framework 2.0 版，新的執行緒都會初始化成&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;如果其 apartment 狀態尚未設定之前啟動。&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">主應用程式執行緒會初始化為&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;預設。&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>You can no longer set the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by setting the &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; property on the first line of code.</source>
          <target state="translated">您可以不再將設定主應用程式執行緒&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;藉由設定&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;第一行程式碼上的屬性。&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Use the &lt;xref:System.STAThreadAttribute&gt; instead.</source>
          <target state="translated">使用&lt;xref:System.STAThreadAttribute&gt;改用。&lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> linker option.</source>
          <target state="translated">在.NET Framework 2.0 版中，您可以指定的 COM 執行緒模型為 c + + 應用程式使用<bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE （設定 CLR 執行緒屬性）<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>連結器選項。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">其中一個<bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>值。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">初始值是<bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) or multithreaded apartment (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</source>
          <target state="translated">嘗試將此屬性設為無效 apartment 狀態的狀態 (單一執行緒 apartment 以外的狀態 (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) 或多執行緒的 apartment (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>))。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">通知主機在即將執行的程式碼中，執行緒中止或未處理例外狀況的影響可能危及應用程式定義域中的其他工作的區域。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">在其中執行緒中止或未處理的例外狀況的影響可能不是目前的工作是關鍵區域。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">相反地，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">例如，假設有嘗試配置記憶體時保留鎖定工作。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性&lt;xref:System.AppDomain&gt;，因為在等候相同的鎖定網域中可以有其他工作。&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">如果目前的工作已中止，其他工作可能發生死結。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">發生失敗時的關鍵區域中，主機可能會決定卸載整個&lt;xref:System.AppDomain&gt;而不需要繼續執行，可能會不穩定的狀態中的風險。&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>To inform the host that your code is entering a critical region, call BeginCriticalRegion.</source>
          <target state="translated">若要通知您的程式碼正在進入關鍵區域的主機，呼叫 BeginCriticalRegion。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Call &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt; when execution returns to a non-critical region of code.</source>
          <target state="translated">呼叫&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;當執行會傳回非關鍵的程式碼區域。&lt;/xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">通知主機 managed 程式碼即將執行指令，取決於目前實體作業系統執行緒的識別。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供它們自己的執行緒管理。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">提供它自己的執行緒管理的主機執行的工作從一個實體作業系統執行緒之間移動在任何時間。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">大部分的工作不會受到這個切換。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">不過，某些工作執行緒相似性，也就是相依實體作業系統執行緒的識別。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">這些工作必須通知主應用程式時執行程式碼，不會切換。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call BeginThreadAffinity before acquiring the lock, and &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt; after releasing the lock.</source>
          <target state="translated">比方說，如果您的應用程式呼叫系統 API 來取得作業系統鎖定具有執行緒相似性，例如 Win32 CRITICAL_SECTION，您必須呼叫 BeginThreadAffinity 之前取得鎖定，以及&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;之後釋放鎖定。&lt;/xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼叫端沒有必要的權限。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">取得目前執行緒正在執行的內容。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current thread context.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>代表目前的執行緒內容。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼叫端沒有必要的權限。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">取得或設定目前執行緒的文化特性。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Globalization.CultureInfo&gt; object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">&lt;xref:System.Globalization.CultureInfo&gt;物件，這個屬性，以及其相關聯的物件，就會傳回判斷預設格式的日期、 時間、 數字、 貨幣值，排序順序的文字、 大小寫慣例，以及字串比較。&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>See the &lt;xref:System.Globalization.CultureInfo&gt; class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">請參閱&lt;xref:System.Globalization.CultureInfo&gt;類別若要了解有關的文化特性名稱和識別碼，而異，中性和特定文化特性之間的差異，以及方法的文化特性資訊影響執行緒和應用程式定義域。&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>See the &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt; property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">請參閱&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;屬性若要了解如何決定執行緒的預設文化特性，以及使用者如何設定電腦的文化特性資訊。&lt;/xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, you can set the CurrentCulture property to a neutral culture.</source>
          <target state="translated">開頭為<ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>，您可以將中性文化特性中的 CurrentCulture 屬性。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>This is because the behavior of the &lt;xref:System.Globalization.CultureInfo&gt; class has changed: When it represents a neutral culture, its property values (in particular, the &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, and &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt; properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">這是因為的行為&lt;xref:System.Globalization.CultureInfo&gt;類別已變更︰ 當它代表中性文化特性，其屬性值 (特別是， &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;， &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;， &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;， &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;，和&lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;屬性) 現在反映中性文化特性相關聯的特定文化特性。&lt;/xref:System.Globalization.CultureInfo.TextInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.NumberFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.CompareInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.Calendar%2A&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>In earlier versions of the .NET Framework, the CurrentCulture property threw a &lt;xref:System.NotSupportedException&gt; exception when a neutral culture was assigned.</source>
          <target state="translated">在舊版的.NET Framework 中的 CurrentCulture 屬性擲回&lt;xref:System.NotSupportedException&gt;時中性文化特性已指派的例外狀況。&lt;/xref:System.NotSupportedException&gt;</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">物件，代表目前執行緒的文化特性。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">屬性設定為<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">取得或設定執行緒目前的原則 （適用於角色型安全性）。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Security.Principal.IPrincipal&gt; value representing the security context.</source>
          <target state="translated">&lt;xref:System.Security.Principal.IPrincipal&gt;值，代表安全性內容。&lt;/xref:System.Security.Principal.IPrincipal&gt;</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">呼叫端沒有必要使用權限設定主體。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Gets the currently running thread.</source>
          <target state="translated">取得目前執行的執行緒。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is the representation of the currently running thread.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>也就是在目前執行之執行緒的表示法。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">取得或設定資源管理員用來在執行階段查詢特定文化特性資源的目前文化特性。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>An object that represents the current culture.</source>
          <target state="translated">物件，代表目前的文化特性。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">屬性設定為<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">屬性設定為無法用來尋找資源檔的文化特性名稱。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">資源檔名稱必須包含字母、 數字、 連字號或底線。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">關閉自動清除之執行階段可呼叫包裝函式 (RCW) 目前的執行緒。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">根據預設，common language runtime (CLR) 會清除執行階段可呼叫包裝函式自動。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:      -   The application does its own message pumping.</source>
          <target state="translated">CLR 激發訊息期間清除作業，可能會造成一些符合下列準則不尋常的應用程式的重新進入問題:-應用程式會自己訊息幫浦作業。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>-   The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">-應用程式需要訊息幫浦作業發生時，精確地控制。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Such applications can use the DisableComObjectEagerCleanup method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">這類應用程式可用來防止 CLR 執行的執行階段可呼叫包裝函式自動回收 DisableComObjectEagerCleanup 方法。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">如果在執行緒上呼叫此方法，就無法重新啟用該執行緒自動清除。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>When your application is ready to clean up runtime callable wrappers, use the &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt; method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">您的應用程式準備好要清除執行階段可呼叫包裝函式時，請使用&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;方法，以指示清除所有執行階段可呼叫包裝函式在目前內容中執行階段。&lt;/xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">當方法執行時，就會發生訊息幫浦作業。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">通知主機在即將執行的程式碼中的執行緒中止或未處理例外狀況的影響限於目前的工作區域。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">在其中執行緒中止或未處理的例外狀況的影響可能不是目前的工作是關鍵區域。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">相反地，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">例如，假設有嘗試配置記憶體時保留鎖定工作。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性&lt;xref:System.AppDomain&gt;，因為在等候相同的鎖定網域中可以有其他工作。&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">如果目前的工作已中止，其他工作可能發生死結。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">發生失敗時的關鍵區域中，主機可能會決定卸載整個&lt;xref:System.AppDomain&gt;而不需要繼續執行，可能會不穩定的狀態中的風險。&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>To inform the host that your code is entering a critical region, call &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.</source>
          <target state="translated">若要通知主機程式碼會進入重大的區域，呼叫&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.&lt;/xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Call EndCriticalRegion when execution returns to a non-critical region of code.</source>
          <target state="translated">當執行會傳回非關鍵的程式碼區域，請呼叫 EndCriticalRegion。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">通知主機 managed 程式碼已完成執行這些指令相依於目前實體作業系統執行緒的識別。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供它們自己的執行緒管理。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">提供它自己的執行緒管理的主機執行的工作從一個實體作業系統執行緒之間移動在任何時間。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">大部分的工作不會受到這個切換。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">不過，某些工作執行緒相似性，也就是相依實體作業系統執行緒的識別。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">這些工作必須通知主應用程式時執行程式碼，不會切換。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt; before acquiring the lock, and EndThreadAffinity after releasing the lock.</source>
          <target state="translated">例如，如果您的應用程式呼叫系統 API，以取得作業系統鎖定具有執行緒相似性，例如 Win32 CRITICAL_SECTION，您必須呼叫&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;之前取得的鎖定和 EndThreadAffinity 之後釋放鎖定。&lt;/xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">呼叫端沒有必要的權限。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Gets an &lt;xref:System.Threading.ExecutionContext&gt; object that contains information about the various contexts of the current thread.</source>
          <target state="translated">取得&lt;xref:System.Threading.ExecutionContext&gt;物件，其中包含目前執行緒各種內容的相關資訊。&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Threading.ExecutionContext&gt; class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">&lt;xref:System.Threading.ExecutionContext&gt;類別會提供所有的相關資訊的邏輯執行緒執行的單一容器。&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">這包括安全性內容中，呼叫內容、 同步處理內容、 當地語系化內容和交易內容。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Threading.ExecutionContext&gt; object that consolidates context information for the current thread.</source>
          <target state="translated">&lt;xref:System.Threading.ExecutionContext&gt;物件，合併目前執行緒的內容資訊。&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">確認釋出資源，並在記憶體回收行程回收時執行其他清除作業<bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>物件。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>The garbage collector calls Finalize when the current object is ready to be finalized.</source>
          <target state="translated">記憶體回收行程呼叫 Finalize 準備最終處理而目前的物件時。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">排除的名稱和位置，在程序中的所有執行緒之間的關聯。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">為提升效能，使用與標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性，屬性。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性) 和資料位置。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需有關如何使用 TLS 的詳細資訊，請參閱<bpt id="p1">[</bpt>執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">任何執行緒呼叫之後<ph id="ph1">`FreeNamedDataSlot`</ph>，呼叫的其他任何執行緒&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;相同的名稱就會配置新的位置與名稱相關聯。&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">後續呼叫<ph id="ph1">`GetNamedDataSlot`</ph>任何執行緒會傳回新的位置。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>However, any thread that still has a &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt; returned by an earlier call to <ph id="ph1">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">不過，任何執行緒，仍有&lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;先前呼叫所傳回的<ph id="ph1">`GetNamedDataSlot`</ph>可以繼續使用舊的位置。&lt;/xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">釋放與名稱關聯的位置時，才每<ph id="ph1">`LocalDataStoreSlot`</ph>之前呼叫取得<ph id="ph2">`FreeNamedDataSlot`</ph>已釋放及回收。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">資料位置是每個執行緒的唯一的。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">要釋放之資料插槽的名稱。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value indicating the apartment state.</source>
          <target state="translated">傳回<bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>表示 apartment 狀態的值。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>This method, along with the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">這個方法中，連同&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;方法和&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;方法，會取代&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;屬性。&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the apartment state of the managed thread.</source>
          <target state="translated">其中一個<bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>值，指出 managed 執行緒的 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">預設值是<bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">傳回<bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>可以用於擷取目前執行緒的堆疊物件。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>This method is no longer supported.</source>
          <target state="translated">不再支援這個方法。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">無。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">在所有情況下。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">擷取從目前執行緒上、 目前執行緒的目前網域內的指定位置的值。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">為提升效能，使用與標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性，屬性。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性) 和資料位置。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需有關如何使用 TLS 的詳細資訊，請參閱<bpt id="p1">[</bpt>執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">資料位置是每個執行緒的唯一的。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  GetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; GetData 是<ph id="ph2">`Shared`</ph>一律適用於目前執行中執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">為了避免混淆，類別名稱呼叫時，使用<ph id="ph1">`Shared`</ph>方法︰ <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to get the value.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>要從中取得的值。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The retrieved value.</source>
          <target state="translated">擷取的數值。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">傳回目前執行緒正在其中執行的目前定義域。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current application domain of the running thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>代表執行中的執行緒目前的應用程式定義域。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">傳回唯一的應用程式定義域識別項。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">32 位元帶正負號的整數，用來唯一識別應用程式定義域。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">傳回目前執行緒的雜湊碼。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">不保證是唯一的雜湊碼。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Use the &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property if you need a unique identifier for a managed thread.</source>
          <target state="translated">使用&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;屬性，如果您需要 managed 執行緒的唯一識別碼。&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>An integer hash code value.</source>
          <target state="translated">整數雜湊碼值。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Looks up a named data slot.</source>
          <target state="translated">尋找具名的資料位置。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">為提升效能，使用與標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性，屬性。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性) 和資料位置。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需有關如何使用 TLS 的詳細資訊，請參閱<bpt id="p1">[</bpt>執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">資料位置是每個執行緒的唯一的。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">如果具名的位置不存在，則會配置新的位置。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">具名的資料位置是公用的任何人都可以管理。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The name of the local data slot.</source>
          <target state="translated">本機資料位置的名稱。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> allocated for this thread.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>這個執行緒配置。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Interrupts a thread that is in the <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> thread state.</source>
          <target state="translated">中斷處於執行緒<bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>執行緒狀態。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">如果這個執行緒目前未遭到封鎖在等候、 睡眠或聯結狀態，它將會中斷接下來開始封鎖時。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ThreadInterruptedException&gt; is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadInterruptedException&gt;在中斷之執行緒，但直到則執行緒會封鎖，就會擲回。&lt;/xref:System.Threading.ThreadInterruptedException&gt;</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">如果執行緒永不封鎖，永遠不會擲回例外狀況，並因此執行緒可能會完成，而任何中斷。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">呼叫端沒有適當<bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">取得值，指出目前執行緒的執行狀態。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread has been started and has not terminated normally or aborted; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果這個執行緒已經啟動但還沒有正常終止或中止。否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">取得或設定值，指出執行緒背景執行緒。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">執行緒是背景執行緒或前景執行緒。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">背景執行緒就前景執行緒相同，不同之處在於背景執行緒不會防止處理序終止。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">一旦處理程序所屬的所有前景執行緒已經都終止，common language runtime 會結束處理程序。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">任何剩餘的背景執行緒已停止，並不會完成。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>By default, the following threads execute in the foreground (that is, their IsBackground property returns <ph id="ph1">`false`</ph>):      -   The primary thread (or main application thread).</source>
          <target state="translated">依預設，下列執行緒則是在前景執行 (也就是其 IsBackground 屬性會傳回<ph id="ph1">`false`</ph>):-主執行緒 （或主應用程式執行緒）。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>-   All threads created by calling a &lt;xref:System.Threading.Thread&gt; class constructor.</source>
          <target state="translated">的藉由呼叫建立所有執行緒&lt;xref:System.Threading.Thread&gt;類別建構函式。&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>By default, the following threads execute in the background  (that is, their IsBackground property returns <ph id="ph1">`true`</ph>):      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">依預設，下列執行緒則是在背景中執行 (也就是其 IsBackground 屬性會傳回<ph id="ph1">`true`</ph>):-執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">您可以在執行緒集區執行緒上設定執行緒集區和排程工作，使用&lt;xref:System.Threading.ThreadPool&gt;類別。&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在執行緒集區執行緒上自動執行工作為基礎的非同步作業。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-所有執行緒從 unmanaged 程式碼進入 managed 的執行環境。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread is or is to become a background thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果這個執行緒是的或者會成為背景執行緒，否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The thread is dead.</source>
          <target state="translated">執行緒已無作用。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">取得值，指出屬於 managed 的執行緒集區的執行緒。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>Managed 執行緒集區<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread belongs to the managed thread pool; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果這個執行緒屬於 managed 的執行緒集區中。否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> pumping.</source>
          <target state="translated">封鎖呼叫執行緒，直到這個執行個體所表示的執行緒結束，但仍繼續執行標準的 COM 和<bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>幫浦作業。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose Join method is called has completed.</source>
          <target state="translated">聯結是同步處理方法會封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到完成呼叫方法的聯結執行緒。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">使用這個方法，以確保執行緒已終止。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">如果執行緒不會終止，將會無限期地封鎖呼叫端。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the Join method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block until <ph id="ph4">`Thread2`</ph> has completed.</source>
          <target state="translated">在下列範例中，<ph id="ph1">`Thread1`</ph>執行緒呼叫的聯結方法<ph id="ph2">`Thread2`</ph>，這會導致<ph id="ph3">`Thread1`</ph>區塊，直到<ph id="ph4">`Thread2`</ph>已完成。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept><ept id="p3">]</ept>       If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept> <ept id="p3">]</ept>如果執行緒已經終止時有&lt;xref:System.Threading.Thread.Join%2A&gt;呼叫時，此方法會立即傳回。&lt;/xref:System.Threading.Thread.Join%2A&gt;  </target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!WARNING]</ph> &gt;  You should never call the Join method of the &lt;xref:System.Threading.Thread&gt; object that represents the current thread from the current thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!WARNING]</ph> &gt; 您應該永遠不會呼叫的聯結方法&lt;xref:System.Threading.Thread&gt;物件，代表目前執行緒從目前的執行緒。&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,       This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">這會導致您的應用程式停止回應，因為目前的執行緒本身會永遠等候，這個方法會變更来包含&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;呼叫執行緒的狀態</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">無法叫用<ph id="ph1">`Join`</ph>中的執行緒上&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;狀態。&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">呼叫端嘗試聯結處於執行緒<bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>狀態。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">執行緒在等待時中斷。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">封鎖呼叫執行緒，直到此執行個體所表示的執行緒終止為止或指定的時間超過，但仍繼續執行標準的 COM 與 SendMessage 幫浦作業。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">聯結會封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的&lt;xref:System.Threading.Thread.Join%2A&gt;方法呼叫已完成或經過逾時間隔。&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">在下列範例中，<ph id="ph1">`Thread1`</ph>執行緒呼叫&lt;xref:System.Threading.Thread.Join&gt;方法<ph id="ph2">`Thread2`</ph>，這會導致<ph id="ph3">`Thread1`</ph>封鎖直到 <ph id="ph4">`Thread2`</ph>已完成或經過 2 秒。&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for the <ph id="ph1">`millisecondsTimeout`</ph> parameter, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept> <ept id="p3">]</ept>如果&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;指定<ph id="ph1">`millisecondsTimeout`</ph>參數，此方法的行為即會相同與&lt;xref:System.Threading.Thread.Join&gt;方法多載，除了傳回的值。&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">如果執行緒已經終止時有&lt;xref:System.Threading.Thread.Join%2A&gt;呼叫時，此方法會立即傳回。&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">這個方法會變更要包含&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;呼叫執行緒的狀態</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">無法叫用<ph id="ph1">`Join`</ph>中的執行緒上&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;狀態。&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">等候執行緒終止的毫秒數。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread has terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果執行緒已經終止;<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>執行緒還沒有終止指定的時間量之後<bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p3">&lt;/code&gt;</ept>參數。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds.</source>
          <target state="translated">值<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p1">&lt;/code&gt;</ept>為負數且不等於<ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>以毫秒為單位。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The thread has not been started.</source>
          <target state="translated">無法啟動執行緒。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">封鎖呼叫執行緒，直到此執行個體所表示的執行緒終止為止或指定的時間超過，但仍繼續執行標準的 COM 與 SendMessage 幫浦作業。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">聯結會封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的&lt;xref:System.Threading.Thread.Join%2A&gt;方法呼叫已完成或經過逾時間隔。&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">在下列範例中，<ph id="ph1">`Thread1`</ph>執行緒呼叫&lt;xref:System.Threading.Thread.Join&gt;方法<ph id="ph2">`Thread2`</ph>，這會導致<ph id="ph3">`Thread1`</ph>封鎖直到 <ph id="ph4">`Thread2`</ph>已完成或經過 2 秒。&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for <ph id="ph1">`timeout`</ph>, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept> <ept id="p3">]</ept>如果&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;指定<ph id="ph1">`timeout`</ph>，此方法的行為即會相同與&lt;xref:System.Threading.Thread.Join&gt;方法多載，除了傳回的值。&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">如果執行緒已經終止時有&lt;xref:System.Threading.Thread.Join%2A&gt;呼叫時，此方法會立即傳回。&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>This method changes the state of the current thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">這個方法會變更目前的執行緒可包括&lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;的狀態</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">無法叫用<ph id="ph1">`Join`</ph>中的執行緒上&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;狀態。&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated">A&lt;xref:System.TimeSpan&gt;設等候執行緒終止的時間量。&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果執行緒終止;<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>執行緒還沒有終止指定的時間量之後<bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p3">&lt;/code&gt;</ept>參數。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">值<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept>為負數且不等於<ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>以毫秒為單位，或大於<ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph>毫秒為單位。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">呼叫端嘗試聯結處於執行緒<bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>狀態。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">取得目前 managed 執行緒的唯一識別碼。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>A thread's ManagedThreadId property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">執行緒的 ManagedThreadId 屬性值是用來唯一識別其處理程序中的執行緒。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>The value of the ManagedThreadId property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">ManagedThreadId 屬性的值不會變化經過一段時間，即使裝載 common language runtime 的 unmanaged 程式碼實作在 fiber 的執行緒。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">整數，表示這個 managed 執行緒的唯一識別碼。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</source>
          <target state="translated">同步處理記憶體存取，如下所示︰ 執行目前執行緒的處理器無法重新排列指示，例如後呼叫 MemoryBarrier 記憶體存取之後執行之前呼叫 MemoryBarrier 記憶體存取的方式。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>MemoryBarrier is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated">只在多處理器系統上需要 MemoryBarrier 弱式排序 （例如，採用多個將 Intel Itanium 處理器的系統） 的記憶體。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the &lt;xref:System.Threading.Monitor&gt; class provide easier ways to synchronize data.</source>
          <target state="translated">大部分的用途而言，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，或&lt;xref:System.Threading.Monitor&gt;類別提供簡單的方式同步處理資料。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">取得或設定執行緒的名稱。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>This property is write-once.</source>
          <target state="translated">這個屬性是寫入-之後。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>Because the default value of a thread's Name property is <ph id="ph1">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph2">`null`</ph>.</source>
          <target state="translated">因為執行緒的名稱屬性的預設值是<ph id="ph1">`null`</ph>，您可以判斷是否已明確指派名稱給執行緒藉由比較它與<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>The string assigned to the Name property can include any Unicode character.</source>
          <target state="translated">指派給名稱屬性的字串可以包含任何 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>A string containing the name of the thread, or <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if no name was set.</source>
          <target state="translated">字串，包含執行緒的名稱或<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果沒有設定名稱。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>A set operation was requested, but the <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> property has already been set.</source>
          <target state="translated">已要求一組作業，但<bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>屬性已設定。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">取得或設定值，指出執行緒的排程優先權。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>A thread can be assigned any one of the following priority &lt;xref:System.Threading.ThreadPriority&gt; values:      -   <ph id="ph1">`Highest`</ph><ph id="ph2">      -   </ph><ph id="ph3">`AboveNormal`</ph><ph id="ph4">      -   </ph><ph id="ph5">`Normal`</ph><ph id="ph6">      -   </ph><ph id="ph7">`BelowNormal`</ph><ph id="ph8">      -   </ph><ph id="ph9">`Lowest`</ph>       Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">下列優先順序的任何一個可以指派一個執行緒&lt;xref:System.Threading.ThreadPriority&gt;值:- <ph id="ph1">`Highest`</ph> <ph id="ph2">      -   </ph> <ph id="ph3">`AboveNormal`</ph> <ph id="ph4">      -   </ph> <ph id="ph5">`Normal`</ph> <ph id="ph6">      -   </ph> <ph id="ph7">`BelowNormal`</ph> <ph id="ph8">      -   </ph> <ph id="ph9">`Lowest`</ph>作業系統不需要接受執行緒的優先權。&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">其中一個<bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>值。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">預設值是<bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The thread has reached a final state, such as <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">此執行緒已達到最終狀態，例如<bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is not a valid <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">指定給 set 作業不是有效的值<bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>值。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Cancels an &lt;xref:System.Threading.Thread.Abort*&gt; requested for the current thread.</source>
          <target state="translated">取消&lt;xref:System.Threading.Thread.Abort*&gt;目前執行緒要求。&lt;/xref:System.Threading.Thread.Abort*&gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">只使用適當的權限的程式碼可以呼叫這個方法。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt;.</source>
          <target state="translated">進行呼叫以<ph id="ph1">`Abort`</ph>來終止執行緒，系統會擲回&lt;xref:System.Threading.ThreadAbortException&gt;.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>是特殊的例外狀況，應用程式程式碼可以攔截但重新擲回的 catch 區塊的結尾除非<ph id="ph2">`ResetAbort`</ph>呼叫。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>取消要求中止，並防止<ph id="ph2">`ThreadAbortException`</ph>終止執行緒。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>See &lt;xref:System.Threading.ThreadAbortException&gt; for an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method.</source>
          <target state="translated">請參閱&lt;xref:System.Threading.ThreadAbortException&gt;的範例，示範如何呼叫<ph id="ph1">`ResetAbort`</ph>方法。&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> was not invoked on the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>不在目前的執行緒上叫用。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">呼叫端沒有必要的安全性權限目前的執行緒。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">繼續已暫止的執行緒。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">執行緒未啟動、 已無作用，或不是處於暫停狀態。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">呼叫端沒有適當<bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">它會啟動之前，請設定執行緒的 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">新的執行緒都會初始化成&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;如果其 apartment 狀態尚未設定之前啟動。&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">在執行緒啟動之前，必須設定 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 主應用程式執行緒會初始化為&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;預設。&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">若要設定主應用程式執行緒的 apartment 狀態的唯一方式&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;是套用&lt;xref:System.STAThreadAttribute&gt;屬性設定為進入點方法。&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>The SetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">SetApartmentState 方法中，連同&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;方法和&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;方法，會取代&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;屬性。&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">新的 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>不是有效的 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">已啟動執行緒。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">Apartment 狀態已經初始化。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Applies a captured <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the current thread.</source>
          <target state="translated">適用於擷取<bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>到目前的執行緒。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>This method is no longer supported.</source>
          <target state="translated">不再支援這個方法。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to be applied to the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>来套用至目前執行緒的物件。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">在所有情況下。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">目前執行的執行緒，該執行緒的目前網域的指定位置中設定資料。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>For better performance, use fields marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">以提升效能、 使用以標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性，屬性。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位&lt;xref:System.ThreadStaticAttribute&gt;屬性) 和資料位置。&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需有關如何使用 TLS 的詳細資訊，請參閱<bpt id="p1">[</bpt>執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the &lt;xref:System.Threading.Thread&gt; object has been reclaimed by garbage collection.</source>
          <target state="translated">執行緒用來配置資料存放區中的資料位置，儲存和擷取資料值插槽中並在執行緒程序結束之後釋放重複使用的位置和&lt;xref:System.Threading.Thread&gt;已經由記憶體回收回收物件。&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Data slots are unique per thread.</source>
          <target state="translated">資料位置是每個執行緒的唯一的。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  SetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; SetData 是<ph id="ph2">`Shared`</ph>一律適用於目前執行中執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">為了避免混淆，類別名稱呼叫時，使用<ph id="ph1">`Shared`</ph>方法︰ <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in which to set the value.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>要設定的值。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The value to be set.</source>
          <target state="translated">要設定的值。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">暫止指定的毫秒數目前的執行緒。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">執行緒不會執行由作業系統在指定的時間排程。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">這個方法會變更要包含&lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;執行緒的狀態</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>You can specify &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; for the <ph id="ph1">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">您可以指定&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;如<ph id="ph1">`millisecondsTimeout`</ph>無限期地暫止執行緒的參數。&lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">不過，我們建議您使用其他&lt;xref:System.Threading?displayProperty=fullName&gt;之類的類別&lt;xref:System.Threading.Mutex&gt;， &lt;xref:System.Threading.Monitor&gt;， &lt;xref:System.Threading.EventWaitHandle&gt;，或&lt;xref:System.Threading.Semaphore&gt;改為還執行緒或管理資源。&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">在特定速率的系統時鐘刻度呼叫時鐘的解析度。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">實際逾時可能不完全指定的逾時，因為指定的逾時將會調整，讓時鐘刻度一致。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">如需有關時鐘的解析度和等候時間的詳細資訊，請參閱<bpt id="p1">[</bpt>睡眠函式<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept>主題。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">這個方法會呼叫<bpt id="p1">[</bpt>睡眠函式<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept>Windows 系統應用程式開發介面。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 如果您需要進入睡眠狀態已在執行緒上&lt;xref:System.STAThreadAttribute&gt;，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載的&lt;xref:System.Threading.Thread.Join%2A&gt;方法所指定的逾時間隔。&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">執行緒暫止的毫秒數。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">如果值<ph id="ph1">`millisecondsTimeout`</ph>引數是&amp;0;，執行緒會佔用剩餘的任何準備好要執行的同等優先權執行緒的時間配量。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">如果有任何其他的同等優先權執行緒，準備好要執行，則目前執行緒的執行不會暫停。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The time-out value is negative and is not equal to &lt;xref:System.Threading.Timeout.Infinite&gt;.</source>
          <target state="translated">逾時值為負數且不等於&lt;xref:System.Threading.Timeout.Infinite&gt;.&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">指定的時間量內暫止目前的執行緒。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">執行緒不會執行由作業系統在指定的時間排程。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">這個方法會變更要包含&lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;執行緒的狀態</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>You can specify &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt; for the <ph id="ph1">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">您可以指定&lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;如<ph id="ph1">`timeout`</ph>無限期地暫止執行緒的參數。&lt;/xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">不過，我們建議您使用其他&lt;xref:System.Threading?displayProperty=fullName&gt;之類的類別&lt;xref:System.Threading.Mutex&gt;， &lt;xref:System.Threading.Monitor&gt;， &lt;xref:System.Threading.EventWaitHandle&gt;，或&lt;xref:System.Threading.Semaphore&gt;改為還執行緒或管理資源。&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>This overload of &lt;xref:System.Threading.Thread.Sleep%2A&gt; uses the total number of whole milliseconds in <ph id="ph1">`timeout`</ph>.</source>
          <target state="translated">這個多載&lt;xref:System.Threading.Thread.Sleep%2A&gt;使用中的整數毫秒總數<ph id="ph1">`timeout`</ph>。&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">小數的毫秒都會被捨棄。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 如果您需要進入睡眠狀態已在執行緒上&lt;xref:System.STAThreadAttribute&gt;，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載的&lt;xref:System.Threading.Thread.Join%2A&gt;方法所指定的逾時間隔。&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">執行緒暫止的時間量。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">如果值<ph id="ph1">`millisecondsTimeout`</ph>引數是<ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>，執行緒會佔用剩餘的任何準備好要執行的同等優先權執行緒的時間配量。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">如果有任何其他的同等優先權執行緒，準備好要執行，則目前執行緒的執行不會暫停。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">值<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept>為負數且不等於<ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>以毫秒為單位，或大於<ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph>毫秒為單位。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Causes a thread to wait the number of times defined by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">iterations</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">造成等候的次數所定義的執行緒<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">iterations</ph> <ept id="p1">&lt;/code&gt;</ept>參數。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The SpinWait method is useful for implementing locks.</source>
          <target state="translated">SpinWait 方法可用於實作鎖定。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>Classes in the .NET Framework, such as &lt;xref:System.Threading.Monitor&gt; and &lt;xref:System.Threading.ReaderWriterLock&gt;, use this method internally.</source>
          <target state="translated">類別在.NET Framework 中，例如&lt;xref:System.Threading.Monitor&gt;和&lt;xref:System.Threading.ReaderWriterLock&gt;，這個方法會在內部使用。&lt;/xref:System.Threading.ReaderWriterLock&gt; &lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>SpinWait essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph1">`iterations`</ph> parameter.</source>
          <target state="translated">SpinWait 基本上放處理器非常緊密迴圈中，與所指定的迴圈計數<ph id="ph1">`iterations`</ph>參數。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">等候的持續時間因此取決於處理器的速度。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Contrast this with the &lt;xref:System.Threading.Thread.Sleep%2A&gt; method.</source>
          <target state="translated">與&lt;xref:System.Threading.Thread.Sleep%2A&gt;方法。&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>A thread that calls &lt;xref:System.Threading.Thread.Sleep%2A&gt; yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">呼叫的執行緒&lt;xref:System.Threading.Thread.Sleep%2A&gt;會產生其目前的配量的處理器時間的其餘部分，即使指定的時間間隔為零。&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Specifying a non-zero interval for &lt;xref:System.Threading.Thread.Sleep%2A&gt; removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">指定非零間隔&lt;xref:System.Threading.Thread.Sleep%2A&gt;經過的時間間隔之前，由執行緒排程器將不考慮移除執行緒。&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>SpinWait is not generally useful for ordinary applications.</source>
          <target state="translated">SpinWait 不通常適用於一般的應用程式。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; or a statement that wraps &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; (<ph id="ph1">`lock`</ph> in C# or <ph id="ph2">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">在大部分情況下，您應該使用.NET Framework; 所提供的同步處理類別例如，呼叫&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;或陳述式包裝&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;(<ph id="ph1">`lock`</ph>在 C# 或<ph id="ph2">`SyncLock`</ph>在 Visual Basic 中)。&lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; &lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the SpinWait method in your loop.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 的少數情況下，其中的好處是，若要避免將內容切換，例如當您知道狀態變更已即將發生，請 SpinWait 方法的呼叫在迴圈中。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>The code SpinWait executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">SpinWait 執行的程式碼被為了防止具有多個處理器的電腦上可能發生的問題。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, SpinWait prevents processor starvation in certain situations.</source>
          <target state="translated">比方說，在電腦上具有多個採用超執行緒技術的 Intel 處理器，SpinWait 可防止在某些情況下的處理器資源用盡。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">32 位元帶正負號的整數，定義執行緒的時間等候。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">造成作業系統將目前的執行個體的狀態變更為<bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">一旦執行緒處於&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;狀態時，系統可以將它排程執行。&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">在執行緒開始執行所表示之方法的第一行&lt;xref:System.Threading.ThreadStart&gt;或&lt;xref:System.Threading.ParameterizedThreadStart&gt;委派提供給執行緒的建構函式。&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">請注意，開始呼叫不會封鎖呼叫執行緒。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If this overload is used with a thread created using a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 這個多載會搭配使用所建立的執行緒&lt;xref:System.Threading.ParameterizedThreadStart&gt;委派，<ph id="ph2">`null`</ph>傳遞至由執行緒執行的方法。&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">一旦在執行緒結束，無法將它重新啟動與另一個呼叫<ph id="ph1">`Start`</ph>。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">已啟動執行緒。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">沒有足夠的記憶體可用來啟動這個執行緒。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">造成作業系統將目前的執行個體的狀態變更為<bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>，並選擇性地提供物件，其中包含要由執行緒執行的方法所使用的資料。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">一旦執行緒處於&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;狀態時，系統可以將它排程執行。&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">在執行緒開始執行所表示之方法的第一行&lt;xref:System.Threading.ThreadStart&gt;或&lt;xref:System.Threading.ParameterizedThreadStart&gt;委派提供給執行緒的建構函式。&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">請注意，開始呼叫不會封鎖呼叫執行緒。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">一旦在執行緒結束，無法將它重新啟動與另一個呼叫<ph id="ph1">`Start`</ph>。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>This overload and the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">這個多載而&lt;xref:System.Threading.ParameterizedThreadStart&gt;委派即可輕易地將資料傳遞給執行緒的程序，但方法不是類型安全因為任何物件可以傳遞給這個多載。&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">將執行緒的程序與資料欄位放入背景工作物件是更穩固的方式，將資料傳遞給執行緒的程序。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>建立執行緒和開始時間傳遞資料<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">物件，其中包含資料的方法所使用的執行緒執行。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">已啟動執行緒。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">沒有足夠的記憶體可用來啟動這個執行緒。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>This thread was created using a <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate instead of a <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> delegate.</source>
          <target state="translated">這個執行緒使用建立<bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>而不是委派<bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>委派。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">暫止的執行緒，或者如果執行緒已經暫止，則沒有影響。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">如果執行緒已經暫止，這個方法沒有任何作用。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Do not use the Suspend and &lt;xref:System.Threading.Thread.Resume%2A&gt; methods to synchronize the activities of threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 不使用暫停並&lt;xref:System.Threading.Thread.Resume%2A&gt;方法來同步處理執行緒活動。&lt;/xref:System.Threading.Thread.Resume%2A&gt;</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">您有無從得知哪些程式碼的執行緒正在執行，當您暫停它。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the &lt;xref:System.AppDomain&gt; might be blocked.</source>
          <target state="translated">如果您暫停執行緒，而安全性權限評估期間保留鎖定，其他執行緒中&lt;xref:System.AppDomain&gt;可能封鎖。&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the &lt;xref:System.AppDomain&gt; that attempt to use that class are blocked.</source>
          <target state="translated">如果類別建構函式執行時，您可以暫停執行緒，其他執行緒中&lt;xref:System.AppDomain&gt;，嘗試使用封鎖的類別。&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">很容易發生死結。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">執行緒未啟動，或已無作用。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">呼叫端沒有適當<bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">將一組名稱對應至一組對應的分派識別項。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">如需有關<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>，請參閱 MSDN Library。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">保留供將來使用。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">必須是 IID_NULL。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">傳入的對應名稱的陣列。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
          <target state="translated">要對應的名稱計數。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">地區設定內容，用於解譯名稱。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">呼叫端配置的陣列，用於接收對應於名稱的 Id。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">使用 COM 的晚期繫結存取<ph id="ph1">`IDispatch`</ph>不支援的介面。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">擷取的類型資訊物件，然後可以用來取得介面的型別資訊。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">如需有關<ph id="ph1">`IDispatch::GetTypeInfo`</ph>，請參閱 MSDN Library。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
          <target state="translated">要傳回的類型資訊。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
          <target state="translated">型別資訊的地區設定識別項。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">接收到要求的類型資訊物件的指標。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">使用 COM 的晚期繫結存取<ph id="ph1">`IDispatch`</ph>不支援的介面。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">擷取物件提供 （0 或 1） 的類型資訊介面數目。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">如需有關<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>，請參閱 MSDN Library。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">指向接收物件提供的類型資訊介面數目的位置。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">使用 COM 的晚期繫結存取<ph id="ph1">`IDispatch`</ph>不支援的介面。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">提供屬性和物件所公開的方法存取權。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">如需有關<ph id="ph1">`IDispatch::Invoke`</ph>，請參閱 MSDN Library。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
          <target state="translated">辨識成員。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">保留供將來使用。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">必須是 IID_NULL。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">地區設定內容，用於解譯引數。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
          <target state="translated">描述呼叫之內容的旗標。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">此結構包含引數陣列，為具名引數，以及陣列中的項目數目的計數的引數 Dispid 陣列指標。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">儲存結果之位置的指標。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">包含例外狀況資訊的結構指標。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">發生錯誤的第一個引數索引。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">使用 COM 的晚期繫結存取<ph id="ph1">`IDispatch`</ph>不支援的介面。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">取得值，其中包含目前執行緒的狀態。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>The ThreadState property provides more specific information than the &lt;xref:System.Threading.Thread.IsAlive%2A&gt; property.</source>
          <target state="translated">ThreadState 屬性提供更具體的資訊比&lt;xref:System.Threading.Thread.IsAlive%2A&gt;屬性。&lt;/xref:System.Threading.Thread.IsAlive%2A&gt;</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 執行緒狀態只有時才想要偵錯案例。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">您的程式碼永遠不應該使用執行緒狀態來同步處理執行緒活動。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the state of the current thread.</source>
          <target state="translated">其中一個<bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>值，表示目前執行緒的狀態。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">初始值是<bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">它會啟動之前，請設定執行緒的 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">新的執行緒都會初始化成&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;如果其 apartment 狀態尚未設定之前啟動。&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">在執行緒啟動之前，必須設定 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 主應用程式執行緒會初始化為&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;預設。&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">若要設定主應用程式執行緒的 apartment 狀態的唯一方式&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;是套用&lt;xref:System.STAThreadAttribute&gt;屬性設定為進入點方法。&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>The TrySetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">TrySetApartmentState 方法中，連同&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;方法和&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;方法，會取代&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;屬性。&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">新的 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the apartment state is set; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果已設定 apartment 狀態。否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>不是有效的 apartment 狀態。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">已啟動執行緒。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">VolatileRead 和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, VolatileRead obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，VolatileRead 會取得由任意處理器寫入記憶體位置的最新值。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">甚至單一處理器的系統上，VolatileRead 和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用 VolatileRead 或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用 VolatileRead 或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">讀取欄位值。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;取得最新的值由任意處理器寫入記憶體位置。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">要讀取的欄位。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">由任意處理器寫入欄位的最新值。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;而且 VolatileWrite 的同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, VolatileWrite ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，VolatileWrite 可確保寫入記憶體位置的值就會立即顯示所有處理器。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和 VolatileWrite 確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">若要提供有效欄位的同步處理，必須使用欄位的所有存取&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或 VolatileWrite。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位會都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或 VolatileWrite。&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">將值寫入欄位，以便都可以看到電腦中的所有處理器的值。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;會同步處理的特殊案例。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">在一般情況下，C#<ph id="ph1">`lock`</ph>陳述式，Visual Basic<ph id="ph2">`SyncLock`</ph>陳述式，而&lt;xref:System.Threading.Monitor&gt;類別提供您更輕鬆的替代項目。&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">在多處理器系統上，&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;可確保寫入記憶體位置的值就會立即顯示所有處理器。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>This might require flushing processor caches.</source>
          <target state="translated">這可能需要清除處理器快取。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">在單一處理器系統上，甚至&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;和&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">呼叫這個方法只會影響單一記憶體存取。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">若要提供有效的同步處理欄位，欄位的所有存取必須都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 在 C# 中，使用<ph id="ph2">`volatile`</ph>欄位修飾詞可確保所有存取該欄位都使用&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;或&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">要寫入的值欄位。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">要寫入的值。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">造成呼叫執行緒執行的準備好要執行目前處理器上的另一個執行緒。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">作業系統會選擇要到執行的執行緒。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">如果此方法成功，會產生其他執行緒的目前時間配量。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">作業系統排程呼叫執行緒的另一個時間配量，根據其優先順序和可執行其他執行緒的狀態。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">產生僅限於用來執行呼叫執行緒的處理器。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">作業系統不會切換執行為另一個處理器，即使該處理器處於閒置狀態，或正在執行較低優先權的執行緒。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果沒有其他準備好要執行目前處理器上的執行緒、 作業系統並不會執行，產生和這個方法會傳回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">這個方法相當於使用平台叫用呼叫原生 Win32<ph id="ph1">`SwitchToThread`</ph>函式。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>You should call the Yield method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">您應該呼叫方法，而不要使用平台叫用時，結果因為平台叫用略過任何自訂主應用程式已要求的執行緒行為。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the operating system switched execution to another thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果作業系統切換為執行其他執行緒，否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>