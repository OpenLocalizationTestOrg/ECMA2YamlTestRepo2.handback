<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-pt">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7eaeef8182df822d8450ac41fd997baeb1b5ca0a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Security.IStackWalk.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1d82e212664542ea10575b94c8c1a0c20fc534ea</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3847cece6936397f0018f665bdc1dd7b863aea97</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</source>
          <target state="translated">Gere o percurso da pilha que determina se os todos os chamadores na pilha de chamadas têm as permissões necessárias para aceder a um recurso protegido.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Partially trusted code always presents a security risk.</source>
          <target state="translated">Código parcialmente fidedigno sempre apresenta um risco de segurança.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</source>
          <target state="translated">Por vezes, pode ser manipulado para efetuar ações em nome de código malicioso que não tem permissão para aceder a um recurso.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this way, malicious code can achieve higher security access than it should be allowed.</source>
          <target state="translated">Desta forma, o código malicioso pode alcançar mais elevada de segurança de acesso que deve ter permissão.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</source>
          <target state="translated">O language runtime ajuda a proteger código gerido contra estes ataques executando um percurso da pilha em todas as chamadas.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack walk requires that all code in the call stack has permission to access a protected resource.</source>
          <target state="translated">O percurso da pilha requer que todo o código na pilha de chamadas tem permissão para aceder a um recurso protegido.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</source>
          <target state="translated">Porque o código de tentativa de ataque será sempre algures na pilha de chamadas, será possível exceder os seus próprios permissões de segurança.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">Asserções-se de que o código de chamada pode aceder ao recurso identificado pelo objecto actual da permissão, mesmo se os chamadores superiores na pilha não tenham sido concedidos permissão para aceder ao recurso.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling Assert stops the permission check on callers higher in the call stack.</source>
          <target state="translated">Chamar asserção interrompe a verificação da permissão nos chamadores superiores na pilha de chamadas.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, even if these callers do not have the requisite permissions, they can still access resources.</source>
          <target state="translated">Por conseguinte, mesmo que estes chamadores não tiverem as permissões da, ainda podem aceder a recursos.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>An assertion is effective only if the code that calls Assert passes the security check for the permission that it is asserting.</source>
          <target state="translated">Uma asserção é eficaz apenas se o código que chama a asserção passar a verificação de segurança para a permissão que é asserting.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>A call to Assert is effective until the calling code returns to its caller or until a subsequent call to Assert renders the previous assertion ineffective.</source>
          <target state="translated">Uma chamada para declarar tem efeita até que o código de chamada devolve ao respetivo autor da chamada ou até que uma chamada subsequente para declarar compõe a asserção anterior ineficaz.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also, &lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; removes a pending Assert.</source>
          <target state="translated">Além disso, &lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;ou &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;Remove uma asserção pendente.&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assert is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">Asserção é ignorada para uma permissão não concedida devido uma pedido para essa permissão não será concluída com êxito.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if code lower on the call stack calls &lt;xref:System.Security.IStackWalk.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call Assert.</source>
          <target state="translated">No entanto, se inferior na pilha de chamadas chama &lt;xref:System.Security.IStackWalk.Demand%2A&gt;para essa permissão, uma &lt;xref:System.Security.SecurityException&gt;é acionada quando o percurso da pilha atinge o código que tentou chamar asserção.&lt;/xref:System.Security.SecurityException&gt; &lt;/xref:System.Security.IStackWalk.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>This happens because the code that called Assert has not been granted the permission, even though it tried to Assert it.</source>
          <target state="translated">Isto acontece porque o código que chamado asserção não foi concedido permissão, apesar de o tentar Assert-lo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Because calling Assert removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; Porque chamar asserção remove o requisito de que todo o código na cadeia de chamada tem de ser concedido permissão para aceder ao recurso especificado, pode abrir vulnerabilidades de segurança se utilizado inadequada ou incorretamente.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">Por conseguinte, deve ser utilizada com cuidado excelente.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The calling code does not have <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermissionFlag"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O código de chamada não tem <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermissionFlag"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</source>
          <target state="translated">Determina em tempo de execução se todos os chamadores na pilha de chamadas foi concedidos a permissão especificada pelo objeto atual a permissão.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">Este método é normalmente utilizado pelo bibliotecas seguras para se certificar de que os chamadores tem permissão para aceder a um recurso.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a file class in a secure class library calls Demand for the necessary &lt;xref:System.Security.Permissions.FileIOPermission&gt; before performing a file operation requested by the caller.</source>
          <target state="translated">Por exemplo, uma classe de ficheiro numa biblioteca segura de classe chama a pedido para o necessário &lt;xref:System.Security.Permissions.FileIOPermission&gt;antes de efetuar uma operação de ficheiro solicitada pelo chamador.&lt;/xref:System.Security.Permissions.FileIOPermission&gt;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">As permissões de código que chama este método não são examinadas; a verificação começa do chamador imediato desse código e continua a pilha de cópia de segurança.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Demand succeeds only if no &lt;xref:System.Security.SecurityException&gt; is raised.</source>
          <target state="translated">Será efetuada com êxito a pedido apenas se não &lt;xref:System.Security.SecurityException&gt;é gerado.&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have the permission specified by the current permission object.</source>
          <target state="translated">Um chamador superior na pilha de chamadas não tem a permissão especificada pelo objeto atual a permissão.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>-or-       A caller in the call stack has called &lt;xref:System.Security.IStackWalk.Deny*&gt; on the current permission object.</source>
          <target state="translated">- ou - foi chamado um emissor na pilha de chamadas &lt;xref:System.Security.IStackWalk.Deny*&gt;no objeto de permissão atual.&lt;/xref:System.Security.IStackWalk.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Causes every &lt;xref:System.Security.IStackWalk.Demand*&gt; for the current object that passes through the calling code to fail.</source>
          <target state="translated">Faz com que cada &lt;xref:System.Security.IStackWalk.Demand*&gt;para o objeto atual que atravessa o código de chamada falhe.&lt;/xref:System.Security.IStackWalk.Demand*&gt;</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">Este método impede os chamadores superiores na pilha de chamadas de aceder ao recurso protegido através de código que chama este método, mesmo que esses chamadores tem permissão para aceder ao mesmo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">A pilha de chamadas é normalmente representada como a crescer para baixo, para que os métodos superiores na pilha de chamadas chamar os métodos inferior na pilha de chamadas.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deny can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls Deny from being used to access the resource protected by the denied permission.</source>
          <target state="translated">Negar pode limitar a responsabilidade do programador ou ajudar a evitar vulnerabilidades de segurança acidental porque ajuda a impedir que o método que chama a negação de que está a ser utilizado para aceder o recursos protegidos pela permissão negada.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a method calls Deny on a permission, and if a &lt;xref:System.Security.IStackWalk.Demand%2A&gt; for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the Deny.</source>
          <target state="translated">Se um método chama negar uma permissão e um &lt;xref:System.Security.IStackWalk.Demand%2A&gt;para essa permissão é invocada por um emissor inferior na pilha de chamadas, que essa verificação de segurança falhará quando atinge o negar.&lt;/xref:System.Security.IStackWalk.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deny is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">Negar são ignoradas para uma permissão não concedida devido uma pedido para essa permissão não será concluída com êxito.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Causes every &lt;xref:System.Security.IStackWalk.Demand*&gt; for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</source>
          <target state="translated">Faz com que cada &lt;xref:System.Security.IStackWalk.Demand*&gt;para todos os objetos, exceto o atual que atravessa o código de chamada falhe, mesmo se superior na pilha de chamadas de código tem permissão para aceder a outros recursos.&lt;/xref:System.Security.IStackWalk.Demand*&gt;</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>PermitOnly is similar to &lt;xref:System.Security.IStackWalk.Deny%2A&gt;, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated">PermitOnly é semelhante à &lt;xref:System.Security.IStackWalk.Deny%2A&gt;, em que ambos fazer com que a pilha explica como falha quando que caso contrário, seriam concluída com êxito.&lt;/xref:System.Security.IStackWalk.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>The difference is that &lt;xref:System.Security.IStackWalk.Deny%2A&gt; specifies permissions that will cause the stack walk to fail, but PermitOnly specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">A diferença é que &lt;xref:System.Security.IStackWalk.Deny%2A&gt;Especifica as permissões que fará com que a pilha guiá-lo a falhar, mas PermitOnly Especifica as permissões de apenas não causam a falhar o percurso da pilha.&lt;/xref:System.Security.IStackWalk.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">Chame este método para se certificar de que o seu código pode ser utilizado para aceder apenas os recursos especificados.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>PermitOnly is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">PermitOnly é ignorada para uma permissão não concedida devido uma pedido para essa permissão não será concluída com êxito.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if code lower on the call stack later calls &lt;xref:System.Security.IStackWalk.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call PermitOnly.</source>
          <target state="translated">No entanto, se o código inferior na chamada da pilha mais tarde chamadas &lt;xref:System.Security.IStackWalk.Demand%2A&gt;para essa permissão, uma &lt;xref:System.Security.SecurityException&gt;é acionada quando o percurso da pilha atinge o código que tentou chamar PermitOnly.&lt;/xref:System.Security.SecurityException&gt; &lt;/xref:System.Security.IStackWalk.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the code that called PermitOnly has not been granted the permission, even though it called PermitOnly for that permission.</source>
          <target state="translated">Isto acontece porque o código que chamado PermitOnly não foi concedido permissão, apesar de chamou PermitOnly para essa permissão.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">A pilha de chamadas é normalmente representada como a crescer para baixo, para que os métodos superiores na pilha de chamadas chamar os métodos inferior na pilha de chamadas.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>