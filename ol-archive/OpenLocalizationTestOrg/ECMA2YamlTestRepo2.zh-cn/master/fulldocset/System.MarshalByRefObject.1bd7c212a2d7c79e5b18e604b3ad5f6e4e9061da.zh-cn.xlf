<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">579f9c16abb22a2b2476ae0ea2cfa6be42e8b022</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.MarshalByRefObject.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c9cf13a4e181672ae69c12e8c1f5e0793dd207ab</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eb057e9c33ce8cf40a25274cfb0511bb390cae10</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Enables access to objects across application domain boundaries in applications that support remoting.</source>
          <target state="translated">启用访问对象跨应用程序中的应用程序域边界支持远程处理。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>An application domain is a partition in an operating system process where one or more applications reside.</source>
          <target state="translated">应用程序域是在一个或多个应用程序所在位置的操作系统进程中的分区。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Objects in the same application domain communicate directly.</source>
          <target state="translated">在同一应用程序域中的对象直接进行通信。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Objects in different application domains communicate either by transporting copies of objects across application domain boundaries, or by using a proxy to exchange messages.</source>
          <target state="translated">不同的应用程序域中的对象进行通信的传输对象的副本跨应用程序域边界进行，或通过使用代理服务器来交换消息。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>MarshalByRefObject is the base class for objects that communicate across application domain boundaries by exchanging messages using a proxy.</source>
          <target state="translated">MarshalByRefObject 是跨应用程序域边界通过交换消息使用的代理进行通信的对象的基类。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Objects that do not inherit from MarshalByRefObject are implicitly marshal by value.</source>
          <target state="translated">对象不是继承自 MarshalByRefObject 的隐式是按值封送。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>When a remote application references a marshal by value object, a copy of the object is passed across application domain boundaries.</source>
          <target state="translated">当远程应用程序引用封送值对象时，跨应用程序域边界传递对象的副本。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>MarshalByRefObject objects are accessed directly within the boundaries of the local application domain.</source>
          <target state="translated">直接在本地应用程序域的边界内访问 MarshalByRefObject 对象。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The first time an application in a remote application domain accesses a MarshalByRefObject, a proxy is passed to the remote application.</source>
          <target state="translated">第一次远程应用程序域中的应用程序访问 MarshalByRefObject，代理将传递到远程应用程序。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Subsequent calls on the proxy are marshaled back to the object residing in the local application domain.</source>
          <target state="translated">代理上的后续调用将封送回驻留在本地应用程序域中的对象。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Types must inherit from MarshalByRefObject when the type is used across application domain boundaries, and the state of the object must not be copied because the members of the object are not usable outside the application domain where they were created.</source>
          <target state="translated">类型使用跨应用程序域边界进行，并且不得复制对象的状态，因为对象的成员不在其创建位置的应用程序域之外使用时，类型必须从 MarshalByRefObject 中继承。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When you derive an object from MarshalByRefObject for use across application domain boundaries, you should not override any of its members, nor should you call its methods directly.</source>
          <target state="translated">当你对象从 MarshalByRefObject 中派生用于跨应用程序域边界时，不应重写任何的成员，也不应直接调用其方法。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The runtime recognizes that classes derived from  MarshalByRefObject should be marshaled across app domain boundaries.</source>
          <target state="translated">运行时识别应跨应用程序域边界进行封送类派生自 MarshalByRefObject。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>类。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.</source>
          <target state="translated">创建包含所有生成代理用于与远程对象进行通信所需的相关信息的对象。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>TheCreateObjRef method is called by remote object creation methods such as &lt;xref:System.AppDomain.CreateInstance%2A?displayProperty=fullName&gt; and &lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">由远程对象创建方法，如&lt;xref:System.AppDomain.CreateInstance%2A?displayProperty=fullName&gt;和&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=fullName&gt;.&lt;/xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=fullName&gt;&lt;/xref:System.AppDomain.CreateInstance%2A?displayProperty=fullName&gt;调用 TheCreateObjRef 方法</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In most cases, there is no need to override this method.</source>
          <target state="translated">在大多数情况下，没有无需重写此方法。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Type&gt; of the object that the new <bpt id="p1">&lt;xref href="System.Runtime.Remoting.ObjRef"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> will reference.</source>
          <target state="translated">&lt;xref:System.Type&gt;的对象的新<bpt id="p1">&lt;xref href="System.Runtime.Remoting.ObjRef"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>将引用。&lt;/xref:System.Type&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Information required to generate a proxy.</source>
          <target state="translated">生成代理所需的信息。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This instance is not a valid remoting object.</source>
          <target state="translated">此实例不是有效的远程处理对象。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The immediate caller does not have infrastructure permission.</source>
          <target state="translated">直接调用方没有基础结构权限。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Retrieves the current lifetime service object that controls the lifetime policy for this instance.</source>
          <target state="translated">检索当前生存期服务对象，用于控制此实例的生存期策略。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For more information about lifetime services, see the &lt;xref:System.Runtime.Remoting.Lifetime.LifetimeServices&gt; class.</source>
          <target state="translated">生存期服务有关的详细信息，请参阅&lt;xref:System.Runtime.Remoting.Lifetime.LifetimeServices&gt;类。&lt;/xref:System.Runtime.Remoting.Lifetime.LifetimeServices&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>An object of type <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Lifetime.ILease"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to control the lifetime policy for this instance.</source>
          <target state="translated">类型的对象<bpt id="p1">&lt;xref href="System.Runtime.Remoting.Lifetime.ILease"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>用于控制此实例的生存期策略。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The immediate caller does not have infrastructure permission.</source>
          <target state="translated">直接调用方没有基础结构权限。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Obtains a lifetime service object to control the lifetime policy for this instance.</source>
          <target state="translated">获取要控制此实例的生存期策略生存期服务对象。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For more information about lifetime services, see the &lt;xref:System.Runtime.Remoting.Lifetime.LifetimeServices&gt; class.</source>
          <target state="translated">生存期服务有关的详细信息，请参阅&lt;xref:System.Runtime.Remoting.Lifetime.LifetimeServices&gt;类。&lt;/xref:System.Runtime.Remoting.Lifetime.LifetimeServices&gt;</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>An object of type <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Lifetime.ILease"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to control the lifetime policy for this instance.</source>
          <target state="translated">类型的对象<bpt id="p1">&lt;xref href="System.Runtime.Remoting.Lifetime.ILease"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>用于控制此实例的生存期策略。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This is the current lifetime service object for this instance if one exists; otherwise, a new lifetime service object initialized to the value of the <ph id="ph1">&amp;lt;</ph>xref:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> property.</source>
          <target state="translated">这是此实例，如果一个服务对象存在，则当前生存期否则，新生存期服务对象初始化的值为<ph id="ph1">&amp;lt;</ph>xref:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The immediate caller does not have infrastructure permission.</source>
          <target state="translated">直接调用方没有基础结构权限。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Creates a shallow copy of the current <bpt id="p1">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">创建当前的浅表副本<bpt id="p1">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The MemberwiseClone method creates a shallow copy by creating a new &lt;xref:System.MarshalByRefObject&gt; object, and then copying the nonstatic fields of the current &lt;xref:System.MarshalByRefObject&gt; object to the new object.</source>
          <target state="translated">MemberwiseClone 方法创建的浅表副本通过创建一个新&lt;xref:System.MarshalByRefObject&gt;对象，然后再复制当前的非静态字段&lt;xref:System.MarshalByRefObject&gt;到新的对象的对象。&lt;/xref:System.MarshalByRefObject&gt; &lt;/xref:System.MarshalByRefObject&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If a field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">如果字段是值类型，则执行字段的按位复制。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</source>
          <target state="translated">如果字段是引用类型，引用将复制，但被引用的对象不;因此，原始对象和其克隆引用同一对象。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;xref:System.MarshalByRefObject&gt; object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy C. Use a class that implements the &lt;xref:System.ICloneable&gt; interface to perform a deep or shallow copy of an object.</source>
          <target state="translated">例如，考虑&lt;xref:System.MarshalByRefObject&gt;对象被称为引用对象 A 和 B，反过来，X 引用对象 c。X 的浅表副本创建新的对象 X2 也引用对象 A 和 b。与此相反，X 的深层副本创建新对象 X2 引用 A2 和 B2，是的一个副本的新对象并 B.B2，反过来，引用副本 C.使用实现的类的新对象 C2，&lt;xref:System.ICloneable&gt;接口来执行对象的深度或浅表副本。&lt;/xref:System.ICloneable&gt; &lt;/xref:System.MarshalByRefObject&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The identity of a &lt;xref:System.MarshalByRefObject&gt; object is defined as the remote server object that is the target of a remoting client call.</source>
          <target state="translated">标识&lt;xref:System.MarshalByRefObject&gt;对象定义为目标的远程客户端调用的远程服务器对象。&lt;/xref:System.MarshalByRefObject&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>By default, the memberwise clone of a &lt;xref:System.MarshalByRefObject&gt; object has the same identity as the original object, which is typically not the correct behavior for clones of server-side objects that are marshaled across a remoting boundary to the client side.</source>
          <target state="translated">默认情况下，成员副本&lt;xref:System.MarshalByRefObject&gt;对象具有与原始对象，并通常不会跨客户端为远程处理边界封送的服务器端对象的克隆是正确行为相同的标识。&lt;/xref:System.MarshalByRefObject&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Specify <ph id="ph1">`false`</ph>, which is usually appropriate, to delete the identity of the clone and cause a new identity to be assigned when the clone is marshaled across a remoting boundary, or <ph id="ph2">`true`</ph> to cause the clone to retain the identity of the original &lt;xref:System.MarshalByRefObject&gt; object.</source>
          <target state="translated">指定<ph id="ph1">`false`</ph>，这是通常适当，从而删除克隆的标识，并且导致跨远程处理边界，封送克隆时要分配的新标识或<ph id="ph2">`true`</ph>导致克隆以保留原始标识&lt;xref:System.MarshalByRefObject&gt;对象。&lt;/xref:System.MarshalByRefObject&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The MemberwiseClone method is intended to be used by developers implementing remote server objects.</source>
          <target state="translated">MemberwiseClone 方法旨在实现远程服务器对象的开发人员可使用。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to delete the current <bpt id="p2">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object's identity, which will cause the object to be assigned a new identity when it is marshaled across a remoting boundary.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>若要删除当前<bpt id="p2">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>对象的标识，这将导致要跨远程处理边界封送时，将分配新标识的对象。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A value of <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is usually appropriate.</source>
          <target state="translated">值为<bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>通常比较合适。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to copy the current <bpt id="p2">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object's identity to its clone, which will cause remoting client calls to be routed to the remote server object.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>要复制当前<bpt id="p2">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>到它的克隆，这将导致远程客户端调用路由到的远程服务器对象的对象的标识。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>A shallow copy of the current <bpt id="p1">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">当前的浅表副本<bpt id="p1">&lt;xref href="System.MarshalByRefObject"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>对象。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>