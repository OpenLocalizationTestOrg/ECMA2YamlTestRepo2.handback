<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa8d9be9bd8a6e579a04c9a6e75191b7d59e2792</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.PropertyMetadata.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff40b04314562dceced1eca41762d8f11e0b2d05</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb79b96cb966a9c981d9c339abc43bdee740d9d8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</source>
          <target state="translated">定义依赖项属性的某些行为方面，如应用于特定类型，包括已注册的条件。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Property metadata can be defined and used during dependency property registration when calling the &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; method.</source>
          <target state="translated">可以定义的属性元数据，并将其在注册依赖属性过程中调用时使用&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;方法 （或附加的属性或只读依赖属性的变化形式），或在调用时的原始所有者注册后&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;方法。&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; also takes property metadata.</source>
          <target state="translated">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;此外接受属性元数据。&lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This class is a concrete base class that can be used in each of these calls.</source>
          <target state="translated">此类是一个具体基类，该类可以在其中每一个调用中使用。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>However, it is very common to specify metadata using one of the derived classes such as &lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.</source>
          <target state="translated">但是，它是很常见，用于指定元数据使用派生的类，例如&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.&lt;/xref:System.Windows.FrameworkPropertyMetadata&gt;之一</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> framework level.</source>
          <target state="translated">这些派生的类支持更多详细的元数据作为可用于检测或启用仅实现在某些属性系统和布局行为的布尔属性值来传输<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>framework 级别。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; or &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.</source>
          <target state="translated">此类的几个属性是读写的对对象模型中，但只能写入之前如&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;或&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;&lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;属性系统操作中正在使用的实例</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Each of these properties could also have been set by the constructor but are exposed so that &lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt; method implementations can set them.</source>
          <target state="translated">每个这些属性还可能已设置构造函数，但公开，以便&lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;方法实现可以设置它们。&lt;/xref:System.Windows.PropertyMetadata.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    This type, and members of this type, are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # XAML 文本用法这种类型，此类型的成员不通常使用和中<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>类。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified default value for the dependency property that this metadata will be applied to.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>与指定的默认值为此元数据将应用于依赖项属性的类。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">因为在 （不匹配会引发运行时异常） 的编译期间不能检测到不匹配，是，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">尽管每个无参数构造函数中，默认<ph id="ph1">`defaultValue`</ph>的&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;不能指定。&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">尝试这样做将引发的异常。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The default value to specify for a dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">要指定作为某个特定类型的值通常提供的依赖项属性的默认值。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>不能设置为值<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; 请参阅备注。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>使用指定的类<bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>实现引用。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">对是有效的属性值发生更改时由属性系统调用处理程序实现的引用。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>与指定的默认值的类和<bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>实现引用。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The type of the value provided <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">因为在 （不匹配会引发运行时异常） 的编译期间不能检测到不匹配，是，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">尽管每个无参数构造函数中，默认<ph id="ph1">`defaultValue`</ph>的&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;不能指定。&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">尝试这样做将引发的异常。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">依赖项属性，作为某个特定类型的值通常提供默认值。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">对是有效的属性值发生更改时由属性系统调用处理程序实现的引用。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>不能设置为值<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; 请参阅备注。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and callbacks.</source>
          <target state="translated">初始化的新实例<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>用指定的默认值和回调的类。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you want to specify a &lt;xref:System.Windows.CoerceValueCallback&gt; but not a &lt;xref:System.Windows.PropertyChangedCallback&gt;, you can pass <ph id="ph1">`null`</ph> for the <ph id="ph2">`propertyChangedCallback`</ph> parameter.</source>
          <target state="translated">如果你想要指定&lt;xref:System.Windows.CoerceValueCallback&gt;但不是&lt;xref:System.Windows.PropertyChangedCallback&gt;，可以将传递<ph id="ph1">`null`</ph>为<ph id="ph2">`propertyChangedCallback`</ph>参数。&lt;/xref:System.Windows.PropertyChangedCallback&gt; &lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">因为在 （不匹配会引发运行时异常） 的编译期间不能检测到不匹配，是，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">尽管每个无参数构造函数中，默认<ph id="ph1">`defaultValue`</ph>的&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;不能指定。&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">尝试这样做将引发的异常。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">依赖项属性，作为某个特定类型的值通常提供默认值。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">对是有效的属性值发生更改时由属性系统调用处理程序实现的引用。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called whenever the property system calls &lt;xref:System.Windows.DependencyObject.CoerceValue*&gt; against this property.</source>
          <target state="translated">引用是每当属性系统调用的处理程序实现&lt;xref:System.Windows.DependencyObject.CoerceValue*&gt;针对此属性。&lt;/xref:System.Windows.DependencyObject.CoerceValue*&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>不能设置为值<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; 请参阅备注。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">获取或设置一个引用， <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>此元数据中指定的实现。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">属性元数据中的回调不是上包含的类型，通常公共成员，因此此属性的值并不重要仅仅使用现有依赖项属性的元数据的大多数情况下。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.CoerceValueCallback&gt;.</source>
          <target state="translated">此属性公开的一个原因是，因此，元数据子类可以执行其所需的合并逻辑，如果基本元数据和重写/添加元数据指定一种&lt;xref:System.Windows.CoerceValueCallback&gt;。&lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>However, the default merge logic for a CoerceValueCallback is to replace the previous one.</source>
          <target state="translated">但是，CoerceValueCallback 的默认合并逻辑是替换前一个。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>CoerceValueCallback is defined in the object model as read-write.</source>
          <target state="translated">CoerceValueCallback 对象模型中定义为读写。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This is so CoerceValueCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">这是因此可以初始化后调整 CoerceValueCallback&lt;xref:System.Windows.PropertyMetadata&gt;对象本身。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;， &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;，或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;、 属性系统将密封该元数据实例和属性都被视为不可变。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Attempting to set CoerceValueCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">尝试一次设置 CoerceValueCallback&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;是<ph id="ph1">`true`</ph>对此元数据实例将引发的异常。&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>实现引用。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">对依赖属性操作应用后，无法设置元数据属性。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Gets or sets the default value of the dependency property.</source>
          <target state="translated">获取或设置依赖项属性的默认值。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>DefaultValue is defined in the object model as read-write.</source>
          <target state="translated">DefaultValue 对象模型中定义为读写。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This is so DefaultValue can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">这是因此可以初始化后调整 DefaultValue&lt;xref:System.Windows.PropertyMetadata&gt;对象本身。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;， &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;，或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;、 属性系统将密封该元数据实例和属性都被视为不可变。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Attempting to set DefaultValue once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">尝试一次设置 DefaultValue&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;是<ph id="ph1">`true`</ph>对此元数据实例将引发的异常。&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be set using either DefaultValue or the constructor.</source>
          <target state="translated">尽管每个无参数构造函数中，默认<ph id="ph1">`defaultValue`</ph>的&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;不能通过 DefaultValue 或构造函数设置。&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">尝试这样做将引发的异常。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    Members of this type are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # 此类型的 XAML 文本用法成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The default value of the property.</source>
          <target state="translated">属性的默认值。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The default value on a <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance created with the parameterless constructor will be <bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated">上的默认值<bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>使用无参数构造函数创建的实例将<bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>; 请参阅备注。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> once created; see Remarks.</source>
          <target state="translated">不能设置为值<bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>后创建; 请参阅备注。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">对依赖属性操作应用后，无法设置元数据属性。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</source>
          <target state="translated">获取一个值，确定是否已将元数据应用到以某种方式，从而导致该元数据实例的不可变状态属性。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Various properties of &lt;xref:System.Windows.PropertyMetadata&gt;, such as &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;, are defined in the object model as read-write.</source>
          <target state="translated">各种属性&lt;xref:System.Windows.PropertyMetadata&gt;，如&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;，在为读写模式的对象模型中定义。&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; &lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This is so those properties can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">这是以便这些属性可进行调整后的初始化&lt;xref:System.Windows.PropertyMetadata&gt;对象本身。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>However, once the metadata is applied to a dependency property as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分应用于依赖属性元数据后&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;， &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;，或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;、 属性系统将密封该元数据实例和属性都被视为不可变。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>At the time of one of these calls, &lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt; is called, and the value of this property is set to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">在这些调用之一时&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;调用时，此属性的值设置为<ph id="ph1">`true`</ph>。&lt;/xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the metadata instance is immutable; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果元数据实例是不可变;否则为<bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Merges this metadata with the base metadata.</source>
          <target state="translated">合并的基本元数据与此元数据。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This method is used internally when metadata is being overridden (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; method).</source>
          <target state="translated">重写元数据时在内部使用此方法 (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;方法)。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The base metadata to merge with this instance's values.</source>
          <target state="translated">要与此实例的值合并的基本元数据。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The dependency property to which this metadata is being applied.</source>
          <target state="translated">正在向其应用此元数据依赖项属性。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">当此元数据已应用到属性，它指示正在密封元数据时调用。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Subclasses should assure that any mutability of the data structure of a &lt;xref:System.Windows.PropertyMetadata&gt; subclass should be marked as immutable once OnApply is called.</source>
          <target state="translated">子类应确保︰ 数据结构的任何可变性&lt;xref:System.Windows.PropertyMetadata&gt;子类应标记为不可变后调用 OnApply。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</source>
          <target state="translated">这将调用后对属性系统操作应用了元数据 （注册、 将所有者添加、 重写元数据）。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">向其应用了元数据依赖项属性。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">如果这是类型特定的元数据与此元数据关联的类型。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If this is default metadata, this value is a null reference.</source>
          <target state="translated">如果这是默认元数据，此值为空引用。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">获取或设置一个引用， <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>此元数据中指定的实现。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">属性元数据中的回调不是上定义的类型，通常公共成员，因此此属性的值并不重要仅仅使用现有依赖项属性的元数据的大多数情况下。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.PropertyChangedCallback&gt;.</source>
          <target state="translated">此属性公开的一个原因是，因此，元数据类可以执行其所需的合并逻辑，如果基本元数据和重写/添加元数据指定一种&lt;xref:System.Windows.PropertyChangedCallback&gt;。&lt;/xref:System.Windows.PropertyChangedCallback&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The default merge logic for is to maintain all PropertyChangedCallback implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</source>
          <target state="translated">默认合并逻辑是维护表中的所有 PropertyChangedCallback 实现并调用其中，每台运行第一个层次结构中最深的类所建立的回调。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>PropertyChangedCallback is defined in the object model as read-write.</source>
          <target state="translated">PropertyChangedCallback 对象模型中定义为读写。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This is so PropertyChangedCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">这是因此可以初始化后调整 PropertyChangedCallback&lt;xref:System.Windows.PropertyMetadata&gt;对象本身。&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;， &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;，或&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;、 属性系统将密封该元数据实例和属性都被视为不可变。&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Attempting to set PropertyChangedCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">尝试一次设置 PropertyChangedCallback&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;是<ph id="ph1">`true`</ph>对此元数据实例将引发的异常。&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>实现引用。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">对依赖属性操作应用后，无法设置元数据属性。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>