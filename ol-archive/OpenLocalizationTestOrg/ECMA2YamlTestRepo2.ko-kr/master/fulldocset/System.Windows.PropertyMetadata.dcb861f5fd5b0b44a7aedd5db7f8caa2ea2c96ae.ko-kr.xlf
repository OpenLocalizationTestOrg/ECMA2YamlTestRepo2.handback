<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa8d9be9bd8a6e579a04c9a6e75191b7d59e2792</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.PropertyMetadata.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e549028ed296d03d13f33fd463370a904a5b4b8a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb79b96cb966a9c981d9c339abc43bdee740d9d8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</source>
          <target state="translated">등록 된 조건을 포함 하 여 특정 형식에 적용 될 때 종속성 속성의 특정 동작 측면을 정의 합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property metadata can be defined and used during dependency property registration when calling the &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; method.</source>
          <target state="translated">속성 메타 데이터를 정의 하 고 호출 하는 경우 종속성 속성을 등록할 때 사용 될 수는 &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;메서드 (또는 연결 된 속성 또는 읽기 전용 종속성 속성에 대 한 변형)을 호출할 때 원래 소유자 등록 후 또는 &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;메서드.&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; also takes property metadata.</source>
          <target state="translated">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;또한 속성 메타 데이터를 사용합니다.&lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>This class is a concrete base class that can be used in each of these calls.</source>
          <target state="translated">이 클래스는 이러한 각 호출에 사용할 수 있는 구체적 기본 클래스입니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is very common to specify metadata using one of the derived classes such as &lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.</source>
          <target state="translated">그러나 것은 매우 일반적 &lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.&lt;/xref:System.Windows.FrameworkPropertyMetadata&gt; 같은 파생된 클래스 중 하나를 사용 하 여 메타 데이터를 지정 하려면</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> framework level.</source>
          <target state="translated">이러한 파생된 클래스는 감지 또는에 구현 되는 일부 속성 시스템 및 레이아웃 동작을 사용 하도록 설정 하는 데 필요한 부울 속성 값으로 전달 하는 보다 자세한 메타 데이터 지원의 <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> 프레임 워크 수준입니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; or &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.</source>
          <target state="translated">이 클래스의 몇 가지 속성을 읽기 / 쓰기 개체 모델에 있지만 등 &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt; 속성 시스템 작업에 사용 되는 인스턴스가 전에 작성할 수 있습니다</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each of these properties could also have been set by the constructor but are exposed so that &lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt; method implementations can set them.</source>
          <target state="translated">이러한 각 속성 또한 설정 될 수는 생성자가 있지만 표시 됩니다 되도록 &lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;메서드 구현에서는 속성을 설정할 수 있습니다.&lt;/xref:System.Windows.PropertyMetadata.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    This type, and members of this type, are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># #이 형식의 멤버 및 XAML 텍스트 사용이이 형식에 일반적으로에서 사용 되지 않는 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified default value for the dependency property that this metadata will be applied to.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 메타 데이터가 적용 하는 종속성 속성에 대 한 지정 된 기본값을 사용 하 여 클래스입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">제공 된 값의 형식 <ph id="ph1">`defaultValue`</ph> 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 불일치 (일치 하지 않는 런타임 예외가 발생 합니다) 컴파일하는 동안 불일치를 감지할 수 없기 때문에 디버깅을 어려울 수 있습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">매개 변수가 없는 생성자에 대해 기본값으로 있지만 <ph id="ph1">`defaultValue`</ph> 의 &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;지정할 수 없습니다.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">이렇게 하면 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The default value to specify for a dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">기본값을 일반적으로 몇 가지 특정 유형의 값으로 제공 되는 종속성 속성을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>값으로 설정할 수 없습니다 <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; 설명을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 구현 참조 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">속성의 유효 값이 변경 될 때마다 속성 시스템에 의해 호출 되는 처리기 구현에 대 한 참조입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정 된 기본값을 사용 하 여 클래스 및 <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 구현 참조 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">제공 된 값 형식 <ph id="ph1">`defaultValue`</ph> 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 불일치 (일치 하지 않는 런타임 예외가 발생 합니다) 컴파일하는 동안 불일치를 감지할 수 없기 때문에 디버깅을 어려울 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">매개 변수가 없는 생성자에 대해 기본값으로 있지만 <ph id="ph1">`defaultValue`</ph> 의 &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;지정할 수 없습니다.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">이렇게 하면 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">일반적으로 몇 가지 특정 유형의 값으로 제공 하는 종속성 속성의 기본값입니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">속성의 유효 값이 변경 될 때마다 속성 시스템에 의해 호출 되는 처리기 구현에 대 한 참조입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>값으로 설정할 수 없습니다 <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; 설명을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and callbacks.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정 된 기본값 및 콜백 클래스.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a &lt;xref:System.Windows.CoerceValueCallback&gt; but not a &lt;xref:System.Windows.PropertyChangedCallback&gt;, you can pass <ph id="ph1">`null`</ph> for the <ph id="ph2">`propertyChangedCallback`</ph> parameter.</source>
          <target state="translated">지정 하려는 경우는 &lt;xref:System.Windows.CoerceValueCallback&gt;하지 않고는 &lt;xref:System.Windows.PropertyChangedCallback&gt;를 전달할 수 있습니다 <ph id="ph1">`null`</ph> 에 대 한는 <ph id="ph2">`propertyChangedCallback`</ph> 매개 변수.&lt;/xref:System.Windows.PropertyChangedCallback&gt; &lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">제공 된 값의 형식 <ph id="ph1">`defaultValue`</ph> 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 불일치 (일치 하지 않는 런타임 예외가 발생 합니다) 컴파일하는 동안 불일치를 감지할 수 없기 때문에 디버깅을 어려울 수 있습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">매개 변수가 없는 생성자에 대해 기본값으로 있지만 <ph id="ph1">`defaultValue`</ph> 의 &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;지정할 수 없습니다.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">이렇게 하면 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">일반적으로 몇 가지 특정 유형의 값으로 제공 하는 종속성 속성의 기본값입니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">속성의 유효 값이 변경 될 때마다 속성 시스템에 의해 호출 되는 처리기 구현에 대 한 참조입니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called whenever the property system calls &lt;xref:System.Windows.DependencyObject.CoerceValue*&gt; against this property.</source>
          <target state="translated">속성 시스템 호출할 때마다 호출 되는 처리기 구현에 대 한 참조 &lt;xref:System.Windows.DependencyObject.CoerceValue*&gt;이 속성에 대해.&lt;/xref:System.Windows.DependencyObject.CoerceValue*&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>값으로 설정할 수 없습니다 <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; 설명을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">에 대 한 참조를 가져오거나는 <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 메타 데이터에 지정 된 구현 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">속성 메타 데이터에 대 한 콜백이 되지 않으므로 일반적으로 public 멤버를 포함 하는 형식,이 속성의 값은 기존 종속성 속성의 메타 데이터를 사용 하는 대부분의 시나리오에 대 한 중요 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.CoerceValueCallback&gt;.</source>
          <target state="translated">이 속성을 노출 하는 한 가지 이유는 메타 데이터의 하위 클래스는 기본 메타 데이터와 메타 데이터 재정의/추가 지정 &lt;xref:System.Windows.CoerceValueCallback&gt;.&lt;/xref:System.Windows.CoerceValueCallback&gt; 원하는 병합 논리를 수행할 수 있도록</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the default merge logic for a CoerceValueCallback is to replace the previous one.</source>
          <target state="translated">그러나는 된에 대 한 기본 병합 논리 이전을 대체 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>CoerceValueCallback is defined in the object model as read-write.</source>
          <target state="translated">된 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so CoerceValueCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">따라서 초기화 된을 조정할 수는 &lt;xref:System.Windows.PropertyMetadata&gt;개체 자체입니다.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">그러나 메타 데이터에 대 한 호출의 일부로 사용 된 경우 &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, 또는 &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 현재 변경할 수 없는 것으로 간주 됩니다.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set CoerceValueCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">된을 한 번 설정 하려고 &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;은 <ph id="ph1">`true`</ph> 이 메타 데이터 인스턴스 예외를 발생 시킵니다.&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 구현 참조 합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">종속성 속성 작업에 적용 한 후에 메타 데이터 속성을 설정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Gets or sets the default value of the dependency property.</source>
          <target state="translated">종속성 속성의 기본값을 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>DefaultValue is defined in the object model as read-write.</source>
          <target state="translated">DefaultValue 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so DefaultValue can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">따라서 초기화 한 후 DefaultValue를 조정할 수는 &lt;xref:System.Windows.PropertyMetadata&gt;개체 자체입니다.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">그러나 메타 데이터에 대 한 호출의 일부로 사용 된 경우 &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, 또는 &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 현재 변경할 수 없는 것으로 간주 됩니다.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set DefaultValue once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">DefaultValue를 한 번 설정 하려고 &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;은 <ph id="ph1">`true`</ph> 이 메타 데이터 인스턴스 예외를 발생 시킵니다.&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be set using either DefaultValue or the constructor.</source>
          <target state="translated">매개 변수가 없는 생성자에 대해 기본값으로 있지만 <ph id="ph1">`defaultValue`</ph> 의 &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;DefaultValue 또는 생성자 중 하나를 사용 하 여 설정할 수 없습니다.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">이렇게 하면 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    Members of this type are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># #이 유형의 XAML 텍스트 사용 멤버에 일반적으로 사용 되지 않는 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The default value of the property.</source>
          <target state="translated">속성의 기본값입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The default value on a <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance created with the parameterless constructor will be <bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated">값에서 기본값을 <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 매개 변수가 없는 생성자를 사용 하 여 만든 인스턴스가 됩니다 <bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>; 설명을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> once created; see Remarks.</source>
          <target state="translated">값으로 설정할 수 없습니다 <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 만들어지면; 설명을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">종속성 속성 작업에 적용 한 후에 메타 데이터 속성을 설정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</source>
          <target state="translated">속성에 해당 메타 데이터 인스턴스의 변경할 수 없는 상태에 데이터가 메타 데이터를 적용 되었는지 여부를 결정 하는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Various properties of &lt;xref:System.Windows.PropertyMetadata&gt;, such as &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;, are defined in the object model as read-write.</source>
          <target state="translated">다양 한 속성 &lt;xref:System.Windows.PropertyMetadata&gt;와 같은 &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;, 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다.&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; &lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so those properties can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">따라서 초기화 한 후 해당 속성을 조정할 수는 &lt;xref:System.Windows.PropertyMetadata&gt;개체 자체입니다.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is applied to a dependency property as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">그러나 메타 데이터에 대 한 호출의 일부로 종속성 속성에 적용 되 고 나면 &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, 또는 &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 현재 변경할 수 없는 것으로 간주 됩니다.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>At the time of one of these calls, &lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt; is called, and the value of this property is set to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">이러한 호출 중 하나의 시 &lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;를 호출 하 고이 속성의 값 설정 <ph id="ph1">`true`</ph>.&lt;/xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the metadata instance is immutable; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>메타 데이터 인스턴스; 변경할 수 없는 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Merges this metadata with the base metadata.</source>
          <target state="translated">기본 메타 데이터와이 메타 데이터를 병합합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used internally when metadata is being overridden (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; method).</source>
          <target state="translated">이 메서드는 메타 데이터 재정의 될 때 내부적으로 사용 됩니다 (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; 메서드).&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The base metadata to merge with this instance's values.</source>
          <target state="translated">이 인스턴스의 값 병합할 기본 메타 데이터입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The dependency property to which this metadata is being applied.</source>
          <target state="translated">이 메타 데이터가 적용 되는 종속성 속성입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">이 메타 데이터는 메타 데이터는 봉인 여부를 나타내는 속성에 적용 된 경우 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subclasses should assure that any mutability of the data structure of a &lt;xref:System.Windows.PropertyMetadata&gt; subclass should be marked as immutable once OnApply is called.</source>
          <target state="translated">서브 클래스 해야 속하는 어떠한 방법으로의 데이터 구조는 &lt;xref:System.Windows.PropertyMetadata&gt;하위 클래스 표시 해야 변경할 수 없는 것 OnApply 호출 되 면.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</source>
          <target state="translated">메타 데이터 속성 시스템 작업에 적용 된 후 호출 됩니다 (등록, 소유자를 추가, 메타 데이터 재정의).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">종속성 속성 메타 데이터에 적용 되었습니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">이 특정 형식의 메타 데이터는 경우이 메타 데이터와 연결 된 형식입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If this is default metadata, this value is a null reference.</source>
          <target state="translated">기본 메타 데이터 인 경우이 값은 null 참조입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">에 대 한 참조를 가져오거나는 <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 메타 데이터에 지정 된 구현 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">속성 메타 데이터의 콜백은 되지 않으므로 정의 형식에 대해 일반적으로 public 멤버가이 속성의 값은 기존 종속성 속성의 메타 데이터를 사용 하는 대부분의 시나리오에 대 한 중요 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.PropertyChangedCallback&gt;.</source>
          <target state="translated">이 속성을 노출 하는 한 가지 이유는 메타 데이터 클래스는 기본 메타 데이터와 메타 데이터 재정의/추가 지정 &lt;xref:System.Windows.PropertyChangedCallback&gt;.&lt;/xref:System.Windows.PropertyChangedCallback&gt; 원하는 병합 논리를 수행할 수 있도록</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default merge logic for is to maintain all PropertyChangedCallback implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</source>
          <target state="translated">에 대 한 기본 병합 논리 테이블의 모든 PropertyChangedCallback 구현 유지 관리 하 고 첫 번째 실행 하는 계층 구조에서 가장 깊은 클래스에 설정 된 콜백이 각각를 호출 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>PropertyChangedCallback is defined in the object model as read-write.</source>
          <target state="translated">PropertyChangedCallback 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so PropertyChangedCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">따라서 초기화 한 후 PropertyChangedCallback를 조정할 수는 &lt;xref:System.Windows.PropertyMetadata&gt;개체 자체입니다.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">그러나 메타 데이터에 대 한 호출의 일부로 사용 된 경우 &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, 또는 &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 현재 변경할 수 없는 것으로 간주 됩니다.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set PropertyChangedCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">PropertyChangedCallback를 한 번 설정 하려고 &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;은 <ph id="ph1">`true`</ph> 이 메타 데이터 인스턴스 예외를 발생 시킵니다.&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 구현 참조 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">종속성 속성 작업에 적용 한 후에 메타 데이터 속성을 설정할 수 없습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>