<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4691a6e122ecbf5305faed03fb963be4f3007c7e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.DependencyPropertyKey.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6841db7b46cbc620ad780d693b6cf47c03bc2d50</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f8a436c8a112474f58b9bb1881a040508df4e8e6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides a dependency property identifier for limited write access to a read-only dependency property.</source>
          <target state="translated">읽기 전용 종속성 속성에 대 한 제한 된 쓰기에 대 한 종속성 속성 식별자를 제공합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>DependencyPropertyKey instances are obtained as the return value of a dependency property registration call using the methods &lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt; or &lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;.</source>
          <target state="translated">메서드 &lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;또는 &lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;.&lt;/xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt; &lt;/xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt; 를 사용 하 여 종속성 속성 등록 호출의 반환 값으로 가져온 DependencyPropertyKey 인스턴스</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The types that register a dependency property can use the DependencyPropertyKey in calls to &lt;xref:System.Windows.DependencyObject.SetValue%2A&gt; and &lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt; that adjust the property's value as part of class logic.</source>
          <target state="translated">종속성 속성을 등록 하는 형식은 DependencyPropertyKey를 사용 하 여에 대 한 호출 수 &lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;및 &lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;클래스 논리의 일부로 속성의 값을 조정 하는.&lt;/xref:System.Windows.DependencyObject.ClearValue%2A&gt; &lt;/xref:System.Windows.DependencyObject.SetValue%2A&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>If permitted by the access level of the key, related classes can use the key and the dependency property also.</source>
          <target state="translated">키의 액세스 수준에서 허용 하는 경우 관련된 클래스 צ ְ ײ 키와 종속성 속성도 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</source>
          <target state="translated">예를 들어, 키 internal로 선언할 수 있습니다 및 기타 형식을 동일한 어셈블리 내에서 해당 종속성 속성을 설정할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The DependencyPropertyKey returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</source>
          <target state="translated">읽기 전용 종속성 속성 등록 반환한 DependencyPropertyKey 하지 이루어져야 public 속성을 설정할 수 있게 키가 노출 하기 때문에 따라서 읽기 전용 종속성 속성으로 등록 지점 하는데 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also, exposing the key causes a mismatch between the available dependency property behaviors and its <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]</ph> property wrapper implementations, which is bad class design.</source>
          <target state="translated">또한 키가 노출 간에 불일치가 발생 사용할 수 있는 종속성 속성이 동작 및 해당 <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]</ph> 는 잘못 된 클래스 디자인 속성 래퍼 구현이 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead of exposing the key itself, you should instead expose the &lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt; value of the DependencyPropertyKey as a <ph id="ph1">`public static readonly`</ph>&lt;xref:System.Windows.DependencyProperty&gt; on your class.</source>
          <target state="translated">키 자체를 노출 하는 대신 노출 해야는 &lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;으로 DependencyPropertyKey의 값을 <ph id="ph1">`public static readonly`</ph> &lt;xref:System.Windows.DependencyProperty&gt;프로그램 클래스의&lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</source>
          <target state="translated">그러면 유효한 종속성 속성 식별자 속성 시스템 작업 로컬 설정 값을 열거 하는 등 특정 반환할 속성이 있습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the identifier thus obtained does not have the full capabilities of a &lt;xref:System.Windows.DependencyProperty&gt; for many property system operations.</source>
          <target state="translated">그러나 가져온 따라서 식별자가 없습니다의 전체 기능은 &lt;xref:System.Windows.DependencyProperty&gt;많은 속성 시스템 작업에 대 한.&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</source>
          <target state="translated">이 특수 한 읽기 전용 종속성 속성 식별자와 연결 된 종속성 속성 식별자를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The DependencyProperty value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</source>
          <target state="translated">DependencyProperty 값은 참여 공통 속성 시스템 작업을 사용 하 여 일부 동일한 인터페이스는 사용 된 것과 읽기 / 쓰기 종속성 속성에 대 한 읽기 전용 속성의 식별자를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order to implement the get property accessor for a read-only dependency property, you should create and expose a &lt;xref:System.Windows.DependencyProperty&gt; identifier on your class.</source>
          <target state="translated">읽기 전용 종속성 속성의 get 속성 접근자를 구현 하기 위해 만들고이 &lt;xref:System.Windows.DependencyProperty&gt;프로그램 클래스에 대 한 식별자&lt;/xref:System.Windows.DependencyProperty&gt; 를 노출 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>This serves two purposes:      -   Your own class needs the &lt;xref:System.Windows.DependencyProperty&gt; identifier in order to implement the get accessor for the property wrapper.</source>
          <target state="translated">이 두 가지 용도로 사용:-사용자 소유 하는 클래스 요구는 &lt;xref:System.Windows.DependencyProperty&gt;식별자 속성 래퍼에 대 한 get 접근자를 구현 하는 데.&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>You use the &lt;xref:System.Windows.DependencyProperty&gt; as a parameter for the &lt;xref:System.Windows.DependencyObject.GetValue%2A&gt; call that implements the get accessor.</source>
          <target state="translated">사용 된 &lt;xref:System.Windows.DependencyProperty&gt;에 대 한 매개 변수로 &lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;get 접근자를 구현 하는 호출.&lt;/xref:System.Windows.DependencyObject.GetValue%2A&gt; &lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   &lt;xref:System.Windows.DependencyProperty&gt; identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</source>
          <target state="translated">- &lt;xref:System.Windows.DependencyProperty&gt;메타 데이터를 사용 하는 다른 메서드는 표준 양식에서 액세스할 수 있도록 식별자 속성 시스템에 종속성 속성을 노출 합니다.&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>For instance, if you called &lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt; on some &lt;xref:System.Windows.DependencyObject&gt; and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your &lt;xref:System.Windows.DependencyProperty&gt; value rather than the key.</source>
          <target state="translated">예를 들어, 호출한 경우 &lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;일부에 &lt;xref:System.Windows.DependencyObject&gt;로컬에서 설정한 속성 (값 및 식별자)의 열거형 식별자를 가져옵니다는 읽기 전용 종속성 속성에 대해 반환 되 여 &lt;xref:System.Windows.DependencyProperty&gt;대신 값.&lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyObject&gt; &lt;/xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not exposing a &lt;xref:System.Windows.DependencyProperty&gt; identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</source>
          <target state="translated">노출 되지 않은 한 &lt;xref:System.Windows.DependencyProperty&gt;식별자 어떤 방식으로든에서 읽기 전용 종속성 속성의 보안을 증가 하지 않습니다, 이기 후속 파생 된 클래스, 클래스 인스턴스 모두에 대해 잘못 된 구문이 속성과 관련 된 작업 때문입니다.&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>To expose the  &lt;xref:System.Windows.DependencyProperty&gt; identifier on your class, you call DependencyProperty directly on your key.</source>
          <target state="translated">노출 하는 &lt;xref:System.Windows.DependencyProperty&gt;키에서 직접 DependencyProperty를 호출 하거나 클래스에 있는 식별자를.&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this value to create a <ph id="ph1">`public static readonly`</ph>&lt;xref:System.Windows.DependencyProperty&gt; identifier on the class, which parallels the &lt;xref:System.Windows.DependencyPropertyKey&gt;.</source>
          <target state="translated">이 값을 사용 하 여 만들려는 <ph id="ph1">`public static readonly`</ph> &lt;xref:System.Windows.DependencyProperty&gt; &lt;xref:System.Windows.DependencyPropertyKey&gt;.&lt;/xref:System.Windows.DependencyPropertyKey&gt; 기능과 유사한는 클래스에는 식별자&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The relevant dependency property identifier.</source>
          <target state="translated">관련 종속성 속성 식별자입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</source>
          <target state="translated">이 종속성 속성 식별자로 표현 하는 읽기 전용 종속성 속성의 메타 데이터를 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</source>
          <target state="translated">읽기 전용 종속성 속성의 메타 데이터 재정의 메타 데이터에서 읽기 / 쓰기 종속성 속성을 재정의 하는 것과 비슷한 이유로 수행 하며 키 수준에서 액세스 제한 때문에 메타 데이터에 지정 된 동작 집합 동작을 변경할 수 (기본 값, 예를 들어).</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</source>
          <target state="translated">으로 읽기 / 쓰기 종속성 속성이 있는 읽기 전용 종속성 속성의 메타 데이터 재정의 수행 해야 해당 속성 (속성을 등록 하는 개체의 특정 인스턴스가 시작 된 시간에 같은) 속성 시스템에서 사용 하 게 되 고 이전 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calls to OverrideMetadata should only be performed within the static constructors of the type that provides itself as the <ph id="ph1">`forType`</ph> parameter of this method, or equivalent initialization for that class.</source>
          <target state="translated">OverrideMetadata에 대 한 호출으로 자신을 제공 하는 형식의 정적 생성자 내에서 수행 해야는 <ph id="ph1">`forType`</ph> 이 메서드 또는 해당 클래스에 대 한 동등한 초기화 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method effectively forwards to the &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; method, passing the &lt;xref:System.Windows.DependencyPropertyKey&gt; instance as the key parameter.</source>
          <target state="translated">이 메서드를 효과적으로 전달 된 &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;전달 하는 메서드는 &lt;xref:System.Windows.DependencyPropertyKey&gt;인스턴스 키 매개 변수로.&lt;/xref:System.Windows.DependencyPropertyKey&gt; &lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The type on which this dependency property exists and metadata should be overridden.</source>
          <target state="translated">형식에는이 종속성 속성 및 메타 데이터를 재정의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Metadata supplied for this type.</source>
          <target state="translated">이 형식에 제공 된 메타 데이터입니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Attempted metadata override on a read-write dependency property (cannot be done using this signature).</source>
          <target state="translated">시도 된 메타 데이터 읽기 / 쓰기 종속성 속성에 대 한 무시 (수행할 수 없습니다.이 서명을 사용 하 여).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Metadata was already established for the property as it exists on the provided type.</source>
          <target state="translated">제공 된 형식에 있는 속성에 대 한 메타 데이터가 이미 설정 된 경우</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>