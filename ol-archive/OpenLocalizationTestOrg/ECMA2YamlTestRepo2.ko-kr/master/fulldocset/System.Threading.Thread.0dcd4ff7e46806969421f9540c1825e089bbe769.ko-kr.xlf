<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e5df80f20fb8f8e9d58d7fd51e841a9b301b1bb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.Thread.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">836a4a28ca4635685ece20dbbe7b56da6a73e287</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d53c4cef63a323cfe675bb4658023858adff4b10</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">만듭니다 및 스레드를 제어 하의 우선 순위를 설정 하 고 상태를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">프로세스가 시작 되 면 공용 언어 런타임 응용 프로그램 코드를 실행 하는 단일 포그라운드 스레드를 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">이 기본 전경 스레드 함께 프로세스는 프로세스와 관련 된 프로그램 코드의 일부를 실행 하려면 하나 이상의 스레드를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">이러한 스레드는 포그라운드에서 또는 백그라운드에서 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, you can use the &lt;xref:System.Threading.ThreadPool&gt; class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">또한 사용할 수 있습니다는 &lt;xref:System.Threading.ThreadPool&gt;공용 언어 런타임에 의해 관리 되는 작업자 스레드에 대 한 코드를 실행 하는 클래스입니다.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section       <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept>     <bpt id="p2">[</bpt>Retrieving Thread objects<ept id="p2">](#Retrieving)</ept>     <bpt id="p3">[</bpt>Foreground and background threads<ept id="p3">](#Foreground)</ept>     <bpt id="p4">[</bpt>Culture and threads<ept id="p4">](#Culture)</ept>     <bpt id="p5">[</bpt>Getting information about and controlling threads<ept id="p5">](#Properties)</ept>     <bpt id="p6">[</bpt>Accessing the source code for the Thread class<ept id="p6">](#Source)</ept>      <bpt id="p7">&lt;a name="Starting"&gt;</bpt><ept id="p7">&lt;/a&gt;</ept>    ## Starting a thread    You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">이 섹션에서는 <bpt id="p1">[</bpt>스레드 시작<ept id="p1">](#Starting)</ept><bpt id="p2">[</bpt>스레드 검색 개체<ept id="p2">](#Retrieving)</ept><bpt id="p3">[</bpt>포그라운드 및 백그라운드 스레드<ept id="p3">](#Foreground)</ept><bpt id="p4">[</bpt>문화권 및 스레드<ept id="p4">](#Culture)</ept><bpt id="p5">[</bpt>및에 대 한 제어 스레드 정보를 가져오는<ept id="p5">](#Properties)</ept><bpt id="p6">[</bpt>스레드 클래스에 대 한 소스 코드 액세스<ept id="p6">](#Source)</ept> <bpt id="p7">&lt;a name="Starting"&gt;</bpt> <ept id="p7">&lt;/a&gt;</ept> # # 스레드는 스레드는 해당 클래스 생성자에서를 실행 하는 메서드를 나타내는 대리자를 제공 하 여 시작 스레드 시작 합니다.                               </target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>You then call the &lt;xref:System.Threading.Thread.Start%2A&gt; method to begin execution.</source>
          <target state="translated">그런 다음 호출에서 &lt;xref:System.Threading.Thread.Start%2A&gt;메서드 실행을 시작 합니다.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Thread constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:      -   If the method has no arguments, you pass a &lt;xref:System.Threading.ThreadStart&gt; delegate to  the constructor.</source>
          <target state="translated">스레드 생성자 실행할 메서드를 인수를 전달할 수 있는지 여부에 따라 두 대리자 유형 중 하나를 수행:-전달 하면 메서드는 인수가 없는 경우는 &lt;xref:System.Threading.ThreadStart&gt;생성자에 위임 합니다.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph>           The following example creates and starts a thread that executes the <ph id="ph3">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">시그니처가: <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph> 다음 예제를 만들고 실행 하는 스레드를 시작는 <ph id="ph3">`ExecuteInForeground`</ph> 메서드.          </target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">메서드가 일부 스레드 속성에 대 한 정보를 표시 한 다음는&amp;0;.5 초 일시 중지 하 고 경과 된 초 수를 표시 하는 루프를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">스레드가&amp;5; 초 이상 동안 실행 된 경우 루프 종료 되 고 스레드는 실행을 종료 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept><ept id="p3">]</ept>      -   If the method has an argument, you pass a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate to the constructor.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept> <ept id="p3">]</ept> -메서드는 인수를 전달 하면 한 &lt;xref:System.Threading.ParameterizedThreadStart&gt;생성자에 위임 합니다.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;      </target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph>           The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">시그니처가: <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph> 메서드가 대리자가 실행 수 다음 캐스팅 (C#) 또는 변환 (Visual Basic)에서는 매개 변수는 적절 한 형식입니다.          </target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example is identical to the previous one, except that it calls the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor.</source>
          <target state="translated">다음 예제는 이전 쿼리와 동일 호출 한다는 점을 제외 하 고는 &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;생성자.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">이 버전의는 <ph id="ph1">`ExecuteInForeground`</ph> 메서드는 루프를 실행 하는 시간 (밀리초). 대략적인 수를 나타내는 단일 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept><ept id="p3">]</ept>       It is not necessary to retain a reference to a Thread object once you have started the thread.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept> <ept id="p3">]</ept> 스레드를 시작 되 면 스레드 개체에 대 한 참조를 유지할 필요는 없습니다.      </target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">스레드 실행 스레드 프로시저가 완료 될 때까지 계속 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Retrieving Thread objects    You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># #-스레드를 검색 하는 중 개체를 정적을 사용할 수 있습니다 (<ph id="ph1">`Shared`</ph> Visual basic에서) &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;스레드가 실행 하는 코드에서 현재 실행 중인 스레드에 대 한 참조를 검색할 속성.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">다음 예제에서는 &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;속성을 기본 응용 프로그램 스레드, 다른 포그라운드 스레드, 백그라운드 스레드 및 스레드 풀 스레드에 대 한 정보를 표시 합니다.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Foreground"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Foreground and background threads    Instances of the Thread class represent either foreground threads or background threads.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Foreground"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> # # 전경 스레드 또는 백그라운드 스레드 포그라운드 및 백그라운드 스레드는 스레드 클래스의 인스턴스를 나타냅니다.        </target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">백그라운드 스레드는 한 가지 예외로 포그라운드 스레드 동일: 모든 포그라운드 스레드가 했습니다. 종료 하는 경우 백그라운드 스레드에서 실행 되는 프로세스를 보관 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">모든 포그라운드 스레드가 중지 되 면 런타임은 모든 백그라운드 스레드를 중지 하 고 종료 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground:      -   The main application thread.</source>
          <target state="translated">기본적으로 다음 스레드 포그라운드에서 실행:-주 응용 프로그램 스레드입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a Thread class constructor.</source>
          <target state="translated">-모든 스레드가 스레드 클래스 생성자를 호출 하 여 만듭니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following threads execute in the background by default:      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">기본적으로 백그라운드에서 실행 하는 다음과 같은 스레드:-스레드는 런타임에서 유지 관리 되는 작업자 스레드 풀은 풀 스레드를 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadPool&gt;클래스&lt;/xref:System.Threading.ThreadPool&gt; 를 사용 하 여 스레드 풀에서 스레드 풀 및 일정 작업을 구성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 작업 기반 비동기 작업을 스레드 풀 스레드에서 자동으로 실행 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Task-based asynchronous operations use the &lt;xref:System.Threading.Tasks.Task&gt; and &lt;xref:System.Threading.Tasks.Task%601&gt; classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">사용 하 여 작업 기반 비동기 작업의 &lt;xref:System.Threading.Tasks.Task&gt;및 &lt;xref:System.Threading.Tasks.Task%601&gt;클래스를 구현 하는 <bpt id="p1">[</bpt>작업 기반 비동기 패턴<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.&lt;/xref:System.Threading.Tasks.Task%601&gt; &lt;/xref:System.Threading.Tasks.Task&gt;</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-비관리 코드에서 관리 되는 실행 환경에 들어가는 모든 스레드입니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can change a thread to execute in the background by setting the &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property at any time.</source>
          <target state="translated">설정 하 여 백그라운드에서 실행 하는 스레드를 변경할 수는 &lt;xref:System.Threading.Thread.IsBackground%2A&gt;언제 든 지 속성.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">백그라운드 스레드는 응용 프로그램이 실행 되 고 있지만 응용 프로그램의 파일 시스템 변경 사항 또는 들어오는 소켓 연결을 모니터링 하는 등 종료를 방지 해야 한다면 계속 해야 하는 모든 작업에 유용 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">다음 예제에서는 포그라운드 및 백그라운드 스레드 간의 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">첫 번째 예제 비슷합니다는 <bpt id="p1">[</bpt>스레드 시작<ept id="p1">](#Starting)</ept> 섹션을 제외 하 고 스레드를 시작 하기 전에 백그라운드에서 실행할 설정 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">출력에서 볼 수 있듯이&amp;5; 초 동안 실행 하기 전에 루프 중단 됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Culture"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Culture and threads    Each thread has a culture, represented by the &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt; property, and a UI culture, represented by the &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt; property.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Culture"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> # # 각 스레드에로 표시 되는 문화권, 문화권 및 스레드는 &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;속성 및 UI 문화권에서 표시 된 &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;속성.&lt;/xref:System.Threading.Thread.CurrentUICulture%2A&gt; &lt;/xref:System.Threading.Thread.CurrentCulture%2A&gt;        </target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">현재 문화권 등의 문화권 구분 작업 구문 분석 및 형식 지정, 문자열 비교 및 정렬을 지원 하 고 또한 쓰기 시스템 및 사용 하 여 스레드에서 일정을 제어 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">현재 UI 문화권 리소스 파일에서 리소스의 문화권 구분 검색을 위해 제공합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">새 스레드를 인스턴스화할 때 해당 culture 및 UL culture 문화권 및 UI 스레드의 문화권에 새 스레드가 만들어집니다가 아니라 및 현재 시스템 문화권 및 UI 문화권에 의해 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">즉, 예를 들어 있는 경우 현재 시스템 문화권이 영어 (미국) 및 기본 응용 프로그램 스레드의 현재 문화권이 프랑스어 (프랑스) 문화권 호출 하 여 만든 새 스레드는 &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;주 스레드에서 생성자는 영어 (미국) 및 프랑스어 (프랑스) 되지 않습니다.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">자세한 내용은의 "문화권 및 스레드" 섹션을 참조 하십시오.는 &lt;xref:System.Globalization.CultureInfo&gt;클래스 항목.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 대상으로 하는 앱에 대 한 비동기 작업을 실행 하는 스레드는 적용 되지 않습니다는 <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> 및 이상 버전에서는이 경우, 문화권 및 UI 문화권에는 비동기 작업 컨텍스트의 일부인; 기본적으로 비동기 작업을 실행 하는 스레드 문화권 및 비동기 작업을 시작 하는 스레드의 UI 문화권을 상속 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">자세한 내용은의 "문화권 및 작업 기반 비동기 작업" 섹션을 참조 하십시오.는 &lt;xref:System.Globalization.CultureInfo&gt;클래스 항목.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:      -   You can pass a &lt;xref:System.Globalization.CultureInfo&gt; object that represents that culture to the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate or the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; method.</source>
          <target state="translated">하나를 수행 하면 같은 culture 및 UL culture 공유 응용 프로그램에서 실행 되도록 하는 모든 스레드는 다음 중:-전달할 수 있습니다는 &lt;xref:System.Globalization.CultureInfo&gt;해당 문화권을 나타내는 개체는 &lt;xref:System.Threading.ParameterizedThreadStart&gt;위임 또는 &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt;메서드.&lt;/xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; &lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt; and &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; properties.</source>
          <target state="translated">-실행 되는 앱에 대 한는 <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> 이상 버전, 문화권 및 UI 문화권의 값을 설정 하 여 응용 프로그램 도메인에서 만든 모든 스레드에 할당 하는 정의할 수 있습니다는 &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;및 &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;속성.&lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; &lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">이것은 응용 프로그램별 도메인 설정 note 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information and examples, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">자세한 내용 및 예제에 대 한의 "문화권 및 스레드" 섹션을 참조는 &lt;xref:System.Globalization.CultureInfo&gt;클래스 항목.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Getting information about and controlling threads    You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # 스레드 제어 및에 대 한 정보를 가져오는 다양 한 스레드에 대 한 정보를 제공 하는 속성 값을 검색할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">경우에 따라 스레드 작업을 제어 하려면 이러한 속성 값을 설정할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>These thread properties include:      -   A name.</source>
          <target state="translated">이러한 스레드 속성에 포함:-이름입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.Name%2A&gt; is a write-once property that you can use to identify a thread.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Name%2A&gt;대 한 쓰기-스레드를 식별 하는 데 사용할 수 있는 속성에 한 번입니다.&lt;/xref:System.Threading.Thread.Name%2A&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A hash code, which you can retrieve by calling the &lt;xref:System.Threading.Thread.GetHashCode%2A&gt; method.</source>
          <target state="translated">-해시 코드를 호출 하 여 검색할 수 있는 &lt;xref:System.Threading.Thread.GetHashCode%2A&gt;메서드.&lt;/xref:System.Threading.Thread.GetHashCode%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">해시 코드를 사용 하 여 고유 하 게 식별 스레드 수 있습니다. 스레드 수명 동안에 대 한 해시 코드 값을 가져온 응용 프로그램 도메인과 관계 없이 다른 스레드의 값과 충돌 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A thread ID.</source>
          <target state="translated">-스레드 id입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the read-only &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">읽기 전용 값 &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;속성 런타임에 의해 할당 되 고 해당 프로세스 내에서 스레드를 고유 하 게 식별 합니다.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 운영 체제 <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> 은 관리 되지 않는 호스트가 관리 되는 스레드와 관리 되지 않는 스레드 간의 관계를 제어할 수 있으므로 관리 되는 스레드를 고정된 관계가 없습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">특히, 정교한 호스트를 사용할 수는 <bpt id="p1">[</bpt>CLR 호스팅 API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> 를 동일한 운영 체제 스레드에 대해 관리 되는 여러 스레드를 예약 하거나 다양 한 운영 체제 스레드 간에 관리 되는 스레드를 이동할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The thread's current state.</source>
          <target state="translated">-는 스레드의 현재 상태입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the &lt;xref:System.Threading.ThreadState&gt; property.</source>
          <target state="translated">존재 기간에 대 한 스레드는 항상 하나 이상으로 정의 된 상태에는 &lt;xref:System.Threading.ThreadState&gt;속성.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A scheduling priority level, which is defined by the &lt;xref:System.Threading.ThreadPriority&gt; property.</source>
          <target state="translated">-일정 예약 우선 순위 수준, 문자로 정의 되는 &lt;xref:System.Threading.ThreadPriority&gt;속성.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">스레드의 우선 순위를 요청 하려면이 값을 설정할 수 있지만 운영 체제에 의해 적용 되는 것 보장할 수는 없습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The read-only &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt; property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">-읽기 전용 &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;스레드는 스레드 풀 스레드 인지 여부를 나타내는 속성입니다.&lt;/xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property.</source>
          <target state="translated">- &lt;xref:System.Threading.Thread.IsBackground%2A&gt;속성.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">자세한 내용은 참조는 <bpt id="p1">[</bpt>포그라운드 및 백그라운드 스레드<ept id="p1">](#Foreground)</ept> 섹션.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Accessing the source code for the Thread class    To view the .NET Framework source code for the Thread class, see the <bpt id="p2">[</bpt>Reference Source<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # 참조 스레드 클래스에 대 한.NET Framework 소스 코드를 보려면 스레드 클래스에 대 한 소스 코드에 액세스 하는 <bpt id="p2">[</bpt>참조 소스<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
          <target state="translated">소스 코드를 온라인, 오프 라인에서 살펴보고에 대 한 참조를 다운로드 및; 디버그 시 소스 (패치 및 업데이트 포함)를 단계별로 실행 참조 <bpt id="p1">[</bpt>지침<ept id="p1">](http://referencesource.microsoft.com/)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체가 스레드가 시작 될 때 스레드로 전달할 수 있도록 하는 대리자를 지정 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">스레드 생성 될 때 실행을 시작 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">스레드 실행을 예약 하려면 호출 된 &lt;xref:System.Threading.Thread.Start%2A&gt;메서드.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>To pass a data object to the thread, use the &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt; method overload.</source>
          <target state="translated">스레드에 데이터 개체를 전달 하려면는 &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;메서드 오버 로드.&lt;/xref:System.Threading.Thread.Start%28System.Object%29&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Visual Basic 사용자를 생략할 수는 &lt;xref:System.Threading.ThreadStart&gt;스레드를 만드는 경우 생성자.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">`AddressOf`</ph> 예를 들어 메서드를 전달할 때 연산자 <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic에서 자동으로 호출 된 &lt;xref:System.Threading.ThreadStart&gt;생성자.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">이 스레드의 실행이 시작 될 때 호출할 메서드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">스레드 생성 될 때 실행을 시작 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">스레드 실행을 예약 하려면 호출 된 &lt;xref:System.Threading.Thread.Start%2A&gt;메서드.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Visual Basic 사용자를 생략할 수는 &lt;xref:System.Threading.ThreadStart&gt;스레드를 만드는 경우 생성자.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">`AddressOf`</ph> 예를 들어 메서드를 전달할 때 연산자 <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic에서 자동으로 호출 된 &lt;xref:System.Threading.ThreadStart&gt;생성자.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 스레드의 실행이 시작 될 때 호출 될 메서드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체가 스레드가 시작 될 때 스레드로 전달할 수 있도록 하는 대리자를 지정 하 고 스레드의 최대 스택 크기를 지정 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">이 생성자 오버 로드를 사용 하지 마십시오.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">사용 하는 기본 스택 크기는 &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;생성자 오버 로드는 스레드에 대 한 권장된 스택 크기.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">스레드가 메모리 문제가 발생 하는 경우는 가장 일반적인 원인은 프로그래밍 무한 재귀 같은 오류입니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 부터는 <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>코드 설정할 수 있습니다 완전히 신뢰할 수 있는, <ph id="ph3">`maxStackSize`</ph> (1mb)의 기본 스택 크기 보다 큰 값으로.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">더 큰 값을 지정 하는 경우 <ph id="ph1">`maxStackSize`</ph> 코드가 부분 신뢰로 실행 되 고 때 <ph id="ph2">`maxStackSize`</ph> 는 무시 됩니다 기본 스택 크기는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">코드 모든 신뢰 수준에서 설정할 수 있습니다 <ph id="ph1">`maxStackSize`</ph> 기본 스택 크기 보다 작은 값으로.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 경우 부분적으로 신뢰할 수 있는 코드에 의해 사용 될 완전히 신뢰할 수 있는 라이브러리를 개발 하는 고 큰 스택이 필요로 하는 스레드를 시작 해야 할 스레드를 만들기 전에 완전 신뢰를 어설션해야 또는 기본 스택 크기를 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">스레드에서 실행 되는 코드를 완벽 하 게 제어 하지 않는 한에 이렇게 하지 마십시오.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">경우 <ph id="ph1">`maxStackSize`</ph> 작으면 최소 스택 크기 보다 최소 스택 크기가 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">경우 <ph id="ph1">`maxStackSize`</ph> 배수가 아닙니다. 페이지 크기의 큰 페이지 크기의 배수로 반올림 됩니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">예를 들어.NET Framework 버전 2.0은 Windows vista를 사용 하는 256KB (262, 144 바이트)는 최소 스택 크기 및 페이지 크기는 64KB (65536 바이트)입니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Windows XP 및 Windows Server 2003 이전 버전에서 <ph id="ph2">`maxStackSize`</ph> 무시 되는 실행 파일 헤더에 지정 된 스택 크기는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">매우 작은 스택 크기를 지정 하면 스택 오버플로 검색을 사용 하지 않도록 설정 해야 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">스택에 엄격 하 게 제한 하는 경우 찾기 자체 지정 하면 스택 오버플로가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">스택 오버플로 검색을 사용 하지 않으려면 다음 응용 프로그램 구성 파일을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 스레드의 실행이 시작 될 때 호출 될 메서드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">최대 스택 크기 (바이트)를 실행 파일에 대 한 헤더에 지정 된 기본 최대 스택 크기를 사용 하는 스레드 또는 0에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">중요 한 부분적으로 신뢰할 수 있는 코드, <ph id="ph1">`maxStackSize`</ph> 기본 스택 크기 보다 큰 경우 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>가&amp;0; 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 스레드의 최대 스택 크기를 지정 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">이 생성자 오버 로드를 사용 하지 마십시오.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">사용 하는 기본 스택 크기는 &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;생성자 오버 로드는 스레드에 대 한 권장된 스택 크기.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">스레드가 메모리 문제가 발생 하는 경우는 가장 일반적인 원인은 프로그래밍 무한 재귀 같은 오류입니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 부터는 <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>코드 설정할 수 있습니다 완전히 신뢰할 수 있는, <ph id="ph3">`maxStackSize`</ph> (1mb)의 기본 스택 크기 보다 큰 값으로.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">더 큰 값을 지정 하는 경우 <ph id="ph1">`maxStackSize`</ph> 코드가 부분 신뢰로 실행 되 고 때 <ph id="ph2">`maxStackSize`</ph> 는 무시 됩니다 기본 스택 크기는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">코드 모든 신뢰 수준에서 설정할 수 있습니다 <ph id="ph1">`maxStackSize`</ph> 기본 스택 크기 보다 작은 값으로.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 경우 부분적으로 신뢰할 수 있는 코드에 의해 사용 될 완전히 신뢰할 수 있는 라이브러리를 개발 하는 고 큰 스택이 필요로 하는 스레드를 시작 해야 할 스레드를 만들기 전에 완전 신뢰를 어설션해야 또는 기본 스택 크기를 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">스레드에서 실행 되는 코드를 완벽 하 게 제어 하지 않는 한에 이렇게 하지 마십시오.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">경우 <ph id="ph1">`maxStackSize`</ph> 작으면 최소 스택 크기 보다 최소 스택 크기가 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">경우 <ph id="ph1">`maxStackSize`</ph> 배수가 아닙니다. 페이지 크기의 큰 페이지 크기의 배수로 반올림 됩니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">예를 들어.NET Framework 버전 2.0은 Windows vista를 사용 하는 256KB (262, 144 바이트)는 최소 스택 크기 및 페이지 크기는 64KB (65536 바이트)입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Windows XP 및 Windows Server 2003 이전 버전에서 <ph id="ph2">`maxStackSize`</ph> 무시 되는 실행 파일 헤더에 지정 된 스택 크기는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">매우 작은 스택 크기를 지정 하면 스택 오버플로 검색을 사용 하지 않도록 설정 해야 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">스택에 엄격 하 게 제한 하는 경우 찾기 자체 지정 하면 스택 오버플로가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">스택 오버플로 검색을 사용 하지 않으려면 다음 응용 프로그램 구성 파일을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 스레드의 실행이 시작 될 때 호출 될 메서드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">최대 스택 크기 (바이트)를 실행 파일에 대 한 헤더에 지정 된 기본 최대 스택 크기를 사용 하는 스레드 또는 0에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">중요 한 부분적으로 신뢰할 수 있는 코드, <ph id="ph1">`maxStackSize`</ph> 기본 스택 크기 보다 큰 경우 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>가&amp;0; 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">발생 한 <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 있는 메서드가 호출, 스레드 종료 프로세스를 시작 하려면 스레드에서 합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">일반적으로이 메서드를 호출 스레드를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">이 메서드는 스레드에서 호출 되 면 시스템은 throw &lt;xref:System.Threading.ThreadAbortException&gt;에서 스레드를 중단 합니다.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>응용 프로그램 코드에서 사용할 수 있는 특별 한 예외가 있지만 끝날 때 다시 throw 된 <ph id="ph2">`catch`</ph> 차단 하지 않는 한 &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;호출 됩니다.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>중단을 요청을 취소 하 고 방지는 <ph id="ph2">`ThreadAbortException`</ph> 의 스레드를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">실행 되지 않은 <ph id="ph1">`finally`</ph> 블록 스레드가 중단 되기 전에 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 호출 하면 스레드 <ph id="ph2">`Abort`</ph> 효과 자기 비슷합니다 자체에 &lt;xref:System.Threading.ThreadAbortException&gt;즉시 발생 하는 결과 예측 가능한.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">그러나 한 스레드가 <ph id="ph1">`Abort`</ph> 다른 스레드에서 abort 인터럽트 모든 코드가 실행 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">정적 생성자를 중단 될 수 있는 기회 이기도 합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">드문 경우에서 해당 클래스의 인스턴스로 해당 응용 프로그램 도메인에서 생성 되지 못할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1은 스레드가 중단 수 있는 기회 동안는 <ph id="ph1">`finally`</ph> 블록이 실행 되는 경우, 고 <ph id="ph2">`finally`</ph> 블록이 중단 됩니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">스레드가 즉시 또는 전혀 중단 보장 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">스레드 제한 없는에 계산의 경우 이러한 상황이 발생할 수 있습니다는 <ph id="ph1">`finally`</ph> 무한정 중단이 지연 되는 중단 절차의 일부분으로 호출 된 합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee the wait will end.</source>
          <target state="translated">스레드가 중단 될 때까지 기다려야 호출할 수 있습니다는 &lt;xref:System.Threading.Thread.Join%2A&gt;Abort 메서드를 호출한 후 스레드에서 메서드가 있지만 될 보장 되지 않습니다.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls Abort might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 중단 중인 스레드가 코드의 보호 된 영역에 같은 이면 Abort를 호출 하는 스레드를 차단할 수는 <ph id="ph2">`catch`</ph> 블록 <ph id="ph3">`finally`</ph> 블록 또는 제약이 있는 실행 영역입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls Abort holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Abort를 호출 하는 스레드가 중단 된 스레드 필요한 잠금을 유지 하는 경우 교착 상태가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">경우 <ph id="ph1">`Abort`</ph> 라고 시작 되지 않은 스레드에서 스레드가 될 때 중단 됩니다 &lt;xref:System.Threading.Thread.Start%2A&gt;호출 됩니다.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">경우 <ph id="ph1">`Abort`</ph> 라고 차단 되었거나 대기 중인 스레드에 스레드가 중단 되며 완전히 중단 됩니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">경우 <ph id="ph1">`Abort`</ph> 중단 된 스레드에서 호출는 &lt;xref:System.Threading.ThreadStateException&gt;호출 스레드에서 throw 되 &lt;xref:System.Threading.Thread.Abort%2A&gt;, 및 &lt;xref:System.Threading.ThreadState&gt;에 추가 되는 &lt;xref:System.Threading.Thread.ThreadState%2A&gt;중단 중인 스레드 속성입니다.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">A &lt;xref:System.Threading.ThreadAbortException&gt;될 때까지 일시 중단 된 스레드에서 throw 되지 &lt;xref:System.Threading.Thread.Resume%2A&gt;호출 됩니다.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">경우 <ph id="ph1">`Abort`</ph> 비관리 코드를 실행 하는 동안 관리 되는 스레드에서 호출 됩니다는 <ph id="ph2">`ThreadAbortException`</ph> 스레드가 관리 코드에 반환 될 때까지 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">두 번 호출 하는 경우 <ph id="ph1">`Abort`</ph> 제공 같은 시간에 대해 불가능 한 상태 정보를 설정 하는 한 번 호출 하 고 실행 하 고 다른 호출에서 <ph id="ph2">`Abort`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">그러나 응용 프로그램이이 상황을 검색할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">후 <ph id="ph1">`Abort`</ph> 호출 되는 스레드에서 스레드의 상태를 &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt; 포함</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">성공적으로 호출의 결과로 스레드가 종료 후 <ph id="ph1">`Abort`</ph>, &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt; 변경 되는 스레드의 상태</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">충분 한 권한이 있는 스레드는의 대상이 되는 <ph id="ph1">`Abort`</ph> 사용 하 여 중단을 취소할 수는 <ph id="ph2">`ResetAbort`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">에 대 한 호출을 보여 주는 예제는 <ph id="ph1">`ResetAbort`</ph> 메서드를 참조는 <ph id="ph2">`ThreadAbortException`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">호출자에 게 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">중단 중인 스레드가 현재 일시 중단 합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">발생 한 <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 있는 메서드가 호출, 스레드 종료에 대 한 예외 정보를 제공 하는 동시 스레드 종료 프로세스를 시작 하려면 스레드에서 합니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">일반적으로이 메서드를 호출 스레드를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">이 메서드는 스레드에서 호출 되 면 시스템은 throw &lt;xref:System.Threading.ThreadAbortException&gt;에서 스레드를 중단 합니다.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>응용 프로그램 코드에서 사용할 수 있는 특별 한 예외가 있지만 끝날 때 다시 throw 된 <ph id="ph2">`catch`</ph> 차단 하지 않는 한 &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;호출 됩니다.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>중단을 요청을 취소 하 고 방지는 <ph id="ph2">`ThreadAbortException`</ph> 의 스레드를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">실행 되지 않은 <ph id="ph1">`finally`</ph> 블록 스레드가 중단 되기 전에 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 호출 하면 스레드 <ph id="ph2">`Abort`</ph> 효과 자기 비슷합니다 자체에 &lt;xref:System.Threading.ThreadAbortException&gt;즉시 발생 하는 결과 예측 가능한.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">그러나 한 스레드가 <ph id="ph1">`Abort`</ph> 다른 스레드에서 abort 인터럽트 모든 코드가 실행 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">수 있으므로 정적 생성자를 중단할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">드문 경우에서 해당 클래스의 인스턴스로 해당 응용 프로그램 도메인에서 생성 되지 못할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1은 스레드가 중단 수 있는 기회 동안는 <ph id="ph1">`finally`</ph> 블록이 실행 되는 경우, 고 <ph id="ph2">`finally`</ph> 블록이 중단 됩니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">스레드가 즉시 또는 전혀 중단 보장 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">스레드 제한 없는에 계산의 경우 이러한 상황이 발생할 수 있습니다는 <ph id="ph1">`finally`</ph> 무한정 중단이 지연 되는 중단 절차의 일부분으로 호출 된 합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee that the wait will end.</source>
          <target state="translated">스레드가 중단 될 때까지 기다려야 호출할 수 있습니다는 &lt;xref:System.Threading.Thread.Join%2A&gt;Abort 메서드를 호출한 후 스레드에서 메서드가 있지만 될 보장 되지 않습니다.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 호출 하는 스레드에서 &lt;xref:System.Threading.Thread.Abort%2A&gt;중단 중인 스레드가 코드의 보호 된 영역에 같은 경우를 차단할 수는 <ph id="ph2">`catch`</ph> 블록 <ph id="ph3">`finally`</ph> 블록 또는 제약이 있는 실행 영역.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">호출 하는 스레드가 &lt;xref:System.Threading.Thread.Abort%2A&gt;잠금이 중단 된 스레드 필요한 교착 상태가 발생할 수 있습니다.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">경우 <ph id="ph1">`Abort`</ph> 라고 시작 되지 않은 스레드에서 스레드가 될 때 중단 됩니다 &lt;xref:System.Threading.Thread.Start%2A&gt;호출 됩니다.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">경우 <ph id="ph1">`Abort`</ph> 라고 차단 되었거나 대기 중인 스레드에 스레드가 중단 되며 완전히 중단 됩니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">경우 <ph id="ph1">`Abort`</ph> 중단 된 스레드에서 호출는 &lt;xref:System.Threading.ThreadStateException&gt;호출 스레드에서 throw 되 &lt;xref:System.Threading.Thread.Abort%2A&gt;, 및 &lt;xref:System.Threading.ThreadState&gt;에 추가 되는 &lt;xref:System.Threading.Thread.ThreadState%2A&gt;중단 중인 스레드 속성입니다.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">A &lt;xref:System.Threading.ThreadAbortException&gt;될 때까지 일시 중단 된 스레드에서 throw 되지 &lt;xref:System.Threading.Thread.Resume%2A&gt;호출 됩니다.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">경우 <ph id="ph1">`Abort`</ph> 비관리 코드를 실행 하는 동안 관리 되는 스레드에서 호출 됩니다는 <ph id="ph2">`ThreadAbortException`</ph> 스레드가 관리 코드에 반환 될 때까지 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">두 번 호출 하는 경우 <ph id="ph1">`Abort`</ph> 제공 같은 시간에 대해 불가능 한 상태 정보를 설정 하는 한 번 호출 하 고 실행 하 고 다른 호출에서 <ph id="ph2">`Abort`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">그러나 응용 프로그램이이 상황을 검색할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">후 <ph id="ph1">`Abort`</ph> 호출 되는 스레드에서 스레드의 상태를 &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt; 포함</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">성공적으로 호출의 결과로 스레드가 종료 후 <ph id="ph1">`Abort`</ph>, &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt; 변경 되는 스레드의 상태</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">충분 한 권한이 있는 스레드는의 대상이 되는 <ph id="ph1">`Abort`</ph> 사용 하 여 중단을 취소할 수는 <ph id="ph2">`ResetAbort`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">에 대 한 호출을 보여 주는 예제는 <ph id="ph1">`ResetAbort`</ph> 메서드를 참조는 <ph id="ph2">`ThreadAbortException`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">상태와 같이 중단 중인 스레드에서 사용할 수 있는 응용 프로그램 관련 정보를 포함 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">호출자에 게 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">중단 중인 스레드가 현재 일시 중단 합니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">모든 스레드에 대 한 명명 되지 않은 데이터 슬롯을 할당 합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">성능 향상을 위해 표시 된 필드를 사용 하 여는 &lt;xref:System.ThreadStaticAttribute&gt;특성을 대신 합니다.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 &lt;xref:System.ThreadStaticAttribute&gt;특성) 및 데이터 슬롯.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">슬롯 모든 스레드가 할당 됩니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">데이터 슬롯은 스레드당 고유 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">할당 된 명명 된 모든 스레드에서 데이터 슬롯입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">모든 스레드에 명명 된 데이터 슬롯을 할당 합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">성능 향상을 위해 표시 된 필드를 사용 하 여는 &lt;xref:System.ThreadStaticAttribute&gt;특성을 대신 합니다.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 &lt;xref:System.ThreadStaticAttribute&gt;특성) 및 데이터 슬롯.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">데이터 슬롯은 스레드당 고유 합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not necessary to use the AllocateNamedDataSlot method to allocate a named data slot, because the &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; method allocates the slot if it has not already been allocated.</source>
          <target state="translated">되었기 때문에 명명 된 데이터 슬롯을 할당 하려면 AllocateNamedDataSlot 메서드를 사용 하는 데 필요한는 &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;메서드가 아직 할당 되지 않은 경우 슬롯을 할당 합니다.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; AllocateNamedDataSlot 메서드를 사용 하는 경우 호출 해야 프로그램을 시작할 때 주 스레드에서 지정 된 이름의 슬롯이 이미 할당 되어 있으면 예외를 throw 하기 때문에 있습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">슬롯이 이미 할당 되어 있는지 여부를 테스트 방식은 없습니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Slots allocated with this method must be freed with &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.</source>
          <target state="translated">이 메서드를 사용 하 여 할당 슬롯 &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.&lt;/xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt; 해제 해야 합니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">할당할 데이터 슬롯의 이름입니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">할당 된 명명 된 모든 스레드에서 데이터 슬롯입니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">지정 된 이름 가진 명명 된 데이터 슬롯이 이미 있습니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">이 스레드의 아파트 상태를 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>The ApartmentState property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>ApartmentState 속성은 사용 되지 않습니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>The non-obsolete alternatives are the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method to retrieve the apartment state and the   &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method to set the apartment state.</source>
          <target state="translated">대체 방법은 사용 되는 &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;아파트 상태를 검색 하는 메서드 및 &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;아파트 상태를 설정 하는 방법은.&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1에서는 <ph id="ph1">`ApartmentState`</ph> 속성은 스레드가 단일 스레드 또는 다중 스레드 아파트에서 실행 될를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">이 속성은 스레드가 때 설정할 수 있습니다는 <ph id="ph1">`Unstarted`</ph> 또는 <ph id="ph2">`Running`</ph> 스레드 상태; 그러나 설정할 수 있습니다 한 번만 스레드에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">반환 하는 경우 속성에 설정 되어 있지 <ph id="ph1">`Unknown`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to use the ApartmentState property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">아파트 상태가 이미 설정 되어 스레드의 아파트 상태를 설정 하려면 ApartmentState 속성을 사용 하도록 시도 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method throws a &lt;xref:System.InvalidOperationException&gt; in this case.</source>
          <target state="translated">그러나는 &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;메서드가 throw 한 &lt;xref:System.InvalidOperationException&gt;이 예제의.&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  In the .NET Framework version 2.0, new threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;에서.NET Framework 버전 2.0에서 새 스레드로 초기화 됩니다 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;아파트 상태 설정 있지 않은 경우 되어 시작 되기 전에.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">기본 응용 프로그램 스레드도 초기화 됩니다 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;기본적으로.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can no longer set the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by setting the &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; property on the first line of code.</source>
          <target state="translated">기본 응용 프로그램 스레드를 더 이상 설정할 수 없습니다 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;설정 하 여는 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;코드의 첫 번째 줄에는 속성.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.STAThreadAttribute&gt; instead.</source>
          <target state="translated">사용 하 여 &lt;xref:System.STAThreadAttribute&gt;대신.&lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> linker option.</source>
          <target state="translated">.NET Framework 버전 2.0에서에서의 COM 스레딩 모델이 사용 하 여 c + + 응용 프로그램에 대 한를 지정할 수 있습니다는 <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (CLR 스레드 특성 설정)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> 링커 옵션입니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">초기 값은 <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) or multithreaded apartment (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</source>
          <target state="translated">잘못 된 아파트 상태가 되지 않는 상태로이 속성을 설정 하려고 시도 (단일 스레드 아파트 이외의 상태 (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) 또는 다중 스레드 아파트 (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">입력 스레드 중단 또는 처리 되지 않은 예외는 응용 프로그램 도메인에서 다른 작업을 위협할 수 코드 영역이 실행 될 호스트에 알립니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Microsoft SQL Server 2005와 같은 공용 언어 런타임 (CLR)의 호스트에는 코드의 중요 하 고 중요 하지 않은 영역에서 발생 한 실패에 대해 다른 정책을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">중요 한 영역을는 하는 스레드 중단 또는 처리 되지 않은 예외가 국한 되지 않는 현재 작업에 하나입니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">반면, 한 중단 이나 오류 코드는 중요 하지 않은 영역에서 오류가 발생 하는 작업을만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">예를 들어 잠금을 보유 하는 동안 메모리를 할당 하려고 시도 하는 작업을 살펴보겠습니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">메모리 할당이 실패 하면 현재 작업이 중단 만으로는의 안정성을 보장 하는 &lt;xref:System.AppDomain&gt;도메인에 동일한 잠금을 대기 하는 다른 작업이 있을 수 있으므로,.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">현재 작업이 종료 되는 경우 다른 작업 교착 상태가 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">중요 한 영역에서 오류가 발생 하는 경우 호스트는 전체 언로드 결정할 수 &lt;xref:System.AppDomain&gt;하지 않고는 잠재적으로 불안정 한 상태에서 실행을 계속 위험.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call BeginCriticalRegion.</source>
          <target state="translated">코드의 중요 영역 시작 하는 호스트에 제공, BeginCriticalRegion를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt; when execution returns to a non-critical region of code.</source>
          <target state="translated">호출 &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;실행 중요 하지 않은 코드 영역을 반환 하는 경우.&lt;/xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">관리 코드는 호스트를 현재 실제 운영 체제 스레드의 id에 종속 되는 명령을 실행 하려고에 알립니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Microsoft SQL Server 2005 등 공용 언어 런타임의 일부 호스트는 고유한 스레드 관리를 제공합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">고유한 스레드 관리를 제공 하는 호스트 간에 이동할 수는 실행 중인 작업 실제 운영 체제 스레드 간에 언제 든 지 합니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">이 전환 하 여 대부분의 작업 영향을 받지 않습니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">그러나 일부 작업에는 스레드 선호도-즉, 실제 운영 체제 스레드의 id에 종속 됩니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">이러한 작업은 코드를 안을 실행 하는 동안 호스트에 게 알려야 합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call BeginThreadAffinity before acquiring the lock, and &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt; after releasing the lock.</source>
          <target state="translated">예를 들어 응용 프로그램이 시스템에서 Win32 CRITICAL_SECTION 같은 스레드 선호도 있는 운영 체제 잠금을 획득 하는 API를 호출 하는 경우 호출 해야 BeginThreadAffinity 잠금을 획득 하기 전에 및 &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;잠금을 해제 한 후.&lt;/xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">호출자에 게 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">스레드가 실행 중인 현재 컨텍스트를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current thread context.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 현재 스레드 컨텍스트를 나타내는입니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">호출자에 게 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">현재 스레드 culture를 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Globalization.CultureInfo&gt; object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">&lt;xref:System.Globalization.CultureInfo&gt;날짜에 대 한 기본 형식, 시간, 숫자, 통화 값, 텍스트의 순서 정렬, 대/소문자 규칙을 확인 하 고 문자열을 비교 하는 연결된 된 개체와 함께이 속성에서 반환 되는 개체입니다.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo&gt; class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">참조는 &lt;xref:System.Globalization.CultureInfo&gt;문화권 이름 및 식별자, 고정, 중립 및 특정 문화권 간의 차이점에 대 한 자세한 내용은 클래스와 스레드 및 응용 프로그램 도메인 방식으로 문화권 정보에 영향을 줍니다.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt; property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">참조는 &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;속성 스레드의 기본 문화권을 결정 하는 방법 및 사용자가 자신의 컴퓨터에 대 한 문화권 정보를 설정 하는 방법을 알아보려면.&lt;/xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, you can set the CurrentCulture property to a neutral culture.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, 중립 문화권을 CurrentCulture 속성을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the behavior of the &lt;xref:System.Globalization.CultureInfo&gt; class has changed: When it represents a neutral culture, its property values (in particular, the &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, and &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt; properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">¿¡´의 동작은 &lt;xref:System.Globalization.CultureInfo&gt;클래스가 변경 된: 때 중립 문화권에 해당 속성 값을 나타냅니다 (특히는 &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, 및 &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;속성) 이제 중립 문화권 연관 된 특정 문화권을 반영 합니다.&lt;/xref:System.Globalization.CultureInfo.TextInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.NumberFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.CompareInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.Calendar%2A&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>In earlier versions of the .NET Framework, the CurrentCulture property threw a &lt;xref:System.NotSupportedException&gt; exception when a neutral culture was assigned.</source>
          <target state="translated">CurrentCulture 속성에서.NET Framework의 이전 버전에서는 &lt;xref:System.NotSupportedException&gt;중립 문화권 할당 하는 동안 예외가 발생 했습니다.&lt;/xref:System.NotSupportedException&gt;</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">현재 스레드 문화권을 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">속성이로 설정 되어 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">스레드의 현재 보안 주체 (역할 기반 보안)을 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Security.Principal.IPrincipal&gt; value representing the security context.</source>
          <target state="translated">&lt;xref:System.Security.Principal.IPrincipal&gt;보안 컨텍스트를 나타내는 값입니다.&lt;/xref:System.Security.Principal.IPrincipal&gt;</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">호출자에 게 보안 주체를 설정 하는 데 필요한 사용 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Gets the currently running thread.</source>
          <target state="translated">현재 실행 중인 스레드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is the representation of the currently running thread.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 현재 실행 중인 스레드의 표현입니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">리소스 관리자가 런타임 시 문화권별 리소스를 찾기 위해 사용 되는 현재 문화권을 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>An object that represents the current culture.</source>
          <target state="translated">현재 문화권을 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">속성이로 설정 되어 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">속성이는 리소스 파일을 찾는 데 사용할 수 없는 문화권 이름으로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">리소스 파일 이름에는 문자, 숫자, 하이픈 또는 밑줄만 포함 해야 합니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">현재 스레드에 대 한 런타임 호출 가능 래퍼 (RCW)의 자동 정리를 해제합니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">기본적으로 공용 언어 런타임 (CLR) 런타임 호출 가능 래퍼 자동으로 정리 합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:      -   The application does its own message pumping.</source>
          <target state="translated">CLR 비정상적인는 다음 조건을 충족 하는 몇 가지 응용 프로그램에서 재진입 문제를 일으킬 수 있는 정리 하는 동안 메시지를 펌핑:-응용 프로그램 자체 메시지 펌프를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">-응용 프로그램 메시지 펌핑이 발생 하는 경우에 정확 하 게 제어 해야 합니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such applications can use the DisableComObjectEagerCleanup method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">이러한 응용 프로그램 DisableComObjectEagerCleanup 메서드를 사용 하 여 CLR 런타임 호출 가능 래퍼를 자동으로 회수 것는 것을 방지 수 있습니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">스레드에서이 메서드를 호출 하는 경우 자동 정리를 해당 스레드에 대 한 다시 활성화 수 없습니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application is ready to clean up runtime callable wrappers, use the &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt; method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">사용 하 여 응용 프로그램 런타임 호출 가능 래퍼를 정리 하도록 준비 되 면는 &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;메서드를 현재 컨텍스트의 모든 런타임 호출 가능 래퍼를 정리 하도록 런타임에 지시 합니다.&lt;/xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">메시지 펌프 메서드가 실행 하는 동안 발생 합니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">입력 스레드 중단 또는 처리 되지 않은 예외가 현재 작업에 만된 있는 코드 영역이 실행 될 호스트에 알립니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Microsoft SQL Server 2005와 같은 공용 언어 런타임 (CLR)의 호스트에는 코드의 중요 하 고 중요 하지 않은 영역에서 발생 한 실패에 대해 다른 정책을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">중요 한 영역을는 하는 스레드 중단 또는 처리 되지 않은 예외가 국한 되지 않는 현재 작업에 하나입니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">반면, 한 중단 이나 오류 코드는 중요 하지 않은 영역에서 오류가 발생 하는 작업을만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">예를 들어 잠금을 보유 하는 동안 메모리를 할당 하려고 시도 하는 작업을 살펴보겠습니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">메모리 할당이 실패 하면 현재 작업이 중단 만으로는의 안정성을 보장 하는 &lt;xref:System.AppDomain&gt;도메인에 동일한 잠금을 대기 하는 다른 작업이 있을 수 있으므로,.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">현재 작업이 종료 되는 경우 다른 작업 교착 상태가 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">중요 한 영역에서 오류가 발생 하는 경우 호스트는 전체 언로드 결정할 수 &lt;xref:System.AppDomain&gt;하지 않고는 잠재적으로 불안정 한 상태에서 실행을 계속 위험.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.</source>
          <target state="translated">코드의 중요 영역 시작 하는 호스트에 제공, &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.&lt;/xref:System.Threading.Thread.BeginCriticalRegion%2A&gt; 호출</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call EndCriticalRegion when execution returns to a non-critical region of code.</source>
          <target state="translated">중요 하지 않은 코드 영역이 실행이 반환 하는 경우 EndCriticalRegion를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">관리 코드는 호스트의 현재 실제 운영 체제 스레드의 id에 종속 되는 명령의 실행을 완료 했음을 알립니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Microsoft SQL Server 2005 등 공용 언어 런타임의 일부 호스트는 고유한 스레드 관리를 제공합니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">고유한 스레드 관리를 제공 하는 호스트 간에 이동할 수는 실행 중인 작업 실제 운영 체제 스레드 간에 언제 든 지 합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">이 전환 하 여 대부분의 작업 영향을 받지 않습니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">그러나 일부 작업에는 스레드 선호도-즉, 실제 운영 체제 스레드의 id에 종속 됩니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">이러한 작업은 코드를 안을 실행 하는 동안 호스트에 게 알려야 합니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt; before acquiring the lock, and EndThreadAffinity after releasing the lock.</source>
          <target state="translated">예를 들어, 스레드 선호도 Win32 CRITICAL_SECTION 갖는 응용 프로그램 호출 시스템 API를 운영 체제를 획득을 잠그는 경우에 호출 해야 &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;잠금 및 EndThreadAffinity 잠금을 해제 한 후에 획득 하기 전에.&lt;/xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">호출자에 게 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Gets an &lt;xref:System.Threading.ExecutionContext&gt; object that contains information about the various contexts of the current thread.</source>
          <target state="translated">가져옵니다는 &lt;xref:System.Threading.ExecutionContext&gt;현재 스레드의 다양 한 컨텍스트 정보가 들어 있는 개체입니다.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Threading.ExecutionContext&gt; class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">&lt;xref:System.Threading.ExecutionContext&gt;클래스는 실행의 논리적 스레드와 관련 된 모든 정보에 대 한 단일 컨테이너를 제공 합니다.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">보안 컨텍스트, 호출 컨텍스트에, 동기화 컨텍스트, 지역화 컨텍스트 및 트랜잭션 컨텍스트가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Threading.ExecutionContext&gt; object that consolidates context information for the current thread.</source>
          <target state="translated">&lt;xref:System.Threading.ExecutionContext&gt;현재 스레드에 대 한 컨텍스트 정보를 통합 하는 개체입니다.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">리소스가 해제 되 고 가비지 수집기가 회수 하는 경우 다른 정리 작업이 수행 되도록는 <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector calls Finalize when the current object is ready to be finalized.</source>
          <target state="translated">현재 개체가 종료 될 때 가비지 수집기에서 Finalize를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">이름 및 프로세스의 모든 스레드에 대 한 슬롯 간의 연관이 없앱니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">성능 향상을 위해 표시 된 필드를 사용 하 여는 &lt;xref:System.ThreadStaticAttribute&gt;특성을 대신 합니다.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 &lt;xref:System.ThreadStaticAttribute&gt;특성) 및 데이터 슬롯.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">호출 스레드에서 <ph id="ph1">`FreeNamedDataSlot`</ph>를 호출 하는 다른 스레드가 &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;이름이 같은 이름과 연결 된 새 슬롯을 할당 합니다.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">에 대 한 후속 호출 <ph id="ph1">`GetNamedDataSlot`</ph> 스레드에서 새 슬롯을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, any thread that still has a &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt; returned by an earlier call to <ph id="ph1">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">그러나 모든 스레드는 여전히에 &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;한 이전 호출에서 반환 된 <ph id="ph1">`GetNamedDataSlot`</ph> 계속는 이전 슬롯을 사용할 수 있습니다.&lt;/xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">이름에 연결 되어 있는 슬롯 해제 될 경우에만 모든 <ph id="ph1">`LocalDataStoreSlot`</ph> 호출 하기 전에 가져온 <ph id="ph2">`FreeNamedDataSlot`</ph> 이 해제 되 고 가비지 수집 합니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">데이터 슬롯은 스레드당 고유 합니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">해제할 데이터 슬롯의 이름입니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value indicating the apartment state.</source>
          <target state="translated">반환 된 <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 아파트 상태를 나타내는 값입니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method, along with the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">이 메서드를 함께 &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;메서드 및 &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;메서드를 대체는 &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;속성.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the apartment state of the managed thread.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 관리 되는 스레드의 아파트 상태를 나타내는 값입니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">기본값은 <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">반환 된 <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 현재 스레드 스택을 캡처하는 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">이 메서드는 더 이상 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">없음.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">모든 경우</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">현재 스레드의 도메인 내에서 현재 스레드의 지정된 된 슬롯에서 값을 검색 합니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">성능 향상을 위해 표시 된 필드를 사용 하 여는 &lt;xref:System.ThreadStaticAttribute&gt;특성을 대신 합니다.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 &lt;xref:System.ThreadStaticAttribute&gt;특성) 및 데이터 슬롯.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">데이터 슬롯은 스레드당 고유 합니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  GetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; GetData는는 <ph id="ph2">`Shared`</ph> 항상 다른 스레드를 참조 하는 변수를 사용 하 여 호출 하는 경우에 현재 실행 중인 스레드에 적용 되는 메서드.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">혼동을 피하기 위해 사용 하 여 클래스 이름을 호출할 때 <ph id="ph1">`Shared`</ph> 메서드: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to get the value.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값을 얻을 수 있는 합니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The retrieved value.</source>
          <target state="translated">검색 된 값입니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">현재 스레드가 실행 되 고 있는 현재 도메인을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current application domain of the running thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 실행 중인 스레드의 현재 응용 프로그램 도메인을 나타내는입니다.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">고유한 응용 프로그램 도메인 식별자를 반환합니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">응용 프로그램 도메인을 고유 하 게 식별 하는 32 비트 부호 있는 정수입니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">현재 스레드에 대 한 해시 코드를 반환합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">해시 코드는 고유 하 게 보장 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property if you need a unique identifier for a managed thread.</source>
          <target state="translated">사용 하 여는 &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;관리 되는 스레드에 대 한 고유 식별자가 필요한 경우 속성을 사용 합니다.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>An integer hash code value.</source>
          <target state="translated">정수 해시 코드 값입니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Looks up a named data slot.</source>
          <target state="translated">명명된 된 데이터 슬롯을 찾습니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">성능 향상을 위해 표시 된 필드를 사용 하 여는 &lt;xref:System.ThreadStaticAttribute&gt;특성을 대신 합니다.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 &lt;xref:System.ThreadStaticAttribute&gt;특성) 및 데이터 슬롯.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">데이터 슬롯은 스레드당 고유 합니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">명명 된 슬롯 존재 하지 않는 경우 새 슬롯 할당 됩니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">명명 된 데이터 슬롯은 공용 이며 다른 사용자에 의해 조작 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The name of the local data slot.</source>
          <target state="translated">로컬 데이터 슬롯의 이름입니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> allocated for this thread.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 스레드에 대해 할당 된 합니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Interrupts a thread that is in the <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> thread state.</source>
          <target state="translated">에 있는 스레드를 중단 된 <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 스레드 상태입니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">이 스레드가 대기, 대기 또는 조인 상태에 현재 차단 되지 않은 경우 차단 하는 다음 시작 될 때 중단 됩니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ThreadInterruptedException&gt; is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadInterruptedException&gt;중단된 된 스레드의에서 수행 되지만 해당 스레드는 차단 throw 됩니다.&lt;/xref:System.Threading.ThreadInterruptedException&gt;</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">스레드가 차단 되지 않으면 예외가 throw 되지 및 스레드가 중단 없이 완료할 수 있으므로 합니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">호출자에 게 적절 한 없는 <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">현재 스레드의 실행 상태를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread has been started and has not terminated normally or aborted; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>이 스레드가 시작 되었는지을 하지 않았으면 정상적으로 종료 또는 중단 되었습니다. 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">스레드가 배경 스레드인지 여부를 나타내는 값을 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">스레드는 백그라운드 스레드 이거나 포그라운드 스레드는.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">백그라운드 스레드는 백그라운드 스레드 프로세스를 종료 하는 것을 금지 하지 않는 점을 제외 하 고 포그라운드 스레드를 동일 합니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">프로세스에 속한 모든 포그라운드 스레드가 중단 되 면 공용 언어 런타임에서 프로세스를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">나머지 모든 백그라운드 스레드 중단 되 고 완료 하지 마세요.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground (that is, their IsBackground property returns <ph id="ph1">`false`</ph>):      -   The primary thread (or main application thread).</source>
          <target state="translated">기본적으로 다음 스레드 포그라운드에서 실행 (즉, 해당 IsBackground 속성에서 반환 <ph id="ph1">`false`</ph>):-기본 스레드 (또는 주 응용 프로그램 스레드).</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a &lt;xref:System.Threading.Thread&gt; class constructor.</source>
          <target state="translated">-호출 하 여 만든 모든 스레드는 &lt;xref:System.Threading.Thread&gt;클래스 생성자.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the background  (that is, their IsBackground property returns <ph id="ph1">`true`</ph>):      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">기본적으로 백그라운드에서 실행 하는 다음 스레드 (즉, 해당 IsBackground 속성에서 반환 <ph id="ph1">`true`</ph>):-스레드 풀 스레드는 런타임에서 유지 관리 되는 작업자 스레드의 풀 인 합니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadPool&gt;클래스&lt;/xref:System.Threading.ThreadPool&gt; 를 사용 하 여 스레드 풀에서 스레드 풀 및 일정 작업을 구성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 작업 기반 비동기 작업을 스레드 풀 스레드에서 자동으로 실행 합니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-비관리 코드에서 관리 되는 실행 환경에 들어가는 모든 스레드입니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread is or is to become a background thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>이 스레드가 백그라운드 스레드 이거나 백그라운드 스레드가; 될 예정 이면 하는 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The thread is dead.</source>
          <target state="translated">스레드가 중지 되었습니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">스레드가 관리 되는 스레드 풀에 속하는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>스레드 풀 관리<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread belongs to the managed thread pool; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>이 스레드가 관리 되는 스레드 풀;에 속하는 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> pumping.</source>
          <target state="translated">표준 COM 수행 하면서이 인스턴스가 나타내는 스레드가 종료 될 때까지 호출 스레드를 차단 하 고 <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 펌핑 합니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose Join method is called has completed.</source>
          <target state="translated">공간 연결은 스레드가 해당 조인 메서드는 완료 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 방법을입니다.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">이 메서드를 사용 하 여 스레드가 종료 되었는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">스레드가 종료 되지 않는 경우 호출자에 게는 무기한으로 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the Join method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block until <ph id="ph4">`Thread2`</ph> has completed.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">`Thread1`</ph> 의 조인 메서드를 호출 하는 스레드 <ph id="ph2">`Thread2`</ph>,으로 구독이 <ph id="ph3">`Thread1`</ph> 될 때까지 차단 하려면 <ph id="ph4">`Thread2`</ph> 완료 되었습니다.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept><ept id="p3">]</ept>       If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept> <ept id="p3">]</ept> 스레드가 이미 종료 되는 경우 &lt;xref:System.Threading.Thread.Join%2A&gt;메서드가 즉시 반환 호출 됩니다.&lt;/xref:System.Threading.Thread.Join%2A&gt;  </target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!WARNING]</ph> &gt;  You should never call the Join method of the &lt;xref:System.Threading.Thread&gt; object that represents the current thread from the current thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!WARNING]</ph> &gt;의 Join 메서드를 호출 하지 말아야는 &lt;xref:System.Threading.Thread&gt;현재 스레드에서 현재 스레드를 나타내는 개체입니다.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,       This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">이렇게 하면 현재 스레드가 자체에 제한이 없음을,이 방법 변경 놓입니다 앱 &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt; 포함 하도록 호출 스레드의 상태</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">호출할 수 없습니다 <ph id="ph1">`Join`</ph> 중인 스레드에서 &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;상태.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">호출자에 있는 스레드는 <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 상태입니다.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">스레드가 대기 하는 동안 중단 되었습니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">표준 COM 및 SendMessage 펌프 계속 수행 하면서이 인스턴스가 나타내는 스레드가 종료 될 때까지 호출 스레드 되거나 지정 된 시간이 경과할를 차단 합니다.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">공간 연결은 스레드 중 하나가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 방법을 인 &lt;xref:System.Threading.Thread.Join%2A&gt;메서드는 완료 된 시간 제한 간격이 경과 또는.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">`Thread1`</ph> 호출 스레드는 &lt;xref:System.Threading.Thread.Join&gt;메서드 <ph id="ph2">`Thread2`</ph>,으로 구독이 <ph id="ph3">`Thread1`</ph> 할 때 까지는 차단 하도록 <ph id="ph4">`Thread2`</ph> 완료 2 분이 지난 또는.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for the <ph id="ph1">`millisecondsTimeout`</ph> parameter, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept> <ept id="p3">]</ept> 경우 &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;에 대해 지정 된는 <ph id="ph1">`millisecondsTimeout`</ph> 매개 변수를이 똑같이 동작의 &lt;xref:System.Threading.Thread.Join&gt;반환 값을 제외한 메서드 오버 로드.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">스레드가 이미 종료 되는 경우 &lt;xref:System.Threading.Thread.Join%2A&gt;메서드가 즉시 반환 호출 됩니다.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">이 메서드 &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt; 포함 하도록 호출 스레드의 상태를 변경 합니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">호출할 수 없습니다 <ph id="ph1">`Join`</ph> 중인 스레드에서 &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;상태.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">스레드가 종료 되기를 기다릴 밀리초 수입니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread has terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우에 스레드가 종료 됩니다. <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 로 지정 된 시간 동안 스레드가 종료 되지 않은 경우는 <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p3">&lt;/code&gt;</ept> 경과 된 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds.</source>
          <target state="translated">값 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p1">&lt;/code&gt;</ept> 가 음수이 고 같지 않으면 <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> (밀리초)입니다.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The thread has not been started.</source>
          <target state="translated">스레드가 시작 되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">표준 COM 및 SendMessage 펌프 계속 수행 하면서이 인스턴스가 나타내는 스레드가 종료 될 때까지 호출 스레드 되거나 지정 된 시간이 경과할를 차단 합니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">공간 연결은 스레드 중 하나가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 방법을 인 &lt;xref:System.Threading.Thread.Join%2A&gt;메서드는 완료 된 시간 제한 간격이 경과 또는.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">`Thread1`</ph> 호출 스레드는 &lt;xref:System.Threading.Thread.Join&gt;메서드 <ph id="ph2">`Thread2`</ph>,으로 구독이 <ph id="ph3">`Thread1`</ph> 할 때 까지는 차단 하도록 <ph id="ph4">`Thread2`</ph> 완료 2 분이 지난 또는.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for <ph id="ph1">`timeout`</ph>, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept> <ept id="p3">]</ept> 경우 &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;에 대해 지정 된 <ph id="ph1">`timeout`</ph>,이 메서드는 동일 하 게 동작의 &lt;xref:System.Threading.Thread.Join&gt;반환 값을 제외한 메서드 오버 로드.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">스레드가 이미 종료 되는 경우 &lt;xref:System.Threading.Thread.Join%2A&gt;메서드가 즉시 반환 호출 됩니다.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the current thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">이 메서드 &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt; 포함 하도록 현재 스레드의 상태를 변경 합니다.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">호출할 수 없습니다 <ph id="ph1">`Join`</ph> 중인 스레드에서 &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;상태.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated">A &lt;xref:System.TimeSpan&gt;스레드가 종료 되기를 기다릴 시간으로 설정 합니다.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우에 스레드가 종료 됩니다. <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 로 지정 된 시간 동안 스레드가 종료 되지 않은 경우는 <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p3">&lt;/code&gt;</ept> 경과 된 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">값 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> 가 음수이 고 같지 않으면 <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> 밀리초에서 보다 큰 <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> 시간 (밀리초)입니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">호출자에 있는 스레드는 <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 상태입니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">현재 관리 되는 스레드에 대 한 고유 식별자를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread's ManagedThreadId property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">해당 스레드는 프로세스 내에서 고유 하 게 식별 하는 스레드의 ManagedThreadId 속성 값이 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the ManagedThreadId property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">공용 언어 런타임을 호스트 하는 관리 되지 않는 코드에서 스레드를 파이버를 구현 하는 경우에 ManagedThreadId 속성의 값에서 시간에 따라 달라 지지 않습니다.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">이 관리 되는 스레드에 대 한 고유 식별자를 나타내는 정수입니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</source>
          <target state="translated">다음과 같이 메모리 액세스를 동기화 합니다: 현재 스레드를 실행 하는 프로세서 등의 지침을 변경할 수 없습니다 MemoryBarrier에 대 한 호출 이후의 메모리 액세스 뒤에 MemoryBarrier에 대 한 호출 이전의 메모리 액세스가 하는 방식으로 실행 합니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>MemoryBarrier is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated">MemoryBarrier는 메모리 (예: 여러 Intel Itanium 프로세서를 사용 하는 시스템) 순서가 있는 경우 하나의 다중 프로세서 시스템에만 필요 합니다.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the &lt;xref:System.Threading.Monitor&gt; class provide easier ways to synchronize data.</source>
          <target state="translated">대부분의 용도 C#에 대 한 <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 또는 &lt;xref:System.Threading.Monitor&gt;편리 하 게 데이터를 동기화 할 클래스를 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">스레드의 이름을 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is write-once.</source>
          <target state="translated">이 속성은 쓰기-되 면입니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the default value of a thread's Name property is <ph id="ph1">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph2">`null`</ph>.</source>
          <target state="translated">스레드 이름 속성의 기본값은 때문에 <ph id="ph1">`null`</ph>, 여부 이름을 이미 명시적으로 할당 된 스레드를 사용 하 여 비교 하 여 확인할 수 있습니다 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string assigned to the Name property can include any Unicode character.</source>
          <target state="translated">Name 속성에 할당 된 문자열 모든 유니코드 문자를 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>A string containing the name of the thread, or <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if no name was set.</source>
          <target state="translated">스레드의 이름을 포함 하는 문자열 또는 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 설정 된 이름이 있는 경우.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>A set operation was requested, but the <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> property has already been set.</source>
          <target state="translated">Set 작업을 요청 했지만, 하지만 <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 속성이 이미 설정 되었습니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">스레드의 예약 우선 순위를 나타내는 값을 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can be assigned any one of the following priority &lt;xref:System.Threading.ThreadPriority&gt; values:      -   <ph id="ph1">`Highest`</ph><ph id="ph2">      -   </ph><ph id="ph3">`AboveNormal`</ph><ph id="ph4">      -   </ph><ph id="ph5">`Normal`</ph><ph id="ph6">      -   </ph><ph id="ph7">`BelowNormal`</ph><ph id="ph8">      -   </ph><ph id="ph9">`Lowest`</ph>       Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">스레드 중 하나라도 다음과 같은 우선 순위를 할당할 수 있습니다 &lt;xref:System.Threading.ThreadPriority&gt;값:- <ph id="ph1">`Highest`</ph> <ph id="ph2">      -   </ph> <ph id="ph3">`AboveNormal`</ph> <ph id="ph4">      -   </ph> <ph id="ph5">`Normal`</ph> <ph id="ph6">      -   </ph> <ph id="ph7">`BelowNormal`</ph> <ph id="ph8">      -   </ph> <ph id="ph9">`Lowest`</ph> 운영 체제 스레드의 우선 순위를 준수 하지 않아도 됩니다.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">기본값은 <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The thread has reached a final state, such as <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">스레드가 같은 최종 상태에 도달 <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is not a valid <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">Set 작업은 올바른 아닙니다 변수에 지정한 값이 <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Cancels an &lt;xref:System.Threading.Thread.Abort*&gt; requested for the current thread.</source>
          <target state="translated">취소는 &lt;xref:System.Threading.Thread.Abort*&gt;현재 스레드에 대 한 요청.&lt;/xref:System.Threading.Thread.Abort*&gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">이 메서드는 적절 한 사용 권한 가진 코드에서 호출할 수만 있습니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt;.</source>
          <target state="translated">호출할 때 <ph id="ph1">`Abort`</ph> 시스템 스레드를 종료 하에 &lt;xref:System.Threading.ThreadAbortException&gt;.&lt;/xref:System.Threading.ThreadAbortException&gt; 에서 throw</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>응용 프로그램 코드에서 발견 될 수 있지만 하지 않는 한 catch 블록의 끝에 다시 throw 되는 특별 한 예외는 <ph id="ph2">`ResetAbort`</ph> 라고 합니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>중단을 요청을 취소 하 고 방지는 <ph id="ph2">`ThreadAbortException`</ph> 의 스레드를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>See &lt;xref:System.Threading.ThreadAbortException&gt; for an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method.</source>
          <target state="translated">참조 &lt;xref:System.Threading.ThreadAbortException&gt;호출 방법을 보여 주는 예제는 <ph id="ph1">`ResetAbort`</ph> 메서드.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> was not invoked on the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>현재 스레드에서 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">호출자에 게 현재 스레드에 대 한 필수 보안 사용 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">일시 중단 된 스레드를 다시 시작 합니다.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">스레드가 시작 되지 않은, 또는 일시 중단 된 상태가 아닙니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">호출자에 게 적절 한 없는 <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">시작 하기 전에 스레드의 아파트 상태를 설정 합니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">새 스레드가 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;아파트 상태 설정 있지 않은 경우 되어 시작 되기 전에.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">스레드가 시작 되기 전에 아파트 상태를 설정 해야 합니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;에 주 응용 프로그램 초기화 됩니다 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;기본적으로.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">주 응용 프로그램 스레드의 아파트 상태를 설정 하는 유일한 방법은 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;적용 하는 것은 &lt;xref:System.STAThreadAttribute&gt;진입점 메서드 특성.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">SetApartmentState 메서드와 함께 &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;메서드 및 &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;메서드를 대체는 &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;속성.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">새 아파트 상태입니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>가 잘못 된 아파트 상태가 아닙니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">스레드가 이미 시작 되었습니다.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">아파트 상태가 이미 초기화 되었습니다.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Applies a captured <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the current thread.</source>
          <target state="translated">캡처한 적용 <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 현재 스레드에 있습니다.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">이 메서드는 더 이상 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to be applied to the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 현재 스레드에 적용할 개체입니다.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">모든 경우</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">해당 스레드의 현재 도메인에 대해 현재 실행 중인 스레드의 지정된 된 슬롯에서 데이터를 설정합니다.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>For better performance, use fields marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">성능 향상을 위해 표시 된 필드를 사용 하 여는 &lt;xref:System.ThreadStaticAttribute&gt;특성을 대신 합니다.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 &lt;xref:System.ThreadStaticAttribute&gt;특성) 및 데이터 슬롯.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the &lt;xref:System.Threading.Thread&gt; object has been reclaimed by garbage collection.</source>
          <target state="translated">스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드 프로시저 종료 된 후 다시 사용 하기 위해 슬롯을 해제 및 &lt;xref:System.Threading.Thread&gt;가비지 수집에서 회수 된 개체입니다.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">데이터 슬롯은 스레드당 고유 합니다.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  SetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; SetData는는 <ph id="ph2">`Shared`</ph> 항상 다른 스레드를 참조 하는 변수를 사용 하 여 호출 하는 경우에 현재 실행 중인 스레드에 적용 되는 메서드.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">혼동을 피하기 위해 사용 하 여 클래스 이름을 호출할 때 <ph id="ph1">`Shared`</ph> 메서드: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in which to set the value.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값을 설정 하는 합니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The value to be set.</source>
          <target state="translated">값을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">지정한 시간 (밀리초) 동안 현재 스레드를 일시 중단합니다.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">지정 된 시간 동안 운영 체제에서 스레드를 예약 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">이 메서드 &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt; 의 상태를 변경 합니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; for the <ph id="ph1">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">지정할 수 있습니다 &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;에 대 한는 <ph id="ph1">`millisecondsTimeout`</ph> 매개 변수를 무기한으로 스레드를 일시 중단 합니다.&lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">하지만 다른를 사용 하는 권장 &lt;xref:System.Threading?displayProperty=fullName&gt;와 같은 클래스 &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, 또는 &lt;xref:System.Threading.Semaphore&gt;대신 동기화 할 스레드에 또는 리소스 관리.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">특정 속도로 시스템 클록 틱 클록 해상도 호출합니다.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">실제 시간 제한은 정확 하 게 지정된 된 제한 시간을 지정된 된 제한 시간 클록 틱 일치 하 게 조정 될 것 이므로 아닐 수 있습니다.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">클록의 해상도 대기 시간에 대 한 자세한 내용은 참조는 <bpt id="p1">[</bpt>함수 절전<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">이 메서드를 호출는 <bpt id="p1">[</bpt>함수 절전<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> Windows 시스템 Api에서에서 합니다.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">이 메서드는 표준 COM 및 SendMessage 펌프를 수행 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 있는 스레드를 대기 해야 하는 경우 &lt;xref:System.STAThreadAttribute&gt;, 표준 COM 및 SendMessage 펌프를 수행 하 고 오버 로드 중 하나를 사용 하는 것이 좋습니다. 하지만 &lt;xref:System.Threading.Thread.Join%2A&gt;시간 제한 간격을 지정 하는 메서드.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">스레드가 일시 중단 되는 시간 (밀리초)의 수입니다.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">하는 경우의 값은 <ph id="ph1">`millisecondsTimeout`</ph> 인수가&amp;0; 이면 스레드는 프로세스를 실행할 준비가 된 우선 순위가 같은 스레드에 해당 시간 조각의 나머지입니다.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">실행 준비가 된 우선 순위가 같은 다른 스레드가 없으면 현재 스레드의 실행을 일시 중단 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The time-out value is negative and is not equal to &lt;xref:System.Threading.Timeout.Infinite&gt;.</source>
          <target state="translated">시간 제한 값이 음수이 고 &lt;xref:System.Threading.Timeout.Infinite&gt;.&lt;/xref:System.Threading.Timeout.Infinite&gt; 과 같지 않은</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">지정 된 시간 동안 현재 스레드를 일시 중단합니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">지정 된 시간 동안 운영 체제에서 스레드를 예약 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">이 메서드 &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt; 의 상태를 변경 합니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt; for the <ph id="ph1">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">지정할 수 있습니다 &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;에 대 한는 <ph id="ph1">`timeout`</ph> 매개 변수를 무기한으로 스레드를 일시 중단 합니다.&lt;/xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">하지만 다른를 사용 하는 권장 &lt;xref:System.Threading?displayProperty=fullName&gt;와 같은 클래스 &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, 또는 &lt;xref:System.Threading.Semaphore&gt;대신 동기화 할 스레드에 또는 리소스 관리.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload of &lt;xref:System.Threading.Thread.Sleep%2A&gt; uses the total number of whole milliseconds in <ph id="ph1">`timeout`</ph>.</source>
          <target state="translated">이 오버 로드의 &lt;xref:System.Threading.Thread.Sleep%2A&gt;에서 정수 밀리초의 총 수를 사용 하 여 <ph id="ph1">`timeout`</ph>.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">소수 자릿수 밀리초는 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">이 메서드는 표준 COM 및 SendMessage 펌프를 수행 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 있는 스레드를 대기 해야 하는 경우 &lt;xref:System.STAThreadAttribute&gt;, 표준 COM 및 SendMessage 펌프를 수행 하 고 오버 로드 중 하나를 사용 하는 것이 좋습니다. 하지만 &lt;xref:System.Threading.Thread.Join%2A&gt;시간 제한 간격을 지정 하는 메서드.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">스레드가 일시 중단 된 시간의 양입니다.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">하는 경우의 값은 <ph id="ph1">`millisecondsTimeout`</ph> 인수는 <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, 스레드 프로세스를 실행할 준비가 된 우선 순위가 같은 스레드에 해당 시간 조각의 나머지 합니다.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">실행 준비가 된 우선 순위가 같은 다른 스레드가 없으면 현재 스레드의 실행을 일시 중단 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">값 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> 가 음수이 고 같지 않으면 <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> 밀리초에서 보다 큰 <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> 시간 (밀리초)입니다.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Causes a thread to wait the number of times defined by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">iterations</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">정의 하는 시간 동안 대기 하도록 스레드는 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">iterations</ph> <ept id="p1">&lt;/code&gt;</ept> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SpinWait method is useful for implementing locks.</source>
          <target state="translated">SpinWait 메서드는 잠금을 구현 하는 데 유용 합니다.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes in the .NET Framework, such as &lt;xref:System.Threading.Monitor&gt; and &lt;xref:System.Threading.ReaderWriterLock&gt;, use this method internally.</source>
          <target state="translated">.NET Framework에서와 같은 클래스 &lt;xref:System.Threading.Monitor&gt;및 &lt;xref:System.Threading.ReaderWriterLock&gt;,이 메서드를 내부적으로 사용 합니다.&lt;/xref:System.Threading.ReaderWriterLock&gt; &lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph1">`iterations`</ph> parameter.</source>
          <target state="translated">SpinWait 기본적으로 넣습니다 프로세서 매우 빽빽한 루프에서 지정한 루프 수로는 <ph id="ph1">`iterations`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">따라서 대기 시간은 프로세서의 속도에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contrast this with the &lt;xref:System.Threading.Thread.Sleep%2A&gt; method.</source>
          <target state="translated">이와 반대로와 &lt;xref:System.Threading.Thread.Sleep%2A&gt;메서드.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that calls &lt;xref:System.Threading.Thread.Sleep%2A&gt; yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">호출 하는 스레드 &lt;xref:System.Threading.Thread.Sleep%2A&gt;지정한 간격이&amp;0; 인 경우에 프로세서 시간의 현재 해당 조각의 나머지 부분을 만듭니다.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying a non-zero interval for &lt;xref:System.Threading.Thread.Sleep%2A&gt; removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">에 대 한&amp;0;이 아닌 간격 &lt;xref:System.Threading.Thread.Sleep%2A&gt;시간 간격이 경과할 때까지 스레드가 스레드 스케줄러에서 고려 대상에서 제거 합니다.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait is not generally useful for ordinary applications.</source>
          <target state="translated">SpinWait 일반적인 응용 프로그램에 일반적으로 유용 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; or a statement that wraps &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; (<ph id="ph1">`lock`</ph> in C# or <ph id="ph2">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">대부분의 경우에서.NET Framework; 제공한 동기화 클래스를 사용 해야 예를 들어 호출 &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;또는 래핑하는 문을 &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;(<ph id="ph1">`lock`</ph> C#에서 또는 <ph id="ph2">`SyncLock`</ph> Visual basic에서).&lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; &lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the SpinWait method in your loop.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 피하려면는 상태 변경이 임박을 알고 있는 경우와 같은 컨텍스트 전환 하는 드문 경우 루프에서 SpinWait 메서드 호출을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code SpinWait executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">SpinWait 실행 코드는 여러 개의 프로세서가 있는 컴퓨터에서 발생할 수 있는 문제를 방지 하도록 설계 되었습니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, SpinWait prevents processor starvation in certain situations.</source>
          <target state="translated">예를 들어, 하이퍼 스레딩 기술 채택 하는 여러 Intel 프로세서가 있는 컴퓨터, SpinWait 특정 상황에서는 프로세서 부족을 방지 합니다.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">스레드가 대기 시간을 정의 하는 32 비트 부호 있는 정수입니다.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">현재 인스턴스의 상태를 변경 하려면 운영 체제 <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">이 스레드는 &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;상태 이면 운영 체제 실행을 예약할 수 있습니다.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">스레드가 나타내는 메서드의 첫 번째 줄에서 실행이 시작 되는 &lt;xref:System.Threading.ThreadStart&gt;또는 &lt;xref:System.Threading.ParameterizedThreadStart&gt;스레드 생성자에 제공 합니다.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">참고 시작에 대 한 호출의 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If this overload is used with a thread created using a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;이 오버 로드를 사용 하 여 만든 스레드를 사용 하는 경우는 &lt;xref:System.Threading.ParameterizedThreadStart&gt;대리자 <ph id="ph2">`null`</ph> 스레드에서 실행 하는 메서드에 전달 됩니다.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">스레드가 종료 되 면 다시 호출 하 여 <ph id="ph1">`Start`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">스레드가 이미 시작 되었습니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">이 스레드를 시작할 수 있는 메모리가 부족 합니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">현재 인스턴스의 상태를 변경 하려면 운영 체제 <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>, 필요에 따라 스레드가 실행 하는 메서드에서 사용할 데이터가 들어 있는 개체를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">이 스레드는 &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;상태 이면 운영 체제 실행을 예약할 수 있습니다.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">스레드가 나타내는 메서드의 첫 번째 줄에서 실행이 시작 되는 &lt;xref:System.Threading.ThreadStart&gt;또는 &lt;xref:System.Threading.ParameterizedThreadStart&gt;스레드 생성자에 제공 합니다.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">참고 시작에 대 한 호출의 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">스레드가 종료 되 면 다시 호출 하 여 <ph id="ph1">`Start`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload and the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">이 오버 로드와 &lt;xref:System.Threading.ParameterizedThreadStart&gt;대리자 쉽게 데이터를 전달 하는 스레드 프로시저에 있지만 하는 방법 형식이 안전 하지 않은 모든 개체를이 오버 로드에 전달 될 수 있으므로.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">스레드 프로시저에 데이터를 전달 하는 보다 강력한 방법은 작업자 개체에 데이터 필드와 스레드 프로시저를 넣는 것입니다.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>스레드 만들기 및 시작 시 데이터 전달<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">스레드가 실행 하는 메서드에서 사용할 데이터가 들어 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">스레드가 이미 시작 되었습니다.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">이 스레드를 시작할 수 있는 메모리가 부족 합니다.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>This thread was created using a <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate instead of a <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> delegate.</source>
          <target state="translated">이 메서드를 사용 하 여 만든는 <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 대리자 대신는 <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">스레드를 일시 중단 하거나 스레드가 이미 일시 중단 된 경우 효과가 없습니다.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">스레드가 이미 일시 중단 된 경우이 메서드는 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Do not use the Suspend and &lt;xref:System.Threading.Thread.Resume%2A&gt; methods to synchronize the activities of threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 일시 중단을 사용 하지 않는 및 &lt;xref:System.Threading.Thread.Resume%2A&gt;스레드 활동을 동기화 하는 메서드.&lt;/xref:System.Threading.Thread.Resume%2A&gt;</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">일시 중단 하면 스레드 코드 실행 알 방법이 없습니다.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the &lt;xref:System.AppDomain&gt; might be blocked.</source>
          <target state="translated">보안 권한 확인 하는 동안 잠금을 유지 하는 동안 스레드를 일시 중단, 기타의 스레드는 &lt;xref:System.AppDomain&gt;차단 될 수 있습니다.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the &lt;xref:System.AppDomain&gt; that attempt to use that class are blocked.</source>
          <target state="translated">다른 스레드가 클래스 생성자를 실행 하는 동안 스레드 일시 중단 된 &lt;xref:System.AppDomain&gt;클래스는 차단 사용 하려고 하는.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">교착 상태는 매우 쉽게 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">스레드가 시작 되지 않은 또는 중단 합니다.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">호출자에 게 적절 한 없는 <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">이름 집합을 해당 디스패치 식별자 집합에 매핑합니다.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, MSDN Library를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">나중에 사용하도록 예약되어 있습니다.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">IID_NULL 이어야 합니다.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">전달 된 이름의 배열을 매핑할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
          <target state="translated">매핑할 이름의 수입니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">이름을 해석할 로캘 컨텍스트.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">이름에 해당 하는 Id를 받는 호출자가 할당 된 배열입니다.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">COM을 사용 하 여 런타임에 바인딩된 액세스 <ph id="ph1">`IDispatch`</ph> 인터페이스가 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">인터페이스에 대 한 형식 정보를 얻으려면 다음 사용할 수 있는 개체에 대 한 형식 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, MSDN Library를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
          <target state="translated">반환할 형식 정보입니다.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
          <target state="translated">형식 정보에 대 한 로캘 식별자입니다.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">요청 된 형식 정보 개체에 대 한 포인터를 받습니다.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">COM을 사용 하 여 런타임에 바인딩된 액세스 <ph id="ph1">`IDispatch`</ph> 인터페이스가 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">개체 (0 또는 1)를 제공 하는 형식 정보 인터페이스의 수를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, MSDN Library를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">개체에서 제공 하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">COM을 사용 하 여 런타임에 바인딩된 액세스 <ph id="ph1">`IDispatch`</ph> 인터페이스가 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">개체에서 노출 하는 메서드와 속성에 대 한 액세스를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">`IDispatch::Invoke`</ph>, MSDN Library를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
          <target state="translated">멤버를 식별 합니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">나중에 사용하도록 예약되어 있습니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">IID_NULL 이어야 합니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">인수를 해석할 로캘 컨텍스트입니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
          <target state="translated">호출의 컨텍스트를 설명 하는 플래그입니다.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">인수의 배열, 명명 된 인수 및 배열에 있는 요소 수에 대 한 수에 대 한 인수 Dispid의 배열에 포함 된 구조체에 대 한 포인터입니다.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">결과 저장 될 위치에 대 한 포인터입니다.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">예외 정보가 포함 된 구조에 대 한 포인터입니다.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">오류가 있는 첫 번째 인수의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">COM을 사용 하 여 런타임에 바인딩된 액세스 <ph id="ph1">`IDispatch`</ph> 인터페이스가 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">현재 스레드의 상태를 포함 하는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ThreadState property provides more specific information than the &lt;xref:System.Threading.Thread.IsAlive%2A&gt; property.</source>
          <target state="translated">ThreadState 속성 보다 더 구체적인 정보를 제공는 &lt;xref:System.Threading.Thread.IsAlive%2A&gt;속성.&lt;/xref:System.Threading.Thread.IsAlive%2A&gt;</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 스레드 상태 디버깅 시나리오에 대 한 관심만 유용 합니다.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">코드 스레드 활동을 동기화 할 스레드 상태를 사용해 해야 합니다.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the state of the current thread.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 현재 스레드의 상태를 나타내는 값입니다.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">초기 값은 <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">시작 하기 전에 스레드의 아파트 상태를 설정 합니다.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">새 스레드가 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;아파트 상태 설정 있지 않은 경우 되어 시작 되기 전에.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">스레드가 시작 되기 전에 아파트 상태를 설정 해야 합니다.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;에 주 응용 프로그램 초기화 됩니다 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;기본적으로.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">주 응용 프로그램 스레드의 아파트 상태를 설정 하는 유일한 방법은 &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;적용 하는 것은 &lt;xref:System.STAThreadAttribute&gt;진입점 메서드 특성.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The TrySetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">TrySetApartmentState 메서드와 함께 &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;메서드 및 &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;메서드를 대체는 &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;속성.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">새 아파트 상태입니다.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the apartment state is set; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>아파트 상태가 설정 됩니다. 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>가 잘못 된 아파트 상태가 아닙니다.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">스레드가 이미 시작 되었습니다.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">VolatileRead 및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileRead obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 VolatileRead 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 VolatileRead 에서도 및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 VolatileRead 나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; 필드에 대 한 모든 액세스 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 VolatileRead &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">필드의 값을 읽습니다.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">읽을 필드입니다.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">프로세서에서 해당 필드에 쓴 마지막 값입니다.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;설정 되며 VolatileWrite 동기화의 특별 한 경우에 있습니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileWrite ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 VolatileWrite 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 VolatileWrite 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;또는 VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하는 <ph id="ph2">`volatile`</ph> 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;또는 VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;동기화의 특별 한 경우에는.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">정상적인 상황에서는 C# <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 및 &lt;xref:System.Threading.Monitor&gt;클래스 보다 쉽게 대안을 제공 합니다.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">다중 프로세서 시스템에서 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">프로세서 캐시 플러시 필요할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">단일 프로세서 시스템 에서도 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;및 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;나 &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; C#에서 사용 하 여 <ph id="ph2">`volatile`</ph> 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt; 보장</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">에 값이 쓰여질 필드입니다.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">쓸 값입니다.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">호출 스레드가 현재 프로세서에서 실행할 준비가 되어 있는 다른 스레드에 실행 명령을 내리도록 합니다 하면 됩니다.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">운영 체제 스레드에 양도할 수를 선택 합니다.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">이 메서드가 성공 하면 현재 시간 조각에서 스레드의 나머지가 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">운영 체제의 우선 순위 및 실행할 수 있는 다른 스레드에서의 상태에 따라 다른 시간 조각에 대 한 호출 스레드를 예약 합니다.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">잠긴 호출 스레드를 실행 하는 프로세서로 제한 됩니다.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">운영 체제 해당 프로세서 유휴 또는 낮은 우선 순위의 스레드를 실행 하는 경우에 다른 프로세서로 실행을 전환 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">현재 프로세서에서 실행할 준비가 된 다른 스레드가 없는 운영 체제 실행을 생성 하지 않습니다 및이 메서드가 반환 <ph id="ph1">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">이 메서드는 플랫폼 호출을 사용할를 네이티브 Win32 호출 <ph id="ph1">`SwitchToThread`</ph> 함수입니다.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should call the Yield method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">호출 해야 플랫폼을 사용 하는 대신 메서드를 호출 하는 수익률 플랫폼 바이패스를 호출 하기 때문에 모든 사용자 지정 스레딩 동작 호스트 요청 했습니다.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the operating system switched execution to another thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>운영 체제; 다른 스레드로 실행을 전환 하는 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>