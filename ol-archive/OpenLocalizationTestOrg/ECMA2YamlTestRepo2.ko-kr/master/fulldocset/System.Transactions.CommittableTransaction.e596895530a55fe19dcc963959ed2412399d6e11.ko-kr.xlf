<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ccad41ad00ba86be0f4041b848c7b9b43afa6fe1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Transactions.CommittableTransaction.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1f6a063bfb2dd845caede00389db21813627d9a3</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c5dfad97f107ec792589460840ed49fc52c7bd8c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Describes a committable transaction.</source>
          <target state="translated">커밋할 수 있는 트랜잭션에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CommittableTransaction class provides an explicit way for applications to use a transaction, as opposed to using the &lt;xref:System.Transactions.TransactionScope&gt; class implicitly.</source>
          <target state="translated">CommittableTransaction 클래스를 사용 하지 않고 트랜잭션을 사용 하도록 응용 프로그램에 대 한 명시적으로 제공 된 &lt;xref:System.Transactions.TransactionScope&gt;암시적으로 클래스.&lt;/xref:System.Transactions.TransactionScope&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike the &lt;xref:System.Transactions.TransactionScope&gt; class, the application writer needs to specifically call the &lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt; and &lt;xref:System.Transactions.Transaction.Rollback%2A&gt; methods in order to commit or abort the transaction.</source>
          <target state="translated">와 달리는 &lt;xref:System.Transactions.TransactionScope&gt;클래스, 응용 프로그램 기록기를 명시적으로 호출 하는 데 필요한는 &lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;및 &lt;xref:System.Transactions.Transaction.Rollback%2A&gt;커밋하거나 트랜잭션을 중단 하 고 메서드.&lt;/xref:System.Transactions.Transaction.Rollback%2A&gt; &lt;/xref:System.Transactions.CommittableTransaction.Commit%2A&gt; &lt;/xref:System.Transactions.TransactionScope&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, only the creator of a transaction can commit the transaction.</source>
          <target state="translated">그러나 작성자만 콘텐츠 팩 트랜잭션의 트랜잭션을 커밋할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, copies of a committable transaction, obtained through the &lt;xref:System.Transactions.Transaction.Clone%2A&gt; method are not committable.</source>
          <target state="translated">따라서, 커밋할 수 있는 트랜잭션에의 복사본을 얻은 &lt;xref:System.Transactions.Transaction.Clone%2A&gt;메서드는 커밋할 수 없습니다.&lt;/xref:System.Transactions.Transaction.Clone%2A&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  It is recommended that you create implicit transactions using the &lt;xref:System.Transactions.TransactionScope&gt; class, so that the ambient transaction context is automatically managed for you.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 암시적 트랜잭션을 사용 하 여 만드는 것이 좋습니다.는 &lt;xref:System.Transactions.TransactionScope&gt;클래스, 앰비언트 트랜잭션 컨텍스트에 자동으로 관리 되도록.&lt;/xref:System.Transactions.TransactionScope&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should also use the &lt;xref:System.Transactions.TransactionScope&gt; and &lt;xref:System.Transactions.DependentTransaction&gt; class for applications that require the use of the same transaction across multiple function calls or multiple thread calls.</source>
          <target state="translated">또한 사용 해야는 &lt;xref:System.Transactions.TransactionScope&gt;및 &lt;xref:System.Transactions.DependentTransaction&gt;여러 함수 호출이 나 여러 스레드 호출에서 동일한 트랜잭션 사용 해야 하는 응용 프로그램에 대 한 클래스입니다.&lt;/xref:System.Transactions.DependentTransaction&gt; &lt;/xref:System.Transactions.TransactionScope&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on this model, see the <bpt id="p1">[</bpt>Implementing An Implicit Transaction Using Transaction Scope<ept id="p1">](http://msdn.microsoft.com/en-us/1ddba95e-7587-48b2-8838-708c275e7199)</ept> topic.</source>
          <target state="translated">이 모델에 대 한 자세한 내용은 참조는 <bpt id="p1">[</bpt>구현 하는 암시적 트랜잭션을 사용 하 여 트랜잭션 범위<ept id="p1">](http://msdn.microsoft.com/en-us/1ddba95e-7587-48b2-8838-708c275e7199)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Creating a CommittableTransaction does not automatically set the ambient transaction, which is the transaction your code executes in.</source>
          <target state="translated">CommittableTransaction 만드는 사용자 코드에서 실행 되는 앰비언트 트랜잭션을 자동으로 설정 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can get or set the ambient transaction by calling the static &lt;xref:System.Transactions.Transaction.Current%2A&gt; property of the global &lt;xref:System.Transactions.Transaction&gt; object.</source>
          <target state="translated">가져오거나 정적을 호출 하 여 앰비언트 트랜잭션을 설정할 수 있습니다 &lt;xref:System.Transactions.Transaction.Current%2A&gt;은 전역 &lt;xref:System.Transactions.Transaction&gt;개체입니다.&lt;/xref:System.Transactions.Transaction&gt; &lt;/xref:System.Transactions.Transaction.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on ambient transactions, see the " Managing Transaction Flow using TransactionScopeOption" section of the <bpt id="p1">[</bpt>Implementing An Implicit Transaction Using Transaction Scope<ept id="p1">](http://msdn.microsoft.com/en-us/1ddba95e-7587-48b2-8838-708c275e7199)</ept> topic.</source>
          <target state="translated">앰비언트 트랜잭션에 대 한 자세한 내용은의 "Managing 트랜잭션 흐름 TransactionScopeOption를 사용 하 여" 섹션을 참조 하십시오.는 <bpt id="p1">[</bpt>구현 하는 암시적 트랜잭션을 사용 하 여 트랜잭션 범위<ept id="p1">](http://msdn.microsoft.com/en-us/1ddba95e-7587-48b2-8838-708c275e7199)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the ambient transaction is not set, any operation on a resource manager is not part of that transaction.</source>
          <target state="translated">앰비언트 트랜잭션이 설정 되지 않은 경우 리소스 관리자에 대 한 작업 해당 트랜잭션의 일부가 아닙니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>You need to explicitly set and reset the ambient transaction, to ensure that resource managers operate under the right transaction context.</source>
          <target state="translated">명시적으로 설정 하 고 리소스 관리자 올바른 트랜잭션 컨텍스트 내에서 작동 하도록 앰비언트 트랜잭션이 다시 설정 해야 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Until a CommittableTransaction has been committed, all the resources involved with the transaction are still locked.</source>
          <target state="translated">CommittableTransaction의 커밋된 될 때까지 트랜잭션과 관련된 된 모든 리소스가 잠겨 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>A CommittableTransaction object cannot be reused.</source>
          <target state="translated">CommittableTransaction 개체를 다시 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once it has been committed or rolled back, it cannot be used again in a transaction or set as the current ambient transaction context.</source>
          <target state="translated">커밋 또는 롤백 되었는지가, 되 면 트랜잭션에서 다시 사용 하거나 현재 앰비언트 트랜잭션 컨텍스트로 설정 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Transactions.CommittableTransaction"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Transactions.CommittableTransaction"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>An attempt to create a transaction under Windows 98, Windows 98 Second Edition or Windows Millennium Edition.</source>
          <target state="translated">Windows 98, Windows 98 Second Edition 또는 Windows Millennium Edition에서 트랜잭션을 만들고 하려고 했습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Transactions.CommittableTransaction"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p2">&lt;/code&gt;</ept> value.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Transactions.CommittableTransaction"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 <bpt id="p2">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p2">&lt;/code&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The maximum amount of time the transaction can exist, before it is aborted.</source>
          <target state="translated">중단 되기 전에 트랜잭션이 있을 수는 최대 기간입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>An attempt to create a transaction under Windows 98, Windows 98 Second Edition or Windows Millennium Edition.</source>
          <target state="translated">Windows 98, Windows 98 Second Edition 또는 Windows Millennium Edition에서 트랜잭션을 만들고 하려고 했습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Transactions.CommittableTransaction"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified transaction options.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Transactions.CommittableTransaction"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정 된 트랜잭션 옵션을 사용 하 여 클래스입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Transactions.TransactionOptions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> structure that describes the transaction options to use for the new transaction.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Transactions.TransactionOptions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 트랜잭션 옵션을 사용 하 여 새 트랜잭션을 나타내는 구조입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>An attempt to create a transaction under Windows 98, Windows 98 Second Edition or Windows Millennium Edition.</source>
          <target state="translated">Windows 98, Windows 98 Second Edition 또는 Windows Millennium Edition에서 트랜잭션을 만들고 하려고 했습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;options&lt;/code&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;options&lt;/code&gt;</ph>잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Begins an attempt to commit the transaction asynchronously.</source>
          <target state="translated">트랜잭션을 커밋하는 비동기적으로 시도 시작 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns immediately, before the transaction has been completed.</source>
          <target state="translated">이 메서드는 트랜잭션이 완료 되기 전에 즉시 반환 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The transaction then commits on a different thread, and the <ph id="ph1">`asyncCallback`</ph> delegate is invoked when it has completed.</source>
          <target state="translated">트랜잭션 후 다른 스레드에서 커밋 및 <ph id="ph1">`asyncCallback`</ph> 완료 되지 않았을 때 대리자가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>After this method is called, you do not receive the outcome of the transaction until you call &lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;.</source>
          <target state="translated">이 메서드가 호출 된 후 나타나지 않으면 트랜잭션 결과 &lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;.&lt;/xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt; 를 호출 하기 전에</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The commit process may complete synchronously inside this method call.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 커밋 프로세스가이 메서드 호출 내 동기적으로 완료 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.AsyncCallback&gt; delegate that is invoked when the transaction completes.</source>
          <target state="translated">&lt;xref:System.AsyncCallback&gt;해당 트랜잭션이 완료 될 때 호출 되는 대리자입니다.&lt;/xref:System.AsyncCallback&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This parameter can be <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, in which case the application is not notified of the transaction's completion.</source>
          <target state="translated">이 매개 변수 수 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>,이 경우 응용 프로그램은 트랜잭션 완료의 알림을 받지 않습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Instead, the application must use the &lt;xref:System.IAsyncResult&gt; interface to check for completion and wait accordingly, or call &lt;xref:System.Transactions.CommittableTransaction.EndCommit*&gt; to wait for completion.</source>
          <target state="translated">대신, 응용 프로그램을 사용 해야 합니다는 &lt;xref:System.IAsyncResult&gt;완료 여부를 확인 하 고 대기, 인터페이스 또는 호출 &lt;xref:System.Transactions.CommittableTransaction.EndCommit*&gt;완료를 기다리는.&lt;/xref:System.Transactions.CommittableTransaction.EndCommit*&gt; &lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>An object, which might contain arbitrary state information, associated with the asynchronous commitment.</source>
          <target state="translated">개체에 연결 된 비동기 커밋과 임의의 상태 정보를 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This object is passed to the callback, and is not interpreted by <bpt id="p1">&lt;xref href="System.Transactions"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">이 개체는 콜백에 전달 되 고에서 해석 되지 않습니다 <bpt id="p1">&lt;xref href="System.Transactions"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A null reference is permitted.</source>
          <target state="translated">Null 참조일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.IAsyncResult&gt; interface that can be used by the caller to check the status of the asynchronous operation, or to wait for the operation to complete.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;을 비동기 작업의 상태를 확인 하거나 작업이 완료 될 때까지 대기 하는 호출자가 사용할 수 있는 인터페이스입니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Attempts to commit the transaction.</source>
          <target state="translated">트랜잭션을 커밋하는 시도 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is called, all objects that have registered to participate in the transaction are polled and can independently indicate their vote to either commit or roll back the transaction.</source>
          <target state="translated">이 메서드는 트랜잭션에 참여 하도록 등록 된 모든 개체 폴링을 수행 하 고 독립적으로 커밋 또는 트랜잭션을 여부를 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any participant votes to roll back the transaction, it is rolled back and this method throws a &lt;xref:System.Transactions.TransactionException&gt; exception.</source>
          <target state="translated">트랜잭션을 선택한 참가 요소 롤백됩니다 않으며이 메서드는 &lt;xref:System.Transactions.TransactionException&gt;예외.&lt;/xref:System.Transactions.TransactionException&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a normal occurrence for a transaction and your code should catch and process such exceptions.</source>
          <target state="translated">이 트랜잭션에 대 한 일반적으로 발생 하 고 코드를 catch 하 고 이러한 예외를 처리 해야 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Commit and &lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt; block until the first phase of transaction processing is complete.</source>
          <target state="translated">커밋 및 &lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;트랜잭션 처리의 첫 번째 단계 완료 될 때까지 차단 합니다.&lt;/xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>The first phase ends after all resource managers and enlistments in the transaction have voted on the transaction outcome and the &lt;xref:System.Transactions.TransactionManager&gt; has durably decided to commit or abort the transaction.</source>
          <target state="translated">첫 번째 단계는 모든 리소스 관리자 한 후 종료 하 고 트랜잭션에 인 리스트 먼 트 트랜잭션 결과에 투표 했 고 &lt;xref:System.Transactions.TransactionManager&gt;가 지 속력 있게 커밋하거나 트랜잭션을 중단 하 고 결정 됩니다.&lt;/xref:System.Transactions.TransactionManager&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>The second phase of processing is always asynchronous.</source>
          <target state="translated">처리의 두 번째 단계는 항상 비동기입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, there is no guarantee that data just committed from within a given transaction will be immediately available afterwards when not using another transaction to view this data.</source>
          <target state="translated">따라서은 커밋된 데이터를 바로에서 지정된 된 트랜잭션 내에서 사용할 수 있다는 즉시 나중에이 데이터를 다른 트랜잭션이 사용 하지 않을 때 아닙니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method blocks until the first phase of transaction processing is complete, you should be extremely careful when using this method in a Windows Form (WinForm) application, or a deadlock can occur.</source>
          <target state="translated">이 메서드 차단 트랜잭션 처리의 첫 번째 단계 완료 될 때까지, 매우 주의 해야는 Windows Form (WinForm) 응용 프로그램 또는 교착 상태에서이 메서드를 사용 하는 경우 발생할 수 있습니다 때문에.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call this method inside one WinForm Control event (for example, clicking a button), and use the synchronous &lt;xref:System.Windows.Forms.Control.Invoke%2A&gt; method to direct the control to perform some UI tasks (for example, changing colors) in the middle of processing the transaction, a deadlock will happen.</source>
          <target state="translated">(예: 단추 클릭), 하나의 WinForm 컨트롤 이벤트 내에서이 메서드를 호출 하 고 동기를 사용 하는 경우 &lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;컨트롤 교착 상태가 발생 하는 트랜잭션을 처리 하는 동안 일부 UI 작업 (예를 들어 변경 색)을 수행 하는 메서드.&lt;/xref:System.Windows.Forms.Control.Invoke%2A&gt;</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the &lt;xref:System.Windows.Forms.Control.Invoke%2A&gt; method is synchronous and blocks the worker thread until the UI thread finishes its job.</source>
          <target state="translated">때문에 이것이 &lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;메서드는 동기적 이므로 UI 스레드 작업을 완료 될 때까지 작업자 스레드를 차단 합니다.&lt;/xref:System.Windows.Forms.Control.Invoke%2A&gt;</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, in our scenario, the UI thread is also waiting for the worker thread to commit the transaction.</source>
          <target state="translated">시나리오에서 UI 스레드 또한 트랜잭션을 커밋하는 작업자 스레드 대기 됩니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is that none is able to proceed and the scope waits indefinitely for the Commit to finish.</source>
          <target state="translated">결과를 계속할 수 없는 및 범위는 커밋이 완료에 대 한 무기한 대기입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should use &lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt; rather than &lt;xref:System.Windows.Forms.Control.Invoke%2A&gt; wherever possible, because it is asynchronous and thus less prone to deadlock.</source>
          <target state="translated">사용 해야 &lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;대신 &lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;비동기적이 고 교착 상태가 발생할 가능성이 적으므로 이기 때문에 가능 합니다.&lt;/xref:System.Windows.Forms.Control.Invoke%2A&gt; &lt;/xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Commit is called on a transaction and the transaction becomes <bpt id="p1">&lt;xref href="System.Transactions.TransactionStatus"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">트랜잭션에 대해 커밋을 호출 되 고 트랜잭션이 트랜잭션이 <bpt id="p1">&lt;xref href="System.Transactions.TransactionStatus"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Commit is called and the transaction rolls back for the first time.</source>
          <target state="translated">커밋 라고 하 고 트랜잭션이 처음으로 롤백합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Ends an attempt to commit the transaction asynchronously.</source>
          <target state="translated">트랜잭션을 커밋하는 비동기적으로 시도 끝냅니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should call this method in the callback delegate specified as a parameter to the &lt;xref:System.Transactions.CommittableTransaction.BeginCommit%2A&gt; method, when you have finished any cleanup work associated with the asynchronous commitment.</source>
          <target state="translated">에 대 한 매개 변수로 지정 된 콜백 대리자에서이 메서드를 호출 해야는 &lt;xref:System.Transactions.CommittableTransaction.BeginCommit%2A&gt;메서드를 비동기 커밋과 관련 된 정리 작업을 완료 합니다.&lt;/xref:System.Transactions.CommittableTransaction.BeginCommit%2A&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also call this method early without waiting for the delegate.</source>
          <target state="translated">또한이 메서드는 대리자를 기다리지 않고 초기 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>If, by the time you call this method, the transaction has not completed, this method waits for its completion.</source>
          <target state="translated">이 메서드를 호출 하는 시점에서는 트랜잭션이 완료 되지 않은 경우이 메서드는 완료 되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  The &lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt; property returned by <ph id="ph2">`asyncResult`</ph> is always <ph id="ph3">`false`</ph>, even if the operation completed synchronously.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt;는 &lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;속성에서 반환 되 <ph id="ph2">`asyncResult`</ph> 항상 <ph id="ph3">`false`</ph>작업이 동기적으로 완료 하는 경우에.&lt;/xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt; and EndCommit block until the first phase of transaction processing is complete.</source>
          <target state="translated">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;및 트랜잭션 처리의 첫 번째 단계 완료 될 때까지 EndCommit 블록을 추가 합니다.&lt;/xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>The first phase ends after all resource managers and enlistments in the transaction have voted on the transaction outcome and the &lt;xref:System.Transactions.TransactionManager&gt; has durably decided to commit or abort the transaction.</source>
          <target state="translated">첫 번째 단계는 모든 리소스 관리자 한 후 종료 하 고 트랜잭션에 인 리스트 먼 트 트랜잭션 결과에 투표 했 고 &lt;xref:System.Transactions.TransactionManager&gt;가 지 속력 있게 커밋하거나 트랜잭션을 중단 하 고 결정 됩니다.&lt;/xref:System.Transactions.TransactionManager&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>The second phase of processing is always asynchronous.</source>
          <target state="translated">처리의 두 번째 단계는 항상 비동기입니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, there is no guarantee that data just committed from within a given transaction will be immediately available afterwards when not using another transaction to view this data.</source>
          <target state="translated">따라서은 커밋된 데이터를 바로에서 지정된 된 트랜잭션 내에서 사용할 수 있다는 즉시 나중에이 데이터를 다른 트랜잭션이 사용 하지 않을 때 아닙니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.IAsyncResult&gt; object associated with the asynchronous commitment.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;비동기 커밋과 관련 된 개체입니다.&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Transactions.CommittableTransaction.BeginCommit*&gt; is called and the transaction rolls back for the first time.</source>
          <target state="translated">&lt;xref:System.Transactions.CommittableTransaction.BeginCommit*&gt;호출 되 고 트랜잭션이 처음으로 롤백합니다.&lt;/xref:System.Transactions.CommittableTransaction.BeginCommit*&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Gets the object provided as the last parameter of the &lt;xref:System.Transactions.CommittableTransaction.BeginCommit*&gt; method call.</source>
          <target state="translated">마지막 매개 변수로 제공 된 개체를 가져옵니다는 &lt;xref:System.Transactions.CommittableTransaction.BeginCommit*&gt;메서드를 호출 합니다.&lt;/xref:System.Transactions.CommittableTransaction.BeginCommit*&gt;</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The object provided as the last parameter of the &lt;xref:System.Transactions.CommittableTransaction.BeginCommit*&gt; method call.</source>
          <target state="translated">마지막 매개 변수로 제공 된 개체는 &lt;xref:System.Transactions.CommittableTransaction.BeginCommit*&gt;메서드를 호출 합니다.&lt;/xref:System.Transactions.CommittableTransaction.BeginCommit*&gt;</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Gets a &lt;xref:System.Threading.WaitHandle&gt; that is used to wait for an asynchronous operation to complete.</source>
          <target state="translated">가져옵니다는 &lt;xref:System.Threading.WaitHandle&gt;비동기 작업이 완료 되기를 기다리는 데 사용 되는.&lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Threading.WaitHandle&gt; that is used to wait for an asynchronous operation to complete.</source>
          <target state="translated">A &lt;xref:System.Threading.WaitHandle&gt;비동기 작업이 완료 되기를 기다리는 데 사용 되는.&lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Gets an indication of whether the asynchronous commit operation completed synchronously.</source>
          <target state="translated">비동기 커밋 작업이 동기적으로 완료 여부를 나타내는 표시를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the asynchronous commit operation completed synchronously; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>비동기 커밋 작업이 동기적으로; 완료 하는 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This property always returns <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> even if the operation completed synchronously.</source>
          <target state="translated">이 속성은 항상 반환 <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 작업이 동기적으로 완료 하는 경우에 합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Gets an indication whether the asynchronous commit operation has completed.</source>
          <target state="translated">비동기 커밋 작업이 완료 되었는지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the operation is complete; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>이 작업을 완료 하는 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>