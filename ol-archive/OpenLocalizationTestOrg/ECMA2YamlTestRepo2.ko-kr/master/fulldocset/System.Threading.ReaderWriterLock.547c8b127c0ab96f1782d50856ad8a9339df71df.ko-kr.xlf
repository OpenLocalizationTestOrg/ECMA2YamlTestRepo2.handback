<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ec4eb6abc1cdf4de3aec918a6749eb637feb389</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.ReaderWriterLock.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9e2c24c218a229c81059e01f388a03a2f20ba07c</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc33aa4e80118dfe4cd1a4cad4ba16b2cf1248f7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines a lock that supports single writers and multiple readers.</source>
          <target state="translated">여러 판독기와 단일 작성기를 지 원하는 잠금을 정의 합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The <ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph> has two reader-writer locks, &lt;xref:System.Threading.ReaderWriterLockSlim&gt; and ReaderWriterLock.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;은 <ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph> 는 두 개의 판독기 및 작성기 잠금 &lt;xref:System.Threading.ReaderWriterLockSlim&gt;및 ReaderWriterLock.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is recommended for all new development.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;새로운 개발의 모든 것이 좋습니다.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;유사한 ReaderWriterLock, 재귀 및 업그레이드 및 잠금 상태를 다운 그레이드에 대 한 규칙 간소화 합니다.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; avoids many cases of potential deadlock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;대부분의 경우 잠재적인 교착 상태를 방지할 수 있습니다.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, the performance of &lt;xref:System.Threading.ReaderWriterLockSlim&gt; is significantly better than ReaderWriterLock.</source>
          <target state="translated">또한의 성능 &lt;xref:System.Threading.ReaderWriterLockSlim&gt;ReaderWriterLock 보다 훨씬 더 좋습니다.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>ReaderWriterLock is used to synchronize access to a resource.</source>
          <target state="translated">ReaderWriterLock은 리소스에 대 한 액세스를 동기화 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</source>
          <target state="translated">지정된 된 시간에 여러 스레드에 대 한 동시 읽기 액세스 하거나 단일 스레드에 대 한 쓰기 권한을 허용합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a situation where a resource is changed infrequently, a <ph id="ph1">`ReaderWriterLock`</ph> provides better throughput than a simple one-at-a-time lock, such as &lt;xref:System.Threading.Monitor&gt;.</source>
          <target state="translated">리소스 자주 변경 되는 경우에는 <ph id="ph1">`ReaderWriterLock`</ph> &lt;xref:System.Threading.Monitor&gt;.&lt;/xref:System.Threading.Monitor&gt; 같은 간단한 한 런타임 잠금 보다 처리량이 향상</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ReaderWriterLock`</ph> works best where most accesses are reads, while writes are infrequent and of short duration.</source>
          <target state="translated"><ph id="ph1">`ReaderWriterLock`</ph>대부분 액세스는 읽기에 쓰기가 자주 수행 되 고 짧은 기간 가장 잘 작동 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</source>
          <target state="translated">어떤 오랜 시간 동안 차단 되도록 여러 판독기와 단일 작성기 대체 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Holding reader locks or writer locks for long periods will starve other threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 오랜 시간 동안 다른 스레드에서 실행할 수 없게 됩니다에 대 한 잠금 판독기 또는 작성기 잠금을 보유 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>For best performance, consider restructuring your application to minimize the duration of writes.</source>
          <target state="translated">최상의 성능을 위해 쓰기의 기간을 최소화 하기 위해 응용 프로그램을 재구성 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can hold a reader lock or a writer lock, but not both at the same time.</source>
          <target state="translated">스레드 잠금 또는 기록기 잠금으로 하나만 동시에 판독기를 보유할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead of releasing a reader lock in order to acquire the writer lock, you can use &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;.</source>
          <target state="translated">판독기 잠금을 작성기 잠금을 획득 하기 위해 해제 하는 대신 &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; 및&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests increase the lock count on a lock.</source>
          <target state="translated">재귀적 잠금 요청에서 잠금을 잠금 수를 늘립니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>Readers and writers are queued separately.</source>
          <target state="translated">판독기와 작성기는 별도로 대기 됩니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</source>
          <target state="translated">작성기 잠금을 해제 하는 스레드를 즉시 판독기 queue에서 대기 중인 모든 스레드에 판독기 잠금이; 부여 됩니다. 때 모든 판독기 잠금이 해제 된, 작성기에서 다음 스레드 대기 중인 있는 경우 작성기 잠금이 부여 되 면 큐 등에입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other words, <ph id="ph1">`ReaderWriterLock`</ph> alternates between a collection of readers, and one writer.</source>
          <target state="translated">즉, <ph id="ph1">`ReaderWriterLock`</ph> 독자의 컬렉션과 기록기 간을 전환 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</source>
          <target state="translated">잠금이 해제 될 현재 판독기에 대 한 스레드 작성기 큐에서 대기 하는 동안 새 판독기 잠금을 요청 하는 스레드 판독기 큐에 누적 됩니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</source>
          <target state="translated">해당 요청은 권한을 부여 하지 동시 액세스 기존 판독기 잠금 소유자에 게;와 공유할 수 있지만 이 판독기에서 무한 중단에 대 한 작성자를 보호할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most methods for acquiring locks on a <ph id="ph1">`ReaderWriterLock`</ph> accept time-out values.</source>
          <target state="translated">잠금을 획득 하는 것에 대 한 대부분의 메서드는 <ph id="ph1">`ReaderWriterLock`</ph> 제한 시간 값을 허용 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use time-outs to avoid deadlocks in your application.</source>
          <target state="translated">응용 프로그램에서 교착 상태 방지 하려면 제한 시간을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</source>
          <target state="translated">스레드 수 하나의 리소스에 대해 작성기 잠금을 설정 하 고 두 번째 리소스;에 대 한 판독기 잠금을 요청 하는 예를 들어 그 동안에 다른 스레드에서 두 번째 리소스에 작성기 잠금을 설정 하 고 첫 번째 판독기 잠금을 요청 하 여 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unless time-outs are used, the threads deadlock.</source>
          <target state="translated">제한 시간을 사용 하지 않는 스레드 교착 상태가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">시간 제한 간격이 만료 되는 경우 잠금 요청이 허용 되지 않았음을 메서드가 제어를 호출 스레드로 &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt; throw 하 여</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can catch this exception and determine what action to take next.</source>
          <target state="translated">스레드 수이 예외를 catch 하 고을 수행 하는 작업을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Time-outs are expressed in milliseconds.</source>
          <target state="translated">제한 시간 (밀리초)로 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use a &lt;xref:System.TimeSpan?displayProperty=fullName&gt; to specify the time-out, the value used is the total number of whole milliseconds represented by the &lt;xref:System.TimeSpan&gt;.</source>
          <target state="translated">&lt;xref:System.TimeSpan?displayProperty=fullName&gt;제한 시간을 지정 하려면 사용 되는 값은에 &lt;xref:System.TimeSpan&gt;.&lt;/xref:System.TimeSpan&gt; 나타내는 정수 밀리초의 총 수는&lt;/xref:System.TimeSpan?displayProperty=fullName&gt; 를 사용 하는 경우</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows the valid time-out values in milliseconds.</source>
          <target state="translated">다음 표에서 시간 (밀리초)에 유효한 제한 시간 값을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>|Value|Description|   |-----------|-----------------|   |-1|The thread waits until the lock is acquired, regardless of how long it takes.</source>
          <target state="translated">| 값 | 설명 |   |-----------|-----------------|   |-1 | 스레드는 잠금을 얻으면 소요 되는 시간 될 때까지 대기 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>For methods that specify integer time-outs, the constant &lt;xref:System.Threading.Timeout.Infinite&gt; can be used.|   |0|The thread does not wait to acquire the lock.</source>
          <target state="translated">정수 제한 시간을 지정 하는 방법에 대 한 &lt;xref:System.Threading.Timeout.Infinite&gt;상수를 사용할 수 있습니다. |   |&amp;0; | 스레드 잠금을 기다리지 않습니다.&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the lock cannot be acquired immediately, the method returns.|   |&gt;0|The number of milliseconds to wait.|       With the exception of -1, negative time-out values are not allowed.</source>
          <target state="translated">메서드가 반환 하는 경우 잠금을 획득할 수 없는 즉시. |   | &gt;&amp;0; | 시간 (밀리초)의 수입니다. |       -1을 제외한 음수 시간 제한 값 허용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a negative integer other than -1, a time-out value of zero is used instead.</source>
          <target state="translated">-1이 아닌 음수를 지정 하는 경우 시간 제한 값이&amp;0;이 대신 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a &lt;xref:System.TimeSpan&gt; that represents a negative number of milliseconds other than -1, &lt;xref:System.ArgumentOutOfRangeException&gt; is thrown.</source>
          <target state="translated">(즉, 메서드는, 대기 하지 않고 즉시 잠금을 가져올 수 있는 경우) 지정 하는 경우는 &lt;xref:System.TimeSpan&gt;음수-1 이외의 시간 (밀리초)을 나타내는 &lt;xref:System.ArgumentOutOfRangeException&gt;throw 됩니다.&lt;/xref:System.ArgumentOutOfRangeException&gt; &lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">판독기를 획득 잠금, 사용 하는 &lt;xref:System.Int32&gt;제한 시간에 대 한 값.&lt;/xref:System.Int32&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>AcquireReaderLock blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">AcquireReaderLock 다른 스레드에 작성기 잠금이 있으면 하나 이상의 스레드가 기록기 잠금으로 인해 대기 하는 경우 차단 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 현재 스레드에 작성기 잠금이 이미 있으면 판독기 잠금이 획득 됩니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">대신, 작성기 잠금을 잠금 수가 증가 합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">이 자체 작성기 잠금을 차단에서 스레드를 차단 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">결과 정확 하 게 호출할 때와 동일 &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, 및를 추가로 호출 &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;는 작성기 잠금을 해제 하는 경우 필요 합니다.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>재귀적 판독기 잠금 요청을 지원합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">즉, 스레드 수 AcquireReaderLock를 여러 번 호출할 때마다 잠금 수를 증가입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">호출 해야 &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;호출할 때마다에 대해 한 번씩 <ph id="ph1">`AcquireReaderLock`</ph>.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">호출할 수 있습니다 &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;즉시&amp;0; 잠금 수를 줄일 수 있습니다.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">재귀적 잠금 요청은 항상 요청 하는 스레드의 판독기 큐에 배치 하지 않고 즉시, 부여 됩니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">오랜 시간 동안 작성기 잠금 요청을 차단 되지 않도록 주의 해야 재귀적 잠금을 사용.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">유효한 제한 시간 값에 대 한 참조 &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">밀리초 단위로 제한 시간입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>잠금 요청이 부여 되기 전에 만료 됩니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">판독기를 획득 잠금, 사용 하는 &lt;xref:System.TimeSpan&gt;제한 시간에 대 한 값.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt; blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;작성기 잠금을 보유 한 다른 스레드 또는 하나 이상의 스레드가 기록기 잠금으로 인해 대기 하는 경우 차단 합니다.&lt;/xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 현재 스레드에 작성기 잠금이 이미 있으면 판독기 잠금이 획득 됩니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">대신, 작성기 잠금을 잠금 수가 증가 합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">이 자체 작성기 잠금을 차단에서 스레드를 차단 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">결과 정확 하 게 호출할 때와 동일 &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, 및를 추가로 호출 &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;는 작성기 잠금을 해제 하는 경우 필요 합니다.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>재귀적 판독기 잠금 요청을 지원합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">즉, 스레드 수 AcquireReaderLock를 여러 번 호출할 때마다 잠금 수를 증가입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">호출 해야 &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;호출할 때마다에 대해 한 번씩 <ph id="ph1">`AcquireReaderLock`</ph>.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">호출할 수 있습니다 &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;즉시&amp;0; 잠금 수를 줄일 수 있습니다.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">재귀적 잠금 요청은 항상 요청 하는 스레드의 판독기 큐에 배치 하지 않고 즉시, 부여 됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">오랜 시간 동안 작성기 잠금 요청을 차단 되지 않도록 주의 해야 재귀적 잠금을 사용.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">유효한 제한 시간 값에 대 한 참조 &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated">A <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 제한 시간을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>잠금 요청이 부여 되기 전에 만료 됩니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>-1 밀리초 이외의 음수 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">작성기 획득 잠금, 사용 하는 &lt;xref:System.Int32&gt;제한 시간에 대 한 값.&lt;/xref:System.Int32&gt;</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">이 메서드는 다른 스레드가 판독기 잠금을 또는 작성기 잠금을 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">방법에 대 한 설명을 여러 동시 판독기 잠금을 작성기 잠금 대체 참조 &lt;xref:System.Threading.ReaderWriterLock&gt;클래스&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">판독기 잠금을 있는 스레드는 두 가지 방법 중 하나로 작성기 잠금을 획득할 수: AcquireWriterLock를 호출 하기 전에 판독기 잠금을 해제 하 여 또는 &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; 를 호출 하 여</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 스레드가 호출 하는 경우 <ph id="ph2">`AcquireWriterLock`</ph> 의 자체 판독기 잠금이 차단 됩니다 판독기 잠금으로 아직, 동안; 스레드가 교착 상태가 무한 한 제한 시간을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">이러한 교착 상태를 방지 하려면 사용 &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;현재 스레드에 판독기 잠금이 이미에 있는지 확인 하려면.&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>재귀적 작성기 잠금 요청을 지원합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">즉, 스레드 호출 수 <ph id="ph1">`AcquireWriterLock`</ph> 여러 번 있는 잠금 수가 때마다 커집니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">호출 해야 &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;호출할 때마다에 대해 한 번씩 <ph id="ph1">`AcquireWriterLock`</ph>.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">호출할 수 있습니다 &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;즉시&amp;0; 잠금 수를 줄일 수 있습니다.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">재귀적 잠금 요청은 항상 요청 하는 스레드의 작성기 큐에 배치 하지 않고 즉시, 부여 됩니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">유효한 제한 시간 값에 대 한 참조 &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">밀리초 단위로 제한 시간입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>잠금 요청이 부여 되기 전에 만료 됩니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">작성기 획득 잠금, 사용 하는 &lt;xref:System.TimeSpan&gt;제한 시간에 대 한 값.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">이 메서드는 다른 스레드가 판독기 잠금을 또는 작성기 잠금을 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">방법에 대 한 설명을 여러 동시 판독기 잠금을 작성기 잠금 대체 참조 &lt;xref:System.Threading.ReaderWriterLock&gt;클래스&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">판독기 잠금을 있는 스레드는 두 가지 방법 중 하나로 작성기 잠금을 획득할 수: 호출 하기 전에 판독기 잠금을 해제 하 여 &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; 를 호출 하 여&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 스레드가 호출 하는 경우 <ph id="ph2">`AcquireWriterLock`</ph> 의 자체 판독기 잠금이 차단 됩니다 판독기 잠금으로 아직, 동안; 스레드가 교착 상태가 무한 한 제한 시간을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">이러한 교착 상태를 방지 하려면 사용 &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;현재 스레드에 판독기 잠금이 이미에 있는지 확인 하려면.&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>재귀적 작성기 잠금 요청을 지원합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">즉, 스레드 호출 수 <ph id="ph1">`AcquireWriterLock`</ph> 여러 번 있는 잠금 수가 때마다 커집니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">호출 해야 &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;호출할 때마다에 대해 한 번씩 <ph id="ph1">`AcquireWriterLock`</ph>.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">호출할 수 있습니다 &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;즉시&amp;0; 잠금 수를 줄일 수 있습니다.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">재귀적 잠금 요청은 항상 요청 하는 스레드의 작성기 큐에 배치 하지 않고 즉시, 부여 됩니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">유효한 제한 시간 값에 대 한 참조 &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 제한 시간을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>잠금 요청이 부여 되기 전에 만료 됩니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>-1 밀리초 이외의 음수 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</source>
          <target state="translated">시퀀스 번호를 가져온 후 작성기 잠금이 임의의 스레드에 부여 되어 있는지 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use &lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt; and <ph id="ph1">`AnyWritersSince`</ph> to improve application performance.</source>
          <target state="translated">사용할 수 있습니다 &lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;및 <ph id="ph1">`AnyWritersSince`</ph> 응용 프로그램 성능 향상을 위해.&lt;/xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">예를 들어 스레드 판독기 잠금을 보유 하는 동안 가져온 정보를 캐시할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>After releasing and later reacquiring the lock, the thread can use <ph id="ph1">`AnyWritersSince`</ph> to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</source>
          <target state="translated">스레드 잠금을 썼는지 나중에 있으며, צ ְ ײ <ph id="ph1">`AnyWritersSince`</ph> 중간;에 다른 스레드가 리소스에 작성 한 경우 여부, 캐시 된 정보를 사용할 수를 확인 하려면.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">이 기술은 유용 잠금으로 보호 되는 정보를 읽는 비쌉니다. 예를 들어 데이터베이스 쿼리를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">호출자가 보유 하 고 있어야 판독기 잠금을 또는 기록기 잠금으로 유용 하 게 되려면 시퀀스 번호에 대 한 순서 대로 합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The sequence number.</source>
          <target state="translated">시퀀스 번호입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>시퀀스 번호를 가져온; 이후 스레드에 작성기 잠금이 부여 된 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt; was called.</source>
          <target state="translated">복원 하기 전에 스레드의 잠금 상태를 복원 &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;호출 되었습니다.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>DowngradeFromWriterLock releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</source>
          <target state="translated">DowngradeFromWriterLock 재귀 잠금 수에 관계 없이 작성기 잠금을 해제 하 고 판독기 잠금을 작성기 잠금으로 업그레이드 하기 전에 스레드에 의해 보유 된를 복원 합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>The lock count on the reader lock is restored.</source>
          <target state="translated">판독기 잠금을 잠금 수가 복원 됩니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph><ph id="ph2"> &gt;  </ph><ph id="ph3">`DowngradeFromWriterLock`</ph> accepts a &lt;xref:System.Threading.LockCookie&gt; obtained by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> <ph id="ph2"> &gt;  </ph> <ph id="ph3">`DowngradeFromWriterLock`</ph> &lt;xref:System.Threading.LockCookie&gt; &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; 를 호출 하 여 가져온&lt;/xref:System.Threading.LockCookie&gt; 허용</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use a <ph id="ph1">`LockCookie`</ph> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">사용 하지 않는 한 <ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; 반환한</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</source>
          <target state="translated">스레드에는 작성기 잠금이 해제 될 때 모든 판독기 잠금 요청 권한이 부여 되므로 다른 스레드에서 작성기 잠금을 기다리는 경우에 작성기 잠금을에서 다운 그레이드할 때을 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt; 반환한</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">스레드에는 작성기 잠금이 않아도 됩니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">주소 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept> 가 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">리소스가 해제 되 고 가비지 수집기가 회수 하는 경우 다른 정리 작업이 수행 되도록는 <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector calls Finalize when the current &lt;xref:System.Threading.ReaderWriterLock&gt; object is ready to be finalized.</source>
          <target state="translated">가비지 수집기 호출이 완료 될 때 현재 &lt;xref:System.Threading.ReaderWriterLock&gt;개체는 종료 될.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds a reader lock.</source>
          <target state="translated">현재 스레드에 판독기 잠금이 있는지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds a reader lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>현재 스레드에 판독기 잠금이; 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds the writer lock.</source>
          <target state="translated">현재 스레드에 작성기 잠금이 있는지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds the writer lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>현재 스레드에 작성기 잠금이; 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Releases the lock, regardless of the number of times the thread acquired the lock.</source>
          <target state="translated">스레드에서 잠금을 가져온 횟수에 관계 없이 잠금을 해제 합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count.</source>
          <target state="translated">ReleaseLock은 판독기 잠금 또는 재귀 잠금 수에 관계 없이 작성기 잠금을 해제합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>To restore the state of the lock, including the lock count, pass the &lt;xref:System.Threading.LockCookie&gt; to &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">잠금 수를 포함 하 여 잠금 상태를 복원 하려면 &lt;xref:System.Threading.LockCookie&gt; &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt; &lt;/xref:System.Threading.LockCookie&gt; 전달</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value representing the released lock.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해제 된 잠금을 나타내는 값입니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Decrements the lock count.</source>
          <target state="translated">잠금 횟수를 줄입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>ReleaseReaderLock decrements the lock count.</source>
          <target state="translated">잠금 횟수를 ReleaseReaderLock 줄입니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the count reaches zero, the lock is released.</source>
          <target state="translated">수가&amp;0;에 도달 하면 잠금이 해제 됩니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has the writer lock, calling <ph id="ph2">`ReleaseReaderLock`</ph> has the same effect as calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 호출 스레드에 작성기 잠금이 있으면 <ph id="ph2">`ReleaseReaderLock`</ph> &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; 호출 것과 동일한 결과가</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has no locks, calling <ph id="ph1">`ReleaseReaderLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">호출 스레드가 잠금이 없습니다 경우 <ph id="ph1">`ReleaseReaderLock`</ph> &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt; throw</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The thread does not have any reader or writer locks.</source>
          <target state="translated">스레드는 판독기 또는 작성기 잠금을 없습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Decrements the lock count on the writer lock.</source>
          <target state="translated">작성기 잠금을 잠금 횟수를 줄입니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>ReleaseWriterLock decrements the writer lock count.</source>
          <target state="translated">기록기 잠금 횟수를 ReleaseWriterLock 줄입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the count reaches zero, the writer lock is released.</source>
          <target state="translated">횟수가&amp;0; 작성기 잠금이 해제 됩니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has a reader lock, or no locks, calling <ph id="ph2">`ReleaseWriterLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 호출 스레드가 판독기 잠금 또는 잠금 없음 있으면 <ph id="ph2">`ReleaseWriterLock`</ph> &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt; throw</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">스레드에는 작성기 잠금이 않아도 됩니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">복원 &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt; 를 호출 하기 전에 스레드의 잠금 상태를 복구 합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>The state restored by <ph id="ph1">`RestoreLock`</ph> includes the recursive lock count.</source>
          <target state="translated">상태에서 복원할 <ph id="ph1">`RestoreLock`</ph> 재귀 잠금 수를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</source>
          <target state="translated">스레드는 차단 되는 잠금 판독기 또는 작성기 잠금을 다른 스레드가 가져온 후 작성기 잠금을 복원 하려는 경우 또는 다른 스레드에 작성기 잠금이 가져온 후 판독기 잠금을 복원 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">`RestoreLock`</ph> does not accept a time-out, you should take care to avoid possible deadlocks.</source>
          <target state="translated">때문에 <ph id="ph1">`RestoreLock`</ph> 는 제한 시간을 허용 하지 않습니다 가능한 교착 상태를 방지 하기 위해 주의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Before calling <ph id="ph2">`RestoreLock`</ph>, make sure you have released all locks acquired since the call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 호출 하기 전에 <ph id="ph2">`RestoreLock`</ph>, &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; 호출 이후 모든 잠금을 해제 했는지 확인</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</source>
          <target state="translated">예를 들어 한 스레드 교착 상태 판독기 잠금을 획득 하 고 이전 기록기 잠금으로 복원 하려고 시도 합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; to detect such additional locks.</source>
          <target state="translated">사용 하 여 &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;및 &lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt;에 이러한 추가 잠금을 검색.&lt;/xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use a &lt;xref:System.Threading.LockCookie&gt; returned from &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Threading.LockCookie&gt; &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; 에서 반환 되&lt;/xref:System.Threading.LockCookie&gt; 는 사용 하지 마십시오</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt; 반환한</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">주소 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept> 가 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using an <bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">판독기 잠금을 작성기 잠금으로 업그레이드를 사용 하 여 프로그램 <bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 제한 시간 값입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">호출 하면 스레드 <ph id="ph1">`UpgradeToWriterLock`</ph> 판독기 잠금을 잠금 수에 관계 없이 해제 되 고 스레드 작성기 잠금을 큐의 끝으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">따라서 다른 스레드에서 업그레이드 작성기 잠금이 부여를 요청 하는 스레드 하기 전에 리소스를 쓸 수 있습니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; UpgradeToWriterLock 메서드를 호출한 스레드가 판독기 잠금을 다시 가져올 수 있습니다 때까지 시간 초과 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">기록기 잠금으로 인해 대기 하는 다른 스레드가 있으면 즉시 전파 합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if another thread is queued for the writer lock, the thread that called the UpgradeToWriterLock method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">그러나 작성기 잠금을 다른 스레드에서 큐에 대기 하는 경우 UpgradeToWriterLock 메서드를 호출한 스레드에 모든 현재 판독기가 잠금을 해제 하 고 스레드 하나에 획득 하 고 작성기 잠금을 해제할 때까지 판독기 잠금을 다시 가져올 수 없습니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the UpgradeToWriterLock method.</source>
          <target state="translated">작성기 잠금을 요청 하는 다른 스레드가 현재 스레드 UpgradeToWriterLock 메서드를 호출한 후 요청 하는 경우에 마찬가지입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">잠금 상태를 복원 하려면 호출 &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;를 사용 하는 &lt;xref:System.Threading.LockCookie&gt;반환한 <ph id="ph1">`UpgradeToWriterLock`</ph>.&lt;/xref:System.Threading.LockCookie&gt; &lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">이 사용 하지 마십시오 <ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">스레드에 판독기 잠금이 사용 하지 마십시오 <ph id="ph1">`UpgradeToWriterLock`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">사용 하 여 &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;대신.&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">유효한 제한 시간 값에 대 한 참조 &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">밀리초 단위로 제한 시간입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>잠금 요청이 부여 되기 전에 만료 됩니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using a <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">판독기 잠금을 작성기 잠금으로 업그레이드를 사용 하 여 한 <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 제한 시간 값입니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">호출 하면 스레드 <ph id="ph1">`UpgradeToWriterLock`</ph> 판독기 잠금을 잠금 수에 관계 없이 해제 되 고 스레드 작성기 잠금을 큐의 끝으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">따라서 다른 스레드에서 업그레이드 작성기 잠금이 부여를 요청 하는 스레드 하기 전에 리소스를 쓸 수 있습니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method can reacquire the reader lock.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;까지 호출한 스레드가 시간 초과 예외가 throw 되지 않습니다는 &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;메서드는 판독기 잠금을 다시 가져올 수 있습니다.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">기록기 잠금으로 인해 대기 하는 다른 스레드가 있으면 즉시 전파 합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if another thread is queued for the writer lock, the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">그러나 작성기 잠금을 다른 스레드에서 큐에 대기 하는 경우를 호출한 스레드가 &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;모든 현재 판독기가 잠금을 해제 하 고 스레드 하나에 획득 하 고 작성기 잠금을 해제할 때까지 메서드는 판독기 잠금을 다시 가져올 수 없습니다.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method.</source>
          <target state="translated">작성기 잠금을 요청 하는 다른 스레드가 현재 스레드의 호출 후 요청 하는 경우에 마찬가지입니다는 &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;메서드.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">잠금 상태를 복원 하려면 호출 &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;를 사용 하는 &lt;xref:System.Threading.LockCookie&gt;반환한 <ph id="ph1">`UpgradeToWriterLock`</ph>.&lt;/xref:System.Threading.LockCookie&gt; &lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">이 사용 하지 마십시오 <ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">스레드에 판독기 잠금이 사용 하지 마십시오 <ph id="ph1">`UpgradeToWriterLock`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">사용 하 여 &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;대신.&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">유효한 제한 시간 값에 대 한 참조 &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 제한 시간을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>잠금 요청이 부여 되기 전에 만료 됩니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>-1 밀리초 이외의 음수 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Gets the current sequence number.</source>
          <target state="translated">현재 시퀀스 번호를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sequence number increases whenever a thread acquires the writer lock.</source>
          <target state="translated">시퀀스 번호가 증가 때마다 스레드 작성기 잠금을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can save the sequence number and pass it to &lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt; at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</source>
          <target state="translated">시퀀스 번호를 저장 하 고 전달 &lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;다른 스레드에서 그 동안 작성기 잠금을 획득 못한 있는지 여부를 확인 하려는 경우 이후 한 번에.&lt;/xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">`WriterSeqNum`</ph> to improve application performance.</source>
          <target state="translated">사용할 수 있습니다 <ph id="ph1">`WriterSeqNum`</ph> 응용 프로그램 성능 향상을 위해 합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">예를 들어 스레드 판독기 잠금을 보유 하는 동안 가져온 정보를 캐시할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling <ph id="ph1">`AnyWritersSince`</ph>; if not, the cached information can be used.</source>
          <target state="translated">나중에 잠금이 썼는지 있으며, 스레드가 다른 스레드에서 호출 하 여 리소스에 썼는지 여부를 확인할 수 <ph id="ph1">`AnyWritersSince`</ph>; 이면 not, 캐시 된 정보를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">잠금에 의해 보호 된 정보를 읽는 하는 것은 비용이 많이 드는; 때이 기술은 유용 합니다. 예를 들어 데이터베이스 쿼리를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">호출자가 보유 하 고 있어야 판독기 잠금을 또는 기록기 잠금으로 유용 하 게 되려면 시퀀스 번호에 대 한 순서 대로 합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The current sequence number.</source>
          <target state="translated">현재 시퀀스 번호입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>