<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6268fc94480a4936a59717d3dc614a6d4975ccec</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.Markup.XamlReader.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">974ec307b3512b7e8acac3fc2c82475555d82dac</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa63fc760c757e6f8ed203edf588d497bc9712ca</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</source>
          <target state="translated">XAML 입력을 읽고 WPF 기본 XAML 판독기 및 XAML 개체 작성기가 연결된을 사용 하 여 개체 그래프를 만듭니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The synchronous &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; methods are static, but the asynchronous &lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt; methods are not static and require an instance of the XamlReader class to use.</source>
          <target state="translated">동기 &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;메서드는 정적 이지만 비동기 &lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;메서드는 정적 및 사용할 XamlReader 클래스의 인스턴스를 필요로 합니다.&lt;/xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt; &lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The output of the <ph id="ph1">`Load`</ph> methods is a single object, which represents the root object of a created object tree or object graph.</source>
          <target state="translated">출력은 <ph id="ph1">`Load`</ph> methods는 생성된 된 개체 트리 또는 개체 그래프의 루트 개체를 나타내는 단일 개체입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>Object graphs that are created by XamlReader are typically added to the existing object tree of a WPF application at run time.</source>
          <target state="translated">XamlReader에 의해 만들어진 개체 그래프 일반적으로 런타임 시 WPF 응용 프로그램의 기존 개체 트리에 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</source>
          <target state="translated">그렇지 않은 경우 새 개체 그래프는 WPF 응용 프로그램 모델의 목적에 대 한 연결이 끊어진 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs &lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;, &lt;xref:System.Windows.LogicalTreeHelper&gt;, &lt;xref:System.Windows.Media.VisualTreeHelper&gt;).</source>
          <target state="translated">즉, 렌더링 하지 않습니다 적용할 수 없습니다 액세스를 사용 하 여 개체 트리 기술을으로 WPF 응용 프로그램의 주 개체 트리 (예를 들어 Api &lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;, &lt;xref:System.Windows.LogicalTreeHelper&gt;, &lt;xref:System.Windows.Media.VisualTreeHelper&gt;).&lt;/xref:System.Windows.Media.VisualTreeHelper&gt; &lt;/xref:System.Windows.LogicalTreeHelper&gt; &lt;/xref:System.Windows.FrameworkElement.FindName%2A&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on object tree concepts, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">개체 트리 개념에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>In WPF<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>XamlReader supports the following primary scenarios:      -   <bpt id="p1">**</bpt>Cloning/object factory<ept id="p1">**</ept>: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</source>
          <target state="translated">XamlReader 다음과 같은 주요 시나리오는 지원:- <bpt id="p1">**</bpt>복제/개체 공장<ept id="p1">**</ept>: 참조 형식 일반적 추가적인 메커니즘 없이 WPF 개체 트리의에서 둘 이상의 위치에 포함 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on &lt;xref:System.Windows.Freezable&gt;, or support for commonly shareable objects such as &lt;xref:System.Windows.Media.Brush&gt; that are referenced as an item from a &lt;xref:System.Windows.ResourceDictionary&gt;.) One way to clone an object that is already in the object tree is to serialize the object using &lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">(WPF에서 다시 사용할 또는 공유에 대 한 지원을 제공 하는 추가 메커니즘의 예로 기반으로 하는 개체 &lt;xref:System.Windows.Freezable&gt;와 같이 일반적으로 공유할 수 있는 개체에 대 한 지원 또는 &lt;xref:System.Windows.Media.Brush&gt;에서 항목으로 참조 되는 &lt;xref:System.Windows.ResourceDictionary&gt;.)&lt;/xref:System.Windows.ResourceDictionary&gt; &lt;/xref:System.Windows.Media.Brush&gt; &lt;/xref:System.Windows.Freezable&gt; 개체 트리에 이미 있는 개체를 복제 하는 한 가지 방법은 &lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName&gt;.&lt;/xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName&gt; 를 사용 하 여 개체를 serialize 하는 것</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>You then use the serialized string as input for a call to &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;, with a stream or &lt;xref:System.Xml.XmlReader&gt; as an intermediary.</source>
          <target state="translated">그런 다음 직렬화 된 문자열 입력으로 사용할 있습니다에 대 한 호출에 대 한 &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;, 스트림 또는 &lt;xref:System.Xml.XmlReader&gt;중간자로.&lt;/xref:System.Xml.XmlReader&gt; &lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   <bpt id="p1">**</bpt>Constructing objects based on just-in-time information<ept id="p1">**</ept>: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</source>
          <target state="translated">- <bpt id="p1">**</bpt>적시에 정보를 기반으로 개체 생성<ept id="p1">**</ept>: 런타임에 바인딩 또는 사용자가 제공한 입력이 기존 개체의 상태를 변경 하는 다른 방법을 종종 있습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example you could use the same value to set more than one property, or use data binding.</source>
          <target state="translated">예를 들어 둘 이상의 속성을 설정 하려면 동일한 값을 사용 하거나 데이터 바인딩을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; input is often a useful technique.</source>
          <target state="translated">여기서도 만들 개체의 형식이 결정할 수 있는 런타임 시 또는 사용자 상호 작용 하는 시나리오를 사용 하도록 설정한 경우 다음 만들어 이러한 개체에 대 한 문자열을 작성 하 여 하지만 &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;입력은 종종 기술을 사용 하면 유용 합니다.&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   <bpt id="p1">**</bpt>Using existing resource techniques<ept id="p1">**</ept>: The &lt;xref:System.IO.Stream&gt; type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</source>
          <target state="translated">- <bpt id="p1">**</bpt>기존 리소스 기술을 사용 하 여<ept id="p1">**</ept>:는 &lt;xref:System.IO.Stream&gt;형식에서 자주 사용 되 다른 프레임 워크 또는 기술 응용 프로그램 경계 간의 데이터 나 개체를 전송에 대 한 또는 이와 유사한 상황에 대 한.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then use the &lt;xref:System.IO.Stream&gt; techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</source>
          <target state="translated">그런 다음 사용할 수는 &lt;xref:System.IO.Stream&gt;저장 하거나 결국 응용 프로그램의 일부로 개체를 만드는 데 사용 하는 XAML 형식의 데이터를 얻을 수 있는 기술을.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   <bpt id="p1">**</bpt>Fixed documents:<ept id="p1">**</ept> Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</source>
          <target state="translated">- <bpt id="p1">**</bpt>고정 문서:<ept id="p1">**</ept> 응용 프로그램에서 WPF 응용 프로그램 개체 트리의 UI에 대 한 로컬 또는 다운로드 한 XPS 문서를 로드할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  This documentation sometimes describes an object graph, as opposed to an object tree.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 개체 그래프를 개체 트리로 달리 때로는이 설명서에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</source>
          <target state="translated">엄격한 부모-자식 관계 항상 없으므로 런타임 WPF 응용 프로그램의 런타임 개체 관계에서 개체 그래프는 널리 적용 가능한 용어 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because WPF also includes two different tree conceptualization APIs (&lt;xref:System.Windows.LogicalTreeHelper&gt;, &lt;xref:System.Windows.Media.VisualTreeHelper&gt;) the tree metaphor still applies adequately to most real-world cases in WPF.</source>
          <target state="translated">그러나 WPF에 두 개의 다른 트리 개념화 Api도 포함 되어 있으므로 (&lt;xref:System.Windows.LogicalTreeHelper&gt;, &lt;xref:System.Windows.Media.VisualTreeHelper&gt;) WPF에서 대부분의 실제 경우를 트리 메타포 적절 하 게 여전히 적용 됩니다.&lt;/xref:System.Windows.Media.VisualTreeHelper&gt; &lt;/xref:System.Windows.LogicalTreeHelper&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</source>
          <target state="translated">그러나 XAML 언어 관점에서 개체 그래프는 종종 생각 하면 XAML에서 개체 생성 방법에 대 한 XAML 언어 자체 반드시 지정 하지 않으므로 관계를 트리 구조로 더 다시 표시 하는 도우미 클래스 방법론은 가장 좋은 방법은 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code Access Security, Loose XAML, and XamlReader    XAML is a markup language that directly represents object instantiation and execution.</source>
          <target state="translated">코드 액세스 보안, 느슨한 XAML 및 XamlReader XAML는 태그 언어 개체 인스턴스화 및 실행을 직접 나타내는입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</source>
          <target state="translated">따라서 XAML에서 생성 된 요소는 생성 된 동일한 것으로 시스템 리소스 (예: 액세스, 파일 시스템 IO, 네트워크)와 상호 작용 하는 동일한 기능이 코드는 않습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> supports the <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/add/includes/tla2sharptla-net-md.md)]</ph> security framework <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/add/includes/tlasharptla-cas-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>지원 된 <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/add/includes/tla2sharptla-net-md.md)]</ph> 보안 프레임 워크 <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/add/includes/tlasharptla-cas-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> content running in the internet zone has reduced execution permissions.</source>
          <target state="translated">즉 <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> 콘텐츠 인터넷 영역에서 실행 되는 실행 권한이 줄어듭니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]</ph> are usually run in this internet zone and use the same permission set.</source>
          <target state="translated">"느슨한 XAML" (컴파일되지 않은 XAML의 페이지 로드 시 해석 XAML 뷰어에서) 및 <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]</ph> 이 인터넷 영역에서 일반적으로 실행 되 고 동일한 권한 집합을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</source>
          <target state="translated">그러나 완전히 신뢰할 수 있는 응용 프로그램으로 로드 된 XAML 호스팅 응용 프로그램과 시스템 리소스에 대 한 동일한 액세스를 있습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>WPF Partial Trust Security<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>WPF 부분 신뢰 보안<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The implications of these statements for XamlReader is that your application design must make trust decisions about the XAML you decide to load.</source>
          <target state="translated">XamlReader에 대 한 이러한 문의 의미는 응용 프로그램 디자인 로드 하려는 경우 XAML에 대 한 신뢰 결정을 확인 해야 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</source>
          <target state="translated">신뢰할 수 없는 XAML을 로드 하는 경우에 결과 개체 그래프를 로드 하는 방법에 대 한 사용자 고유의 샌드 박싱 기술을 구현 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>XamlReader can also be called by partial trust code.</source>
          <target state="translated">XamlReader 부분 신뢰 코드에서 호출할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, Internet security zone is applied for code access security.</source>
          <target state="translated">이 경우 인터넷 보안 영역의 코드 액세스 보안에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</source>
          <target state="translated">인터넷 보안 영역에서 유효 하지 않으면 로드 된 XAML에 아무 것도 XAML 구문 분석 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under XBAP and other cases that are partial trust at the platform level, where XamlReader is part of the execution, you get the same exception behavior as with explicit partial trust calls.</source>
          <target state="translated">XBAP 및 XamlReader 인 부분을 실행 하는 플랫폼 수준에서 일부 신뢰 된 다른 경우 부분 신뢰 명시적 호출으로 동일한 예외 동작을을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>WPF XAML, XAML Readers/Writers, and XAML Language Versioning    <ph id="ph1">[!INCLUDE[xaml2009](~/add/includes/xaml2009-md.md)]</ph> includes language features such as  and .</source>
          <target state="translated">WPF XAML, XAML 판독기/기록기 및 XAML 언어 버전 관리 <ph id="ph1">[!INCLUDE[xaml2009](~/add/includes/xaml2009-md.md)]</ph> 와 같은 언어 기능을 포함 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use signatures of <ph id="ph1">`Load`</ph> or <ph id="ph2">`Parse`</ph> to load XAML that uses these features.</source>
          <target state="translated">시그니처를 사용할 수 있습니다 <ph id="ph1">`Load`</ph> 또는 <ph id="ph2">`Parse`</ph> 이러한 기능을 사용 하는 XAML을 로드 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the <bpt id="p1">**</bpt>Page<ept id="p1">**</ept> build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</source>
          <target state="translated">그러나, 이러한 언어 기능은 태그를 컴파일해야 하는 XAML에 대 한 지원 되지 않습니다 (에 대 한 XAML 등의 <bpt id="p1">**</bpt>페이지<ept id="p1">**</ept> 에서 WPF 응용 프로그램 또는 빌드 작업에서 태그 컴파일 작업와 관련 된 모든 XAML 빌드 작업).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</source>
          <target state="translated">WPF 형식 및 WPF 기술은 일반적 WPF 내부에 대 한 액세스를 사용 하는 개념을 지원 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</source>
          <target state="translated">예를 들어, WPF 종속성 속성을 구현 하는 방법을 효율적인 유형 멤버 조회에 대 한 내부 기술에 의존 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>Access to these internals is enabled by the XAML reading and writing APIs provided in &lt;xref:System.Windows.Markup.XamlWriter&gt; and XamlReader from the &lt;xref:System.Windows.Markup&gt; namespace and PresentationFramework assembly.</source>
          <target state="translated">이러한 내부 구조에 대 한 액세스는 XAML 읽기 및 쓰기에 제공 된 Api에 의해 사용 하도록 설정 &lt;xref:System.Windows.Markup.XamlWriter&gt;및에서 XamlReader의 &lt;xref:System.Windows.Markup&gt;네임 스페이스 및 PresentationFramework 어셈블리.&lt;/xref:System.Windows.Markup&gt; &lt;/xref:System.Windows.Markup.XamlWriter&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on &lt;xref:System.Xaml.XamlReader?displayProperty=fullName&gt;, &lt;xref:System.Xaml.XamlWriter?displayProperty=fullName&gt;) do not have access to the WPF internals.</source>
          <target state="translated">그러나 하위 XAML 판독기 및 XAML 작성기 System.Xaml 어셈블리에서 (클래스에 따라 &lt;xref:System.Xaml.XamlReader?displayProperty=fullName&gt;, &lt;xref:System.Xaml.XamlWriter?displayProperty=fullName&gt;) WPF 내부에 대 한 액세스 권한이 없습니다.&lt;/xref:System.Xaml.XamlWriter?displayProperty=fullName&gt; &lt;/xref:System.Xaml.XamlReader?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no dependency from System.Xaml to any WPF-specific assembly.</source>
          <target state="translated">System.Xaml에서 모든 WPF 관련 어셈블리에 종속성이 있습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</source>
          <target state="translated">WPF 내부에 연결 되지 않은 System.Xaml 판독기와 작성기 올바르게 로드 하지 못했거나, 모든 WPF 저장 형식 또는 형식에 따라 WPF 형식입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</source>
          <target state="translated">특히 System.Xaml 판독기와 작성기 WPF 종속성 속성을 속성 저장소 및 WPF 스타일, 리소스 사전 및 템플릿을 사용 하는 방법의 모든 문의 지원 같은 개념을 이해 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore you have a choice to make:      -   If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</source>
          <target state="translated">따라서는 선택할 수 있는: WPF 형식을 로드 하는 어떤 방식으로든에서 BAML 양식에서 XAML을 사용 하는 경우-PresentationFramework XAML 판독기 및 XAML 작성기를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</source>
          <target state="translated">-모든 WPF 형식 또는 BAML 형식의 XAML 사용 하지 않고도 하 고 다른 특정 기술 XAML 판독기 또는 XAML 작성기 구현 프레임 워크에 있는 관련 된 이유로 사용 하지 않는 경우 System.Xaml의 XAML 판독기 및 XAML 작성기를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>System.Xaml Backing Implementation in .NET 4    XamlReader is the callable API surface for the WPF framework-level XAML parser.</source>
          <target state="translated">.NET 4 XamlReader System.Xaml 백업 구현은 WPF 프레임 워크 수준 XAML 파서에 대 한 호출 가능 API 화면입니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target <ph id="ph1">[!INCLUDE[net_v30_short](~/add/includes/net-v30-short-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)]</ph>.</source>
          <target state="translated">같은 기본 XAML 파서가 성능도 런타임에 XAML을 로드 하 고 대상으로 하는 WPF 응용 프로그램에 대 한 구문 분석 <ph id="ph1">[!INCLUDE[net_v30_short](~/add/includes/net-v30-short-md.md)]</ph> 및 <ph id="ph2">[!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>, the external API is the same, but parts of the implementation are built on the <ph id="ph2">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph> general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</source>
          <target state="translated">대상으로 하는 경우 <ph id="ph1">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>, 외부 API는 같지만 구현 요소를 기반으로 만들어진는 <ph id="ph2">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph> 대부분 XAML을 구문 분석의 기술 및 보고 측면의 향상 되는 System.Xaml 어셈블리의 일반 XAML 구현 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph> necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</source>
          <target state="translated">대상 지정 <ph id="ph1">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph> 보고 예외는 System.Xaml에서 가져올 수 같은 구현 세부 정보는 참조로 System.Xaml를 포함 하는 포함 형식을 정의 하는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_XamlReader"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_XamlReader"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # XAML 텍스트 사용</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</source>
          <target state="translated">보류 중인 비동기 로드 작업이 없는 경우 현재 비동기 로드 작업을 중단 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>CancelAsync is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</source>
          <target state="translated">Cancelasync 메서드가 비동기 작업입니다. 따라서 일부 로드에는 작업을 중단 하기 전에 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Xaml.XamlSchemaContext"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that represents the WPF schema context settings for a <bpt id="p2">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">반환 된 <bpt id="p1">&lt;xref href="System.Xaml.XamlSchemaContext"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 에 대 한 WPF 스키마 컨텍스트 설정을 나타내는 개체는 <bpt id="p2">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Xaml.XamlSchemaContext"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that represents the WPF schema context settings for a <bpt id="p2">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Xaml.XamlSchemaContext"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 에 대 한 WPF 스키마 컨텍스트 설정을 나타내는 개체를 <bpt id="p2">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns an &lt;xref:System.Object&gt; that is the root of the corresponding object tree.</source>
          <target state="translated">지정 된 XAML 입력을 읽고 &lt;xref:System.IO.Stream&gt;반환는 &lt;xref:System.Object&gt;해당 개체 트리의 루트입니다.&lt;/xref:System.Object&gt; &lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The XAML to load, in stream form.</source>
          <target state="translated">스트림 형식으로 로드 하는 XAML입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The object at the root of the created object tree.</source>
          <target state="translated">만든된 개체 트리의 루트에 대 한 개체입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Reads the XAML input through a provided <bpt id="p1">&lt;xref href="System.Xaml.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">제공 된 XAML 입력을 읽고 <bpt id="p1">&lt;xref href="System.Xaml.XamlReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해당 개체 트리의 루트는 개체를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>The input &lt;xref:System.Xaml.XamlReader&gt; can be &lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;.</source>
          <target state="translated">입력 &lt;xref:System.Xaml.XamlReader&gt; &lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;.&lt;/xref:System.Windows.Baml2006.Baml2006Reader&gt; 수&lt;/xref:System.Xaml.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is how you can load BAML at run time, or for localization tool purposes.</source>
          <target state="translated">실행 시 또는 지역화 도구에 BAML에 로드 하는 방법입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Xaml.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Xaml.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is expected to be initialized with input XAML.</source>
          <target state="translated">이 입력된 XAML을 사용 하 여 초기화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">이 개체에 만든된 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.Xml.XmlReader&gt; and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">지정 된 XAML 입력을 읽고 &lt;xref:System.Xml.XmlReader&gt;해당 개체 트리의 루트는 개체를 반환 합니다.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.XmlReader&gt; that has already loaded the XAML input to load in XML form.</source>
          <target state="translated">&lt;xref:System.Xml.XmlReader&gt;를 이미 로드 XAML XML 형식으로 로드를 입력 합니다.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">이 개체에 만든된 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">지정 된 XAML 입력을 읽고 &lt;xref:System.IO.Stream&gt;해당 개체 트리의 루트는 개체를 반환 합니다.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The stream that contains the XAML input to load.</source>
          <target state="translated">로드할 입력 XAML이 포함 된 스트림입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Context information used by the parser.</source>
          <target state="translated">파서에서 사용 하는 컨텍스트 정보입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">이 개체에 만든된 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;parserContext&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">-or-       <ph id="ph1">&lt;code&gt;parserContext&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns the root of the corresponding object tree.</source>
          <target state="translated">지정 된 XAML 입력을 읽고 &lt;xref:System.IO.Stream&gt;하 고 해당 개체 트리의 루트를 반환 합니다.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">비동기 XAML 로드 작업에는 루트 개체는 순수 하 게 되는 개체가 반환 처음 됩니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">비동기적으로 계속 XAML 다음 구문 분석 하 고 루트 아래에 자식 개체가 채워집니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">이것이 일반적인 WPF XAML 처리 동작 및 개체 수명의 WPF 개념 상호 작용 합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">일반적인 (비동기) 상호 작용에 요소를 반환 하 고 로드 된 것으로 보고 하기 전에 모든 자식 컬렉션을 포함 하는 개체의 모든 속성이 채워집니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">해당 동작 상향식 방법 사용 루트 개체인를 사용할 수 있을 마지막 개체 트리를 만드는 것과 같습니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">하면 일반적으로 WPF 응용 프로그램의 개체 트리에 일부 위치로 반환 되는 개체를 할당 합니다, 콘텐츠 지식을 계속 채워지고 및 전체가 UI의 일부로 노출 되는 경우 증분 레이아웃 업데이트가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt; is handled.</source>
          <target state="translated">이러한 이유로 일반적인 격리 또는 XAML에서 비동기적으로 로드 된 모든 개체를 가상화 하 고 응용 프로그램별 논리 또는 응용 프로그램 상태를 알릴 때 사용 하는 &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;처리 됩니다.&lt;/xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order for LoadAsync to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value <ph id="ph1">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">XAML 입력을 비동기적으로 로드 하는 LoadAsync xaml에서 루트 요소에 대 한 입력 특성 및 값 포함 해야 <ph id="ph1">`x:SynchronousMode="Async"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">값은 대/소문자입니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XAML input root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see &lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;).</source>
          <target state="translated">XAML 입력된 루트가 포함 되어 있지 않으면 <ph id="ph1">`x:SynchronousMode="Async"`</ph>, 예외가 throw 되지 않으며 호출 동기 로드로 처리 됩니다 (참조 &lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;).&lt;/xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one asynchronous load operation per instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class can be performed at a time.</source>
          <target state="translated">인스턴스당 하나의 비동기 로드 작업은 &lt;xref:System.Windows.Markup.XamlReader&gt;클래스는 한 번에 수행할 수 있습니다.&lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If more than one asynchronous operation is attempted on the same instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class an &lt;xref:System.InvalidOperationException&gt; is thrown.</source>
          <target state="translated">동일한 인스턴스에서 둘 이상의 비동기 작업을 시도 하는 경우는 &lt;xref:System.Windows.Markup.XamlReader&gt;클래스는 &lt;xref:System.InvalidOperationException&gt;throw 됩니다.&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The stream containing the XAML input to load.</source>
          <target state="translated">로드할 입력 XAML을 포함 하는 스트림.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">이 개체에 만든된 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Multiple load operations are pending concurrently with the same <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">보류 중인 여러 부하 작업이 동일한 동시 <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.Xml.XmlReader&gt; and returns the root of the corresponding object tree.</source>
          <target state="translated">지정 된 XAML 입력을 읽고 &lt;xref:System.Xml.XmlReader&gt;하 고 해당 개체 트리의 루트를 반환 합니다.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">비동기 XAML 로드 작업에는 루트 개체는 순수 하 게 되는 개체가 반환 처음 됩니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">비동기적으로 계속 XAML 다음 구문 분석 하 고 루트 아래에 자식 개체가 채워집니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">이것이 일반적인 WPF XAML 처리 동작 및 개체 수명의 WPF 개념 상호 작용 합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">일반적인 (비동기) 상호 작용에 요소를 반환 하 고 로드 된 것으로 보고 하기 전에 모든 자식 컬렉션을 포함 하는 개체의 모든 속성이 채워집니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">해당 동작 상향식 방법 사용 루트 개체인를 사용할 수 있을 마지막 개체 트리를 만드는 것과 같습니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>You typically would assign the returned object from LoadAsync to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">하면 일반적으로 응용 프로그램의 개체 트리에 일부 위치로 LoadAsync에서 반환된 된 개체를 할당 합니다, 콘텐츠 지식을 계속 채워지고 및 전체가 UI의 일부로 노출 되는 경우 증분 레이아웃 업데이트가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt; is handled.</source>
          <target state="translated">이러한 이유로 일반적인 격리 또는 XAML에서 비동기적으로 로드 된 모든 개체를 가상화 하 고 응용 프로그램별 논리 또는 응용 프로그램 상태를 알릴 때 사용 하는 &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;처리 됩니다.&lt;/xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order for LoadAsync to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph1">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">LoadAsync 로드를 위해에서 XAML 입력을 비동기적으로, XAML 태그의 루트 요소는 특성 및 값 있어야 합니다. <ph id="ph1">`x:SynchronousMode="Async"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">값은 대/소문자입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is instead processed as a synchronous load (see &lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;).</source>
          <target state="translated">XAML 태그 루트가 포함 되어 있지 않으면 <ph id="ph1">`x:SynchronousMode="Async"`</ph>, 예외가 throw 되지 않으며 호출 동기 로드로 처리 대신 됩니다 (참조 &lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;).&lt;/xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one asynchronous load operation per instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class can be performed at a time.</source>
          <target state="translated">인스턴스당 하나의 비동기 로드 작업은 &lt;xref:System.Windows.Markup.XamlReader&gt;클래스는 한 번에 수행할 수 있습니다.&lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>If more than one asynchronous operation is attempted on the same instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class an &lt;xref:System.InvalidOperationException&gt; is thrown.</source>
          <target state="translated">동일한 인스턴스에서 둘 이상의 비동기 작업을 시도 하는 경우는 &lt;xref:System.Windows.Markup.XamlReader&gt;클래스는 &lt;xref:System.InvalidOperationException&gt;throw 됩니다.&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>An existing  &lt;xref:System.Xml.XmlReader&gt; that has already loaded/read the XAML input.</source>
          <target state="translated">기존 &lt;xref:System.Xml.XmlReader&gt;하에 이미 로드/읽기 XAML 입력.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The root of the created object tree.</source>
          <target state="translated">만든된 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Multiple load operations are performed concurrently with the same <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">여러 로드 작업은 동일한 동시에 수행 됩니다 <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns the root of the corresponding object tree.</source>
          <target state="translated">지정 된 XAML 입력을 읽고 &lt;xref:System.IO.Stream&gt;하 고 해당 개체 트리의 루트를 반환 합니다.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">비동기 XAML 로드 작업에는 루트 개체는 순수 하 게 되는 개체가 반환 처음 됩니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">비동기적으로 계속 XAML 다음 구문 분석 하 고 루트 아래에 자식 개체가 채워집니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">이것이 일반적인 WPF XAML 처리 동작 및 개체 수명의 WPF 개념 상호 작용 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">일반적인 (비동기) 상호 작용에 요소를 반환 하 고 로드 된 것으로 보고 하기 전에 모든 자식 컬렉션을 포함 하는 개체의 모든 속성이 채워집니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">해당 동작 상향식 방법 사용 루트 개체인를 사용할 수 있을 마지막 개체 트리를 만드는 것과 같습니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">하면 일반적으로 응용 프로그램의 개체 트리에 일부 위치로 반환 되는 개체를 할당 합니다, 콘텐츠 지식을 계속 채워지고 및 전체가 UI의 일부로 노출 되는 경우 증분 레이아웃 업데이트가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt; is handled.</source>
          <target state="translated">이러한 이유로 일반적인 격리 또는 XAML에서 비동기적으로 로드 된 모든 개체를 가상화 하 고 응용 프로그램별 논리 또는 응용 프로그램 상태를 알릴 때 사용 하는 &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;처리 됩니다.&lt;/xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order for LoadAsync to load markup asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph1">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">태그를 비동기적으로 로드 하는 LoadAsync에서 XAML 태그의 루트 요소 특성 및 값 포함 해야 <ph id="ph1">`x:SynchronousMode="Async"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">값은 대/소문자입니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see &lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;).</source>
          <target state="translated">XAML 태그 루트가 포함 되어 있지 않으면 <ph id="ph1">`x:SynchronousMode="Async"`</ph>, 예외가 throw 되지 않으며 호출 동기 로드로 처리 됩니다 (참조 &lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;).&lt;/xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one asynchronous load operation per instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class can be performed at a time.</source>
          <target state="translated">인스턴스당 하나의 비동기 로드 작업은 &lt;xref:System.Windows.Markup.XamlReader&gt;클래스는 한 번에 수행할 수 있습니다.&lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>If more than one asynchronous operation is attempted on the same instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class an &lt;xref:System.InvalidOperationException&gt; is thrown.</source>
          <target state="translated">동일한 인스턴스에서 둘 이상의 비동기 작업을 시도 하는 경우는 &lt;xref:System.Windows.Markup.XamlReader&gt;클래스는 &lt;xref:System.InvalidOperationException&gt;throw 됩니다.&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A stream containing the XAML input to load.</source>
          <target state="translated">로드할 입력 XAML을 포함 하는 스트림.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Context information used by the parser.</source>
          <target state="translated">파서에서 사용 하는 컨텍스트 정보입니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The root of the created object tree.</source>
          <target state="translated">만든된 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Multiple load operations are performed concurrently with the same <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">여러 로드 작업은 동일한 동시에 수행 됩니다 <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Occurs when an asynchronous load operation completes.</source>
          <target state="translated">비동기 로드 작업이 완료 될 때 발생 합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>LoadCompleted is also raised when an asynchronous load operation aborts.</source>
          <target state="translated">비동기 로드 작업이 중단 LoadCompleted도 발생 합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">추가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">지정된 된 텍스트 문자열에서 XAML 입력을 읽고 지정된 된 태그의 루트에 해당 하는 개체를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>The implementation calls &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; internally after creating a stream from the string.</source>
          <target state="translated">구현 호출 하 여 &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;문자열에서 스트림을 만든 후에 내부적으로.&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>See &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; for additional information such as possible exceptions.</source>
          <target state="translated">참조 &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;가능한 예외와 같은 추가 정보에 대 한.&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">XAML 하나의 텍스트 문자열로 입력 합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The root of the created object tree.</source>
          <target state="translated">만든된 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Reads the XAML markup in the specified text string (using a specified <bpt id="p1">&lt;xref href="System.Windows.Markup.ParserContext"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">지정된 된 텍스트 문자열에서 XAML 태그를 읽고 (사용 하 여 지정 된 <bpt id="p1">&lt;xref href="System.Windows.Markup.ParserContext"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>) 하 고 지정된 된 태그의 루트에 해당 하는 개체를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>The implementation calls &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; internally after creating a stream from the string.</source>
          <target state="translated">구현 호출 하 여 &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;문자열에서 스트림을 만든 후에 내부적으로.&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>See &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; for additional information such as possible exceptions.</source>
          <target state="translated">참조 &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;가능한 예외와 같은 추가 정보에 대 한.&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">XAML 하나의 텍스트 문자열로 입력 합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Context information used by the parser.</source>
          <target state="translated">파서에서 사용 하는 컨텍스트 정보입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The root of the created object tree.</source>
          <target state="translated">만든된 개체 트리의 루트입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>