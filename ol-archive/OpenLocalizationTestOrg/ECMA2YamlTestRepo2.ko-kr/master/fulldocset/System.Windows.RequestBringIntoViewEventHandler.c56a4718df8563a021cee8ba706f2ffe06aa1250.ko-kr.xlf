<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">090ebe53f727be99a100b9af773bb82108c2964a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.RequestBringIntoViewEventHandler.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ccc91037cf2ea43cd32cec1f87360b23e4d0358e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bc516054c8f11ef86c766b5d8deb2ae53815760f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents the method that will handle the <bpt id="p1">&lt;xref href="System.Windows.FrameworkElement.RequestBringIntoView"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> routed event.</source>
          <target state="translated">처리 하는 메서드를 나타냅니다는 <bpt id="p1">&lt;xref href="System.Windows.FrameworkElement.RequestBringIntoView"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 라우트된 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</source>
          <target state="translated">이 이벤트를 처리 합니다. 일반적으로 스크롤 가능한 영역을 지 원하는 또는 일치 하지 않으면 의도적으로 설정 하며, 렌더링 크기 자식 요소 콘텐츠를 원하는 크기 보다 작은 요소 내에 수행 됩니다 및 의도적으로 요소 트리에 있는 위쪽으로 라우팅 했습니다 하 고 스크롤 영역 지원에서 제공 하는 첫 번째 부모에 도달한 후 이벤트를 처리 하 여만 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is &lt;xref:System.Windows.Controls.ScrollViewer&gt;.</source>
          <target state="translated">일반적으로 필요한 사용자 컨트롤에 대 한 방법으로 스크롤 영역을 처리 하는 기존 구현을 &lt;xref:System.Windows.Controls.ScrollViewer&gt;.&lt;/xref:System.Windows.Controls.ScrollViewer&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you derive from &lt;xref:System.Windows.Controls.ScrollViewer&gt;, you can register a class handler for &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; and supplement the base class handling of the event.</source>
          <target state="translated">파생 하는 경우 &lt;xref:System.Windows.Controls.ScrollViewer&gt;에 대 한 클래스 처리기를 등록할 수 있습니다 &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;이벤트의 기본 클래스 처리를 보완 하 고.&lt;/xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; &lt;/xref:System.Windows.Controls.ScrollViewer&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should also consider using or class-handling the class-defined &lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt; event instead of &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;.</source>
          <target state="translated">또는 클래스 정의 &lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;이벤트 &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;.&lt;/xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; 대신&lt;/xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt; 한 클래스 처리를 사용 하 여 고려해 야</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, if you create an entirely custom class that does not derive from &lt;xref:System.Windows.Controls.ScrollViewer&gt;, you can still add class handling by calling &lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=fullName&gt; in your class instantiation.</source>
          <target state="translated">또는 완전 한 사용자 지정 클래스에서 파생 되지 않은 경우 만들 &lt;xref:System.Windows.Controls.ScrollViewer&gt;, 클래스를 호출 하 여 처리를 추가할 수 있습니다 &lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=fullName&gt;클래스 인스턴스화할에서.&lt;/xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=fullName&gt; &lt;/xref:System.Windows.Controls.ScrollViewer&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details on class handling, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">클래스 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>표시 라우트된 이벤트로 클래스를 처리 하 고,<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Content elements can cause the event to be raised by their content hosts (through calling &lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt; and raising &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; from the content host).</source>
          <target state="translated">콘텐츠 요소는 이벤트를 콘텐츠 호스트에 의해 발생 될 수 있습니다 (호출을 통해 &lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;및 발생 &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;는 콘텐츠 호스트에서).&lt;/xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; &lt;/xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, you can request logical tree elements to be brought into view with the helper method &lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">마찬가지로, 논리적 트리 도우미 메서드로 &lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=fullName&gt;.&lt;/xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=fullName&gt; 보기에 맞게 수정할 수 요소를 요청할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Windows.Controls.ListBox&gt; implements a related but different method &lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Windows.Controls.ListBox&gt; &lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;.&lt;/xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt; 관련 하지만 서로 다른 메서드를 구현 하&lt;/xref:System.Windows.Controls.ListBox&gt; 는</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>