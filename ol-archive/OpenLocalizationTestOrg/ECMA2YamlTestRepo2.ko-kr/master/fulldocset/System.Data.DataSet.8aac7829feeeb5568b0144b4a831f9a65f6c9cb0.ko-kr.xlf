<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">705003c6f689a2b4d0080db9ca21f5c5de2802c2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Data.DataSet.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">74010e0949011039899655bb1f89853766d73f76</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1a3d97bb9d963824c560aaa35301932b8da2af76</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents an in-memory cache of data.</source>
          <target state="translated">데이터의 메모리에 캐시를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The DataSet, which is an in-memory cache of data retrieved from a data source, is a major component of the ADO.NET architecture.</source>
          <target state="translated">데이터 원본에서 검색 된 데이터의 메모리에 캐시 인 데이터 집합은 ADO.NET 아키텍처의 주요 구성 요소입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The DataSet consists of a collection of &lt;xref:System.Data.DataTable&gt; objects that you can relate to each other with &lt;xref:System.Data.DataRelation&gt; objects.</source>
          <target state="translated">데이터 집합의 컬렉션으로 이루어져 &lt;xref:System.Data.DataTable&gt;개체를 통해 서로 연결할 수 있습니다 &lt;xref:System.Data.DataRelation&gt;개체.&lt;/xref:System.Data.DataRelation&gt; &lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also enforce data integrity in the DataSet by using the &lt;xref:System.Data.UniqueConstraint&gt; and &lt;xref:System.Data.ForeignKeyConstraint&gt; objects.</source>
          <target state="translated">사용 하 여 데이터 집합의 데이터 무결성을 적용할 수도 있습니다는 &lt;xref:System.Data.UniqueConstraint&gt;및 &lt;xref:System.Data.ForeignKeyConstraint&gt;개체.&lt;/xref:System.Data.ForeignKeyConstraint&gt; &lt;/xref:System.Data.UniqueConstraint&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>For further details about working with DataSet objects, see <bpt id="p1">[</bpt>DataSets, DataTables, and DataViews<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">데이터 집합 개체를 사용 하는 방법에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>데이터 집합, Datatable 및 Dataview<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>Whereas &lt;xref:System.Data.DataTable&gt; objects contain the data, the &lt;xref:System.Data.DataRelationCollection&gt; allows you to navigate though the table hierarchy.</source>
          <target state="translated">반면 &lt;xref:System.Data.DataTable&gt;개체 데이터가 &lt;xref:System.Data.DataRelationCollection&gt;테이블 계층 구조를 탐색할 수 있습니다.&lt;/xref:System.Data.DataRelationCollection&gt; &lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>The tables are contained in a &lt;xref:System.Data.DataTableCollection&gt; accessed through the &lt;xref:System.Data.DataSet.Tables%2A&gt; property.</source>
          <target state="translated">테이블에 포함 된 한 &lt;xref:System.Data.DataTableCollection&gt;를 통해 액세스는 &lt;xref:System.Data.DataSet.Tables%2A&gt;속성.&lt;/xref:System.Data.DataSet.Tables%2A&gt; &lt;/xref:System.Data.DataTableCollection&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>When accessing &lt;xref:System.Data.DataTable&gt; objects, note that they are conditionally case sensitive.</source>
          <target state="translated">에 액세스할 때 &lt;xref:System.Data.DataTable&gt;개체, 조건에 따라 대/소문자 구분 되는지 확인 합니다.&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if one &lt;xref:System.Data.DataTable&gt; is named "mydatatable" and another is named "Mydatatable", a string used to search for one of the tables is regarded as case sensitive.</source>
          <target state="translated">예를 들어 하나의 &lt;xref:System.Data.DataTable&gt;"mydatatable" 라고 하 고 "Mydatatable" 라는 다른, 테이블 중 하나를 검색 하는 데 사용 하는 문자열 같이 대/소문자 구분 간주 됩니다.&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if "mydatatable" exists and "Mydatatable" does not, the search string is regarded as case insensitive.</source>
          <target state="translated">그러나 "mydatatable" 있으며 "Mydatatable" 하지 않는 경우 검색 문자열 소문자 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about working with &lt;xref:System.Data.DataTable&gt; objects, see <bpt id="p1">[</bpt>Creating a DataTable<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">작업에 대 한 자세한 내용은 &lt;xref:System.Data.DataTable&gt;개체 참조 <bpt id="p1">[</bpt>DataTable 만들기<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>A DataSet can read and write data and schema as XML documents.</source>
          <target state="translated">데이터 집합을 읽고 XML 문서로 데이터와 스키마를 쓸 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>The data and schema can then be transported across HTTP and used by any application, on any platform that is XML-enabled.</source>
          <target state="translated">데이터 및 스키마 다음 전체 HTTP 전송 및 사용할 수는 XML을 사용 하도록 설정 하는 모든 플랫폼에서 모든 응용 프로그램에서 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can save the schema as an XML schema with the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method, and both schema and data can be saved using the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; method.</source>
          <target state="translated">스키마와 XML 스키마로 저장할 수 있습니다는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드, 및 스키마와 데이터 모두를 사용 하 여 저장할 수는 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXml%2A&gt; &lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read an XML document that includes both schema and data, use the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method.</source>
          <target state="translated">사용 하 여 스키마와 데이터 모두 포함 하는 XML 문서를 읽으려면는 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;메서드.&lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a typical multiple-tier implementation, the steps for creating and refreshing a DataSet, and in turn, updating the original data are to:      1.</source>
          <target state="translated">일반적인 다중 계층 구현에서 원래 데이터를 업데이트 하는 단계 그리고 나아가서는 만들고 데이터 집합을 새로에: 1입니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>Build and fill each &lt;xref:System.Data.DataTable&gt; in a DataSet with data from a data source using a &lt;xref:System.Data.Common.DataAdapter&gt;.</source>
          <target state="translated">빌드 및 각 &lt;xref:System.Data.DataTable&gt; &lt;xref:System.Data.Common.DataAdapter&gt;.&lt;/xref:System.Data.Common.DataAdapter&gt; 를 사용 하 여 데이터 원본의 데이터로 데이터 집합에서&lt;/xref:System.Data.DataTable&gt; 채우기</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>2.</source>
          <target state="translated">2.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>Change the data in individual &lt;xref:System.Data.DataTable&gt; objects by adding, updating, or deleting &lt;xref:System.Data.DataRow&gt; objects.</source>
          <target state="translated">개인의 데이터 변경 &lt;xref:System.Data.DataTable&gt;추가, 업데이트 또는 삭제 하 여 개체 &lt;xref:System.Data.DataRow&gt;개체.&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>3.</source>
          <target state="translated">3.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invoke the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method to create a second DataSet that features only the changes to the data.</source>
          <target state="translated">호출의 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;방법을 변경한 데이터는 두 번째 데이터 집합을 만들 수 있습니다.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>4.</source>
          <target state="translated">4.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the &lt;xref:System.Data.Common.DataAdapter.Update%2A&gt; method of the &lt;xref:System.Data.Common.DataAdapter&gt;, passing the second DataSet as an argument.</source>
          <target state="translated">호출 된 &lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;의 메서드는 &lt;xref:System.Data.Common.DataAdapter&gt;, 두 번째 데이터 집합을 인수로 전달 합니다.&lt;/xref:System.Data.Common.DataAdapter&gt; &lt;/xref:System.Data.Common.DataAdapter.Update%2A&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>5.</source>
          <target state="translated">5.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invoke the &lt;xref:System.Data.DataSet.Merge%2A&gt; method to merge the changes from the second DataSet into the first.</source>
          <target state="translated">호출 된 &lt;xref:System.Data.DataSet.Merge%2A&gt;첫 번째에 두 번째 데이터 집합에서 변경 내용을 병합 하는 메서드.&lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>6.</source>
          <target state="translated">6.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invoke the &lt;xref:System.Data.DataSet.AcceptChanges%2A&gt; on the DataSet.</source>
          <target state="translated">호출 된 &lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;데이터 집합에.&lt;/xref:System.Data.DataSet.AcceptChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, invoke &lt;xref:System.Data.DataSet.RejectChanges%2A&gt; to cancel the changes.</source>
          <target state="translated">또는, 호출 &lt;xref:System.Data.DataSet.RejectChanges%2A&gt;변경을 취소 하.&lt;/xref:System.Data.DataSet.RejectChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The DataSet and &lt;xref:System.Data.DataTable&gt; objects inherit from &lt;xref:System.ComponentModel.MarshalByValueComponent&gt;, and support the &lt;xref:System.Runtime.Serialization.ISerializable&gt; interface for remoting.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 데이터 집합 및 &lt;xref:System.Data.DataTable&gt;개체에서 상속 &lt;xref:System.ComponentModel.MarshalByValueComponent&gt;, 및 지원에서 &lt;xref:System.Runtime.Serialization.ISerializable&gt;원격에 대 한 인터페이스입니다.&lt;/xref:System.Runtime.Serialization.ISerializable&gt; &lt;/xref:System.ComponentModel.MarshalByValueComponent&gt; &lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>These are the only ADO.NET objects that can be remoted.</source>
          <target state="translated">이들은 원격으로 연결할 수 있는 유일한 ADO.NET 개체입니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Classes inherited from DataSet are not finalized by the garbage collector, because the finalizer has been suppressed in DataSet.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 데이터 집합에서 상속 된 클래스 종료 자가 데이터 집합에 표시 되지 않았습니다. 때문에 가비지 수집기에 의해 종료 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The derived class can call the &lt;xref:System.GC.ReRegisterForFinalize%2A&gt; method in its constructor to allow the class to be finalized by the garbage collector.</source>
          <target state="translated">파생된 클래스를 호출할 수는 &lt;xref:System.GC.ReRegisterForFinalize%2A&gt;해당 생성자를 클래스에는 가비지 수집기에 의해 종료 될 수 있도록 합니다.&lt;/xref:System.GC.ReRegisterForFinalize%2A&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation of the &lt;xref:System.Data.DataSet&gt; constructor takes no parameters, and creates a default name, "NewDataSet," for the new instance.</source>
          <target state="translated">이 구현에서 &lt;xref:System.Data.DataSet&gt;생성자 매개 변수를 하 고 새 인스턴스에 대 한 기본 이름이 "NewDataSet"를 만듭니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>A name for the &lt;xref:System.Data.DataSet&gt; is required to ensure that the XML representation of the &lt;xref:System.Data.DataSet&gt; always has a name for the document element, which is the highest-level element in a schema definition.</source>
          <target state="translated">에 대 한 이름을 &lt;xref:System.Data.DataSet&gt;의 XML 표현이 있는지 확인 하는 데 필요한는 &lt;xref:System.Data.DataSet&gt;항상 스키마 정의에 최상위 요소가 문서 요소에 대 한 이름을 가집니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the given name.</source>
          <target state="translated">새 인스턴스를 초기화 한 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정 된 이름의 클래스입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>A name for the &lt;xref:System.Data.DataSet&gt; is required to ensure that the XML representation of the &lt;xref:System.Data.DataSet&gt; always has a name for the document element, which is the highest level element in a schema definition.</source>
          <target state="translated">에 대 한 이름을 &lt;xref:System.Data.DataSet&gt;의 XML 표현이 있는지 확인 하는 데 필요한는 &lt;xref:System.Data.DataSet&gt;항상 스키마 정의에서 가장 높은 수준의 요소가 있는 문서 요소에 대 한 이름을 가집니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The name of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">이름에서 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class that has the given serialization information and context.</source>
          <target state="translated">새 인스턴스를 초기화 한 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 를 가진 지정 된 serialization 정보와 컨텍스트.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The data needed to serialize or deserialize an object.</source>
          <target state="translated">Serialize 하거나 개체를 역직렬화 하는 데 필요한 데이터입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The source and destination of a given serialized stream.</source>
          <target state="translated">원본 및 대상 지정 된 직렬화 된 스트림의 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">새 인스턴스를 초기화는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Runtime.Serialization.StreamingContext&gt; object.</source>
          <target state="translated">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;개체입니다.&lt;/xref:System.Runtime.Serialization.StreamingContext&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The boolean value.</source>
          <target state="translated">부울 값입니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Commits all the changes made to this <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> since it was loaded or since the last time AcceptChanges was called.</source>
          <target state="translated">이에 대 한 모든 변경 내용을 커밋합니다 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 로드 된 이후 이후 또는 마지막으로 AcceptChanges를 호출 했습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both the &lt;xref:System.Data.DataRow&gt; and &lt;xref:System.Data.DataTable&gt; classes have AcceptChanges methods.</source>
          <target state="translated">둘 다는 &lt;xref:System.Data.DataRow&gt;및 &lt;xref:System.Data.DataTable&gt;클래스는 AcceptChanges 메서드가.&lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataRow&gt;</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling &lt;xref:System.Data.DataTable.AcceptChanges%2A&gt; at the &lt;xref:System.Data.DataTable&gt; level causes the &lt;xref:System.Data.DataRow.AcceptChanges%2A&gt; method for each &lt;xref:System.Data.DataRow&gt; to be called.</source>
          <target state="translated">호출 &lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;에 &lt;xref:System.Data.DataTable&gt;원인을 수준는 &lt;xref:System.Data.DataRow.AcceptChanges%2A&gt;메서드 각각에 대해 &lt;xref:System.Data.DataRow&gt;를 호출할 수 있습니다.&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataRow.AcceptChanges%2A&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataTable.AcceptChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, invoking AcceptChanges on the &lt;xref:System.Data.DataSet&gt; causes &lt;xref:System.Data.DataTable.AcceptChanges%2A&gt; to be called on each table within the &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">마찬가지로, &lt;xref:System.Data.DataSet&gt; &lt;xref:System.Data.DataTable.AcceptChanges%2A&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 내에서 각 테이블에 호출&lt;/xref:System.Data.DataTable.AcceptChanges%2A&gt; 되도록&lt;/xref:System.Data.DataSet&gt; 에 AcceptChanges를 호출</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this manner, you have multiple levels at which the method can be invoked.</source>
          <target state="translated">이러한 방식으로 메서드를 호출할 수 있는 여러 수준을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the AcceptChanges of the &lt;xref:System.Data.DataSet&gt; enables you to invoke the method on all subordinate objects (for example, tables and rows) with one call.</source>
          <target state="translated">AcceptChanges를 호출는 &lt;xref:System.Data.DataSet&gt;호출 하 여 모든 하위 개체 (예: 테이블 및 행)에 대 한 메서드를 호출할 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call <ph id="ph1">`AcceptChanges`</ph> on the <ph id="ph2">`DataSet`</ph>, any &lt;xref:System.Data.DataRow&gt; objects still in edit-mode end their edits successfully.</source>
          <target state="translated">호출 하는 경우 <ph id="ph1">`AcceptChanges`</ph> 에 <ph id="ph2">`DataSet`</ph>있으면 모든 &lt;xref:System.Data.DataRow&gt;아직 편집 모드에에서는 개체의 편집을 성공적으로 완료 합니다.&lt;/xref:System.Data.DataRow&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataRow.RowState%2A&gt; property of each &lt;xref:System.Data.DataRow&gt; also changes; <ph id="ph1">`Added`</ph> and <ph id="ph2">`Modified`</ph> rows become <ph id="ph3">`Unchanged`</ph>, and <ph id="ph4">`Deleted`</ph> rows are removed.</source>
          <target state="translated">각 &lt;xref:System.Data.DataRow&gt; &lt;xref:System.Data.DataRow.RowState%2A&gt;속성도 변경 됩니다. <ph id="ph1">`Added`</ph> 및 <ph id="ph2">`Modified`</ph> 될 행 <ph id="ph3">`Unchanged`</ph>, 및 <ph id="ph4">`Deleted`</ph> 행이 제거 됩니다. &lt;/xref:System.Data.DataRow.RowState%2A&gt;&lt;/xref:System.Data.DataRow&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`DataSet`</ph> contains &lt;xref:System.Data.ForeignKeyConstraint&gt; objects, invoking the <ph id="ph2">`AcceptChanges`</ph> method also causes the &lt;xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A&gt; to be enforced.</source>
          <target state="translated">경우는 <ph id="ph1">`DataSet`</ph> 포함 &lt;xref:System.Data.ForeignKeyConstraint&gt;개체를 호출 하는 <ph id="ph2">`AcceptChanges`</ph> 메서드는 &lt;xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A&gt;적용 됩니다.&lt;/xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A&gt; &lt;/xref:System.Data.ForeignKeyConstraint&gt;</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph><ph id="ph2"> &gt;  </ph><ph id="ph3">`AcceptChanges`</ph> and <ph id="ph4">`RejectChanges`</ph> only apply to <ph id="ph5">`DataRow`</ph> related changes (that is, Add, Remove, Delete, and Modify).</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> <ph id="ph2"> &gt;  </ph> <ph id="ph3">`AcceptChanges`</ph> 및 <ph id="ph4">`RejectChanges`</ph> 에 적용 <ph id="ph5">`DataRow`</ph> 관련 변경 내용 (즉, 추가, 제거, 삭제 및 수정).</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>They are not applicable to schema or structural changes.</source>
          <target state="translated">스키마 나 구조 변경 내용을 적용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt;    &gt;  Calling AcceptChanges will not replicate these changes back to the data source if the DataSet was filled using a DataAdapter.</source>
          <target state="translated">&gt;&gt; 호출 AcceptChanges DataAdapter를 사용 하 여 데이터 집합 채워진 경우 이러한 변경 내용을 데이터 소스에 다시 복제 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that situation, call &lt;xref:System.Data.Common.DataAdapter.Update%2A&gt; instead.</source>
          <target state="translated">이러한 상황에서는 호출 &lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;대신.&lt;/xref:System.Data.Common.DataAdapter.Update%2A&gt;</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <bpt id="p1">[</bpt>Updating Data Sources with DataAdapters<ept id="p1">](http://msdn.microsoft.com/library/33y2221y.aspx)</ept> for more information.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>Dataadapter로 데이터 원본 업데이트<ept id="p1">](http://msdn.microsoft.com/library/33y2221y.aspx)</ept> 자세한 정보에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Begins the initialization of a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is used on a form or used by another component.</source>
          <target state="translated">초기화를 시작는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 폼에 사용 되거나 다른 구성 요소에서 사용 하 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The initialization occurs at run time.</source>
          <target state="translated">초기화는 런타임에 발생 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Visual Studio .NET design environment uses this method to start the initialization of a component that is used on a form or used by another component.</source>
          <target state="translated">Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.EndInit%2A&gt; method ends the initialization.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.EndInit%2A&gt;메서드 초기화를 끝냅니다.&lt;/xref:System.Data.DataSet.EndInit%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using the BeginInit and &lt;xref:System.Data.DataSet.EndInit%2A&gt; methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">BeginInit를 사용 하 여 및 &lt;xref:System.Data.DataSet.EndInit%2A&gt;메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.&lt;/xref:System.Data.DataSet.EndInit%2A&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether string comparisons within <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> objects are case-sensitive.</source>
          <target state="translated">문자열을 나타내는 값 내에서 비교 하는지 여부를 가져오거나 <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체는 대/소문자 구분 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CaseSensitive property affects how sorting, searching, and filtering operations are performed on each &lt;xref:System.Data.DataTable&gt; object contained in a &lt;xref:System.Data.DataSet&gt; when using the &lt;xref:System.Data.DataTable.Select%2A&gt; method.</source>
          <target state="translated">CaseSensitive 속성 정렬, 검색 및 필터링 작업도 각에서 수행 하는 방법에 영향을 줍니다. &lt;xref:System.Data.DataTable&gt;에 포함 된 개체는 &lt;xref:System.Data.DataSet&gt;사용 하는 경우는 &lt;xref:System.Data.DataTable.Select%2A&gt;메서드.&lt;/xref:System.Data.DataTable.Select%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, setting the CaseSensitive property for a &lt;xref:System.Data.DataSet&gt; also sets the &lt;xref:System.Data.DataTable.CaseSensitive%2A&gt; property of each associated &lt;xref:System.Data.DataTable&gt; to the same value.</source>
          <target state="translated">CaseSensitive 속성을 설정 해도 기본적으로는 &lt;xref:System.Data.DataSet&gt;도 설정 하는 &lt;xref:System.Data.DataTable.CaseSensitive%2A&gt;의 연결 된 각 속성 &lt;xref:System.Data.DataTable&gt;동일한 값으로.&lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataTable.CaseSensitive%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if string comparisons are case-sensitive; otherwise <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>문자열 비교는 대/소문자 구분; 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">기본값은 <bpt id="p1">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Clears the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> of any data by removing all rows in all tables.</source>
          <target state="translated">지웁니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 모든 테이블의 모든 행을 제거 하 여 데이터의 합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the &lt;xref:System.Data.DataSet&gt; is bound to an &lt;xref:System.Xml.XmlDataDocument&gt;, calling Clear or &lt;xref:System.Data.DataTable.Clear%2A?displayProperty=fullName&gt; raises the &lt;xref:System.NotSupportedException&gt;.</source>
          <target state="translated">경우 &lt;xref:System.Data.DataSet&gt;에 &lt;xref:System.Xml.XmlDataDocument&gt;, 지우기 또는 &lt;xref:System.Data.DataTable.Clear%2A?displayProperty=fullName&gt; &lt;xref:System.NotSupportedException&gt;.&lt;/xref:System.NotSupportedException&gt; 발생&lt;/xref:System.Data.DataTable.Clear%2A?displayProperty=fullName&gt; 호출&lt;/xref:System.Xml.XmlDataDocument&gt; 바인딩되어&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid this situation, traverse each table, removing each row one at a time.</source>
          <target state="translated">이러한 상황을 방지 하려면 한 번에 하나씩 행을 제거, 각 테이블을 이동 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Copies the structure of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, including all <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> schemas, relations, and constraints.</source>
          <target state="translated">구조를 복사는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>, 모든 포함 하 여 <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 스키마, 관계 및 제약 조건입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Does not copy any data.</source>
          <target state="translated">모든 데이터를 복사 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>A new <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> with the same schema as the current <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, but none of the data.</source>
          <target state="translated">새 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 현재 스키마 같은 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>, 되지만 데이터입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Copies both the structure and data for this <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">이 구조와 데이터를 모두 복사 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>A new <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> with the same structure (table schemas, relations, and constraints) and data as this <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">새 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 구조 (테이블 스키마, 관계 및 제약 조건) 및 데이터 이와 동일한 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If these classes have been subclassed, the copy will also be of the same subclasses.</source>
          <target state="translated">이러한 클래스 서브클래싱된 복사본 서브 클래스 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> with one result set per <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, in the same sequence as the tables appear in the &lt;xref:System.Data.DataSet.Tables*&gt; collection.</source>
          <target state="translated">반환 된 <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 결과 집합이 당 하나씩 있는 <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>에 순서에 테이블이 나타나는 대로 &lt;xref:System.Data.DataSet.Tables*&gt;컬렉션.&lt;/xref:System.Data.DataSet.Tables*&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order to ensure the order of the result sets within the returned &lt;xref:System.Data.DataTableReader&gt;, if a &lt;xref:System.Data.DataTable&gt; within the &lt;xref:System.Data.DataSet&gt; is empty, it is represented by an empty result set within the returned <ph id="ph1">`DataTableReader`</ph>.</source>
          <target state="translated">반환 된 결과 집합의 순서를 보장 하기 위해 &lt;xref:System.Data.DataTableReader&gt;경우는 &lt;xref:System.Data.DataTable&gt;내에서 &lt;xref:System.Data.DataSet&gt;는 빈 결과 반환 된 집합으로 표현 비어 됩니다 <ph id="ph1">`DataTableReader`</ph>.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataTableReader&gt;</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> containing one or more result sets, corresponding to the <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> instances contained within the source <bpt id="p3">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 에 해당 하 하나 이상의 결과 집합을 포함 하는 <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 원본 내에 포함 된 인스턴스 <bpt id="p3">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> with one result set per <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">반환 된 <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 결과 집합이 당 하나씩 <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order to ensure that the order of the result sets within the returned &lt;xref:System.Data.DataTableReader&gt;, if a &lt;xref:System.Data.DataTable&gt; within the &lt;xref:System.Data.DataSet&gt; is empty, it is represented by an empty result set within the returned <ph id="ph1">`DataTableReader`</ph>.</source>
          <target state="translated">반환 된 결과의 순서를 설정 한다는 보장 하기 위해 &lt;xref:System.Data.DataTableReader&gt;경우는 &lt;xref:System.Data.DataTable&gt;내에서 &lt;xref:System.Data.DataSet&gt;는 빈 결과 반환 된 집합으로 표현 비어 됩니다 <ph id="ph1">`DataTableReader`</ph>.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataTableReader&gt;</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this overloaded version allows you to supply a list of <ph id="ph1">`DataTable`</ph> instances as parameters, you can specify the order in which the result sets appear within the returned <ph id="ph2">`DataTableReader`</ph>.</source>
          <target state="translated">이 오버 로드 된 버전의 목록을 제공할 수 있으므로 <ph id="ph1">`DataTable`</ph> 인스턴스 매개 변수로 반환 된 결과 집합을 나타나는 순서를 지정할 수 있습니다 <ph id="ph2">`DataTableReader`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>An array of DataTables providing the order of the result sets to be returned in the <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 반환 될 결과의 순서를 제공 하는 Datatable의 배열을 설정는 <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> containing one or more result sets, corresponding to the <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> instances contained within the source <bpt id="p3">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Data.DataTableReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 에 해당 하 하나 이상의 결과 집합을 포함 하는 <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 원본 내에 포함 된 인스턴스 <bpt id="p3">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The returned result sets are in the order specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">dataTables</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">반환 된 결과 집합은 지정 된 순서에는 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">dataTables</ph> <ept id="p1">&lt;/code&gt;</ept> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the current <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">현재의 이름을 가져오거나 설정 합니다. <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The name of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">이름에서 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Gets a custom view of the data contained in the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to allow filtering, searching, and navigating using a custom <bpt id="p2">&lt;xref href="System.Data.DataViewManager"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">사용자 지정 보기에 포함 된 데이터를 가져옵니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 필터링, 검색 및 사용자 지정을 사용 하 여 탐색을 허용 하도록 <bpt id="p2">&lt;xref href="System.Data.DataViewManager"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataViewManager&gt; returned by the DefaultViewManager property allows you to create custom settings for each &lt;xref:System.Data.DataTable&gt; in the &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataViewManager&gt;속성을 사용 하면 각 &lt;xref:System.Data.DataTable&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataTable&gt; 에 대 한 사용자 지정 설정을 만들려면 DefaultViewManager 반환한&lt;/xref:System.Data.DataViewManager&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you obtain a &lt;xref:System.Data.DataView&gt; from a &lt;xref:System.Data.DataTable&gt;, the sort order, filtering, and &lt;xref:System.Data.DataViewRowState&gt; are configured according to the settings in the DefaultViewManager property.</source>
          <target state="translated">가져올 때 한 &lt;xref:System.Data.DataView&gt;에서 &lt;xref:System.Data.DataTable&gt;, 필터링, 정렬 순서 및 &lt;xref:System.Data.DataViewRowState&gt;DefaultViewManager 속성의 설정에 따라 구성 됩니다.&lt;/xref:System.Data.DataViewRowState&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataView&gt;</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Data.DataViewManager"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Data.DataViewManager"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Determines the &lt;xref:System.Data.DataSet.SchemaSerializationMode*&gt; for a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">결정는 &lt;xref:System.Data.DataSet.SchemaSerializationMode*&gt;에 대 한는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Data.DataSet.SchemaSerializationMode*&gt;</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be called when deserializing a typed &lt;xref:System.Data.DataSet&gt; to determine its &lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;.</source>
          <target state="translated">이 메서드는 형식화 된 &lt;xref:System.Data.DataSet&gt;해당 &lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;.&lt;/xref:System.Data.DataSet.SchemaSerializationMode%2A&gt; 확인 하려면&lt;/xref:System.Data.DataSet&gt; 를 역직렬화 할 때</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.XmlReader&gt; instance that is passed during deserialization of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">&lt;xref:System.Xml.XmlReader&gt;역직렬화 하는 동안 전달 되는 인스턴스는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.Data.SchemaSerializationMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> enumeration indicating whether schema information has been omitted from the payload.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.SchemaSerializationMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 스키마 정보 페이로드에서 생략 되었는지 여부를 나타내는 열거형입니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Determines the &lt;xref:System.Data.DataSet.SchemaSerializationMode*&gt; for a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">결정는 &lt;xref:System.Data.DataSet.SchemaSerializationMode*&gt;에 대 한는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Data.DataSet.SchemaSerializationMode*&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be called when deserializing a typed &lt;xref:System.Data.DataSet&gt; to determine its &lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;.</source>
          <target state="translated">이 메서드는 형식화 된 &lt;xref:System.Data.DataSet&gt;해당 &lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;.&lt;/xref:System.Data.DataSet.SchemaSerializationMode%2A&gt; 확인 하려면&lt;/xref:System.Data.DataSet&gt; 를 역직렬화 할 때</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that a <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>’s protected constructor <ph id="ph1">&amp;lt;</ph>xref:System.Data.DataSet.%23ctor%2A<ph id="ph2">&amp;gt;</ph> is invoked with during deserialization in remoting scenarios.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 하는 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>보호 된 생성자의 <ph id="ph1">&amp;lt;</ph>xref:System.Data.DataSet.%23ctor%2A<ph id="ph2">&amp;gt;</ph> 원격 시나리오에서 역직렬화 하는 동안 사용 하 여 호출 합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Runtime.Serialization.StreamingContext&gt; that a <bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>’s protected constructor <ph id="ph1">&amp;lt;</ph>xref:System.Data.DataSet.%23ctor%2A<ph id="ph2">&amp;gt;</ph> is invoked with during deserialization in remoting scenarios.</source>
          <target state="translated">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;하는 <bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>보호 된 생성자의 <ph id="ph1">&amp;lt;</ph>xref:System.Data.DataSet.%23ctor%2A<ph id="ph2">&amp;gt;</ph> 와 함께 원격 시나리오에서 역직렬화 하는 동안 호출 됩니다.&lt;/xref:System.Runtime.Serialization.StreamingContext&gt;</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.Data.SchemaSerializationMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> enumeration indicating whether schema information has been omitted from the payload.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.SchemaSerializationMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 스키마 정보 페이로드에서 생략 되었는지 여부를 나타내는 열거형입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Ends the initialization of a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is used on a form or used by another component.</source>
          <target state="translated">초기화를 종료 한 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 폼에 사용 되거나 다른 구성 요소에서 사용 하 합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The initialization occurs at run time.</source>
          <target state="translated">초기화는 런타임에 발생 합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Visual Studio .NET design environment uses this method to end the initialization of a component that is used on a form or used by another component.</source>
          <target state="translated">Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.BeginInit%2A&gt; method starts the initialization.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;메서드 초기화를 시작 합니다.&lt;/xref:System.Data.DataSet.BeginInit%2A&gt;</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using the &lt;xref:System.Data.DataSet.BeginInit%2A&gt; and EndInit methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">사용 하 여 &lt;xref:System.Data.DataSet.BeginInit%2A&gt;하 고 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 하 EndInit 메서드.&lt;/xref:System.Data.DataSet.BeginInit%2A&gt;</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether constraint rules are followed when attempting any update operation.</source>
          <target state="translated">업데이트 작업을 수행할 때 제약 조건 규칙을 따르는지 여부를 나타내는 값을 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constraints are set at the &lt;xref:System.Data.DataTable&gt; level (&lt;xref:System.Data.DataTable.Constraints%2A&gt; property).</source>
          <target state="translated">제약 조건에 설정 되 고 &lt;xref:System.Data.DataTable&gt;수준 (&lt;xref:System.Data.DataTable.Constraints%2A&gt; 속성).&lt;/xref:System.Data.DataTable.Constraints%2A&gt; &lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about creating constraints, see <bpt id="p1">[</bpt>DataTable Constraints<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">제약 조건을 만드는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>DataTable 제약 조건<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if rules are enforced; otherwise <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>규칙이; 적용 하는 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">기본값은 <bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>One or more constraints cannot be enforced.</source>
          <target state="translated">하나 이상의 제약 조건은 적용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Gets the collection of customized user information associated with the <bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">연결 된 사용자 지정 된 사용자 정보 컬렉션을 가져옵니다는 <bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ExtendedProperties property enables you to store custom information with the <ph id="ph1">`DataSet`</ph>.</source>
          <target state="translated">ExtendedProperties 속성을 사용 하 여 사용자 지정 정보를 저장할 수는 <ph id="ph1">`DataSet`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you might store a time when the data should be refreshed.</source>
          <target state="translated">예를 들어 데이터를 새로 고쳐야 할 시간을 저장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>Extended properties must be of type &lt;xref:System.String&gt; if you want them persisted when the &lt;xref:System.Data.DataSet&gt; is written as XML.</source>
          <target state="translated">확장된 속성 형식 이어야 합니다 &lt;xref:System.String&gt;파일과 유지는 &lt;xref:System.Data.DataSet&gt;XML로 기록 됩니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Data.PropertyCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> with all custom user information.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Data.PropertyCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 모든 사용자 지정 사용자 정보로 합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Gets a copy of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains all changes made to it since it was loaded or since &lt;xref:System.Data.DataSet.AcceptChanges*&gt; was last called.</source>
          <target state="translated">복사본을 가져옵니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 내용을 로드 된 이후 또는 이후 모든 변경 내용이 들어 있는 &lt;xref:System.Data.DataSet.AcceptChanges*&gt;마지막으로 호출한.&lt;/xref:System.Data.DataSet.AcceptChanges*&gt;</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Creates a new &lt;xref:System.Data.DataSet&gt; that contains a copy of all rows in the original &lt;xref:System.Data.DataSet&gt; that have pending changes.</source>
          <target state="translated">원본 또는 &lt;xref:System.Data.DataSet&gt;원래에 모든 행의 복사본이 포함 된 &lt;xref:System.Data.DataSet&gt;보류 중인 변경 내용이 있는.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>Relationship constraints can cause additional unchanged rows to be added to the new &lt;xref:System.Data.DataSet&gt; if the unchanged rows contain primary keys corresponding to foreign keys in the changed rows.</source>
          <target state="translated">관계 제약 조건으로 인해 새에 추가할 추가 변경 되지 않은 행 &lt;xref:System.Data.DataSet&gt;변경 되지 않은 행에는 변경 된 행에서 외래 키에 해당 하는 기본 키를 포함 하는 경우.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method returns <ph id="ph1">`null`</ph> if there are no rows in the original &lt;xref:System.Data.DataSet&gt; that have pending changes.</source>
          <target state="translated">메서드가 반환 <ph id="ph1">`null`</ph> 원래에서 행이 없는 경우 &lt;xref:System.Data.DataSet&gt;보류 중인 변경 내용이 있는.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>A copy of the changes from this <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that can have actions performed on it and later be merged back in using &lt;xref:System.Data.DataSet.Merge*&gt;.</source>
          <target state="translated">이 변경의 복사본 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> &lt;xref:System.Data.DataSet.Merge*&gt;.&lt;/xref:System.Data.DataSet.Merge*&gt; 를 사용 하 여에 다시 병합 될 작업을 수행할 수 있는</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>If no changed rows are found, the method returns <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">메서드가 반환 하는 경우 변경 된 행이 발견 되 면 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Gets a copy of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> containing all changes made to it since it was last loaded, or since &lt;xref:System.Data.DataSet.AcceptChanges*&gt; was called, filtered by <bpt id="p2">&lt;xref href="System.Data.DataRowState"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">복사본을 가져옵니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 내용을 마지막 로드 된 이후 또는 이후 모든 변경 내용이 포함 된 &lt;xref:System.Data.DataSet.AcceptChanges*&gt;호출을 기준으로 필터링 <bpt id="p2">&lt;xref href="System.Data.DataRowState"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.&lt;/xref:System.Data.DataSet.AcceptChanges*&gt;</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method is used to produce a second &lt;xref:System.Data.DataSet&gt; object that contains only the changes introduced into the original.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;초를 생성 하기 위해 메서드를 사용 하는 &lt;xref:System.Data.DataSet&gt;원래에 도입 된 변경 내용만 포함 하는 개체입니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.GetChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`rowStates`</ph> argument to specify the type of changes the new object should include.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">`rowStates`</ph> 인수를 새 개체에 포함 될 변경 유형을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>This returned copy is designed to be merged back in to this original &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 반환 된 복사본을이에 다시 병합 될 하도록 되어 원래 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>Relationship constraints may cause parent rows marked <ph id="ph1">`Unchanged`</ph> to be included.</source>
          <target state="translated">관계 제약 조건으로 표시 된 부모 행 않을 <ph id="ph1">`Unchanged`</ph> 포함 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no rows of the desired &lt;xref:System.Data.DataRowState&gt; are found, the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">원하는 행이 없으면 &lt;xref:System.Data.DataRowState&gt;발견 되는 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;메서드 반환 <ph id="ph1">`null`</ph>.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt; &lt;/xref:System.Data.DataRowState&gt;</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.DataRowState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.DataRowState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>A filtered copy of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that can have actions performed on it, and subsequently be merged back in using &lt;xref:System.Data.DataSet.Merge*&gt;.</source>
          <target state="translated">필터링 된 복사본은 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> &lt;xref:System.Data.DataSet.Merge*&gt;.&lt;/xref:System.Data.DataSet.Merge*&gt; 를 사용 하 여에 다시 병합 될을 이후에 수행 된 작업에 있는</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>If no rows of the desired <bpt id="p1">&lt;xref href="System.Data.DataRowState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> are found, the method returns <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">원하는 행이 없으면 <bpt id="p1">&lt;xref href="System.Data.DataRowState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 발견 되 면 메서드가 반환 <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Gets a copy of <bpt id="p1">&lt;xref href="System.Xml.Schema.XmlSchemaSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for the DataSet.</source>
          <target state="translated">복사본을 가져옵니다 <bpt id="p1">&lt;xref href="System.Xml.Schema.XmlSchemaSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터 집합에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The specified schema set.</source>
          <target state="translated">지정 된 스키마 집합입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>A copy of <bpt id="p1">&lt;xref href="System.Xml.Schema.XmlSchemaSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A copy of <bpt id="p1">&lt;xref href="System.Xml.Schema.XmlSchemaSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Populates a serialization information object with the data needed to serialize the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Serialization 정보 개체를 serialize 하는 데 필요한 데이터로 채우는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that holds the serialized data associated with the <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 와 관련 된 serialize 된 데이터를 보유 하는 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Runtime.Serialization.StreamingContext&gt; that contains the source and destination of the serialized stream associated with the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A &lt;xref:System.Runtime.Serialization.StreamingContext&gt;와 관련 된 serialize 된 스트림의 대상이 및 원본을 포함 하는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Runtime.Serialization.StreamingContext&gt;</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">info</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">info</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Returns a serializable &lt;xref:System.Xml.Schema.XMLSchema&gt; instance.</source>
          <target state="translated">반환 된 직렬화 가능 &lt;xref:System.Xml.Schema.XMLSchema&gt;인스턴스.&lt;/xref:System.Xml.Schema.XMLSchema&gt;</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.Schema.XMLSchema&gt; instance.</source>
          <target state="translated">&lt;xref:System.Xml.Schema.XMLSchema&gt;인스턴스.&lt;/xref:System.Xml.Schema.XMLSchema&gt;</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Deserializes the table data from the binary or XML stream.</source>
          <target state="translated">이진 또는 XML 스트림에서 테이블 데이터를 역직렬화합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 인스턴스.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The streaming context.</source>
          <target state="translated">스트리밍 컨텍스트입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Returns the XML representation of the data stored in the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 저장 된 데이터의 XML 표현을 반환는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method is identical to calling &lt;xref:System.Data.DataSet.WriteXml%2A&gt; with &lt;xref:System.Data.XmlWriteMode&gt; set to &lt;xref:System.Data.XmlWriteMode&gt;.</source>
          <target state="translated">이 메서드를 호출 하는 호출 &lt;xref:System.Data.DataSet.WriteXml%2A&gt; &lt;xref:System.Data.XmlWriteMode&gt; &lt;xref:System.Data.XmlWriteMode&gt;.&lt;/xref:System.Data.XmlWriteMode&gt; &lt;/xref:System.Data.XmlWriteMode&gt; 와&lt;/xref:System.Data.DataSet.WriteXml%2A&gt; 동일</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>GetXml returns XML as a string, and therefore requires more overhead than &lt;xref:System.Data.DataSet.WriteXml%2A&gt; to write XML to a file.</source>
          <target state="translated">GetXml XML는 문자열을 반환 하므로 보다 더 많은 오버 헤드가 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;XML 파일에 쓸 수 있습니다.&lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you build a &lt;xref:System.Data.DataSet&gt; using schema inference and serialize it using XML or Web services, the column ordering may change.</source>
          <target state="translated">작성 하는 경우는 &lt;xref:System.Data.DataSet&gt;스키마 유추를 사용 하 고 serialize XML 또는 웹 서비스를 사용 하 고, 열 순서 변경 될 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>A string that is a representation of the data stored in the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 저장 된 데이터의 표현 되는 문자열은 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Returns the XML Schema for the XML representation of the data stored in the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 저장 된 데이터의 XML 표현에 대 한 XML 스키마를 반환 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method is identical to calling &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;, except that only the primary schema is written.</source>
          <target state="translated">이 메서드를 호출 하는 것은 호출 동일 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;한다는 점을 제외 하는 기본 스키마만 기록 됩니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>GetXmlSchema returns XML as a string, and therefore requires more overhead than &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; to write XML to a file.</source>
          <target state="translated">GetXmlSchema XML는 문자열을 반환 하므로 보다 더 많은 오버 헤드가 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;XML 파일에 쓸 수 있습니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you build a &lt;xref:System.Data.DataSet&gt; using schema inference and serialize it using XML or Web services, the column ordering may change.</source>
          <target state="translated">작성 하는 경우는 &lt;xref:System.Data.DataSet&gt;스키마 유추를 사용 하 고 serialize XML 또는 웹 서비스를 사용 하 고, 열 순서 변경 될 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>String that is the XML Schema for the XML representation of the data stored in the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">문자열에 저장 된 데이터의 XML 표현에 대 한 XML 스키마는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> has changes, including new, deleted, or modified rows.</source>
          <target state="translated">나타내는 값을 가져옵니다 여부는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 새, 삭제 또는 수정 된 행을 포함 하 여 변경 내용이 있습니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> has changes; otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우는 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 에 변경 내용이 고, 그렇지 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> has changes, including new, deleted, or modified rows, filtered by <bpt id="p2">&lt;xref href="System.Data.DataRowState"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">나타내는 값을 가져옵니다 여부는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 기준으로 필터링, 삭제 또는 수정 된 행을 포함 하 여 변경 내용이 <bpt id="p2">&lt;xref href="System.Data.DataRowState"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>Examine the &lt;xref:System.Data.DataSet.HasChanges%2A&gt; property of the <ph id="ph1">`DataSet`</ph> before invoking the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method.</source>
          <target state="translated">검사는 &lt;xref:System.Data.DataSet.HasChanges%2A&gt;의 속성은 <ph id="ph1">`DataSet`</ph> 호출 하기 전에 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;메서드.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt; &lt;/xref:System.Data.DataSet.HasChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.DataRowState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.DataRowState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> has changes; otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>경우는 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 에 변경 내용이 고, 그렇지 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether there are errors in any of the <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> objects within this <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">중에 오류가 있는지 여부를 나타내는 값을 가져옵니다는 <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 내의 개체 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each &lt;xref:System.Data.DataTable&gt; in a &lt;xref:System.Data.DataSet&gt; also has a &lt;xref:System.Data.DataTable.HasErrors%2A&gt; property.</source>
          <target state="translated">각 &lt;xref:System.Data.DataTable&gt;에 &lt;xref:System.Data.DataSet&gt;역시는 &lt;xref:System.Data.DataTable.HasErrors%2A&gt;속성.&lt;/xref:System.Data.DataTable.HasErrors%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`HasErrors`</ph> property of the <ph id="ph2">`DataSet`</ph> first, to determine if any table has errors, before checking individual &lt;xref:System.Data.DataTable&gt; objects.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">`HasErrors`</ph> 의 속성은 <ph id="ph2">`DataSet`</ph> 테이블 개별 검사 하기 전에 오류를에 있는지 확인 하려면 첫 번째 &lt;xref:System.Data.DataTable&gt;개체.&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a <ph id="ph1">`DataTable`</ph> has errors, the &lt;xref:System.Data.DataTable.GetErrors%2A&gt; method returns an array of &lt;xref:System.Data.DataRow&gt; objects containing the errors.</source>
          <target state="translated">경우는 <ph id="ph1">`DataTable`</ph> 에 오류가 &lt;xref:System.Data.DataTable.GetErrors%2A&gt;메서드 배열을 반환 &lt;xref:System.Data.DataRow&gt;오류를 포함 하는 개체입니다.&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable.GetErrors%2A&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if any table contains an error;otherwise <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>테이블에 오류가 있습니다; 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Applies the XML schema from the specified &lt;xref:System.IO.Stream&gt; to the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정 된 위치에서 XML 스키마를 적용 &lt;xref:System.IO.Stream&gt;에 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_Stream" name="Stream" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to read the schema.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_Stream" name="Stream" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 스키마를 읽을입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">스키마 유추에서 제외 될 네임 스페이스 식별자 URI (Uniform Resource) 문자열의 배열입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Applies the XML schema from the specified &lt;xref:System.IO.TextReader&gt; to the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정 된 위치에서 XML 스키마를 적용 &lt;xref:System.IO.TextReader&gt;에 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.IO.TextReader&gt;</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TextReader" name="TextReader" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to read the schema.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TextReader" name="TextReader" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 스키마를 읽을입니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">스키마 유추에서 제외 될 네임 스페이스 식별자 URI (Uniform Resource) 문자열의 배열입니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Applies the XML schema from the specified file to the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 지정된 된 파일에서 XML 스키마를 적용 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The name of the file (including the path) from which to read the schema.</source>
          <target state="translated">스키마를 읽을 (경로 포함) 파일의 이름입니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">스키마 유추에서 제외 될 네임 스페이스 식별자 URI (Uniform Resource) 문자열의 배열입니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is not set to <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>로 설정 되지 않은 <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Applies the XML schema from the specified &lt;xref:System.Xml.XmlReader&gt; to the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정 된 위치에서 XML 스키마를 적용 &lt;xref:System.Xml.XmlReader&gt;에 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_XMLReader" name="XMLReader" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to read the schema.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_XMLReader" name="XMLReader" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 스키마를 읽을입니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">스키마 유추에서 제외 될 네임 스페이스 식별자 URI (Uniform Resource) 문자열의 배열입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Occurs after the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is initialized.</source>
          <target state="translated">뒤에 오는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see &lt;xref:System.Data.DataSet.IsInitialized%2A&gt;.</source>
          <target state="translated">자세한 내용은 &lt;xref:System.Data.DataSet.IsInitialized%2A&gt;.&lt;/xref:System.Data.DataSet.IsInitialized%2A&gt; 을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">추가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Deserialize all of the tables data of the DataSet from the binary or XML stream.</source>
          <target state="translated">모든 이진 또는 XML 스트림에서 데이터 집합의 테이블 데이터를 deserialize 합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Inspects the format of the serialized representation of the <bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">serialize 된 표현 형식을 검사는 <bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</source>
          <target state="translated">이 멤버는.NET Framework 인프라를 지원 하며 사용자 코드에서 직접 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Runtime.Serialization.StreamingContext&gt; object.</source>
          <target state="translated">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;개체입니다.&lt;/xref:System.Runtime.Serialization.StreamingContext&gt;</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the specified <bpt id="p2">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> represents a <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> serialized in its binary format, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept> otherwise.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>하는 경우 지정 된 <bpt id="p2">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 나타냅니다는 <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 이진 형식으로 직렬화 <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept> 그렇지 않은 경우.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is initialized.</source>
          <target state="translated">나타내는 값을 가져옵니다 여부는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>Returns the status of the &lt;xref:System.Data.DataSet&gt; while it’s being constructed, for instance by Visual Studio.</source>
          <target state="translated">상태를 반환 하는 &lt;xref:System.Data.DataSet&gt;것은 생성 되 고, 예를 들어 Visual Studio에서 동안.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.BeginInit%2A&gt; method sets it to <ph id="ph1">`false`</ph> and &lt;xref:System.Data.DataSet.EndInit%2A&gt; method sets it to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;메서드를 설정 <ph id="ph1">`false`</ph> 및 &lt;xref:System.Data.DataSet.EndInit%2A&gt;메서드를 설정 <ph id="ph2">`true`</ph>.&lt;/xref:System.Data.DataSet.EndInit%2A&gt; &lt;/xref:System.Data.DataSet.BeginInit%2A&gt;</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to indicate the component has completed initialization; otherwise <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>초기화가 완료를 나타내는 구성 요소 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Fills a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> with values from a data source using the supplied <bpt id="p2">&lt;xref href="System.Data.IDataReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, using an array of <bpt id="p3">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> instances to supply the schema and namespace information.</source>
          <target state="translated">채웁니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 제공 된 데이터 원본의 값으로 <bpt id="p2">&lt;xref href="System.Data.IDataReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>, 배열을 사용 하 여 <bpt id="p3">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 인스턴스 스키마 및 네임 스페이스 정보를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataTable.Load%2A&gt; method provides a technique for filling a single &lt;xref:System.Data.DataTable&gt; with data, retrieved from an &lt;xref:System.Data.IDataReader&gt; instance.</source>
          <target state="translated">&lt;xref:System.Data.DataTable.Load%2A&gt;메서드는 단일을 채우기 위한 수 있는 방법을 제공 &lt;xref:System.Data.DataTable&gt;에서 검색 된 데이터와는 &lt;xref:System.Data.IDataReader&gt;인스턴스.&lt;/xref:System.Data.IDataReader&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataTable.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an &lt;xref:System.Data.IDataReader&gt; into multiple tables within a &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 메서드는 동일한 기능을 제공 하지만 &lt;xref:System.Data.IDataReader&gt;를 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 내에서 여러 테이블에&lt;/xref:System.Data.IDataReader&gt; 에서 여러 결과 집합을 로드할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The load operation will fail with an &lt;xref:System.InvalidOperationException&gt; if any of the source data columns in the incoming <ph id="ph2">`reader`</ph> are computed columns.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 로드 작업이 실패 하며는 &lt;xref:System.InvalidOperationException&gt;경우 들어오는 원본 데이터 열 <ph id="ph2">`reader`</ph> 계산 된 열인.&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`loadOption`</ph> parameter allows you to specify how you want the imported data to interact with existing data, and can be any of the values from the &lt;xref:System.Data.LoadOption&gt; enumeration.</source>
          <target state="translated"><ph id="ph1">`loadOption`</ph> 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 및의 값 중 하나일 수 있습니다 방법을 지정할 수 있습니다는 &lt;xref:System.Data.LoadOption&gt;열거형.&lt;/xref:System.Data.LoadOption&gt;</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the documentation for the &lt;xref:System.Data.DataTable&gt;&lt;xref:System.Data.DataTable.Load%2A&gt; method for more information on using this parameter.</source>
          <target state="translated">&lt;xref:System.Data.DataTable&gt;에 대 한 설명서를 참조 하십시오. &lt;xref:System.Data.DataTable.Load%2A&gt;이 매개 변수를 사용 하 여 대 한 자세한 내용은 메서드.&lt;/xref:System.Data.DataTable.Load%2A&gt;&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`tables`</ph> parameter allows you to specify an array of &lt;xref:System.Data.DataTable&gt; instances, indicating the order of the tables corresponding to each result set loaded from the reader.</source>
          <target state="translated"><ph id="ph1">`tables`</ph> 매개 변수 배열을 지정할 수 있습니다 &lt;xref:System.Data.DataTable&gt;해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 인스턴스.&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Loadmethod fills each supplied &lt;xref:System.Data.DataTable&gt; instance with data from a single result set from the source data reader.</source>
          <target state="translated">Loadmethod 채우기 각 제공 &lt;xref:System.Data.DataTable&gt;단일 결과 집합에서 원본 데이터 판독기에서에서 데이터를 사용 하 여 인스턴스.&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>After each result set, the Loadmethod moves on to the next result set within the reader, until there are no more result sets.</source>
          <target state="translated">각 결과 집합 후 Loadmethod는 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내에서 집합으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name resolution scheme for this method is the same as that followed by the &lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt; method of the &lt;xref:System.Data.Common.DbDataAdapter&gt; class.</source>
          <target state="translated">이 메서드에 대 한 이름 확인 스키마 &lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt; &lt;xref:System.Data.Common.DbDataAdapter&gt;클래스&lt;/xref:System.Data.Common.DbDataAdapter&gt; 의 메서드&lt;/xref:System.Data.Common.DbDataAdapter.Fill%2A&gt; 뒤와 같습니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.Data.IDataReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that provides one or more result sets.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.IDataReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 하나 이상의 결과 집합을 제공 하는 합니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>A value from the <bpt id="p1">&lt;xref href="System.Data.LoadOption"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> enumeration that indicates how rows already in the <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> instances within the <bpt id="p3">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> will be combined with incoming rows that share the same primary key.</source>
          <target state="translated">값은 <bpt id="p1">&lt;xref href="System.Data.LoadOption"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 를 나타내는 열거형입니다 방법을 있는 행의 <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 인스턴스에 <bpt id="p3">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 동일한 기본 키를 공유 하는 들어오는 행과 결합 되는 합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>An array of <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instances, from which the Load method retrieves name and namespace information.</source>
          <target state="translated">배열을 <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 인스턴스, Load 메서드를 이름 및 네임 스페이스 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Each of these tables must be a member of the <bpt id="p1">&lt;xref href="System.Data.DataTableCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> contained by this <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">이러한 테이블의 각의 구성원 이어야 합니다는 <bpt id="p1">&lt;xref href="System.Data.DataTableCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 포함 된 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Fills a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> with values from a data source using the supplied <bpt id="p2">&lt;xref href="System.Data.IDataReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, using an array of strings to supply the names for the tables within the <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated">채웁니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 제공 된 데이터 원본의 값으로 <bpt id="p2">&lt;xref href="System.Data.IDataReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>, 문자열의 배열을 사용 하 여 내에 있는 테이블에 대 한 이름을 제공 하는 <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataTable.Load%2A&gt; method provides a technique for filling a single &lt;xref:System.Data.DataTable&gt; with data, retrieved from an &lt;xref:System.Data.IDataReader&gt; instance.</source>
          <target state="translated">&lt;xref:System.Data.DataTable.Load%2A&gt;메서드는 단일을 채우기 위한 수 있는 방법을 제공 &lt;xref:System.Data.DataTable&gt;에서 검색 된 데이터와는 &lt;xref:System.Data.IDataReader&gt;인스턴스.&lt;/xref:System.Data.IDataReader&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataTable.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an <ph id="ph1">`IDataReader`</ph> into multiple tables within a <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated">여러 결과 집합을 로드할 수 있습니다, 동일한 기능을 제공 하는이 메서드는 <ph id="ph1">`IDataReader`</ph> 내에서 여러 테이블에는 <ph id="ph2">`DataSet`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The load operation will fail with an &lt;xref:System.InvalidOperationException&gt; if any of the source data columns in the incoming <ph id="ph2">`reader`</ph> are computed columns.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 로드 작업이 실패 하며는 &lt;xref:System.InvalidOperationException&gt;경우 들어오는 원본 데이터 열 <ph id="ph2">`reader`</ph> 계산 된 열인.&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`loadOption`</ph> parameter allows you to specify how you want the imported data to interact with existing data, and can be any of the values from the &lt;xref:System.Data.LoadOption&gt; enumeration.</source>
          <target state="translated"><ph id="ph1">`loadOption`</ph> 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 및의 값 중 하나일 수 있습니다 방법을 지정할 수 있습니다는 &lt;xref:System.Data.LoadOption&gt;열거형.&lt;/xref:System.Data.LoadOption&gt;</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the documentation for the &lt;xref:System.Data.DataTable.Load%2A&gt; method for more information on using this parameter.</source>
          <target state="translated">에 대 한 설명서를 참조 하십시오.는 &lt;xref:System.Data.DataTable.Load%2A&gt;이 매개 변수를 사용 하 여 대 한 자세한 내용은 메서드.&lt;/xref:System.Data.DataTable.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`tables`</ph> parameter allows you to specify an array of table names, indicating the order of the tables corresponding to each result set loaded from the reader.</source>
          <target state="translated"><ph id="ph1">`tables`</ph> 매개 변수를 사용 하면 해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 테이블 이름의 배열을 지정 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Load`</ph> method attempts to find a table within the <ph id="ph2">`DataSet`</ph> matching the name found in the array of table names, in order.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 내에서 테이블을 찾으려고는 <ph id="ph2">`DataSet`</ph> 이름과 일치 하는 순서로 테이블 이름의 배열에서 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a matching table is found, that table is loaded with the content of the current result set.</source>
          <target state="translated">일치 하는 테이블 발견 되 면 해당 테이블은 현재 결과 집합의 내용을 사용 하 여 로드 됩니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no matching table is found, a table is created using the name supplied in the array of table names, and the new table's schema is inferred from the result set.</source>
          <target state="translated">일치 하는 테이블이 있으면 테이블 이름의 배열에 제공 된 이름을 사용 하 여 테이블을 만들 하 고 새 테이블의 스키마는 결과 집합에서 유추 됩니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>After each result set, the <ph id="ph1">`Load`</ph> method moves on to the next result set within the reader, until there are no more result sets.</source>
          <target state="translated">각 결과 집합 후의 <ph id="ph1">`Load`</ph> 메서드 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내에서 집합으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default namespace associated with <ph id="ph1">`DataSet`</ph>, if any, is associated with each newly created <ph id="ph2">`DataTable`</ph>.</source>
          <target state="translated">와 연결 된 기본 네임 스페이스 <ph id="ph1">`DataSet`</ph>있는 경우 새로 만든 각와 연결 된 경우, <ph id="ph2">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name resolution scheme for this method is the same as that followed by the &lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt; method of the &lt;xref:System.Data.Common.DbDataAdapter&gt; class.</source>
          <target state="translated">이 메서드에 대 한 이름 확인 스키마 &lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt; &lt;xref:System.Data.Common.DbDataAdapter&gt;클래스&lt;/xref:System.Data.Common.DbDataAdapter&gt; 의 메서드&lt;/xref:System.Data.Common.DbDataAdapter.Fill%2A&gt; 뒤와 같습니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.Data.IDataReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that provides one or more result sets.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.IDataReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 하나 이상의 결과 집합을 제공 하는 합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>A value from the <bpt id="p1">&lt;xref href="System.Data.LoadOption"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> enumeration that indicates how rows already in the <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> instances within the <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> will be combined with incoming rows that share the same primary key.</source>
          <target state="translated">값은 <bpt id="p1">&lt;xref href="System.Data.LoadOption"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 를 나타내는 열거형입니다 방법을 있는 행의 <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 인스턴스에 <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 동일한 기본 키를 공유 하는 들어오는 행과 결합 되는 합니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>An array of strings, from which the <bpt id="p1">&lt;xref uid="langword_csharp_Load" name="Load" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> method retrieves table name information.</source>
          <target state="translated">문자열의 배열을 <bpt id="p1">&lt;xref uid="langword_csharp_Load" name="Load" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 메서드 테이블 이름 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Fills a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> with values from a data source using the supplied <bpt id="p2">&lt;xref href="System.Data.IDataReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, using an array of <bpt id="p3">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> instances to supply the schema and namespace information.</source>
          <target state="translated">채웁니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 제공 된 데이터 원본의 값으로 <bpt id="p2">&lt;xref href="System.Data.IDataReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>, 배열을 사용 하 여 <bpt id="p3">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 인스턴스 스키마 및 네임 스페이스 정보를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataTable.Load%2A&gt; method provides a technique for filling a single &lt;xref:System.Data.DataTable&gt; with data, retrieved from an &lt;xref:System.Data.IDataReader&gt; instance.</source>
          <target state="translated">&lt;xref:System.Data.DataTable.Load%2A&gt;메서드는 단일을 채우기 위한 수 있는 방법을 제공 &lt;xref:System.Data.DataTable&gt;에서 검색 된 데이터와는 &lt;xref:System.Data.IDataReader&gt;인스턴스.&lt;/xref:System.Data.IDataReader&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataTable.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an &lt;xref:System.Data.IDataReader&gt; into multiple tables within a &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 메서드는 동일한 기능을 제공 하지만 &lt;xref:System.Data.IDataReader&gt;를 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 내에서 여러 테이블에&lt;/xref:System.Data.IDataReader&gt; 에서 여러 결과 집합을 로드할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The load operation will fail with an &lt;xref:System.InvalidOperationException&gt; if any of the source data columns in the incoming <ph id="ph2">`reader`</ph> are computed columns.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 로드 작업이 실패 하며는 &lt;xref:System.InvalidOperationException&gt;경우 들어오는 원본 데이터 열 <ph id="ph2">`reader`</ph> 계산 된 열인.&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`loadOption`</ph> parameter allows you to specify how you want the imported data to interact with existing data, and can be any of the values from the &lt;xref:System.Data.LoadOption&gt; enumeration.</source>
          <target state="translated"><ph id="ph1">`loadOption`</ph> 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 및의 값 중 하나일 수 있습니다 방법을 지정할 수 있습니다는 &lt;xref:System.Data.LoadOption&gt;열거형.&lt;/xref:System.Data.LoadOption&gt;</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the documentation for the &lt;xref:System.Data.DataTable&gt;&lt;xref:System.Data.DataTable.Load%2A&gt; method for more information on using this parameter.</source>
          <target state="translated">&lt;xref:System.Data.DataTable&gt;에 대 한 설명서를 참조 하십시오. &lt;xref:System.Data.DataTable.Load%2A&gt;이 매개 변수를 사용 하 여 대 한 자세한 내용은 메서드.&lt;/xref:System.Data.DataTable.Load%2A&gt;&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`errorHandler`</ph> parameter is a &lt;xref:System.Data.FillErrorEventHandler&gt; delegate that refers to a procedure that is called when an error occurs while loading data.</source>
          <target state="translated"><ph id="ph1">`errorHandler`</ph> 매개 변수는 한 &lt;xref:System.Data.FillErrorEventHandler&gt;데이터를 로드 하는 동안 오류가 발생할 때 호출 되는 프로시저를 참조 하는 대리자입니다.&lt;/xref:System.Data.FillErrorEventHandler&gt;</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.FillErrorEventArgs&gt; parameter passed to the procedure provides properties that allow you to retrieve information about the error that occurred, the current row of data, and the &lt;xref:System.Data.DataTable&gt; being filled.</source>
          <target state="translated">&lt;xref:System.Data.FillErrorEventArgs&gt;발생 한 오류, 데이터의 현재 행에 대 한 정보를 검색할 수 있도록 하는 속성을 제공 하는 프로시저에 전달 된 매개 변수 및 &lt;xref:System.Data.DataTable&gt;채워지고.&lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.FillErrorEventArgs&gt;</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this delegate mechanism, rather than a simpler try/catch block, allows you to determine the error, handle the situation, and continue processing if you like.</source>
          <target state="translated">이 대리자 메커니즘을 사용 하 여, 대신 간단한 try/catch 블록을 오류를 확인할 수 있습니다 상황을 처리을 원하는 경우 처리를 계속 합니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.FillErrorEventArgs&gt; parameter supplies a &lt;xref:System.Data.FillErrorEventArgs.Continue%2A&gt; property: set this property to <ph id="ph1">`true`</ph> to indicate that you have handled the error and wish to continue processing; set the property to <ph id="ph2">`false`</ph> to indicate that you wish to halt processing.</source>
          <target state="translated">&lt;xref:System.Data.FillErrorEventArgs&gt;매개 변수를 제공는 &lt;xref:System.Data.FillErrorEventArgs.Continue%2A&gt;속성:이 속성을 설정 <ph id="ph1">`true`</ph> 오류 및; 처리를 계속 하려는 처리 했음을 나타내기 위해 속성을 설정 <ph id="ph2">`false`</ph> 처리를 중단 하려면 나타냅니다.&lt;/xref:System.Data.FillErrorEventArgs.Continue%2A&gt; &lt;/xref:System.Data.FillErrorEventArgs&gt;</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Be aware that setting the property to <ph id="ph1">`false`</ph> causes the code that triggered the problem to throw an exception.</source>
          <target state="translated">주의 해당 속성을 설정 <ph id="ph1">`false`</ph> 하면 예외를 throw 하는 문제를 발생 시킨 코드가 있습니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`tables`</ph> parameter allows you to specify an array of &lt;xref:System.Data.DataTable&gt; instances, indicating the order of the tables corresponding to each result set loaded from the reader.</source>
          <target state="translated"><ph id="ph1">`tables`</ph> 매개 변수 배열을 지정할 수 있습니다 &lt;xref:System.Data.DataTable&gt;해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 인스턴스.&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Loadmethod fills each supplied &lt;xref:System.Data.DataTable&gt; instance with data from a single result set from the source data reader.</source>
          <target state="translated">Loadmethod 채우기 각 제공 &lt;xref:System.Data.DataTable&gt;단일 결과 집합에서 원본 데이터 판독기에서에서 데이터를 사용 하 여 인스턴스.&lt;/xref:System.Data.DataTable&gt;</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>After each result set, the Loadmethod moves on to the next result set within the reader, until there are no more result sets.</source>
          <target state="translated">각 결과 집합 후 Loadmethod는 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내에서 집합으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name resolution scheme for this method is the same as that followed by the &lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt; method of the &lt;xref:System.Data.Common.DbDataAdapter&gt; class.</source>
          <target state="translated">이 메서드에 대 한 이름 확인 스키마 &lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt; &lt;xref:System.Data.Common.DbDataAdapter&gt;클래스&lt;/xref:System.Data.Common.DbDataAdapter&gt; 의 메서드&lt;/xref:System.Data.Common.DbDataAdapter.Fill%2A&gt; 뒤와 같습니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.Data.IDataReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that provides one or more result sets.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.IDataReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 하나 이상의 결과 집합을 제공 하는 합니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>A value from the <bpt id="p1">&lt;xref href="System.Data.LoadOption"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> enumeration that indicates how rows already in the <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> instances within the <bpt id="p3">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> will be combined with incoming rows that share the same primary key.</source>
          <target state="translated">값은 <bpt id="p1">&lt;xref href="System.Data.LoadOption"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 를 나타내는 열거형입니다 방법을 있는 행의 <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 인스턴스에 <bpt id="p3">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 동일한 기본 키를 공유 하는 들어오는 행과 결합 되는 합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Data.FillErrorEventHandler"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate to call when an error occurs while loading data.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Data.FillErrorEventHandler"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 로드 하는 동안 오류가 발생할 때 호출할 대리자입니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>An array of <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instances, from which the Load method retrieves name and namespace information.</source>
          <target state="translated">배열을 <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 인스턴스, Load 메서드를 이름 및 네임 스페이스 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Gets or sets the locale information used to compare strings within the table.</source>
          <target state="translated">테이블 내의 문자열을 비교 하는 데 로캘 정보를 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Locale property specifies the locale for which sorting applies.</source>
          <target state="translated">Locale 속성에는 로캘을 지정 정렬을 적용할 합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, setting the Locale for a &lt;xref:System.Data.DataSet&gt; also sets the Locale for each &lt;xref:System.Data.DataTable&gt; object in that <ph id="ph1">`DataSet`</ph> to the same value.</source>
          <target state="translated">기본적으로 설정에 대 한 로캘을 &lt;xref:System.Data.DataSet&gt;도 각각에 대 한 로캘을 설정 &lt;xref:System.Data.DataTable&gt;개체의 <ph id="ph1">`DataSet`</ph> 동일한 값으로.&lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In columns that contain expressions, the &lt;xref:System.StringComparison&gt; is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 식이 포함 된 열에는 &lt;xref:System.StringComparison&gt;사용 됩니다.&lt;/xref:System.StringComparison&gt;</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.StringComparison&gt; is ignored.</source>
          <target state="translated">&lt;xref:System.StringComparison&gt;는 무시 됩니다.&lt;/xref:System.StringComparison&gt;</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Globalization.CultureInfo&gt; that contains data about the user's machine locale.</source>
          <target state="translated">A &lt;xref:System.Globalization.CultureInfo&gt;사용자의 컴퓨터 로캘에 대 한 데이터가 들어 있는.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">기본값은 <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Merges an array of <bpt id="p1">&lt;xref href="System.Data.DataRow"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> objects into the current <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">배열을 병합 <bpt id="p1">&lt;xref href="System.Data.DataRow"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체를 현재 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is used to merge two &lt;xref:System.Data.DataSet&gt; objects that have largely similar schemas.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;병합할 두 개의 메서드를 사용 하는 &lt;xref:System.Data.DataSet&gt;비슷하긴 하지만 스키마가 포함 된 개체입니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">데이터 원본에서 최신 변경 내용을 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows the client application to have a refreshed &lt;xref:System.Data.DataSet&gt; with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. &lt;xref:System.Data.DataSet&gt;데이터 원본에서 최신 데이터로.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 새로 고침을 포함 하는 절차의 끝에 호출&lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this scenario, the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method is first invoked.</source>
          <target state="translated">이 시나리오는 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;메서드가 먼저 호출 됩니다.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>That method returns a second &lt;xref:System.Data.DataSet&gt; optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 &lt;xref:System.Data.DataSet&gt;유효성 검사 및 병합에 대 한 액세스에 최적화 된.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>This second &lt;xref:System.Data.DataSet&gt; object contains only the &lt;xref:System.Data.DataTable&gt; and &lt;xref:System.Data.DataRow&gt; objects that were changed, resulting in a subset of the original &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 두 번째 &lt;xref:System.Data.DataSet&gt;개체는 포함 &lt;xref:System.Data.DataTable&gt;하 고 &lt;xref:System.Data.DataRow&gt;원래 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 의 하위 집합을 변경 된 개체&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>This subset is generally smaller and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">이 하위 집합은 일반적으로 더 작은 때문에 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle tier can then send back either a new &lt;xref:System.Data.DataSet&gt; that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 &lt;xref:System.Data.DataSet&gt;(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned &lt;xref:System.Data.DataSet&gt; can be merged back into the client application's original &lt;xref:System.Data.DataSet&gt; with the &lt;xref:System.Data.DataSet.Merge%2A&gt; method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 &lt;xref:System.Data.DataSet&gt;클라이언트 응용 프로그램의 원래로 다시 병합 되어야 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드.&lt;/xref:System.Data.DataSet.Merge%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the &lt;xref:System.Data.DataSet.Merge%2A&gt; method is called, the schemas of the two &lt;xref:System.Data.DataSet&gt; objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">경우는 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드가 호출 되 면 두 스키마 &lt;xref:System.Data.DataSet&gt;개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source &lt;xref:System.Data.DataSet&gt; contains schema elements (added &lt;xref:System.Data.DataColumn&gt; objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph1">`missingSchemaAction`</ph> argument to <ph id="ph2">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">경우 소스 &lt;xref:System.Data.DataSet&gt;스키마 요소를 포함 (추가 &lt;xref:System.Data.DataColumn&gt;개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 <ph id="ph1">`missingSchemaAction`</ph> 인수 <ph id="ph2">`MissingSchemaAction.Add`</ph>.&lt;/xref:System.Data.DataColumn&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, the merged &lt;xref:System.Data.DataSet&gt; contains the added schema and data.</source>
          <target state="translated">병합 된 경우에서 &lt;xref:System.Data.DataSet&gt;추가 된 스키마와 데이터를 포함 합니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">스키마를 병합 한 후 데이터를 병합 합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>When merging a new source &lt;xref:System.Data.DataSet&gt; into the target, any source rows with a &lt;xref:System.Data.DataRowState&gt; value of <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, or <ph id="ph3">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 &lt;xref:System.Data.DataSet&gt;대상에 모든 소스 행 한 &lt;xref:System.Data.DataRowState&gt;값 <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, 또는 <ph id="ph3">`Deleted`</ph> 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.&lt;/xref:System.Data.DataRowState&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>Source rows with a &lt;xref:System.Data.DataRowState&gt; value of <ph id="ph1">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 &lt;xref:System.Data.DataRowState&gt;값 <ph id="ph1">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.&lt;/xref:System.Data.DataRowState&gt;</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">병합 하는 동안 제약 조건이 비활성화 됩니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any constraints cannot be enabled at the end of a merge, a &lt;xref:System.Data.ConstraintException&gt; is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">병합의 끝에 모든 제약 조건을 사용할 수 없으면는 &lt;xref:System.Data.ConstraintException&gt;생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.&lt;/xref:System.Data.ConstraintException&gt;</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property is set to <ph id="ph1">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">이 경우는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성이 <ph id="ph1">`false`</ph>, 오류에서 유효 하지 않은 모든 행을 표시 합니다.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>The errors must be resolved before attempting to reset the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">다시 설정 하기 전에 오류를 해결 해야 합니다는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성을 <ph id="ph1">`true`</ph>.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The array of <bpt id="p1">&lt;xref uid="langword_csharp_DataRow" name="DataRow" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> objects to be merged into the <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">배열 <bpt id="p1">&lt;xref uid="langword_csharp_DataRow" name="DataRow" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체를 병합할 수는 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Merges a specified <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and its schema into the current <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정 된 병합 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 및 스키마를 현재 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Merge method is used to merge two &lt;xref:System.Data.DataSet&gt; objects that have largely similar schemas.</source>
          <target state="translated">Merge 메서드 두 개를 병합 하는 데는 &lt;xref:System.Data.DataSet&gt;비슷하긴 하지만 스키마가 포함 된 개체입니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">데이터 원본에서 최신 변경 내용을 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows the client application to have a refreshed &lt;xref:System.Data.DataSet&gt; with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. &lt;xref:System.Data.DataSet&gt;데이터 원본에서 최신 데이터로.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Merge method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">Merge 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 새로 고침 관련 된 절차의 끝에 호출</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this scenario, the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method is first invoked.</source>
          <target state="translated">이 시나리오는 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;메서드가 먼저 호출 됩니다.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>That method returns a second &lt;xref:System.Data.DataSet&gt; optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 &lt;xref:System.Data.DataSet&gt;유효성 검사 및 병합에 대 한 액세스에 최적화 된.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>This second &lt;xref:System.Data.DataSet&gt; object contains only the &lt;xref:System.Data.DataTable&gt; and &lt;xref:System.Data.DataRow&gt; objects that were changed, resulting in a subset of the original &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 두 번째 &lt;xref:System.Data.DataSet&gt;개체는 포함 &lt;xref:System.Data.DataTable&gt;하 고 &lt;xref:System.Data.DataRow&gt;원래 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 의 하위 집합을 변경 된 개체&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle tier can then send back either a new &lt;xref:System.Data.DataSet&gt; that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 &lt;xref:System.Data.DataSet&gt;(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned &lt;xref:System.Data.DataSet&gt; can be merged back into the client application's original &lt;xref:System.Data.DataSet&gt; with the Merge method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 &lt;xref:System.Data.DataSet&gt;클라이언트 응용 프로그램의 원래로 다시 병합 되어야 &lt;xref:System.Data.DataSet&gt;병합 메서드로.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the Merge method is called, the schemas of the two &lt;xref:System.Data.DataSet&gt; objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Merge 메서드 호출 될 때 두 개의 스키마 &lt;xref:System.Data.DataSet&gt;개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source &lt;xref:System.Data.DataSet&gt; contains schema elements (added &lt;xref:System.Data.DataColumn&gt; objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph1">`missingSchemaAction`</ph> argument to <ph id="ph2">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">경우 소스 &lt;xref:System.Data.DataSet&gt;스키마 요소를 포함 (추가 &lt;xref:System.Data.DataColumn&gt;개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 <ph id="ph1">`missingSchemaAction`</ph> 인수 <ph id="ph2">`MissingSchemaAction.Add`</ph>.&lt;/xref:System.Data.DataColumn&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, the merged &lt;xref:System.Data.DataSet&gt; contains the added schema and data.</source>
          <target state="translated">병합 된 경우에서 &lt;xref:System.Data.DataSet&gt;추가 된 스키마와 데이터를 포함 합니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">스키마를 병합 한 후 데이터를 병합 합니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>When merging a new source &lt;xref:System.Data.DataSet&gt; into the target, any source rows with a &lt;xref:System.Data.DataRowState&gt; value of <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, or <ph id="ph3">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 &lt;xref:System.Data.DataSet&gt;대상에 모든 소스 행 한 &lt;xref:System.Data.DataRowState&gt;값 <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, 또는 <ph id="ph3">`Deleted`</ph> 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.&lt;/xref:System.Data.DataRowState&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 <ph id="ph1">`DataRowState`</ph> 값 <ph id="ph2">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">병합 하는 동안 제약 조건이 비활성화 됩니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any constraints cannot be enabled at the end of merge, a &lt;xref:System.Data.ConstraintException&gt; is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">병합의 끝에 모든 제약 조건을 사용할 수 없으면는 &lt;xref:System.Data.ConstraintException&gt;생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.&lt;/xref:System.Data.ConstraintException&gt;</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property is set to <ph id="ph1">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">이 경우는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성이 <ph id="ph1">`false`</ph>, 오류에서 유효 하지 않은 모든 행을 표시 합니다.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>The errors must be resolved before attempting to reset the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">다시 설정 하기 전에 오류를 해결 해야 합니다는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성을 <ph id="ph1">`true`</ph>.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> whose data and schema will be merged.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해당 데이터와 스키마를 병합 됩니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>One or more constraints cannot be enabled.</source>
          <target state="translated">하나 이상의 제약 조건은 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">dataSet</ph><ept id="p1">&lt;/code&gt;</ept> is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">dataSet</ph><ept id="p1">&lt;/code&gt;</ept> is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Merges a specified <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and its schema into the current <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정 된 병합 <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 및 스키마를 현재 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is used to merge two &lt;xref:System.Data.DataSet&gt; objects that have largely similar schemas.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;병합할 두 개의 메서드를 사용 하는 &lt;xref:System.Data.DataSet&gt;비슷하긴 하지만 스키마가 포함 된 개체입니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">데이터 원본에서 최신 변경 내용을 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows the client application to have a refreshed &lt;xref:System.Data.DataSet&gt; with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. &lt;xref:System.Data.DataSet&gt;데이터 원본에서 최신 데이터로.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 새로 고침을 포함 하는 절차의 끝에 호출&lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this scenario, the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method is first invoked.</source>
          <target state="translated">이 시나리오는 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;메서드가 먼저 호출 됩니다.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>That method returns a second &lt;xref:System.Data.DataSet&gt; optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 &lt;xref:System.Data.DataSet&gt;유효성 검사 및 병합에 대 한 액세스에 최적화 된.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>This second &lt;xref:System.Data.DataSet&gt; object contains only the &lt;xref:System.Data.DataTable&gt; and &lt;xref:System.Data.DataRow&gt; objects that were changed, resulting in a subset of the original &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 두 번째 &lt;xref:System.Data.DataSet&gt;개체는 포함 &lt;xref:System.Data.DataTable&gt;하 고 &lt;xref:System.Data.DataRow&gt;원래 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 의 하위 집합을 변경 된 개체&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle tier can then send back either a new &lt;xref:System.Data.DataSet&gt; that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 &lt;xref:System.Data.DataSet&gt;(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned &lt;xref:System.Data.DataSet&gt; can be merged back into the client application's original &lt;xref:System.Data.DataSet&gt; with the &lt;xref:System.Data.DataSet.Merge%2A&gt; method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 &lt;xref:System.Data.DataSet&gt;클라이언트 응용 프로그램의 원래로 다시 병합 되어야 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드.&lt;/xref:System.Data.DataSet.Merge%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the &lt;xref:System.Data.DataSet.Merge%2A&gt; method is called, the schemas of the two &lt;xref:System.Data.DataSet&gt; objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">경우는 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드가 호출 되 면 두 스키마 &lt;xref:System.Data.DataSet&gt;개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source &lt;xref:System.Data.DataSet&gt; contains schema elements (added &lt;xref:System.Data.DataColumn&gt; objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph1">`missingSchemaAction`</ph> argument to <ph id="ph2">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">경우 소스 &lt;xref:System.Data.DataSet&gt;스키마 요소를 포함 (추가 &lt;xref:System.Data.DataColumn&gt;개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 <ph id="ph1">`missingSchemaAction`</ph> 인수 <ph id="ph2">`MissingSchemaAction.Add`</ph>.&lt;/xref:System.Data.DataColumn&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, the merged &lt;xref:System.Data.DataSet&gt; contains the added schema and data.</source>
          <target state="translated">병합 된 경우에서 &lt;xref:System.Data.DataSet&gt;추가 된 스키마와 데이터를 포함 합니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">스키마를 병합 한 후 데이터를 병합 합니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>When merging a new source &lt;xref:System.Data.DataSet&gt; into the target, any source rows with a &lt;xref:System.Data.DataRowState&gt; value of <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, or <ph id="ph3">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 &lt;xref:System.Data.DataSet&gt;대상에 모든 소스 행 한 &lt;xref:System.Data.DataRowState&gt;값 <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, 또는 <ph id="ph3">`Deleted`</ph> 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.&lt;/xref:System.Data.DataRowState&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 <ph id="ph1">`DataRowState`</ph> 값 <ph id="ph2">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">병합 하는 동안 제약 조건이 비활성화 됩니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any constraints cannot be enabled at the end of merge, a &lt;xref:System.Data.ConstraintException&gt; is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">병합의 끝에 모든 제약 조건을 사용할 수 없으면는 &lt;xref:System.Data.ConstraintException&gt;생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.&lt;/xref:System.Data.ConstraintException&gt;</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property is set to <ph id="ph1">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">이 경우는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성이 <ph id="ph1">`false`</ph>, 오류에서 유효 하지 않은 모든 행을 표시 합니다.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>The errors must be resolved before attempting to reset the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">다시 설정 하기 전에 오류를 해결 해야 합니다는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성을 <ph id="ph1">`true`</ph>.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> whose data and schema will be merged.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해당 데이터와 스키마를 병합 됩니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">table</ph><ept id="p1">&lt;/code&gt;</ept> is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">table</ph><ept id="p1">&lt;/code&gt;</ept> is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Merges a specified <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and its schema into the current <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, preserving or discarding any changes in this <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> according to the given argument.</source>
          <target state="translated">지정 된 병합 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 및 스키마를 현재 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>이 변경 내용을 합니다 <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 지정 된 인수에 따라 합니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is used to merge two &lt;xref:System.Data.DataSet&gt; objects that have largely similar schemas.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;병합할 두 개의 메서드를 사용 하는 &lt;xref:System.Data.DataSet&gt;비슷하긴 하지만 스키마가 포함 된 개체입니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">데이터 원본에서 최신 변경 내용을 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows the client application to have a refreshed &lt;xref:System.Data.DataSet&gt; with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. &lt;xref:System.Data.DataSet&gt;데이터 원본에서 최신 데이터로.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 새로 고침을 포함 하는 절차의 끝에 호출&lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this scenario, the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method is first invoked.</source>
          <target state="translated">이 시나리오는 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;메서드가 먼저 호출 됩니다.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>That method returns a second &lt;xref:System.Data.DataSet&gt; optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 &lt;xref:System.Data.DataSet&gt;유효성 검사 및 병합에 대 한 액세스에 최적화 된.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>This second &lt;xref:System.Data.DataSet&gt; object contains only the &lt;xref:System.Data.DataTable&gt; and &lt;xref:System.Data.DataRow&gt; objects that were changed, resulting in a subset of the original &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 두 번째 &lt;xref:System.Data.DataSet&gt;개체는 포함 &lt;xref:System.Data.DataTable&gt;하 고 &lt;xref:System.Data.DataRow&gt;원래 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 의 하위 집합을 변경 된 개체&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle tier can then send back either a new &lt;xref:System.Data.DataSet&gt; that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 &lt;xref:System.Data.DataSet&gt;(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned &lt;xref:System.Data.DataSet&gt; can be merged back into the client application's original &lt;xref:System.Data.DataSet&gt; with the &lt;xref:System.Data.DataSet.Merge%2A&gt; method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 &lt;xref:System.Data.DataSet&gt;클라이언트 응용 프로그램의 원래로 다시 병합 되어야 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드.&lt;/xref:System.Data.DataSet.Merge%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the &lt;xref:System.Data.DataSet.Merge%2A&gt; method is called, the schemas of the two &lt;xref:System.Data.DataSet&gt; objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">경우는 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드가 호출 되 면 두 스키마 &lt;xref:System.Data.DataSet&gt;개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source &lt;xref:System.Data.DataSet&gt; contains schema elements (added &lt;xref:System.Data.DataColumn&gt; objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph1">`missingSchemaAction`</ph> argument to <ph id="ph2">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">경우 소스 &lt;xref:System.Data.DataSet&gt;스키마 요소를 포함 (추가 &lt;xref:System.Data.DataColumn&gt;개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 <ph id="ph1">`missingSchemaAction`</ph> 인수 <ph id="ph2">`MissingSchemaAction.Add`</ph>.&lt;/xref:System.Data.DataColumn&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, the merged &lt;xref:System.Data.DataSet&gt; contains the added schema and data.</source>
          <target state="translated">병합 된 경우에서 &lt;xref:System.Data.DataSet&gt;추가 된 스키마와 데이터를 포함 합니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">스키마를 병합 한 후 데이터를 병합 합니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>When merging a new source &lt;xref:System.Data.DataSet&gt; into the target, any source rows with a &lt;xref:System.Data.DataRowState&gt; value of <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, or <ph id="ph3">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 &lt;xref:System.Data.DataSet&gt;대상에 모든 소스 행 한 &lt;xref:System.Data.DataRowState&gt;값 <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, 또는 <ph id="ph3">`Deleted`</ph> 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.&lt;/xref:System.Data.DataRowState&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 <ph id="ph1">`DataRowState`</ph> 값 <ph id="ph2">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">병합 하는 동안 제약 조건이 비활성화 됩니다.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any constraints cannot be enabled at the end of merge, a &lt;xref:System.Data.ConstraintException&gt; is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">병합의 끝에 모든 제약 조건을 사용할 수 없으면는 &lt;xref:System.Data.ConstraintException&gt;생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.&lt;/xref:System.Data.ConstraintException&gt;</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property is set to <ph id="ph1">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">이 경우는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성이 <ph id="ph1">`false`</ph>, 오류에서 유효 하지 않은 모든 행을 표시 합니다.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>The errors must be resolved before attempting to reset the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">다시 설정 하기 전에 오류를 해결 해야 합니다는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성을 <ph id="ph1">`true`</ph>.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> whose data and schema will be merged.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해당 데이터와 스키마를 병합 됩니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to preserve changes in the current <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>현재에서 변경 내용을 유지 하려면 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>고, 그렇지 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Merges an array of <bpt id="p1">&lt;xref href="System.Data.DataRow"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> objects into the current <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, preserving or discarding changes in the <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> and handling an incompatible schema according to the given arguments.</source>
          <target state="translated">배열을 병합 <bpt id="p1">&lt;xref href="System.Data.DataRow"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체를 현재 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>변경 합니다는 <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 된 지정된 된 인수를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is used to merge two &lt;xref:System.Data.DataSet&gt; objects that have largely similar schemas.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;병합할 두 개의 메서드를 사용 하는 &lt;xref:System.Data.DataSet&gt;비슷하긴 하지만 스키마가 포함 된 개체입니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">데이터 원본에서 최신 변경 내용을 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows the client application to have a refreshed &lt;xref:System.Data.DataSet&gt; with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. &lt;xref:System.Data.DataSet&gt;데이터 원본에서 최신 데이터로.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 새로 고침을 포함 하는 절차의 끝에 호출&lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this scenario, the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method is first invoked.</source>
          <target state="translated">이 시나리오는 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;메서드가 먼저 호출 됩니다.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>That method returns a second &lt;xref:System.Data.DataSet&gt; optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 &lt;xref:System.Data.DataSet&gt;유효성 검사 및 병합에 대 한 액세스에 최적화 된.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>This second &lt;xref:System.Data.DataSet&gt; object contains only the &lt;xref:System.Data.DataTable&gt; and &lt;xref:System.Data.DataRow&gt; objects that were changed, resulting in a subset of the original &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 두 번째 &lt;xref:System.Data.DataSet&gt;개체는 포함 &lt;xref:System.Data.DataTable&gt;하 고 &lt;xref:System.Data.DataRow&gt;원래 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 의 하위 집합을 변경 된 개체&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle tier can then send back either a new &lt;xref:System.Data.DataSet&gt; that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 &lt;xref:System.Data.DataSet&gt;(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned &lt;xref:System.Data.DataSet&gt; can be merged back into the client application's original &lt;xref:System.Data.DataSet&gt; with the &lt;xref:System.Data.DataSet.Merge%2A&gt; method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 &lt;xref:System.Data.DataSet&gt;클라이언트 응용 프로그램의 원래로 다시 병합 되어야 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드.&lt;/xref:System.Data.DataSet.Merge%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>To facilitate explanation of the &lt;xref:System.Data.DataSet.Merge%2A&gt; method, we use "target" to signify the current &lt;xref:System.Data.DataSet&gt;, and "source" to name the second (parameter) &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">설명은 용이 하 게 하려면는 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드를 사용 하 여 "대상" 현재 나타낼 &lt;xref:System.Data.DataSet&gt;, "source" (매개 변수) &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 두 번째 이름을 지정 하 고&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target &lt;xref:System.Data.DataSet&gt; is so named because it is the object upon which an action (the merge) occurs.</source>
          <target state="translated">대상 &lt;xref:System.Data.DataSet&gt;가 의미 하는 동작 (병합) 발생 하는 개체입니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>The second &lt;xref:System.Data.DataSet&gt; is called a "source" because the information it contains does not change, but instead is merged into the current &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">두 번째 &lt;xref:System.Data.DataSet&gt;포함 된 정보를 변경 되지 않지만 대신 현재 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 병합 되 때문에 "source" 라고&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the &lt;xref:System.Data.DataSet.Merge%2A&gt; method is called, the schemas of the two &lt;xref:System.Data.DataSet&gt; objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">경우는 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드가 호출 되 면 두 스키마 &lt;xref:System.Data.DataSet&gt;개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source &lt;xref:System.Data.DataSet&gt; contains schema elements (added &lt;xref:System.Data.DataColumn&gt; objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph1">`missingSchemaAction`</ph> argument to <ph id="ph2">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">경우 소스 &lt;xref:System.Data.DataSet&gt;스키마 요소를 포함 (추가 &lt;xref:System.Data.DataColumn&gt;개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 <ph id="ph1">`missingSchemaAction`</ph> 인수 <ph id="ph2">`MissingSchemaAction.Add`</ph>.&lt;/xref:System.Data.DataColumn&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, the merged &lt;xref:System.Data.DataSet&gt; contains the added schema and data.</source>
          <target state="translated">병합 된 경우에서 &lt;xref:System.Data.DataSet&gt;추가 된 스키마와 데이터를 포함 합니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">스키마를 병합 한 후 데이터를 병합 합니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>When merging a new source &lt;xref:System.Data.DataSet&gt; into the target, any source rows with a &lt;xref:System.Data.DataRowState&gt; value of <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, or <ph id="ph3">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 &lt;xref:System.Data.DataSet&gt;대상에 모든 소스 행 한 &lt;xref:System.Data.DataRowState&gt;값 <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, 또는 <ph id="ph3">`Deleted`</ph> 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.&lt;/xref:System.Data.DataRowState&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 <ph id="ph1">`DataRowState`</ph> 값 <ph id="ph2">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">병합 하는 동안 제약 조건이 비활성화 됩니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any constraints cannot be enabled at the end of merge, a &lt;xref:System.Data.ConstraintException&gt; is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">병합의 끝에 모든 제약 조건을 사용할 수 없으면는 &lt;xref:System.Data.ConstraintException&gt;생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.&lt;/xref:System.Data.ConstraintException&gt;</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property is set to <ph id="ph1">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">이 경우는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성이 <ph id="ph1">`false`</ph>, 오류에서 유효 하지 않은 모든 행을 표시 합니다.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>The errors must be resolved before attempting to reset the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">다시 설정 하기 전에 오류를 해결 해야 합니다는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성을 <ph id="ph1">`true`</ph>.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>The array of <bpt id="p1">&lt;xref href="System.Data.DataRow"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> objects to be merged into the <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">배열 <bpt id="p1">&lt;xref href="System.Data.DataRow"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체를 병합할 수는 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to preserve changes in the <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>변경 내용을 유지 하는 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>고, 그렇지 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.MissingSchemaAction"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.MissingSchemaAction"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Merges a specified <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and its schema with the current <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, preserving or discarding changes in the current <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> and handling an incompatible schema according to the given arguments.</source>
          <target state="translated">지정 된 병합 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 및 현재 스키마 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>현재에서 변경 내용을 합니다 <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 된 지정된 된 인수를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is used to merge two &lt;xref:System.Data.DataSet&gt; objects that have largely similar schemas.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;병합할 두 개의 메서드를 사용 하는 &lt;xref:System.Data.DataSet&gt;비슷하긴 하지만 스키마가 포함 된 개체입니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">데이터 원본에서 최신 변경 내용을 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows the client application to have a refreshed &lt;xref:System.Data.DataSet&gt; with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. &lt;xref:System.Data.DataSet&gt;데이터 원본에서 최신 데이터로.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 새로 고침을 포함 하는 절차의 끝에 호출&lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this scenario, the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method is first invoked.</source>
          <target state="translated">이 시나리오는 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;메서드가 먼저 호출 됩니다.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>That method returns a second &lt;xref:System.Data.DataSet&gt; optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 &lt;xref:System.Data.DataSet&gt;유효성 검사 및 병합에 대 한 액세스에 최적화 된.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>This second &lt;xref:System.Data.DataSet&gt; object contains only the &lt;xref:System.Data.DataTable&gt; and &lt;xref:System.Data.DataRow&gt; objects that were changed, resulting in a subset of the original &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 두 번째 &lt;xref:System.Data.DataSet&gt;개체는 포함 &lt;xref:System.Data.DataTable&gt;하 고 &lt;xref:System.Data.DataRow&gt;원래 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 의 하위 집합을 변경 된 개체&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle tier can then send back either a new &lt;xref:System.Data.DataSet&gt; that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 &lt;xref:System.Data.DataSet&gt;(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned &lt;xref:System.Data.DataSet&gt; can be merged back into the client application's original &lt;xref:System.Data.DataSet&gt; with the &lt;xref:System.Data.DataSet.Merge%2A&gt; method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 &lt;xref:System.Data.DataSet&gt;클라이언트 응용 프로그램의 원래로 다시 병합 되어야 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드.&lt;/xref:System.Data.DataSet.Merge%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>To facilitate explanation of the &lt;xref:System.Data.DataSet.Merge%2A&gt; method, we use "target" to signify the current &lt;xref:System.Data.DataSet&gt;, and "source" to name the second (parameter) &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">설명은 용이 하 게 하려면는 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드를 사용 하 여 "대상" 현재 나타낼 &lt;xref:System.Data.DataSet&gt;, "source" (매개 변수) &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 두 번째 이름을 지정 하 고&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target &lt;xref:System.Data.DataSet&gt; is so named because it is the object upon which an action (the merge) occurs.</source>
          <target state="translated">대상 &lt;xref:System.Data.DataSet&gt;가 의미 하는 동작 (병합) 발생 하는 개체입니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>The second &lt;xref:System.Data.DataSet&gt; is called a "source" because the information it contains does not change, but instead is merged into the current &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">두 번째 &lt;xref:System.Data.DataSet&gt;포함 된 정보를 변경 되지 않지만 대신 현재 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 병합 되 때문에 "source" 라고&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the &lt;xref:System.Data.DataSet.Merge%2A&gt; method is called, the schemas of the two &lt;xref:System.Data.DataSet&gt; objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">경우는 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드가 호출 되 면 두 스키마 &lt;xref:System.Data.DataSet&gt;개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source &lt;xref:System.Data.DataSet&gt; contains schema elements (added &lt;xref:System.Data.DataColumn&gt; objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph1">`missingSchemaAction`</ph> argument to <ph id="ph2">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">경우 소스 &lt;xref:System.Data.DataSet&gt;스키마 요소를 포함 (추가 &lt;xref:System.Data.DataColumn&gt;개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 <ph id="ph1">`missingSchemaAction`</ph> 인수 <ph id="ph2">`MissingSchemaAction.Add`</ph>.&lt;/xref:System.Data.DataColumn&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, the merged &lt;xref:System.Data.DataSet&gt; contains the added schema and data.</source>
          <target state="translated">병합 된 경우에서 &lt;xref:System.Data.DataSet&gt;추가 된 스키마와 데이터를 포함 합니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">스키마를 병합 한 후 데이터를 병합 합니다.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>When merging a new source &lt;xref:System.Data.DataSet&gt; into the target, any source rows with a &lt;xref:System.Data.DataRowState&gt; value of <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, or <ph id="ph3">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 &lt;xref:System.Data.DataSet&gt;대상에 모든 소스 행 한 &lt;xref:System.Data.DataRowState&gt;값 <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, 또는 <ph id="ph3">`Deleted`</ph> 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.&lt;/xref:System.Data.DataRowState&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 <ph id="ph1">`DataRowState`</ph> 값 <ph id="ph2">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">병합 하는 동안 제약 조건이 비활성화 됩니다.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any constraints cannot be enabled at the end of merge, a &lt;xref:System.Data.ConstraintException&gt; is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">병합의 끝에 모든 제약 조건을 사용할 수 없으면는 &lt;xref:System.Data.ConstraintException&gt;생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.&lt;/xref:System.Data.ConstraintException&gt;</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property is set to <ph id="ph1">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">이 경우는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성이 <ph id="ph1">`false`</ph>, 오류에서 유효 하지 않은 모든 행을 표시 합니다.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>The errors must be resolved before attempting to reset the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">다시 설정 하기 전에 오류를 해결 해야 합니다는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성을 <ph id="ph1">`true`</ph>.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> whose data and schema will be merged.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해당 데이터와 스키마를 병합 됩니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to preserve changes in the current <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>현재에서 변경 내용을 유지 하려면 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>고, 그렇지 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.MissingSchemaAction"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.MissingSchemaAction"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">dataSet</ph><ept id="p1">&lt;/code&gt;</ept> is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">dataSet</ph><ept id="p1">&lt;/code&gt;</ept> is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Merges a specified <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and its schema into the current <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>, preserving or discarding changes in the <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept> and handling an incompatible schema according to the given arguments.</source>
          <target state="translated">지정 된 병합 <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 및 스키마를 현재 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>, 유지 또는에서 변경 내용 취소는 <bpt id="p3">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept> 된 지정된 된 인수를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is used to merge two &lt;xref:System.Data.DataSet&gt; objects that have largely similar schemas.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;병합할 두 개의 메서드를 사용 하는 &lt;xref:System.Data.DataSet&gt;비슷하긴 하지만 스키마가 포함 된 개체입니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">데이터 원본에서 최신 변경 내용을 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows the client application to have a refreshed &lt;xref:System.Data.DataSet&gt; with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. &lt;xref:System.Data.DataSet&gt;데이터 원본에서 최신 데이터로.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.Merge%2A&gt; method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.Merge%2A&gt;메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 새로 고침을 포함 하는 절차의 끝에 호출&lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>iOn a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 클라이언트 응용 프로그램 이온 되었기 합니다.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this scenario, the &lt;xref:System.Data.DataSet.GetChanges%2A&gt; method is first invoked.</source>
          <target state="translated">이 시나리오는 &lt;xref:System.Data.DataSet.GetChanges%2A&gt;메서드가 먼저 호출 됩니다.&lt;/xref:System.Data.DataSet.GetChanges%2A&gt;</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT">
          <source>That method returns a second &lt;xref:System.Data.DataSet&gt; optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 &lt;xref:System.Data.DataSet&gt;유효성 검사 및 병합에 대 한 액세스에 최적화 된.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT">
          <source>This second &lt;xref:System.Data.DataSet&gt; object contains only the &lt;xref:System.Data.DataTable&gt; and &lt;xref:System.Data.DataRow&gt; objects that were changed, resulting in a subset of the original &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">이 두 번째 &lt;xref:System.Data.DataSet&gt;개체는 포함 &lt;xref:System.Data.DataTable&gt;하 고 &lt;xref:System.Data.DataRow&gt;원래 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 의 하위 집합을 변경 된 개체&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT">
          <source>The middle tier can then send back either a new &lt;xref:System.Data.DataSet&gt; that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 &lt;xref:System.Data.DataSet&gt;(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned &lt;xref:System.Data.DataSet&gt; can be merged back into the client application's original &lt;xref:System.Data.DataSet&gt; with the &lt;xref:System.Data.DataSet.Merge%2A&gt; method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 &lt;xref:System.Data.DataSet&gt;클라이언트 응용 프로그램의 원래로 다시 병합 되어야 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드.&lt;/xref:System.Data.DataSet.Merge%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the &lt;xref:System.Data.DataSet.Merge%2A&gt; method is called, the schemas of the two &lt;xref:System.Data.DataSet&gt; objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">경우는 &lt;xref:System.Data.DataSet.Merge%2A&gt;메서드가 호출 되 면 두 스키마 &lt;xref:System.Data.DataSet&gt;개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source &lt;xref:System.Data.DataSet&gt; contains schema elements (added &lt;xref:System.Data.DataColumn&gt; objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph1">`missingSchemaAction`</ph> argument to <ph id="ph2">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">경우 소스 &lt;xref:System.Data.DataSet&gt;스키마 요소를 포함 (추가 &lt;xref:System.Data.DataColumn&gt;개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 <ph id="ph1">`missingSchemaAction`</ph> 인수 <ph id="ph2">`MissingSchemaAction.Add`</ph>.&lt;/xref:System.Data.DataColumn&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, the merged &lt;xref:System.Data.DataSet&gt; contains the added schema and data.</source>
          <target state="translated">병합 된 경우에서 &lt;xref:System.Data.DataSet&gt;추가 된 스키마와 데이터를 포함 합니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">스키마를 병합 한 후 데이터를 병합 합니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>When merging a new source &lt;xref:System.Data.DataSet&gt; into the target, any source rows with a &lt;xref:System.Data.DataRowState&gt; value of <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, or <ph id="ph3">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 &lt;xref:System.Data.DataSet&gt;대상에 모든 소스 행 한 &lt;xref:System.Data.DataRowState&gt;값 <ph id="ph1">`Unchanged`</ph>, <ph id="ph2">`Modified`</ph>, 또는 <ph id="ph3">`Deleted`</ph> 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.&lt;/xref:System.Data.DataRowState&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 <ph id="ph1">`DataRowState`</ph> 값 <ph id="ph2">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">병합 하는 동안 제약 조건이 비활성화 됩니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any constraints cannot be enabled at the end of merge, a &lt;xref:System.Data.ConstraintException&gt; is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">병합의 끝에 모든 제약 조건을 사용할 수 없으면는 &lt;xref:System.Data.ConstraintException&gt;생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.&lt;/xref:System.Data.ConstraintException&gt;</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property is set to <ph id="ph1">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">이 경우는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성이 <ph id="ph1">`false`</ph>, 오류에서 유효 하지 않은 모든 행을 표시 합니다.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>The errors must be resolved before attempting to reset the &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt; property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">다시 설정 하기 전에 오류를 해결 해야 합니다는 &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;속성을 <ph id="ph1">`true`</ph>.&lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt;</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_DataTable" name="DataTable" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> whose data and schema will be merged.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_DataTable" name="DataTable" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 해당 데이터와 스키마를 병합 됩니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.MissingSchemaAction"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.MissingSchemaAction"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to preserve changes in the <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; otherwise <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>변경 내용을 유지 하는 <bpt id="p2">&lt;xref uid="langword_csharp_DataSet" name="DataSet" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>고, 그렇지 않으면 <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">dataSet</ph><ept id="p1">&lt;/code&gt;</ept> is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">dataSet</ph><ept id="p1">&lt;/code&gt;</ept> is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>Occurs when a target and source <bpt id="p1">&lt;xref href="System.Data.DataRow"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> have the same primary key value, and &lt;xref:System.Data.DataSet.EnforceConstraints*&gt; is set to true.</source>
          <target state="translated">대상 및 원본 때 발생 <bpt id="p1">&lt;xref href="System.Data.DataRow"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 동일한 기본 키 값 및 &lt;xref:System.Data.DataSet.EnforceConstraints*&gt;설정을 true로.&lt;/xref:System.Data.DataSet.EnforceConstraints*&gt;</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>NIB: Consuming Events<ept id="p1">](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)</ept>.</source>
          <target state="translated">이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>NIB: 이벤트 사용<ept id="p1">](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">추가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>Gets or sets the namespace of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">네임 스페이스를 가져오거나 설정 합니다.는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Namespace property is used when reading and writing an XML document into the &lt;xref:System.Data.DataSet&gt; using the &lt;xref:System.Data.DataSet.ReadXml%2A&gt;, &lt;xref:System.Data.DataSet.WriteXml%2A&gt;, &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;, or &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; methods.</source>
          <target state="translated">Namespace 속성이에 문서를 읽고 XML을 쓸 때 사용 되는 &lt;xref:System.Data.DataSet&gt;를 사용 하는 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;, &lt;xref:System.Data.DataSet.WriteXml%2A&gt;, &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;, 또는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.WriteXml%2A&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>The namespace of an XML document is used to scope XML attributes and elements when read into a &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">XML 문서의 네임 스페이스는 XML 특성 및 요소에 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 으로 읽을 때 범위를 지정 하는 데 사용</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if a &lt;xref:System.Data.DataSet&gt; contains a schema that was read from a document with the namespace "myCompany," and an attempt is made to read data only from a document with a different namespace, any data that does not correspond to the existing schema is ignored.</source>
          <target state="translated">예를 들어 경우는 &lt;xref:System.Data.DataSet&gt;스키마가 포함 된 네임 스페이스가 "myCompany" 문서에서 읽은 및만 다른 네임 스페이스를 사용 하 여 문서에서에서 데이터를 읽을 하려고 시도 하 고, 기존 스키마에 해당 하지 않는 모든 데이터는 무시 됩니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>The namespace of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">네임 스페이스는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The namespace already has data.</source>
          <target state="translated">네임 스페이스에 이미 데이터가 있습니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>Raises the OnPropertyChanging event.</source>
          <target state="translated">OnPropertyChanging 이벤트를 발생 시킵니다.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an overview, see <bpt id="p1">[</bpt>NIB: Raising an Event<ept id="p1">](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>NIB: 이벤트를 발생 시키는<ept id="p1">](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt; that contains the event data.</source>
          <target state="translated">A &lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;이벤트 데이터를 포함 하는.&lt;/xref:System.ComponentModel.PropertyChangedEventArgs&gt;</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Occurs when a <bpt id="p1">&lt;xref href="System.Data.DataRelation"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is removed from a <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">발생 경우는 <bpt id="p1">&lt;xref href="System.Data.DataRelation"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체에서 제거 되는 <bpt id="p2">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method should be overridden by subclasses to restrict tables being removed</source>
          <target state="translated">이 메서드는 테이블을 제거 하 고 제한 하는 서브 클래스에서 재정의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.DataRelation"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> being removed.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.DataRelation"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 제거 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>Occurs when a <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is removed from a <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">발생 경우는 <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 에서 제거 되는 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by subclasses to restrict tables from being removed.</source>
          <target state="translated">이 메서드는 제거 되지 않도록 테이블을 제한 하는 서브 클래스에서 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> being removed.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 제거 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>Gets or sets an XML prefix that aliases the namespace of the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">여부를 가져오거나 설정 XML 접두사의 네임 스페이스를 별칭을 지정 하는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Prefix property is used throughout an XML document to identify elements which belong to the namespace of the &lt;xref:System.Data.DataSet&gt; object (as set by the &lt;xref:System.Data.DataSet.Namespace%2A&gt; property).</source>
          <target state="translated">접두사 속성이의 네임 스페이스에 속한 요소를 식별 하는 XML 문서 전체에서 사용 되는 &lt;xref:System.Data.DataSet&gt;개체 (의해 설정 된 &lt;xref:System.Data.DataSet.Namespace%2A&gt;속성).&lt;/xref:System.Data.DataSet.Namespace%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The XML prefix for the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> namespace.</source>
          <target state="translated">에 대 한 XML 접두사는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 네임 스페이스입니다.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>Sends a notification that the specified <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> property is about to change.</source>
          <target state="translated">알림을 전송 지정 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 속성이 변경 되려고 합니다.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>The name of the property that is about to change.</source>
          <target state="translated">변경 하는 속성의 이름입니다.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Reads XML schema and data into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">XML 스키마와 데이터를는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method provides a way to read either data only, or both data and schema into a &lt;xref:System.Data.DataSet&gt; from an XML document, whereas the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method reads only the schema.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 &lt;xref:System.Data.DataSet&gt;XML 문서 로부터 반면는 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 스키마만 읽습니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">데이터 및 스미카를 읽으려면 중 하나를 사용는 <ph id="ph1">`ReadXML`</ph> 포함 하는 오버 로드는 <ph id="ph2">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph3">`ReadSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; and &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;및 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The <ph id="ph2">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph3">`DataColumn`</ph> or <ph id="ph4">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 <ph id="ph2">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph3">`DataColumn`</ph> 또는 <ph id="ph4">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XML Schema for a &lt;xref:System.Data.DataSet&gt; includes <ph id="ph1">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling &lt;xref:System.Data.DataSet.ReadXml%2A&gt; to load the &lt;xref:System.Data.DataSet&gt; with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">경우에 대 한 XML 스키마는 &lt;xref:System.Data.DataSet&gt;포함 <ph id="ph1">`targetNamespace`</ph>, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;로드 하는 &lt;xref:System.Data.DataSet&gt;정규화 네임 스페이스가 없는 요소가 포함 된 XML로.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema, as the following example demonstrates.</source>
          <target state="translated">정규화 되지 않은 요소를 읽으려면 설정 <ph id="ph1">`elementFormDefault`</ph> 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXml%2A&gt; by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated"><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph>&gt; If에 대 한 스키마 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;지정 하 여 <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>An object that derives from &lt;xref:System.IO.Stream&gt;.</source>
          <target state="translated">&lt;xref:System.IO.Stream&gt;.&lt;/xref:System.IO.Stream&gt; 에서 파생 되는 개체</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to read the data.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 읽는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>Reads XML schema and data into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified <ph id="ph1">&amp;lt;</ph>xref:System.IO.TextReader?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">XML 스키마와 데이터를는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 <ph id="ph1">&amp;lt;</ph>xref:System.IO.TextReader?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method provides a way to read either data only, or both data and schema into a &lt;xref:System.Data.DataSet&gt; from an XML document, whereas the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method reads only the schema.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 &lt;xref:System.Data.DataSet&gt;XML 문서 로부터 반면는 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 스키마만 읽습니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">데이터 및 스미카를 읽으려면 중 하나를 사용는 <ph id="ph1">`ReadXML`</ph> 포함 하는 오버 로드는 <ph id="ph2">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph3">`ReadSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; and &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;및 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The <ph id="ph2">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph3">`DataColumn`</ph> or <ph id="ph4">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 <ph id="ph2">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph3">`DataColumn`</ph> 또는 <ph id="ph4">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XML Schema for a &lt;xref:System.Data.DataSet&gt; includes <ph id="ph1">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling &lt;xref:System.Data.DataSet.ReadXml%2A&gt; to load the &lt;xref:System.Data.DataSet&gt; with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">경우에 대 한 XML 스키마는 &lt;xref:System.Data.DataSet&gt;포함 <ph id="ph1">`targetNamespace`</ph>, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;로드 하는 &lt;xref:System.Data.DataSet&gt;정규화 네임 스페이스가 없는 요소가 포함 된 XML로.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">정규화 되지 않은 요소를 읽으려면 설정 <ph id="ph1">`elementFormDefault`</ph> 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph>       Classes that inherit from the &lt;xref:System.IO.TextReader&gt; class include the &lt;xref:System.IO.StreamReader&gt; and &lt;xref:System.IO.StringReader&gt; classes.</source>
          <target state="translated"><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph>클래스에서 상속 되는 &lt;xref:System.IO.TextReader&gt;클래스에 포함 된 &lt;xref:System.IO.StreamReader&gt;및 &lt;xref:System.IO.StringReader&gt;클래스.&lt;/xref:System.IO.StringReader&gt; &lt;/xref:System.IO.StreamReader&gt; &lt;/xref:System.IO.TextReader&gt;</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXml%2A&gt; by specifying <ph id="ph2">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 하는 경우에 대 한 스키마 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;지정 하 여 <ph id="ph2">`XmlReadMode.ReadSchema`</ph>.&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TextReader" name="TextReader" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to read the schema and data.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TextReader" name="TextReader" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 스키마와 데이터를 읽을 수입니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to read the data.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 읽는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>Reads XML schema and data into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified file.</source>
          <target state="translated">XML 스키마와 데이터를는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 파일을 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method provides a way to read either data only, or both data and schema into a &lt;xref:System.Data.DataSet&gt; from an XML document, whereas the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method reads only the schema.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 &lt;xref:System.Data.DataSet&gt;XML 문서 로부터 반면는 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 스키마만 읽습니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">데이터 및 스미카를 읽으려면 중 하나를 사용는 <ph id="ph1">`ReadXML`</ph> 포함 하는 오버 로드는 <ph id="ph2">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph3">`ReadSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; and &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;및 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The <ph id="ph2">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph3">`DataColumn`</ph> or <ph id="ph4">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 <ph id="ph2">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph3">`DataColumn`</ph> 또는 <ph id="ph4">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XML Schema for a &lt;xref:System.Data.DataSet&gt; includes a <ph id="ph1">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling &lt;xref:System.Data.DataSet.ReadXml%2A&gt; to load the &lt;xref:System.Data.DataSet&gt; with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">경우에 대 한 XML 스키마는 &lt;xref:System.Data.DataSet&gt;포함는 <ph id="ph1">`targetNamespace`</ph>, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;로드 하는 &lt;xref:System.Data.DataSet&gt;정규화 네임 스페이스가 없는 요소가 포함 된 XML로.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">정규화 되지 않은 요소를 읽으려면 설정 <ph id="ph1">`elementFormDefault`</ph> 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXml%2A&gt; by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated"><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph>&gt; If에 대 한 스키마 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;지정 하 여 <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>The filename (including the path) from which to read.</source>
          <target state="translated">파일 이름 (경로 포함) 스트림입니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to read the data.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 읽는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is not set to <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>로 설정 되지 않은 <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>Reads XML schema and data into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified <ph id="ph1">&amp;lt;</ph>xref:System.Xml.XmlReader?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">XML 스키마와 데이터를는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 <ph id="ph1">&amp;lt;</ph>xref:System.Xml.XmlReader?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ReadXml method provides a way to read either data only, or both data and schema into a &lt;xref:System.Data.DataSet&gt; from an XML document, whereas the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method reads only the schema.</source>
          <target state="translated">ReadXml 메서드에 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 &lt;xref:System.Data.DataSet&gt;XML 문서 로부터 반면는 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 스키마만 읽습니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">데이터 및 스미카를 읽으려면 중 하나를 사용는 <ph id="ph1">`ReadXML`</ph> 포함 하는 오버 로드는 <ph id="ph2">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph3">`ReadSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; and &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;및 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The <ph id="ph2">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph3">`DataColumn`</ph> or <ph id="ph4">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 <ph id="ph2">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph3">`DataColumn`</ph> 또는 <ph id="ph4">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XML Schema for a &lt;xref:System.Data.DataSet&gt; includes a <ph id="ph1">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling ReadXml to load the &lt;xref:System.Data.DataSet&gt; with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">경우에 대 한 XML 스키마는 &lt;xref:System.Data.DataSet&gt;포함 한 <ph id="ph1">`targetNamespace`</ph>, 데이터를 읽을 수 있습니다, 그리고 및 ReadXml 로드를 호출할 때 예외가 발생할 수 있습니다는 &lt;xref:System.Data.DataSet&gt;정규화 네임 스페이스가 없는 요소가 포함 된 XML로.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">정규화 되지 않은 요소를 읽으려면 설정 <ph id="ph1">`elementFormDefault`</ph> 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph>       &lt;xref:System.Xml.XmlTextReader?displayProperty=fullName&gt; inherits from &lt;xref:System.Xml.XmlReader&gt;.</source>
          <target state="translated"><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph>       &lt;xref:System.Xml.XmlTextReader?displayProperty=fullName&gt;&lt;xref:System.Xml.XmlReader&gt;.&lt;/xref:System.Xml.XmlReader&gt; 에서 상속&lt;/xref:System.Xml.XmlTextReader?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with ReadXml by specifying <ph id="ph2">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 경우에 대 한 스키마 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 &lt;xref:System.Data.DataSet&gt;지정 하 여 ReadXml와 <ph id="ph2">`XmlReadMode.ReadSchema`</ph>.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.XmlReader&gt; from which to read.</source>
          <target state="translated">&lt;xref:System.Xml.XmlReader&gt;읽을.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to read the data.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 읽는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>Reads XML schema and data into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> and <bpt id="p2">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">XML 스키마와 데이터를는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 및 <bpt id="p2">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method provides a way to read either data only, or both data and schema into a &lt;xref:System.Data.DataSet&gt; from an XML document, whereas the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method reads only the schema.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 &lt;xref:System.Data.DataSet&gt;XML 문서 로부터 반면는 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 스키마만 읽습니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">데이터 및 스미카를 읽으려면 중 하나를 사용는 <ph id="ph1">`ReadXML`</ph> 포함 하는 오버 로드는 <ph id="ph2">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph3">`ReadSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source>The same is true for the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; and &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">에 마찬가지입니다는 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;및 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When you use ReadXml and you set &lt;xref:System.Data.XmlReadMode&gt; to <ph id="ph2">`Diffgram`</ph>, the content of the target <ph id="ph3">`DataSet`</ph> and the original <ph id="ph4">`DataSet`</ph> may differ because of how the diffgram is generated and processed.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; ReadXml을 사용 하 고 설정한 &lt;xref:System.Data.XmlReadMode&gt;를 <ph id="ph2">`Diffgram`</ph>, 대상의 내용을 <ph id="ph3">`DataSet`</ph> 과 원래 <ph id="ph4">`DataSet`</ph> diffgram 생성 되 고 처리 되는 방식으로 인해 달라질 수 있습니다.&lt;/xref:System.Data.XmlReadMode&gt;</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on diffgrams, see <bpt id="p1">[</bpt>DiffGrams<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Diffgram에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>Diffgram<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The <ph id="ph2">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph3">`DataColumn`</ph> or <ph id="ph4">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 <ph id="ph2">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph3">`DataColumn`</ph> 또는 <ph id="ph4">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XML Schema for a &lt;xref:System.Data.DataSet&gt; includes <ph id="ph1">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling &lt;xref:System.Data.DataSet.ReadXml%2A&gt; to load the &lt;xref:System.Data.DataSet&gt; with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">경우에 대 한 XML 스키마는 &lt;xref:System.Data.DataSet&gt;포함 <ph id="ph1">`targetNamespace`</ph>, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;로드 하는 &lt;xref:System.Data.DataSet&gt;정규화 네임 스페이스가 없는 요소가 포함 된 XML로.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">정규화 되지 않은 요소를 읽으려면 설정 <ph id="ph1">`elementFormDefault`</ph> 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXml%2A&gt; by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated"><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph>&gt; If에 대 한 스키마 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;지정 하 여 <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.IO.Stream&gt; from which to read.</source>
          <target state="translated">&lt;xref:System.IO.Stream&gt;읽을.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to read the data.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 읽는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>Reads XML schema and data into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified <ph id="ph1">&amp;lt;</ph>xref:System.IO.TextReader?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> and <bpt id="p2">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">XML 스키마와 데이터를는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 <ph id="ph1">&amp;lt;</ph>xref:System.IO.TextReader?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 및 <bpt id="p2">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method provides a way to read either data only, or both data and schema into a &lt;xref:System.Data.DataSet&gt; from an XML document, whereas the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method reads only the schema.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 &lt;xref:System.Data.DataSet&gt;XML 문서 로부터 반면는 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 스키마만 읽습니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">데이터 및 스미카를 읽으려면 중 하나를 사용는 <ph id="ph1">`ReadXML`</ph> 포함 하는 오버 로드는 <ph id="ph2">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph3">`ReadSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; and &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;및 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The <ph id="ph2">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph3">`DataColumn`</ph> or <ph id="ph4">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 <ph id="ph2">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph3">`DataColumn`</ph> 또는 <ph id="ph4">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XML Schema for a &lt;xref:System.Data.DataSet&gt; includes <ph id="ph1">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling &lt;xref:System.Data.DataSet.ReadXml%2A&gt; to load the &lt;xref:System.Data.DataSet&gt; with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">경우에 대 한 XML 스키마는 &lt;xref:System.Data.DataSet&gt;포함 <ph id="ph1">`targetNamespace`</ph>, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;로드 하는 &lt;xref:System.Data.DataSet&gt;정규화 네임 스페이스가 없는 요소가 포함 된 XML로.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">정규화 되지 않은 요소를 읽으려면 설정 <ph id="ph1">`elementFormDefault`</ph> 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXml%2A&gt; by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated"><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph>&gt; If에 대 한 스키마 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;지정 하 여 <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.IO.TextReader&gt; from which to read.</source>
          <target state="translated">&lt;xref:System.IO.TextReader&gt;읽을.&lt;/xref:System.IO.TextReader&gt;</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to read the data.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 읽는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>Reads XML schema and data into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified file and <bpt id="p2">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">XML 스키마와 데이터를는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 파일을 사용 하 여 및 <bpt id="p2">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method provides a way to read either data only, or both data and schema into a &lt;xref:System.Data.DataSet&gt; from an XML document, whereas the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method reads only the schema.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 &lt;xref:System.Data.DataSet&gt;XML 문서 로부터 반면는 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 스키마만 읽습니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">데이터 및 스미카를 읽으려면 중 하나를 사용는 <ph id="ph1">`ReadXML`</ph> 포함 하는 오버 로드는 <ph id="ph2">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph3">`ReadSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; and &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;및 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The <ph id="ph2">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph3">`DataColumn`</ph> or <ph id="ph4">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 <ph id="ph2">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph3">`DataColumn`</ph> 또는 <ph id="ph4">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XML Schema for a &lt;xref:System.Data.DataSet&gt; includes a <ph id="ph1">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling &lt;xref:System.Data.DataSet.ReadXml%2A&gt; to load the &lt;xref:System.Data.DataSet&gt; with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">경우에 대 한 XML 스키마는 &lt;xref:System.Data.DataSet&gt;포함는 <ph id="ph1">`targetNamespace`</ph>, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;로드 하는 &lt;xref:System.Data.DataSet&gt;정규화 네임 스페이스가 없는 요소가 포함 된 XML로.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">정규화 되지 않은 요소를 읽으려면 설정 <ph id="ph1">`elementFormDefault`</ph> 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXml%2A&gt; by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated"><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph>&gt; If에 대 한 스키마 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;지정 하 여 <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>The filename (including the path) from which to read.</source>
          <target state="translated">파일 이름 (경로 포함) 스트림입니다.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to read the data.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 읽는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is not set to <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>로 설정 되지 않은 <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>Reads XML schema and data into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified <ph id="ph1">&amp;lt;</ph>xref:System.Xml.XmlReader?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> and <bpt id="p2">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">XML 스키마와 데이터를는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 <ph id="ph1">&amp;lt;</ph>xref:System.Xml.XmlReader?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 및 <bpt id="p2">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method provides a way to read either data only, or both data and schema into a &lt;xref:System.Data.DataSet&gt; from an XML document, whereas the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method reads only the schema.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 &lt;xref:System.Data.DataSet&gt;XML 문서 로부터 반면는 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 스키마만 읽습니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">데이터 및 스미카를 읽으려면 중 하나를 사용는 <ph id="ph1">`ReadXML`</ph> 포함 하는 오버 로드는 <ph id="ph2">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph3">`ReadSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; and &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;및 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The <ph id="ph2">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph3">`DataColumn`</ph> or <ph id="ph4">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 <ph id="ph2">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph3">`DataColumn`</ph> 또는 <ph id="ph4">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XML Schema for a &lt;xref:System.Data.DataSet&gt; includes a <ph id="ph1">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling &lt;xref:System.Data.DataSet.ReadXml%2A&gt; to load the &lt;xref:System.Data.DataSet&gt; with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">경우에 대 한 XML 스키마는 &lt;xref:System.Data.DataSet&gt;포함는 <ph id="ph1">`targetNamespace`</ph>, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;로드 하는 &lt;xref:System.Data.DataSet&gt;정규화 네임 스페이스가 없는 요소가 포함 된 XML로.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">정규화 되지 않은 요소를 읽으려면 설정 <ph id="ph1">`elementFormDefault`</ph> 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXml%2A&gt; by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated"><ph id="ph1">```   &lt;xsd:schema id="MyDataSet"       elementFormDefault="qualified"       targetNamespace="http://www.tempuri.org/MyDataSet.xsd"       xmlns="http://www.tempuri.org/MyDataSet.xsd"       xmlns:xsd="http://www.w3.org/2001/XMLSchema"       xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"&gt;   &lt;/xsd:schema&gt;   ```</ph><ph id="ph2">      &gt; </ph><ph id="ph3">[!NOTE]</ph>&gt; If에 대 한 스키마 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 &lt;xref:System.Data.DataSet&gt;와 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;지정 하 여 <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; &lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.XmlReader&gt; from which to read.</source>
          <target state="translated">&lt;xref:System.Xml.XmlReader&gt;읽을.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.XmlReadMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> used to read the data.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_XmlReadMode" name="XmlReadMode" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 데이터를 읽는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>Reads the XML schema from the specified &lt;xref:System.IO.Stream&gt; into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정 된 위치에서 XML 스키마를 읽고 &lt;xref:System.IO.Stream&gt;에 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method to create the schema for a &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 대 한 스키마를 만드는 메서드를&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; 사용 하 여</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write a schema to an XML document, use the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method is generally invoked before invoking the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method which is used to fill the &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 일반적으로 &lt;xref:System.Data.DataSet.ReadXml%2A&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 를 채우는 데 사용 되는 메서드&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; 를 호출 하기 전에 호출 됩니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes that derive from the &lt;xref:System.IO.Stream&gt; class include &lt;xref:System.IO.BufferedStream&gt;, &lt;xref:System.IO.FileStream&gt;, &lt;xref:System.IO.MemoryStream&gt;, and &lt;xref:System.Net.Sockets.NetworkStream&gt;.</source>
          <target state="translated">파생 된 클래스는 &lt;xref:System.IO.Stream&gt;클래스 포함 &lt;xref:System.IO.BufferedStream&gt;, &lt;xref:System.IO.FileStream&gt;, &lt;xref:System.IO.MemoryStream&gt;, 및 &lt;xref:System.Net.Sockets.NetworkStream&gt;.&lt;/xref:System.Net.Sockets.NetworkStream&gt; &lt;/xref:System.IO.MemoryStream&gt; &lt;/xref:System.IO.FileStream&gt; &lt;/xref:System.IO.BufferedStream&gt; &lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is be thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 경우 스키마에 대 한 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 예외가 throw 스키마는 into &lt;xref:System.Data.DataSet&gt; &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; 읽을 하려고 할 때&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.IO.Stream&gt; from which to read.</source>
          <target state="translated">&lt;xref:System.IO.Stream&gt;읽을.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>Reads the XML schema from the specified &lt;xref:System.IO.TextReader&gt; into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정 된 위치에서 XML 스키마를 읽고 &lt;xref:System.IO.TextReader&gt;에 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.IO.TextReader&gt;</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method to create the schema for a &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 대 한 스키마를 만드는 메서드를&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; 사용 하 여</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write a schema to an XML document, use the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method is generally invoked before invoking the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method which is used to fill the &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 일반적으로 &lt;xref:System.Data.DataSet.ReadXml%2A&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 를 채우는 데 사용 되는 메서드&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; 를 호출 하기 전에 호출 됩니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes that inherit from the &lt;xref:System.IO.TextReader&gt; class include the &lt;xref:System.IO.StreamReader&gt; and &lt;xref:System.IO.StringReader&gt; classes.</source>
          <target state="translated">클래스에서 상속 되는 &lt;xref:System.IO.TextReader&gt;클래스에 포함 된 &lt;xref:System.IO.StreamReader&gt;및 &lt;xref:System.IO.StringReader&gt;클래스.&lt;/xref:System.IO.StringReader&gt; &lt;/xref:System.IO.StreamReader&gt; &lt;/xref:System.IO.TextReader&gt;</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is be thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 경우 스키마에 대 한 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 예외가 throw 스키마는 into &lt;xref:System.Data.DataSet&gt; &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; 읽을 하려고 할 때&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.IO.TextReader&gt; from which to read.</source>
          <target state="translated">&lt;xref:System.IO.TextReader&gt;읽을.&lt;/xref:System.IO.TextReader&gt;</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>Reads the XML schema from the specified file into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 지정된 된 파일에서 XML 스키마를 읽고는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method to create the schema for a &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 대 한 스키마를 만드는 메서드를&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; 사용 하 여</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write a schema to an XML document, use the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; method is generally invoked before invoking the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method which is used to fill the &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드는 일반적으로 &lt;xref:System.Data.DataSet.ReadXml%2A&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 를 채우는 데 사용 되는 메서드&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; 를 호출 하기 전에 호출 됩니다.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 경우 스키마에 대 한 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마는 into &lt;xref:System.Data.DataSet&gt; &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt; 읽을 하려고 할 때 예외가 throw 됩니다&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>The file name (including the path) from which to read.</source>
          <target state="translated">파일을 읽어올 이름 (경로 포함).</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is not set to <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>로 설정 되지 않은 <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>Reads the XML schema from the specified &lt;xref:System.Xml.XmlReader&gt; into the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">지정 된 위치에서 XML 스키마를 읽고 &lt;xref:System.Xml.XmlReader&gt;에 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the ReadXmlSchema method to create the schema for a &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">ReadXmlSchema 메서드를 사용 하 여에 &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 대 한 스키마를 만들려면</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ReadXmlSchema method is generally invoked before invoking the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; method which is used to fill the &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">일반적으로 ReadXmlSchema 메서드 &lt;xref:System.Data.DataSet.ReadXml%2A&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 를 채우는 데 사용 되는 메서드&lt;/xref:System.Data.DataSet.ReadXml%2A&gt; 를 호출 하기 전에 호출</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Xml.XmlReader?displayProperty=fullName&gt; class is abstract.</source>
          <target state="translated">&lt;xref:System.Xml.XmlReader?displayProperty=fullName&gt;클래스는 추상 클래스입니다.&lt;/xref:System.Xml.XmlReader?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>A class that inherits from the <ph id="ph1">`XmlReader`</ph> is the &lt;xref:System.Xml.XmlTextReader?displayProperty=fullName&gt; class.</source>
          <target state="translated">상속 되는 클래스는 <ph id="ph1">`XmlReader`</ph> &lt;xref:System.Xml.XmlTextReader?displayProperty=fullName&gt;클래스&lt;/xref:System.Xml.XmlTextReader?displayProperty=fullName&gt; 입니다.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the schema for your &lt;xref:System.Data.DataSet&gt; contains elements of the same name, but different type, in the same namespace, an exception is be thrown when you attempt to read the schema into the &lt;xref:System.Data.DataSet&gt; with ReadXmlSchema.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 하는 경우에 대 한 스키마 프로그램 &lt;xref:System.Data.DataSet&gt;요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 예외가 throw에 스키마를 읽을 때는 &lt;xref:System.Data.DataSet&gt;ReadXmlSchema와.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">.NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.XmlReader&gt; from which to read.</source>
          <target state="translated">&lt;xref:System.Xml.XmlReader&gt;읽을.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>Ignores attributes and returns an empty DataSet.</source>
          <target state="translated">특성을 무시 하 고 빈 데이터 집합을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>The specified XML reader.</source>
          <target state="translated">지정 된 XML 판독기입니다.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>Rolls back all the changes made to the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> since it was created, or since the last time <ph id="ph1">&amp;lt;</ph>xref:System.Data.DataSet.AcceptChanges%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> was called.</source>
          <target state="translated">에 대 한 모든 변경 사항을 롤백합니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 만들어진 이후 또는 마지막으로 이후에 <ph id="ph1">&amp;lt;</ph>xref:System.Data.DataSet.AcceptChanges%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 호출 되었습니다.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invoke the RejectChanges to call the &lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName&gt; method on all &lt;xref:System.Data.DataTable&gt; objects contained by the &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName&gt;모든 &lt;xref:System.Data.DataTable&gt; &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 에 포함 된 개체에서&lt;/xref:System.Data.DataTable&gt; 메서드&lt;/xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName&gt; 를 호출합니다 하려면 RejectChanges 호출</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Data.DataRow&gt; objects contained by the &lt;xref:System.Data.DataSet&gt; can each be set into edit mode by invoking the &lt;xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName&gt; method.</source>
          <target state="translated">&lt;xref:System.Data.DataRow&gt;에 포함 된 개체는 &lt;xref:System.Data.DataSet&gt;를 호출 하 여 편집 모드로 설정할 수 있습니다는 &lt;xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName&gt;메서드.&lt;/xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName&gt; &lt;/xref:System.Data.DataSet&gt;&lt;/xref:System.Data.DataRow&gt;</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>After invoking the &lt;xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName&gt; method, changes can be rejected by calling the &lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName&gt; on the &lt;xref:System.Data.DataTable&gt; to which the &lt;xref:System.Data.DataRow&gt; objects belong.</source>
          <target state="translated">호출 후의 &lt;xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName&gt;메서드를 호출 하 여 변경 내용이 거부 될 수 있습니다는 &lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName&gt;에 &lt;xref:System.Data.DataTable&gt;입니다는 &lt;xref:System.Data.DataRow&gt;개체 속합니다.&lt;/xref:System.Data.DataRow&gt; &lt;/xref:System.Data.DataTable&gt; &lt;/xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName&gt; &lt;/xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the &lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName&gt; method is called, any rows still in edit-mode cancel their edits.</source>
          <target state="translated">경우는 &lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName&gt;메서드가 호출 되 면 행이 편집 모드에 계속 편집이 취소 됩니다.&lt;/xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>New rows are removed.</source>
          <target state="translated">새 행이 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>Modified and deleted rows return back to their original state (<ph id="ph1">`DataRowState.Unchanged`</ph>).</source>
          <target state="translated">원래 상태로 다시 수정 및 삭제 된 행을 반환 합니다. (<ph id="ph1">`DataRowState.Unchanged`</ph>).</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>AcceptChanges and RejectChanges only apply to &lt;xref:System.Data.DataRow&gt; related changes (that is, <ph id="ph1">`Add`</ph>, <ph id="ph2">`Remove`</ph>, <ph id="ph3">`Delete`</ph>, and <ph id="ph4">`Modify`</ph>).</source>
          <target state="translated">AcceptChanges 및 RejectChanges에만 적용 &lt;xref:System.Data.DataRow&gt;관련 변경 내용 (즉, <ph id="ph1">`Add`</ph>, <ph id="ph2">`Remove`</ph>, <ph id="ph3">`Delete`</ph>, 및 <ph id="ph4">`Modify`</ph>).&lt;/xref:System.Data.DataRow&gt;</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT">
          <source>They are not applicable to schema or structural changes.</source>
          <target state="translated">스키마 나 구조 변경 내용을 적용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>Get the collection of relations that link tables and allow navigation from parent tables to child tables.</source>
          <target state="translated">테이블에 연결 하 고 탐색 부모에서 자식 테이블에는 테이블을 허용 하는 관계의 컬렉션을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Data.DataRelationCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that contains a collection of <bpt id="p2">&lt;xref href="System.Data.DataRelation"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> objects.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Data.DataRelationCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 의 컬렉션을 포함 하는 <bpt id="p2">&lt;xref href="System.Data.DataRelation"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>An empty collection is returned if no <bpt id="p1">&lt;xref href="System.Data.DataRelation"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> objects exist.</source>
          <target state="translated">없는 경우에 빈 컬렉션이 반환 됩니다 <bpt id="p1">&lt;xref href="System.Data.DataRelation"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체가 존재 합니다.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>Gets or sets a <bpt id="p1">&lt;xref href="System.Data.SerializationFormat"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for the <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> used during remoting.</source>
          <target state="translated">가져오거나는 <bpt id="p1">&lt;xref href="System.Data.SerializationFormat"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 에 대 한는 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> 원격 작업 중에 사용 합니다.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Data.SerializationFormat"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Data.SerializationFormat"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>Clears all tables and removes all relations, foreign constraints, and tables from the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">모든 테이블을 지우고 모든 관계, 외부 제약 조건 및 테이블에서 제거 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>Subclasses should override Reset to restore a <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to its original state.</source>
          <target state="translated">서브 클래스를 복원 하려면 다시 설정 재정의 해야는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 원래 상태로 있습니다.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>Gets or sets a <bpt id="p1">&lt;xref href="System.Data.SchemaSerializationMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for a <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Gets or sets a <bpt id="p1">&lt;xref href="System.Data.SchemaSerializationMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for a <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Data.DataSet&gt; serializes its schema and instance data by default in Web services and remoting scenarios.</source>
          <target state="translated">A &lt;xref:System.Data.DataSet&gt;웹 서비스 및 원격 시나리오에 기본적으로 해당 스키마 및 인스턴스 데이터를 serialize 합니다.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting the SchemaSerializationMode property of a typed <ph id="ph1">`DataSet`</ph> to &lt;xref:System.Data.SchemaSerializationMode&gt; causes schema information to be excluded from the serialization payload.</source>
          <target state="translated">형식화 된 SchemaSerializationMode 속성을 설정 <ph id="ph1">`DataSet`</ph> 를 &lt;xref:System.Data.SchemaSerializationMode&gt;serialization 페이로드에서 제외 되어야 하는 스키마 정보로 인해.&lt;/xref:System.Data.SchemaSerializationMode&gt;</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Data.SchemaSerializationMode&gt; is supported only for a typed <ph id="ph1">`DataSet`</ph>.</source>
          <target state="translated">&lt;xref:System.Data.SchemaSerializationMode&gt;지원 되는 형식화 된에 대해서만 <ph id="ph1">`DataSet`</ph>합니다.&lt;/xref:System.Data.SchemaSerializationMode&gt;</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an un-typed <ph id="ph1">`DataSet`</ph> this property can only be set to &lt;xref:System.Data.SchemaSerializationMode&gt;.</source>
          <target state="translated">형식화 되지 않은 <ph id="ph1">`DataSet`</ph> 시키면 &lt;xref:System.Data.SchemaSerializationMode&gt;.&lt;/xref:System.Data.SchemaSerializationMode&gt; 이 속성</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Data.SchemaSerializationMode&gt; should only be used in cases where the schema information of the underlying typed <ph id="ph1">`DataTables`</ph>, <ph id="ph2">`DataRelations`</ph> and <ph id="ph3">`Constraints`</ph> has not been modified.</source>
          <target state="translated">&lt;xref:System.Data.SchemaSerializationMode&gt;기본 스키마 정보를 입력 한 경우에만 사용 해야 <ph id="ph1">`DataTables`</ph>, <ph id="ph2">`DataRelations`</ph> 및 <ph id="ph3">`Constraints`</ph> 수정 되지 않았습니다.&lt;/xref:System.Data.SchemaSerializationMode&gt;</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>If modifications have occurred, complete schema information should be serialized with &lt;xref:System.Data.SchemaSerializationMode&gt;.</source>
          <target state="translated">&lt;xref:System.Data.SchemaSerializationMode&gt;.&lt;/xref:System.Data.SchemaSerializationMode&gt; 완료, 오류가 발생 했습니다 스키마 정보를 serialize 해야 수정 작업이 필요한 경우</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Data.SchemaSerializationMode&gt; is supported in version 2.0 of the .NET Framework or later.</source>
          <target state="translated">&lt;xref:System.Data.SchemaSerializationMode&gt;2.0 이상 버전의.NET Framework에서 지원 됩니다.&lt;/xref:System.Data.SchemaSerializationMode&gt;</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source>When &lt;xref:System.Data.SchemaSerializationMode&gt; is set, only the top level runtime properties present on the &lt;xref:System.Data.DataSet&gt; are serialized.</source>
          <target state="translated">때 &lt;xref:System.Data.SchemaSerializationMode&gt;설정 되어만 최상위 수준 런타임 속성에는 &lt;xref:System.Data.DataSet&gt;serialize 됩니다.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.SchemaSerializationMode&gt;</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, they are serialized only if they happen to be different from the default values.</source>
          <target state="translated">또한 기본 값과에서 다를 경우에 serialize 됩니다.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>None of the <ph id="ph1">`Tables`</ph>, <ph id="ph2">`Relations`</ph> or <ph id="ph3">`Constraints`</ph> are serialized.</source>
          <target state="translated">중에서 <ph id="ph1">`Tables`</ph>, <ph id="ph2">`Relations`</ph> 또는 <ph id="ph3">`Constraints`</ph> serialize 됩니다.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>The serialized runtime properties include &lt;xref:System.Data.DataSet.DataSetName%2A&gt;, &lt;xref:System.Data.DataSet.Namespace%2A&gt;, &lt;xref:System.Data.DataSet.Prefix%2A&gt;, &lt;xref:System.Data.DataSet.Locale%2A&gt;, &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;, and &lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;.</source>
          <target state="translated">Serialize 된 런타임 속성에 포함 &lt;xref:System.Data.DataSet.DataSetName%2A&gt;, &lt;xref:System.Data.DataSet.Namespace%2A&gt;, &lt;xref:System.Data.DataSet.Prefix%2A&gt;, &lt;xref:System.Data.DataSet.Locale%2A&gt;, &lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;, 및 &lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;.&lt;/xref:System.Data.DataSet.CaseSensitive%2A&gt; &lt;/xref:System.Data.DataSet.EnforceConstraints%2A&gt; &lt;/xref:System.Data.DataSet.Locale%2A&gt; &lt;/xref:System.Data.DataSet.Prefix%2A&gt; &lt;/xref:System.Data.DataSet.Namespace%2A&gt; &lt;/xref:System.Data.DataSet.DataSetName%2A&gt;</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>These properties are serialized to make sure that overall runtime data integrity is preserved.</source>
          <target state="translated">이러한 속성은 전체 런타임 데이터 무결성이 유지 되도록 serialize 됩니다.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Gets or sets a <bpt id="p1">&lt;xref href="System.Data.SchemaSerializationMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for a <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Gets or sets a <bpt id="p1">&lt;xref href="System.Data.SchemaSerializationMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for a <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether &lt;xref:System.Data.DataSet.Relations*&gt; property should be persisted.</source>
          <target state="translated">나타내는 값을 가져옵니다 여부 &lt;xref:System.Data.DataSet.Relations*&gt;속성을 유지 해야 합니다.&lt;/xref:System.Data.DataSet.Relations*&gt;</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>You typically use this method if you are either creating a designer for the &lt;xref:System.Data.DataSet&gt;, or creating your own control incorporating the &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">일반적으로이 방법을 사용 하면 중 하나에 대 한 디자이너를 만드는 경우는 &lt;xref:System.Data.DataSet&gt;, &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 를 통합 하는 사용자 지정 컨트롤 또는&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the property value has been changed from its default; otherwise <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>속성 값이 기본값에서 변경 된 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether &lt;xref:System.Data.DataSet.Tables*&gt; property should be persisted.</source>
          <target state="translated">나타내는 값을 가져옵니다 여부 &lt;xref:System.Data.DataSet.Tables*&gt;속성을 유지 해야 합니다.&lt;/xref:System.Data.DataSet.Tables*&gt;</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT">
          <source>You typically use this method only if you are either creating a designer for the &lt;xref:System.Data.DataSet&gt;, or creating your own control incorporating the &lt;xref:System.Data.DataSet&gt;.</source>
          <target state="translated">에 대 한 디자이너를 만들거나 하는 경우에이 메서드를 일반적으로 사용 된 &lt;xref:System.Data.DataSet&gt;, &lt;xref:System.Data.DataSet&gt;.&lt;/xref:System.Data.DataSet&gt; 를 통합 하는 사용자 지정 컨트롤 또는&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the property value has been changed from its default; otherwise <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>속성 값이 기본값에서 변경 된 경우 그렇지 않으면 <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Gets or sets an <bpt id="p1">&lt;xref href="System.ComponentModel.ISite"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for the <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">가져오거나는 <bpt id="p1">&lt;xref href="System.ComponentModel.ISite"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 에 대 한는 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT">
          <source>Sites bind a &lt;xref:System.ComponentModel.Component&gt; to a &lt;xref:System.ComponentModel.Container&gt; and enable communication between them, as well as provide a way for the container to manage its components.</source>
          <target state="translated">사이트 바인딩는 &lt;xref:System.ComponentModel.Component&gt;에 &lt;xref:System.ComponentModel.Container&gt;서로 통신할 수 있도록 할 뿐만 아니라 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.&lt;/xref:System.ComponentModel.Container&gt; &lt;/xref:System.ComponentModel.Component&gt;</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.ComponentModel.ISite"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for the <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">An <bpt id="p1">&lt;xref href="System.ComponentModel.ISite"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for the <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&amp;lt;</ph>xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">이 멤버에 대 한 참조 <ph id="ph1">&amp;lt;</ph>xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현 이며</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the &lt;xref:System.Data.DataSet&gt; instance is cast to an &lt;xref:System.ComponentModel.IListSource&gt; interface.</source>
          <target state="translated">사용할 수 있습니다 경우에만 &lt;xref:System.Data.DataSet&gt;인스턴스로 캐스팅 되는 &lt;xref:System.ComponentModel.IListSource&gt;인터페이스.&lt;/xref:System.ComponentModel.IListSource&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&amp;lt;</ph>xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">이 멤버에 대 한 참조 <ph id="ph1">&amp;lt;</ph>xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&amp;lt;</ph>xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">이 멤버에 대 한 참조 <ph id="ph1">&amp;lt;</ph>xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현 이며</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the &lt;xref:System.Data.DataSet&gt; instance is cast to an &lt;xref:System.ComponentModel.IListSource&gt; interface.</source>
          <target state="translated">사용할 수 있습니다 경우에만 &lt;xref:System.Data.DataSet&gt;인스턴스로 캐스팅 되는 &lt;xref:System.ComponentModel.IListSource&gt;인터페이스.&lt;/xref:System.ComponentModel.IListSource&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&amp;lt;</ph>xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">이 멤버에 대 한 참조 <ph id="ph1">&amp;lt;</ph>xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&amp;lt;</ph>xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">이 멤버에 대 한 참조 <ph id="ph1">&amp;lt;</ph>xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현 이며</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the &lt;xref:System.Data.DataSet&gt; instance is cast to an &lt;xref:System.Xml.Serialization.IXmlSerializable&gt; interface.</source>
          <target state="translated">사용할 수 있습니다 경우에만 &lt;xref:System.Data.DataSet&gt;인스턴스로 캐스팅 되는 &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;인터페이스.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&amp;lt;</ph>xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">이 멤버에 대 한 참조 <ph id="ph1">&amp;lt;</ph>xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&amp;lt;</ph>xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">이 멤버에 대 한 참조 <ph id="ph1">&amp;lt;</ph>xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현 이며</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the &lt;xref:System.Data.DataSet&gt; instance is cast to an &lt;xref:System.Xml.Serialization.IXmlSerializable&gt; interface.</source>
          <target state="translated">사용할 수 있습니다 경우에만 &lt;xref:System.Data.DataSet&gt;인스턴스로 캐스팅 되는 &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;인터페이스.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Xml.XmlReader&gt;.</source>
          <target state="translated">A &lt;xref:System.Xml.XmlReader&gt;.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&amp;lt;</ph>xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">이 멤버에 대 한 참조 <ph id="ph1">&amp;lt;</ph>xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현 이며</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the &lt;xref:System.Data.DataSet&gt; instance is cast to an &lt;xref:System.Xml.Serialization.IXmlSerializable&gt; interface.</source>
          <target state="translated">사용할 수 있습니다 경우에만 &lt;xref:System.Data.DataSet&gt;인스턴스로 캐스팅 되는 &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;인터페이스.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Xml.XmlWriter&gt;.</source>
          <target state="translated">A &lt;xref:System.Xml.XmlWriter&gt;.&lt;/xref:System.Xml.XmlWriter&gt;</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>Gets the collection of tables contained in the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 포함 된 테이블의 컬렉션을 가져옵니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source>To add tables to the collection, use &lt;xref:System.Data.DataTableCollection.Add%2A&gt; method of the &lt;xref:System.Data.DataTableCollection&gt;.</source>
          <target state="translated">컬렉션에 테이블을 추가 하려면 &lt;xref:System.Data.DataTableCollection.Add%2A&gt; &lt;xref:System.Data.DataTableCollection&gt;.&lt;/xref:System.Data.DataTableCollection&gt; 의 메서드&lt;/xref:System.Data.DataTableCollection.Add%2A&gt; 를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>To remove tables, use the &lt;xref:System.Data.DataTableCollection.Remove%2A&gt; method.</source>
          <target state="translated">사용 하 여 테이블을 제거 하려면는 &lt;xref:System.Data.DataTableCollection.Remove%2A&gt;메서드.&lt;/xref:System.Data.DataTableCollection.Remove%2A&gt;</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Data.DataTableCollection"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> contained by this <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Data.DataTableCollection"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 이 포함 된 <bpt id="p2">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>An empty collection is returned if no <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> objects exist.</source>
          <target state="translated">없는 경우에 빈 컬렉션이 반환 됩니다 <bpt id="p1">&lt;xref href="System.Data.DataTable"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 개체가 존재 합니다.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>Writes the current data for the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>.</source>
          <target state="translated">현재 데이터를 씁니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a &lt;xref:System.Data.DataSet&gt; into an XML document, whereas the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method writes only the schema.</source>
          <target state="translated"><ph id="ph1">`WriteXml`</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 &lt;xref:System.Data.DataSet&gt;XML 문서로 반면는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드는 스키마만 씁니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; and &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;및 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.IO.Stream&gt; object used to write to a file.</source>
          <target state="translated">A &lt;xref:System.IO.Stream&gt;파일에 기록 하는 데 사용 되는 개체입니다.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>Writes the current data for the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified &lt;xref:System.IO.TextWriter&gt;.</source>
          <target state="translated">현재 데이터를 씁니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> &lt;xref:System.IO.TextWriter&gt;.&lt;/xref:System.IO.TextWriter&gt; 지정된을 사용 하 여</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a &lt;xref:System.Data.DataSet&gt; into an XML document, whereas the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method writes only the schema.</source>
          <target state="translated"><ph id="ph1">`WriteXml`</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 &lt;xref:System.Data.DataSet&gt;XML 문서로 반면는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드는 스키마만 씁니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; and &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;및 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.IO.TextWriter&gt; object with which to write.</source>
          <target state="translated">&lt;xref:System.IO.TextWriter&gt;쓰기에 사용할 개체입니다.&lt;/xref:System.IO.TextWriter&gt;</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>Writes the current data for the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the specified file.</source>
          <target state="translated">현재 데이터를 씁니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 지정된 된 파일에 있습니다.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a &lt;xref:System.Data.DataSet&gt; into an XML document, whereas the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method writes only the schema.</source>
          <target state="translated"><ph id="ph1">`WriteXml`</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 &lt;xref:System.Data.DataSet&gt;XML 문서로 반면는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드는 스키마만 씁니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; and &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;및 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The file name (including the path) to which to write.</source>
          <target state="translated">파일 쓰기에 사용할 이름 (경로 포함).</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is not set to <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>로 설정 되지 않은 <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>Writes the current data for the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the specified &lt;xref:System.Xml.XmlWriter&gt;.</source>
          <target state="translated">현재 데이터를 씁니다는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> &lt;xref:System.Xml.XmlWriter&gt;.&lt;/xref:System.Xml.XmlWriter&gt; 지정</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a &lt;xref:System.Data.DataSet&gt; into an XML document, whereas the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method writes only the schema.</source>
          <target state="translated"><ph id="ph1">`WriteXml`</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 &lt;xref:System.Data.DataSet&gt;XML 문서로 반면는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드는 스키마만 씁니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">`mode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; and &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;및 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.XmlWriter&gt; with which to write.</source>
          <target state="translated">&lt;xref:System.Xml.XmlWriter&gt;쓰기에 사용할.&lt;/xref:System.Xml.XmlWriter&gt;</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>Writes the current data, and optionally the schema, for the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> and <bpt id="p2">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 및 <bpt id="p2">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>To write the schema, set the value for the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> parameter to <bpt id="p2">&lt;xref uid="langword_csharp_WriteSchema" name="WriteSchema" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">스키마를 작성 하려면 설정에 대 한 값은 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">mode</ph> <ept id="p1">&lt;/code&gt;</ept> 매개 변수를 <bpt id="p2">&lt;xref uid="langword_csharp_WriteSchema" name="WriteSchema" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a &lt;xref:System.Data.DataSet&gt; into an XML document, whereas the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method writes only the schema.</source>
          <target state="translated"><ph id="ph1">`WriteXml`</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 &lt;xref:System.Data.DataSet&gt;XML 문서로 반면는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드는 스키마만 씁니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 설정는 <ph id="ph1">`mode`</ph> 매개 변수를 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; and &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;및 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.IO.Stream&gt; object used to write to a file.</source>
          <target state="translated">A &lt;xref:System.IO.Stream&gt;파일에 기록 하는 데 사용 되는 개체입니다.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>Writes the current data, and optionally the schema, for the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified &lt;xref:System.IO.TextWriter&gt; and <bpt id="p2">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 &lt;xref:System.IO.TextWriter&gt;및 <bpt id="p2">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.&lt;/xref:System.IO.TextWriter&gt;</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>To write the schema, set the value for the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> parameter to <bpt id="p2">&lt;xref uid="langword_csharp_WriteSchema" name="WriteSchema" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">스키마를 작성 하려면 설정에 대 한 값은 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">mode</ph> <ept id="p1">&lt;/code&gt;</ept> 매개 변수를 <bpt id="p2">&lt;xref uid="langword_csharp_WriteSchema" name="WriteSchema" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a &lt;xref:System.Data.DataSet&gt; into an XML document, whereas the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method writes only the schema.</source>
          <target state="translated"><ph id="ph1">`WriteXml`</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 &lt;xref:System.Data.DataSet&gt;XML 문서로 반면는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드는 스키마만 씁니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 설정는 <ph id="ph1">`mode`</ph> 매개 변수를 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; and &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;및 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&amp;lt;</ph>xref:System.IO.TextWriter?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> object used to write the document.</source>
          <target state="translated">A <ph id="ph1">&amp;lt;</ph>xref:System.IO.TextWriter?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 문서를 쓰는 데 사용 되는 개체입니다.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>Writes the current data, and optionally the schema, for the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the specified file using the specified <bpt id="p2">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 대 한 현재 데이터 및 필요에 따라 스키마에 기록 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정된 된 파일에 <bpt id="p2">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>To write the schema, set the value for the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> parameter to <bpt id="p2">&lt;xref uid="langword_csharp_WriteSchema" name="WriteSchema" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">스키마를 작성 하려면 설정에 대 한 값은 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">mode</ph> <ept id="p1">&lt;/code&gt;</ept> 매개 변수를 <bpt id="p2">&lt;xref uid="langword_csharp_WriteSchema" name="WriteSchema" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a &lt;xref:System.Data.DataSet&gt; into an XML document, whereas the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method writes only the schema.</source>
          <target state="translated"><ph id="ph1">`WriteXml`</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 &lt;xref:System.Data.DataSet&gt;XML 문서로 반면는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드는 스키마만 씁니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 설정는 <ph id="ph1">`mode`</ph> 매개 변수를 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; and &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;및 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>The file name (including the path) to which to write.</source>
          <target state="translated">파일 쓰기에 사용할 이름 (경로 포함).</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is not set to <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>로 설정 되지 않은 <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>Writes the current data, and optionally the schema, for the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> using the specified &lt;xref:System.Xml.XmlWriter&gt; and <bpt id="p2">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 사용 하 여 지정 된 &lt;xref:System.Xml.XmlWriter&gt;및 <bpt id="p2">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.&lt;/xref:System.Xml.XmlWriter&gt;</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>To write the schema, set the value for the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> parameter to <bpt id="p2">&lt;xref uid="langword_csharp_WriteSchema" name="WriteSchema" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">스키마를 작성 하려면 설정에 대 한 값은 <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">mode</ph> <ept id="p1">&lt;/code&gt;</ept> 매개 변수를 <bpt id="p2">&lt;xref uid="langword_csharp_WriteSchema" name="WriteSchema" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a &lt;xref:System.Data.DataSet&gt; into an XML document, whereas the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method writes only the schema.</source>
          <target state="translated"><ph id="ph1">`WriteXml`</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 &lt;xref:System.Data.DataSet&gt;XML 문서로 반면는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드는 스키마만 씁니다.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 설정는 <ph id="ph1">`mode`</ph> 매개 변수를 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the same is true for the &lt;xref:System.Data.DataSet.ReadXml%2A&gt; and &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt; methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 &lt;xref:System.Data.DataSet.ReadXml%2A&gt;및 &lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;메서드를 각각.&lt;/xref:System.Data.DataSet.ReadXmlSchema%2A&gt; &lt;/xref:System.Data.DataSet.ReadXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataSet`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  An &lt;xref:System.InvalidOperationException&gt; will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; and does not implement &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt;는 &lt;xref:System.InvalidOperationException&gt;경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 implements &lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt; &lt;xref:System.Xml.Serialization.IXmlSerializable&gt;.&lt;/xref:System.Xml.Serialization.IXmlSerializable&gt; 를 구현 하지 않으므로&lt;/xref:System.Dynamic.IDynamicMetaObjectProvider&gt; 에 기록 되 고&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.XmlWriter&gt; with which to write.</source>
          <target state="translated">&lt;xref:System.Xml.XmlWriter&gt;쓰기에 사용할.&lt;/xref:System.Xml.XmlWriter&gt;</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">중 하나는 <bpt id="p1">&lt;xref href="System.Data.XmlWriteMode"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 값입니다.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>Writes the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> structure as an XML schema to the specified <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> object.</source>
          <target state="translated">기록 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 구조를 지정 된 XML 스키마로 <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the WriteXmlSchema method to write the schema for a &lt;xref:System.Data.DataSet&gt; to an XML document.</source>
          <target state="translated">WriteXmlSchema 메서드를 사용 하 여에 대 한 스키마를 작성 하는 &lt;xref:System.Data.DataSet&gt;XML 문서에.&lt;/xref:System.Data.DataSet&gt;</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write a schema to an XML document, use the WriteXmlSchema method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 WriteXmlSchema 메서드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write the data to an XML document, use the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes that derive from the &lt;xref:System.IO.Stream&gt; class include &lt;xref:System.IO.BufferedStream&gt;, &lt;xref:System.IO.FileStream&gt;, &lt;xref:System.IO.MemoryStream&gt;, and &lt;xref:System.Net.Sockets.NetworkStream&gt;.</source>
          <target state="translated">파생 된 클래스는 &lt;xref:System.IO.Stream&gt;클래스 포함 &lt;xref:System.IO.BufferedStream&gt;, &lt;xref:System.IO.FileStream&gt;, &lt;xref:System.IO.MemoryStream&gt;, 및 &lt;xref:System.Net.Sockets.NetworkStream&gt;.&lt;/xref:System.Net.Sockets.NetworkStream&gt; &lt;/xref:System.IO.MemoryStream&gt; &lt;/xref:System.IO.FileStream&gt; &lt;/xref:System.IO.BufferedStream&gt; &lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.IO.Stream&gt; object used to write to a file.</source>
          <target state="translated">A &lt;xref:System.IO.Stream&gt;파일에 기록 하는 데 사용 되는 개체입니다.&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>Writes the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> structure as an XML schema to the specified &lt;xref:System.IO.TextWriter&gt; object.</source>
          <target state="translated">기록 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 구조를 지정 된 XML 스키마로 &lt;xref:System.IO.TextWriter&gt;개체입니다.&lt;/xref:System.IO.TextWriter&gt;</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method to write the schema for a &lt;xref:System.Data.DataSet&gt; to an XML document.</source>
          <target state="translated">사용 하 여는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;에 대 한 스키마를 작성 하는 메서드는 &lt;xref:System.Data.DataSet&gt;XML 문서에.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write a schema to an XML document, use the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write the data to an XML document, use the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes the derive from the &lt;xref:System.IO.TextWriter?displayProperty=fullName&gt; class include the &lt;xref:System.Web.HttpWriter?displayProperty=fullName&gt;, &lt;xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName&gt;, &lt;xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName&gt;, &lt;xref:System.IO.StreamWriter?displayProperty=fullName&gt;, and &lt;xref:System.IO.StringWriter?displayProperty=fullName&gt;.</source>
          <target state="translated">파생 되는 클래스는 &lt;xref:System.IO.TextWriter?displayProperty=fullName&gt;클래스에 포함 된 &lt;xref:System.Web.HttpWriter?displayProperty=fullName&gt;, &lt;xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName&gt;, &lt;xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName&gt;, &lt;xref:System.IO.StreamWriter?displayProperty=fullName&gt;, 및 &lt;xref:System.IO.StringWriter?displayProperty=fullName&gt;.&lt;/xref:System.IO.StringWriter?displayProperty=fullName&gt; &lt;/xref:System.IO.StreamWriter?displayProperty=fullName&gt; &lt;/xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName&gt; &lt;/xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName&gt; &lt;/xref:System.Web.HttpWriter?displayProperty=fullName&gt; &lt;/xref:System.IO.TextWriter?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.IO.TextWriter&gt; object with which to write.</source>
          <target state="translated">&lt;xref:System.IO.TextWriter&gt;쓰기에 사용할 개체입니다.&lt;/xref:System.IO.TextWriter&gt;</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>Writes the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> structure as an XML schema to a file.</source>
          <target state="translated">기록는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 파일에 XML 스키마로는 구조입니다.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method to write the schema for a &lt;xref:System.Data.DataSet&gt; to an XML document.</source>
          <target state="translated">사용 하 여는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;에 대 한 스키마를 작성 하는 메서드는 &lt;xref:System.Data.DataSet&gt;XML 문서에.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write a schema to an XML document, use the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write the data to an XML document, use the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>The file name (including the path) to which to write.</source>
          <target state="translated">파일 쓰기에 사용할 이름 (경로 포함).</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> is not set to <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Security.Permissions.FileIOPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>로 설정 되지 않은 <bpt id="p2">&lt;xref href="System.Security.Permissions.FileIOPermissionAccess"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>Writes the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> structure as an XML schema to an &lt;xref:System.Xml.XmlWriter&gt; object.</source>
          <target state="translated">기록 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 구조는 XML 스키마로는 &lt;xref:System.Xml.XmlWriter&gt;개체입니다.&lt;/xref:System.Xml.XmlWriter&gt;</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method to write the schema for a &lt;xref:System.Data.DataSet&gt; to an XML document.</source>
          <target state="translated">사용 하 여는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;에 대 한 스키마를 작성 하는 메서드는 &lt;xref:System.Data.DataSet&gt;XML 문서에.&lt;/xref:System.Data.DataSet&gt; &lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write a schema to an XML document, use the &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt; method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>To write the data to an XML document, use the &lt;xref:System.Data.DataSet.WriteXml%2A&gt; method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 &lt;xref:System.Data.DataSet.WriteXml%2A&gt;메서드.&lt;/xref:System.Data.DataSet.WriteXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>One class that inherits from the &lt;xref:System.Xml.XmlWriter?displayProperty=fullName&gt; class is the &lt;xref:System.Xml.XmlTextWriter?displayProperty=fullName&gt; class.</source>
          <target state="translated">&lt;xref:System.Xml.XmlWriter?displayProperty=fullName&gt;클래스는 &lt;xref:System.Xml.XmlTextWriter?displayProperty=fullName&gt;클래스&lt;/xref:System.Xml.XmlTextWriter?displayProperty=fullName&gt; &lt;/xref:System.Xml.XmlWriter?displayProperty=fullName&gt; 에서 상속 되는 하나의 클래스</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.XmlWriter&gt; to write to.</source>
          <target state="translated">&lt;xref:System.Xml.XmlWriter&gt;에 쓰려고 합니다.&lt;/xref:System.Xml.XmlWriter&gt;</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>Writes the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> structure as an XML schema to the specified <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> object.</source>
          <target state="translated">기록 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 구조를 지정 된 XML 스키마로 <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> object to write to.</source>
          <target state="translated">A <ph id="ph1">&amp;lt;</ph>xref:System.IO.Stream?displayProperty=fullName<ph id="ph2">&amp;gt;</ph> 쓸 개체입니다.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>A delegate used to convert &lt;xref:System.Type&gt; to string.</source>
          <target state="translated">변환 하는 데 사용 되는 대리자 &lt;xref:System.Type&gt;문자열로.&lt;/xref:System.Type&gt;</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>Writes the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> structure as an XML schema to the specified &lt;xref:System.IO.TextWriter&gt;.</source>
          <target state="translated">기록 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 구조 &lt;xref:System.IO.TextWriter&gt;.&lt;/xref:System.IO.TextWriter&gt; 지정된는 XML 스키마로</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.IO.TextWriter&gt; object to write to.</source>
          <target state="translated">A &lt;xref:System.IO.TextWriter&gt;쓸 개체입니다.&lt;/xref:System.IO.TextWriter&gt;</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>A delegate used to convert &lt;xref:System.Type&gt; to string.</source>
          <target state="translated">변환 하는 데 사용 되는 대리자 &lt;xref:System.Type&gt;문자열로.&lt;/xref:System.Type&gt;</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>Writes the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> structure as an XML schema to a file.</source>
          <target state="translated">기록는 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 파일에 XML 스키마로는 구조입니다.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>The name of the file to write to.</source>
          <target state="translated">쓸 파일의 이름입니다.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>A delegate used to convert &lt;xref:System.Type&gt; to string.</source>
          <target state="translated">변환 하는 데 사용 되는 대리자 &lt;xref:System.Type&gt;문자열로.&lt;/xref:System.Type&gt;</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>Writes the <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> structure as an XML schema to the specified &lt;xref:System.Xml.XmlWriter&gt;.</source>
          <target state="translated">기록 된 <bpt id="p1">&lt;xref href="System.Data.DataSet"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> 구조 &lt;xref:System.Xml.XmlWriter&gt;.&lt;/xref:System.Xml.XmlWriter&gt; 지정된는 XML 스키마로</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Xml.XmlWriter&gt; object to write to.</source>
          <target state="translated">A &lt;xref:System.Xml.XmlWriter&gt;쓸 개체입니다.&lt;/xref:System.Xml.XmlWriter&gt;</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>A delegate used to convert &lt;xref:System.Type&gt; to string.</source>
          <target state="translated">변환 하는 데 사용 되는 대리자 &lt;xref:System.Type&gt;문자열로.&lt;/xref:System.Type&gt;</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>