<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e5df80f20fb8f8e9d58d7fd51e841a9b301b1bb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.Thread.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">836a4a28ca4635685ece20dbbe7b56da6a73e287</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d53c4cef63a323cfe675bb4658023858adff4b10</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">Создает и контролирует поток, задает приоритет и возвращает статус.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">При запуске процесса, общеязыковая среда выполнения автоматически создает один основной поток для выполнения кода приложения.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">Вместе с этой главной основного потока процесса можно создать один или несколько потоков для выполнения частей программного кода, связанные с процессом.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">Эти потоки могут выполнять на переднем плане или в фоновом режиме.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, you can use the &lt;xref:System.Threading.ThreadPool&gt; class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">Кроме того, можно использовать &lt;xref:System.Threading.ThreadPool&gt;класса для выполнения кода на рабочих потоков, которые управляются среда.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section       <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept>     <bpt id="p2">[</bpt>Retrieving Thread objects<ept id="p2">](#Retrieving)</ept>     <bpt id="p3">[</bpt>Foreground and background threads<ept id="p3">](#Foreground)</ept>     <bpt id="p4">[</bpt>Culture and threads<ept id="p4">](#Culture)</ept>     <bpt id="p5">[</bpt>Getting information about and controlling threads<ept id="p5">](#Properties)</ept>     <bpt id="p6">[</bpt>Accessing the source code for the Thread class<ept id="p6">](#Source)</ept>      <bpt id="p7">&lt;a name="Starting"&gt;</bpt><ept id="p7">&lt;/a&gt;</ept>    ## Starting a thread    You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">В этом разделе <bpt id="p1">[</bpt>запуска потока<ept id="p1">](#Starting)</ept><bpt id="p2">[</bpt>объектов Получение потока<ept id="p2">](#Retrieving)</ept><bpt id="p3">[</bpt>потоки переднего плана и фона<ept id="p3">](#Foreground)</ept><bpt id="p4">[</bpt>языка и региональных параметров и потоки<ept id="p4">](#Culture)</ept><bpt id="p5">[</bpt>получение сведений об и управление потоками<ept id="p5">](#Properties)</ept><bpt id="p6">[</bpt>доступа к коду источника потока<ept id="p6">](#Source)</ept> <bpt id="p7">&lt;a name="Starting"&gt;</bpt> <ept id="p7">&lt;/a&gt;</ept> ## запуск потока запуска потока, указав делегат, который представляет метод, поток будет выполнена в конструкторе класса.                               </target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>You then call the &lt;xref:System.Threading.Thread.Start%2A&gt; method to begin execution.</source>
          <target state="translated">Затем вызовите &lt;xref:System.Threading.Thread.Start%2A&gt;метод, чтобы начать выполнение.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Thread constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:      -   If the method has no arguments, you pass a &lt;xref:System.Threading.ThreadStart&gt; delegate to  the constructor.</source>
          <target state="translated">Конструкторы потоков можно использовать один из типов два делегата, в зависимости от того, можно ли передать аргумент метода для выполнения:-Если метод не имеет аргументов, то можно передать &lt;xref:System.Threading.ThreadStart&gt;делегат в конструктор.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph>           The following example creates and starts a thread that executes the <ph id="ph3">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">Он имеет сигнатуру: <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph> следующий пример создает и запускает поток, который выполняет <ph id="ph3">`ExecuteInForeground`</ph> метод.          </target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">Метод отображает сведения о некоторых свойств потока, а затем выполняет цикл, в котором он приостанавливает полсекунды и отображает затраченное время в секундах.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">При выполнении потока по крайней мере пять секунд, цикл завершается и поток завершает выполнение.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept><ept id="p3">]</ept>      -   If the method has an argument, you pass a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate to the constructor.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept> <ept id="p3">]</ept> -Если метод имеет аргумент, передайте &lt;xref:System.Threading.ParameterizedThreadStart&gt;делегат в конструктор.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;      </target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph>           The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">Он имеет сигнатуру: <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph> метод, выполняемый по делегату можно затем приведите (в C#) или преобразуйте (в Visual Basic) параметр к соответствующему типу.          </target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example is identical to the previous one, except that it calls the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor.</source>
          <target state="translated">Следующий пример идентичен предыдущему, за исключением того, он вызывает &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;конструктор.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">Эта версия <ph id="ph1">`ExecuteInForeground`</ph> метод принимает один параметр, который представляет приблизительное число миллисекунд, является выполнение цикла.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept><ept id="p3">]</ept>       It is not necessary to retain a reference to a Thread object once you have started the thread.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept> <ept id="p3">]</ept> нет необходимости сохранять ссылку на объект потока, после запуска потока.      </target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">Поток продолжает выполняться, пока не выполнена процедура потока.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Retrieving Thread objects    You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## Получение потока объектов, которые можно использовать статический (<ph id="ph1">`Shared`</ph> в Visual Basic) &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;свойство, чтобы получить ссылку на текущий выполняемый поток из кода, который выполняется поток.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">В следующем примере используется &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;свойство для отображения сведений о основного потока приложения, другой поток переднего плана, в фоновом потоке и поток из пула потоков.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Foreground"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Foreground and background threads    Instances of the Thread class represent either foreground threads or background threads.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Foreground"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> ## переднего плана и фона потоков экземпляры класса потока представляют основные потоки или фоновые потоки.        </target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">Фоновые потоки идентичны основные потоки с одним исключением: в фоновом потоке не сохраняется процесс, выполняемый, если все основные потоки завершились.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">После были остановлены все основные потоки, среда выполнения останавливает все фоновые потоки и завершает работу.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground:      -   The main application thread.</source>
          <target state="translated">По умолчанию, перечисленных ниже потоков выполняются на переднем плане:-основного потока приложения.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a Thread class constructor.</source>
          <target state="translated">-Все потоки, созданные путем вызова конструктора класса потока.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following threads execute in the background by default:      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">По умолчанию в фоновом режиме выполняются следующие потоков:-потоков из пула потоков, которые являются пула рабочих потоков, которые поддерживаются средой выполнения.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">Работа потоков пула и расписание можно настроить в потоках из пула потоков с помощью &lt;xref:System.Threading.ThreadPool&gt;класса.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек автоматическое выполнение асинхронной операции на основе задачи в потоках из пула потоков.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Task-based asynchronous operations use the &lt;xref:System.Threading.Tasks.Task&gt; and &lt;xref:System.Threading.Tasks.Task%601&gt; classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Использование асинхронных операций на основе задач &lt;xref:System.Threading.Tasks.Task&gt;и &lt;xref:System.Threading.Tasks.Task%601&gt;классов для реализации <bpt id="p1">[</bpt>асинхронная модель на основе задач<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.&lt;/xref:System.Threading.Tasks.Task%601&gt; &lt;/xref:System.Threading.Tasks.Task&gt;</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-Все потоки, которые входят в управляемую среду выполнения из неуправляемого кода.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can change a thread to execute in the background by setting the &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property at any time.</source>
          <target state="translated">Вы можете изменить поток для выполнения в фоновом режиме, путем установки &lt;xref:System.Threading.Thread.IsBackground%2A&gt;в любой момент.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">Фоновые потоки полезны для любой операции, следует продолжить до тех пор, пока приложение выполняется, но не предотвращения завершения работы, таких как мониторинг изменений в файловой системе или входящие подключения к сокетам приложения.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">В следующем примере показано различие между потоками переднего плана и фона.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">Как и в первом примере, это <bpt id="p1">[</bpt>запуска потока<ept id="p1">](#Starting)</ept> статьи, за исключением того, он задает выполнение в фоновом режиме, перед его началом потока.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">Как показывает вывод, цикл прерывается до его выполнения в течение пяти секунд.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Culture"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Culture and threads    Each thread has a culture, represented by the &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt; property, and a UI culture, represented by the &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt; property.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Culture"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> ## языка и региональных параметров и потоки каждый поток имеет языка и региональных параметров, представленных &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;свойство и языка и региональных параметров пользовательского интерфейса, представленного &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;свойство.&lt;/xref:System.Threading.Thread.CurrentUICulture%2A&gt; &lt;/xref:System.Threading.Thread.CurrentCulture%2A&gt;        </target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">Текущий язык и региональные параметры поддерживает такие операции, зависящие от культуры как синтаксического анализа и форматирования, сравнение и сортировка строк и также определяет систему письма и календарь, используемый в потоке.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">Текущий язык и региональные параметры пользовательского интерфейса предоставляет язык и региональные параметры извлечения ресурсов в файлах ресурсов.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">При создании нового потока его язык и региональные параметры пользовательского интерфейса определяются текущей культурой и языком и региональными параметрами пользовательского интерфейса, а не язык и региональные параметры пользовательского интерфейса потока, из которого создается новый поток.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">Это означает, например, что если текущую культуру системы является английский (США) и текущий язык и региональные параметры потока основного приложения — французский (Франция) языка и региональных параметров, созданных вызывающими нового потока &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;конструктор из основного потока является английский (США) и французского (Франция).&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Дополнительные сведения см. в разделе «Язык и региональные параметры и потоки» из &lt;xref:System.Globalization.CultureInfo&gt;разделе, посвященном классу.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">Настроек <ph id="ph1">[!IMPORTANT]</ph> настроек это неверно потоков, выполняющих асинхронных операций для приложений, ориентированных на <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> и более поздних версиях, в данном случае, язык и региональные параметры пользовательского интерфейса является частью контекста асинхронных операций, поток, на котором выполняет асинхронную операцию по умолчанию наследует язык и региональные параметры пользовательского интерфейса потока, из которого была запущена асинхронной операции.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Дополнительные сведения см в разделе «Язык и региональные параметры и асинхронные операции на основе задач» &lt;xref:System.Globalization.CultureInfo&gt;разделе, посвященном классу.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:      -   You can pass a &lt;xref:System.Globalization.CultureInfo&gt; object that represents that culture to the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate or the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; method.</source>
          <target state="translated">Можно выполнить одно из следующих действий, чтобы гарантировать, что все потоки выполнение в приложении совместного использования одного языка и региональных:-можно передать &lt;xref:System.Globalization.CultureInfo&gt;объект, представляющий этот язык для &lt;xref:System.Threading.ParameterizedThreadStart&gt;делегата или &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt;метод.&lt;/xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; &lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt; and &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; properties.</source>
          <target state="translated">— Для приложений, выполняющихся <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> и более поздних версиях можно определить язык и региональные параметры пользовательского интерфейса, необходимо назначить для всех потоков, созданных в домене приложения, задав значение &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;и &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;Свойства.&lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; &lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">Обратите внимание, что это параметр на уровне домена приложения.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information and examples, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Дополнительные сведения и примеры см. раздел «Язык и региональные параметры и потоки» &lt;xref:System.Globalization.CultureInfo&gt;разделе, посвященном классу.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Getting information about and controlling threads    You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## Получение сведений о и управление потоками могут получать число значений свойств, которые предоставляют сведения о потоке.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">В некоторых случаях можно также задать значения этих свойств для управления ее работой потока.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>These thread properties include:      -   A name.</source>
          <target state="translated">Эти свойства потока включают:-имя.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.Name%2A&gt; is a write-once property that you can use to identify a thread.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Name%2A&gt;выполняет запись — один раз свойство, которое можно использовать для идентификации потока.&lt;/xref:System.Threading.Thread.Name%2A&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Значением по умолчанию является <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A hash code, which you can retrieve by calling the &lt;xref:System.Threading.Thread.GetHashCode%2A&gt; method.</source>
          <target state="translated">-Хэш-код, который можно получить, вызвав &lt;xref:System.Threading.Thread.GetHashCode%2A&gt;метод.&lt;/xref:System.Threading.Thread.GetHashCode%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">Хэш-код можно использовать для уникальной идентификации поток; в течение времени существования вашего потока ее хэш-код не будет конфликтовать со значением из любого другого потока независимо от домена приложения, из которого получается значение.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A thread ID.</source>
          <target state="translated">Идентификатор потока.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the read-only &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">Значение только для чтения &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;свойство назначается средой выполнения и однозначно определяет поток внутри своего процесса.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек операционной системы <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> не имеет фиксированного отношения с управляемым потоком, так как неуправляемый узел может управлять отношением между управляемым и неуправляемым потоками.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">В частности, более сложный узел может использовать <bpt id="p1">[</bpt>API размещения среды CLR<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> спланировать нескольких управляемых потоков для одного потока операционной системы или перемещать управляемый поток между различными потоками операционной системы.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The thread's current state.</source>
          <target state="translated">-Текущее состояние потока.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the &lt;xref:System.Threading.ThreadState&gt; property.</source>
          <target state="translated">В течение своего существования поток всегда находится в один или несколько состояний, которые определены по &lt;xref:System.Threading.ThreadState&gt;свойство.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A scheduling priority level, which is defined by the &lt;xref:System.Threading.ThreadPriority&gt; property.</source>
          <target state="translated">-Планирование уровня приоритета, который определяется с &lt;xref:System.Threading.ThreadPriority&gt;свойство.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">Несмотря на то, что это значение для запроса приоритет потока, не гарантируется соблюдаться операционной системой.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The read-only &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt; property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">— Только для чтения &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;свойство, которое указывает, является ли поток в поток из пула потоков.&lt;/xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property.</source>
          <target state="translated">- &lt;xref:System.Threading.Thread.IsBackground%2A&gt;Свойство.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>потоки переднего плана и фона<ept id="p1">](#Foreground)</ept> раздела.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Accessing the source code for the Thread class    To view the .NET Framework source code for the Thread class, see the <bpt id="p2">[</bpt>Reference Source<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## Доступ к исходный код для класса потока для просмотра исходного кода .NET Framework для класса потока, в разделе <bpt id="p2">[</bpt>ссылки на источник<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
          <target state="translated">Выполнять поиск исходного кода в Интернете, справочник для автономной работы и пошагово источники (включая исправления и обновления) во время отладки; в разделе <bpt id="p1">[</bpt>инструкции<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">Инициализирует новый экземпляр <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> класса, указывается делегат, позволяющий объекту быть переданным в поток при запуске потока.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Поток не запускается при его создании.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">Чтобы запланировать для выполнения потока, вызовите &lt;xref:System.Threading.Thread.Start%2A&gt;метод.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>To pass a data object to the thread, use the &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt; method overload.</source>
          <target state="translated">Чтобы передать объект данных в поток, используйте &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;перегрузку.&lt;/xref:System.Threading.Thread.Start%28System.Object%29&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек пользователей Visual Basic можно опустить &lt;xref:System.Threading.ThreadStart&gt;конструктор при создании потока.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">`AddressOf`</ph> оператор при передаче в метод, например <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic автоматически вызывает &lt;xref:System.Threading.ThreadStart&gt;конструктор.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Делегат, который представляет методы, которые вызываются при запуске потока.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">Инициализирует новый экземпляр <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> класса.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Поток не запускается при его создании.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">Чтобы запланировать для выполнения потока, вызовите &lt;xref:System.Threading.Thread.Start%2A&gt;метод.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек пользователей Visual Basic можно опустить &lt;xref:System.Threading.ThreadStart&gt;конструктор при создании потока.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">`AddressOf`</ph> оператор при передаче методе, например <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic автоматически вызывает &lt;xref:System.Threading.ThreadStart&gt;конструктор.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Объект <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> делегат, который представляет методы, которые вызываются при запуске потока.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">Инициализирует новый экземпляр <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> класс указывается делегат, позволяющий объекту быть переданным в поток при запуске потока с указанием максимального размера стека для потока.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Старайтесь не использовать эту перегрузку конструктора.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">Размер стека по умолчанию, используемые &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;перегрузку конструктора — это размер стека, рекомендуемые для потоков.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Если поток имеет проблем с памятью, наиболее вероятной причиной является программирования ошибка, например бесконечной рекурсии.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">Настроек <ph id="ph1">[!IMPORTANT]</ph> настроек начиная с версии <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, только полностью доверенный код может установить <ph id="ph3">`maxStackSize`</ph> значение которого больше, чем размер стека по умолчанию (1 МБ).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Если указано большее значение для <ph id="ph1">`maxStackSize`</ph> при выполнении кода с частичным доверием <ph id="ph2">`maxStackSize`</ph> игнорируется и используется размер стека по умолчанию.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">Исключение не возникает.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Код на любом уровне доверия, может установить <ph id="ph1">`maxStackSize`</ph> значение которого меньше, чем размер стека по умолчанию.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек при разработке полностью доверенной библиотеки, который будет использоваться частично доверенным кодом и необходимо запустить поток, который требует большого стека, должно подтвердить полное доверие перед созданием потока или размер стека по умолчанию будет использоваться.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Не делайте этого, если вы полностью управления кодом, который выполняется в потоке.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Если <ph id="ph1">`maxStackSize`</ph> меньше, чем минимальный размер стека, используется минимальный размер стека.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Если <ph id="ph1">`maxStackSize`</ph> не кратному размеру страницы, оно округляется до следующего большего кратной размеру страницы.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Например при использовании .NET Framework версии 2.0 в Windows Vista 256 КБ (262 144 байт) является минимальным размером стека, а размер страницы равен 64 КБ (65 536 байт).</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в версиях Microsoft Windows до Windows XP и Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> игнорируется, и используется размер стека, указанный в заголовке исполняемого.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">При указании очень малого размера стека, может потребоваться отключить проверки на переполнение стека.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Если стек строго ограничивается, проверка сама может вызвать переполнение стека.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Чтобы отключить проверку переполнения стека, добавьте следующий файл конфигурации приложения.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Объект <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> делегат, который представляет методы, которые вызываются при запуске потока.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Максимальный размер стека в байтах, используемый потоком, или же 0 для использования максимального размера по умолчанию, указанное в заголовке исполняемого файла.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Внимание для частично доверенного кода <ph id="ph1">`maxStackSize`</ph> учитывается, если оно превышает размер стека по умолчанию.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">Исключение не возникает.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>меньше нуля.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">Инициализирует новый экземпляр <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> указанием максимального размера стека для потока.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Старайтесь не использовать эту перегрузку конструктора.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">Размер стека по умолчанию, используемые &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;перегрузку конструктора — это размер стека, рекомендуемые для потоков.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Если поток имеет проблем с памятью, наиболее вероятной причиной является программирования ошибка, например бесконечной рекурсии.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">Настроек <ph id="ph1">[!IMPORTANT]</ph> настроек начиная с версии <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, только полностью доверенный код может установить <ph id="ph3">`maxStackSize`</ph> значение которого больше, чем размер стека по умолчанию (1 МБ).</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Если указано большее значение для <ph id="ph1">`maxStackSize`</ph> при выполнении кода с частичным доверием <ph id="ph2">`maxStackSize`</ph> игнорируется и используется размер стека по умолчанию.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">Исключение не возникает.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Код на любом уровне доверия, может установить <ph id="ph1">`maxStackSize`</ph> значение которого меньше, чем размер стека по умолчанию.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек при разработке полностью доверенной библиотеки, который будет использоваться частично доверенным кодом и необходимо запустить поток, который требует большого стека, должно подтвердить полное доверие перед созданием потока или размер стека по умолчанию будет использоваться.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Не делайте этого, если вы полностью управления кодом, который выполняется в потоке.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Если <ph id="ph1">`maxStackSize`</ph> меньше, чем минимальный размер стека, используется минимальный размер стека.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Если <ph id="ph1">`maxStackSize`</ph> не кратному размеру страницы, оно округляется до следующего большего кратной размеру страницы.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Например при использовании .NET Framework версии 2.0 в Windows Vista 256 КБ (262 144 байт) является минимальным размером стека, а размер страницы равен 64 КБ (65 536 байт).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в версиях Microsoft Windows до Windows XP и Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> игнорируется, и используется размер стека, указанный в заголовке исполняемого.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">При указании очень малого размера стека, может потребоваться отключить проверки на переполнение стека.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Если стек строго ограничивается, проверка сама может вызвать переполнение стека.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Чтобы отключить проверку переполнения стека, добавьте следующий файл конфигурации приложения.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Объект <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> делегат, который представляет методы, которые вызываются при запуске потока.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Максимальный размер стека в байтах, используемый потоком, или же 0 для использования максимального размера по умолчанию, указанное в заголовке исполняемого файла.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Внимание для частично доверенного кода <ph id="ph1">`maxStackSize`</ph> учитывается, если оно превышает размер стека по умолчанию.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">Исключение не возникает.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>меньше нуля.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Вызывает <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> в потоке, в которой он вызывается, чтобы начать процесс завершения потока.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Вызов данного метода обычно завершает поток.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">Если этот метод вызывается в потоке, система создает объект &lt;xref:System.Threading.ThreadAbortException&gt;в поток, который необходимо прервать его.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>— специальное исключение, которое может перехватываться кодом приложения, но вызывается повторно в конце <ph id="ph2">`catch`</ph> блокируется пока &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;называется.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Отменяет запрос на аварийное завершение и предотвращает <ph id="ph2">`ThreadAbortException`</ph> от завершения потока.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Невыполненные <ph id="ph1">`finally`</ph> блоки выполняются перед поток прерван.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек Если поток вызывает <ph id="ph2">`Abort`</ph> для себя, действует аналогично исключение; &lt;xref:System.Threading.ThreadAbortException&gt;произойдет немедленно, и результат является предсказуемым.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Тем не менее если один поток вызывает <ph id="ph1">`Abort`</ph> в другом потоке, аварийное завершение прерывает любой выполняющийся код.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">Имеется также вероятно аварийное завершение статического конструктора.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">В редких случаях это может препятствовать экземпляры этого класса в данном домене приложения.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">В .NET Framework версий 1.0 и 1.1, есть вероятность, поток может прервать пока <ph id="ph1">`finally`</ph> блок выполняется, в этом случае <ph id="ph2">`finally`</ph> блок прерывается.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">Не гарантируется, что поток прервется немедленно или вообще.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Такая ситуация может возникнуть, если поток выполняет неограниченное количество вычислений в <ph id="ph1">`finally`</ph> блоки, которые вызываются как часть процедуры прерывания, откладывая аварийное завершение тем самым неопределенное время.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee the wait will end.</source>
          <target state="translated">Подождать, пока поток был прерван, можно вызвать &lt;xref:System.Threading.Thread.Join%2A&gt;метод в потоке после вызова метода Abort, но нет никакой гарантии, Ожидание завершится.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls Abort might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек поток, который вызывает прерывание может блокироваться, если поток, который прерывается находится в защищенной области кода, такие как <ph id="ph2">`catch`</ph> блока <ph id="ph3">`finally`</ph> блока или области ограниченного выполнения.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls Abort holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Если поток, который вызывает прерывание удерживает блокировку, требуемую прерванным потоком, может произойти взаимоблокировка.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">Если <ph id="ph1">`Abort`</ph> вызывается в потоке, который не был запущен, поток будет прервана, когда &lt;xref:System.Threading.Thread.Start%2A&gt;называется.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Если <ph id="ph1">`Abort`</ph> вызывается в потоке, который заблокирован или находится в спящем режиме, поток прерывается и затем прервана.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">Если <ph id="ph1">`Abort`</ph> вызывается в потоке, который был приостановлен, &lt;xref:System.Threading.ThreadStateException&gt;исключение в потоке, который вызвал &lt;xref:System.Threading.Thread.Abort%2A&gt;, и &lt;xref:System.Threading.ThreadState&gt;добавляется &lt;xref:System.Threading.Thread.ThreadState%2A&gt;свойство аварийно завершающимся потоком.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">Объект &lt;xref:System.Threading.ThreadAbortException&gt;не вызывается в приостановленном потоке до &lt;xref:System.Threading.Thread.Resume%2A&gt;называется.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Если <ph id="ph1">`Abort`</ph> вызывается в управляемом потоке при выполнении неуправляемого кода <ph id="ph2">`ThreadAbortException`</ph> не выдается до возвращения потока в управляемом коде.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Если два вызова к <ph id="ph1">`Abort`</ph> поступать одновременно, возможно, что один вызов для установки сведений о состоянии и вызов на выполнение <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Однако приложение не может определить ситуацию.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">После <ph id="ph1">`Abort`</ph> вызывается в потоке, состояние потока включает &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">После завершения потока в результате успешного вызова <ph id="ph1">`Abort`</ph>, состояние потока будет изменен на &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">С достаточными разрешениями поток, который является целевым объектом <ph id="ph1">`Abort`</ph> можно отменить аварийное завершение, используя <ph id="ph2">`ResetAbort`</ph> метод.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Пример, демонстрирующий вызов <ph id="ph1">`ResetAbort`</ph> метода, в разделе <ph id="ph2">`ThreadAbortException`</ph> класса.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Вызывающий объект не имеет необходимых разрешений.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">В настоящее время приостанавливается поток, который прерывается.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">Вызывает <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> в потоке, в которой он вызывается, чтобы начать процесс завершения потока, в то же время предоставляя информацию о завершение потока исключения.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Вызов данного метода обычно завершает поток.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">Если этот метод вызывается в потоке, система создает объект &lt;xref:System.Threading.ThreadAbortException&gt;в поток, который необходимо прервать его.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>— специальное исключение, которое может перехватываться кодом приложения, но вызывается повторно в конце <ph id="ph2">`catch`</ph> блокируется пока &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;называется.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Отменяет запрос на аварийное завершение и предотвращает <ph id="ph2">`ThreadAbortException`</ph> от завершения потока.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Невыполненные <ph id="ph1">`finally`</ph> блоки выполняются перед поток прерван.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек Если поток вызывает <ph id="ph2">`Abort`</ph> для себя, действует аналогично исключение; &lt;xref:System.Threading.ThreadAbortException&gt;произойдет немедленно, и результат является предсказуемым.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Тем не менее если один поток вызывает <ph id="ph1">`Abort`</ph> в другом потоке, аварийное завершение прерывает любой выполняющийся код.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">Есть вероятность, что статический конструктор может прервана.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">В редких случаях это может препятствовать экземпляры этого класса в данном домене приложения.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">В .NET Framework версий 1.0 и 1.1, есть вероятность, поток может прервать пока <ph id="ph1">`finally`</ph> блок выполняется, в этом случае <ph id="ph2">`finally`</ph> блок прерывается.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">Не гарантируется, что поток прервется немедленно или вообще.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Такая ситуация может возникнуть, если поток выполняет неограниченное количество вычислений в <ph id="ph1">`finally`</ph> блоки, которые вызываются как часть процедуры прерывания, откладывая аварийное завершение тем самым неопределенное время.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee that the wait will end.</source>
          <target state="translated">Подождать, пока поток был прерван, можно вызвать &lt;xref:System.Threading.Thread.Join%2A&gt;метод в потоке после вызова метода Abort, но нет никакой гарантии, что время ожидания истекает.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек поток, который вызывает &lt;xref:System.Threading.Thread.Abort%2A&gt;может блокироваться, если поток, который прерывается находится в защищенной области кода, такие как <ph id="ph2">`catch`</ph> блока <ph id="ph3">`finally`</ph> блока или области ограниченного выполнения.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Если поток, вызывающий &lt;xref:System.Threading.Thread.Abort%2A&gt;удерживает блокировку, требуемую прерванным потоком, может произойти взаимоблокировка.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">Если <ph id="ph1">`Abort`</ph> вызывается в потоке, который не был запущен, поток будет прервана, когда &lt;xref:System.Threading.Thread.Start%2A&gt;называется.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Если <ph id="ph1">`Abort`</ph> вызывается в потоке, который заблокирован или находится в спящем режиме, поток прерывается и затем прервана.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">Если <ph id="ph1">`Abort`</ph> вызывается в потоке, который был приостановлен, &lt;xref:System.Threading.ThreadStateException&gt;исключение в потоке, который вызвал &lt;xref:System.Threading.Thread.Abort%2A&gt;, и &lt;xref:System.Threading.ThreadState&gt;добавляется &lt;xref:System.Threading.Thread.ThreadState%2A&gt;свойство аварийно завершающимся потоком.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">Объект &lt;xref:System.Threading.ThreadAbortException&gt;не вызывается в приостановленном потоке до &lt;xref:System.Threading.Thread.Resume%2A&gt;называется.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Если <ph id="ph1">`Abort`</ph> вызывается в управляемом потоке при выполнении неуправляемого кода <ph id="ph2">`ThreadAbortException`</ph> не выдается до возвращения потока в управляемом коде.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Если два вызова к <ph id="ph1">`Abort`</ph> поступать одновременно, возможно, что один вызов для установки сведений о состоянии и вызов на выполнение <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Однако приложение не может определить ситуацию.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">После <ph id="ph1">`Abort`</ph> вызывается в потоке, состояние потока включает &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">После завершения потока в результате успешного вызова <ph id="ph1">`Abort`</ph>, состояние потока будет изменен на &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">С достаточными разрешениями поток, который является целевым объектом <ph id="ph1">`Abort`</ph> можно отменить аварийное завершение, используя <ph id="ph2">`ResetAbort`</ph> метод.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Пример, демонстрирующий вызов <ph id="ph1">`ResetAbort`</ph> метода, в разделе <ph id="ph2">`ThreadAbortException`</ph> класса.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">Объект, содержащий сведения о приложении, например состояние, которое может использоваться аварийно завершающимся потоком.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Вызывающий объект не имеет необходимых разрешений.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">В настоящее время приостанавливается поток, который прерывается.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">Выделяет неименованную область данных всем потокам.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Для повышения производительности используйте поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибутом.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибут) и области данных.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании TLS см. в разделе <bpt id="p1">[</bpt>локальное хранилище потока: статические поля потока и области данных<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">Область данных выделяется во всех потоках.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Потоки используют механизм локального хранилища памяти для хранения данных определенного потока.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Области данных являются уникальными для каждого потока.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ни один поток (даже дочерний поток) можно получить эти данные.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Выделенная Именованная область данных всем потокам.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">Выделяет именованную область данных всем потокам.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Для повышения производительности используйте поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибутом.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибут) и области данных.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании TLS см. в разделе <bpt id="p1">[</bpt>локальное хранилище потока: статические поля потока и области данных<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Потоки используют механизм локального хранилища памяти для хранения данных определенного потока.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Области данных являются уникальными для каждого потока.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ни один поток (даже дочерний поток) можно получить эти данные.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not necessary to use the AllocateNamedDataSlot method to allocate a named data slot, because the &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; method allocates the slot if it has not already been allocated.</source>
          <target state="translated">Нет необходимости использовать метод AllocateNamedDataSlot для выделения именованную область данных, так как &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;метод выделяет область, если он уже не была выделена.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек при использовании AllocateNamedDataSlot метод должен вызываться в основном потоке при запуске программы, так как он вызывает исключение, если область с указанным именем уже был выделен.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">Нет возможности проверить ли уже выделена слот.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Slots allocated with this method must be freed with &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.</source>
          <target state="translated">Слоты, выделенных с помощью этого метода должны быть освобождены вызовом &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.&lt;/xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">Имя выделяемой области данных.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Выделенная Именованная область данных всем потокам.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">Именованную область данных с указанным именем уже существует.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">Возвращает или задает состояние апартамента для данного потока.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>The ApartmentState property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Свойство ApartmentState устарело.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>The non-obsolete alternatives are the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method to retrieve the apartment state and the   &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method to set the apartment state.</source>
          <target state="translated">Альтернативы устаревшему &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;метод для извлечения состояние апартамента и &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;метод, чтобы задать состояние апартамента.&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">В .NET Framework версий 1.0 и 1.1 <ph id="ph1">`ApartmentState`</ph> свойство отмечает поток, чтобы показать, что он будет выполняться в однопотоковый или многопотокового подразделения.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">Это свойство можно задать, если поток находится в <ph id="ph1">`Unstarted`</ph> или <ph id="ph2">`Running`</ph> состоянии; тем не менее, оно может быть задано только один раз для потока.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">Если свойство не было задано, возвращается <ph id="ph1">`Unknown`</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to use the ApartmentState property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">Попытка присвоить состояние подразделения потока состояние подразделения которого уже задано свойство ApartmentState игнорируется.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method throws a &lt;xref:System.InvalidOperationException&gt; in this case.</source>
          <target state="translated">Однако &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;вызывает исключение &lt;xref:System.InvalidOperationException&gt;в этом случае.&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  In the .NET Framework version 2.0, new threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">Настроек <ph id="ph1">[!IMPORTANT]</ph> настроек в .NET Framework версии 2.0, новые потоки инициализируются как &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;Если их состояние подразделения не задано до их запуска.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">Основной поток приложения инициализируется &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;по умолчанию.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can no longer set the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by setting the &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; property on the first line of code.</source>
          <target state="translated">Основной поток приложения могут больше не устанавливаются в &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;, установив &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;свойство в первой строке кода.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.STAThreadAttribute&gt; instead.</source>
          <target state="translated">Используйте &lt;xref:System.STAThreadAttribute&gt;вместо.&lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> linker option.</source>
          <target state="translated">В .NET Framework версии 2.0, можно указать потоковой моделью COM для приложения C++ с помощью <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (установить атрибут потока среды CLR)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> компоновщика.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">Один из <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> значения.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Начальное значение — <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) or multithreaded apartment (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</source>
          <target state="translated">Предпринята попытка задать это свойство в состояние, не является допустимым состоянием подразделения (состояние, отличное от однопотокового подразделения (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) или многопотокового подразделения (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">Уведомляет хост, что выполнение близится ко входу в область кода, в которой эффекты прерывания выполнения или неуправляемого выполнения могут повлиять на другие задачи в домене приложения.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Узлы среды выполнения (CLR), например Microsoft SQL Server 2005, могут устанавливать различные политики для сбоев в критические и некритические областей кода.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Критической области — один, в которой эффекты прерывания выполнения или необработанное исключение не могут быть ограничены текущей задачей.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Напротив прерывание или сбой в некритической области кода влияет только задачи, в котором произошла ошибка.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Например рассмотрим задачу, которая пытается выделить память при блокировке.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Если происходит сбой выделения памяти, прерывания текущей задачи недостаточно для обеспечения стабильности &lt;xref:System.AppDomain&gt;, так как может существовать другие задачи в домене, ожидающих блокировки.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">При прерывании выполнения текущей задачи, другие задачи могут взаимно блокироваться.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">При возникновении сбоя в критической области, узел может потребоваться выгрузить весь &lt;xref:System.AppDomain&gt;, а не рисковать и продолжения выполнения потенциально нестабильно.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call BeginCriticalRegion.</source>
          <target state="translated">Для информирования основного, код переходит в критической области, вызовите BeginCriticalRegion.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt; when execution returns to a non-critical region of code.</source>
          <target state="translated">Вызовите &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;Когда выполнение возвращается некритической области кода.&lt;/xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для выполнения на высоком уровне защиты узла.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Уведомляет хост, что управляемый код близок к выполнению инструкций, зависящих от идентификации текущего потока операционной системы.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Некоторые узлы CLR, например Microsoft SQL Server 2005, обеспечивают самостоятельное управление потоками.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Узел, который предоставляет собственный поток управления можно переместить выполняющуюся задачу из одного потока операционной системы в другую в любое время.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">Большинство задач с помощью этого переключения не затрагиваются.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Тем не менее некоторые задачи поддерживают сходство потоков: то есть они зависят от идентификатора потока операционной системы.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Эти задачи необходимо проинформировать узел выполняемого кода, не будут перенаправлены.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call BeginThreadAffinity before acquiring the lock, and &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt; after releasing the lock.</source>
          <target state="translated">Например, если приложение вызывает API-Интерфейсу блокировки операционной системы, который реализует сходство потоков, например Win32 CRITICAL_SECTION, системы перед необходимо вызвать BeginThreadAffinity запроса на блокировку и &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;после освобождения блокировки.&lt;/xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для выполнения на высоком уровне защиты узла.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Вызывающий объект не имеет необходимых разрешений.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">Возвращает текущий контекст, в котором выполняется поток.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current thread context.</source>
          <target state="translated">Объект <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> представляет текущий контекст потока.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Вызывающий объект не имеет необходимых разрешений.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">Возвращает или задает язык и региональные параметры текущего потока.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Globalization.CultureInfo&gt; object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">&lt;xref:System.Globalization.CultureInfo&gt;Объект, возвращаемый этим свойством, а также связанных с ним объектов, определяют форматом по умолчанию для дат, времени, чисел, денежных значений, текст порядка сортировки, регистр соглашения и операции сравнения строк.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo&gt; class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">В разделе &lt;xref:System.Globalization.CultureInfo&gt;класса для изучения языка и региональных параметров имена и идентификаторы, различия между инвариантным, нейтральные и конкретные языки и региональные параметры, и сведения о культуре способом влияет потоков и доменов приложений.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt; property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">В разделе &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;свойство, чтобы узнать, как определяется язык и региональные параметры потока по умолчанию и как пользователи задать сведения о культуре для их компьютеров.&lt;/xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, you can set the CurrentCulture property to a neutral culture.</source>
          <target state="translated">Начиная с версии <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, можно задать свойство CurrentCulture для нейтрального языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the behavior of the &lt;xref:System.Globalization.CultureInfo&gt; class has changed: When it represents a neutral culture, its property values (in particular, the &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, and &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt; properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">Это, поскольку поведение &lt;xref:System.Globalization.CultureInfo&gt;класс был изменен: когда он представляет нейтральной культуре значения его свойств (в частности, &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, и &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;Свойства) теперь отражают заданных региональных параметров, который связан с нейтральным языком и региональными параметрами.&lt;/xref:System.Globalization.CultureInfo.TextInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.NumberFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.CompareInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.Calendar%2A&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>In earlier versions of the .NET Framework, the CurrentCulture property threw a &lt;xref:System.NotSupportedException&gt; exception when a neutral culture was assigned.</source>
          <target state="translated">В более ранних версиях платформы .NET Framework вызвал свойство CurrentCulture &lt;xref:System.NotSupportedException&gt;исключения, когда был назначен нейтрального языка и региональных параметров.&lt;/xref:System.NotSupportedException&gt;</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">Объект, представляющий язык и региональные параметры текущего потока.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Свойство имеет значение <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">Возвращает или задает текущего участника потока (для безопасности на основе ролей).</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Security.Principal.IPrincipal&gt; value representing the security context.</source>
          <target state="translated">&lt;xref:System.Security.Principal.IPrincipal&gt;Значение, представляющее контекст безопасности.&lt;/xref:System.Security.Principal.IPrincipal&gt;</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">Вызывающий не имеет необходимых прав для задания участника.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Gets the currently running thread.</source>
          <target state="translated">Возвращает в данный момент поток.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is the representation of the currently running thread.</source>
          <target state="translated">Объект <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> , представляющий собой выполняющийся в данный момент поток.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">Возвращает или задает текущий язык и региональные параметры, используемые диспетчером ресурсов для поиска ресурсов, связанных с языком и региональными параметрами, во время выполнения.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>An object that represents the current culture.</source>
          <target state="translated">Объект, представляющий текущий язык и региональные параметры.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Свойство имеет значение <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">Свойству присвоено имя языка и региональных параметров, которое не может использоваться для нахождения файла ресурсов.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">Имена файлов ресурсов должны содержать только буквы, цифры, дефисы и знаки подчеркивания.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">Отключает автоматическую очистку вызываемых оболочек времени выполнения (RCW) для текущего потока.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">По умолчанию общеязыковой среды выполнения (CLR) производит очистку вызываемых оболочек времени выполнения автоматически.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:      -   The application does its own message pumping.</source>
          <target state="translated">Среда CLR передает сообщения во время очистки, что может привести к проблемам повторный вход для нескольких приложений, которые удовлетворяют следующим критериям необычные:-приложение выполняет собственную загрузку сообщения.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">-Приложению для управления точно при загрузке сообщения.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such applications can use the DisableComObjectEagerCleanup method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">Такие приложения могут использовать метод DisableComObjectEagerCleanup, чтобы предотвратить это автоматическое освобождение вызываемых оболочек времени выполнения среды CLR.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">При вызове этого метода в потоке автоматической очистки не может быть включена для этого потока.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application is ready to clean up runtime callable wrappers, use the &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt; method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">Когда приложение будет готово для очистки вызываемые оболочки времени выполнения, используйте &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;метод, чтобы заставить среду выполнения, чтобы очистить все вызываемые оболочки времени выполнения в текущем контексте.&lt;/xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">Выдачи сообщений происходит во время выполнения метода.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">Уведомляет хост, что выполнение близится ко входу в область кода, в которой эффекты прерывания выполнения или неуправляемой ограничены текущей задачей.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Узлы среды выполнения (CLR), например Microsoft SQL Server 2005, могут устанавливать различные политики для сбоев в критические и некритические областей кода.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Критической области — один, в которой эффекты прерывания выполнения или необработанное исключение не могут быть ограничены текущей задачей.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Напротив прерывание или сбой в некритической области кода влияет только задачи, в котором произошла ошибка.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Например рассмотрим задачу, которая пытается выделить память при блокировке.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Если происходит сбой выделения памяти, прерывания текущей задачи недостаточно для обеспечения стабильности &lt;xref:System.AppDomain&gt;, так как может существовать другие задачи в домене, ожидающих блокировки.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">При прерывании выполнения текущей задачи, другие задачи могут взаимно блокироваться.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">При возникновении сбоя в критической области, узел может потребоваться выгрузить весь &lt;xref:System.AppDomain&gt;, а не рисковать и продолжения выполнения потенциально нестабильно.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.</source>
          <target state="translated">Для информирования основного, код переходит в критической области, вызовите &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.&lt;/xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call EndCriticalRegion when execution returns to a non-critical region of code.</source>
          <target state="translated">Вызов EndCriticalRegion выполнение возвращается некритической области кода.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для выполнения на высоком уровне защиты узла.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Уведомляет хост, что управляемый код завершения выполнения инструкций, зависящих от идентификации текущего потока операционной системы.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Некоторые узлы CLR, например Microsoft SQL Server 2005, обеспечивают самостоятельное управление потоками.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Узел, который предоставляет собственный поток управления можно переместить выполняющуюся задачу из одного потока операционной системы в другую в любое время.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">Большинство задач с помощью этого переключения не затрагиваются.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Тем не менее некоторые задачи поддерживают сходство потоков: то есть они зависят от идентификатора потока операционной системы.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Эти задачи необходимо проинформировать узел выполняемого кода, не будут перенаправлены.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt; before acquiring the lock, and EndThreadAffinity after releasing the lock.</source>
          <target state="translated">Например, если приложение вызывает API системы для получения операционной системой блокировки, сходство потоков, например Win32 CRITICAL_SECTION, необходимо вызвать &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;перед установкой блокировки и EndThreadAffinity после освобождения блокировки.&lt;/xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для выполнения на высоком уровне защиты узла.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Вызывающий объект не имеет необходимых разрешений.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Gets an &lt;xref:System.Threading.ExecutionContext&gt; object that contains information about the various contexts of the current thread.</source>
          <target state="translated">Возвращает &lt;xref:System.Threading.ExecutionContext&gt;, содержащий сведения о различных контекстах текущего потока.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Threading.ExecutionContext&gt; class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">&lt;xref:System.Threading.ExecutionContext&gt;Класс предоставляет один контейнер для все сведения, относящиеся к логический поток выполнения.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">Это включает в себя контекст безопасности, контекст вызовов, контекст синхронизации, контекст локализации и контекст транзакции.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Threading.ExecutionContext&gt; object that consolidates context information for the current thread.</source>
          <target state="translated">&lt;xref:System.Threading.ExecutionContext&gt;, Содержащий консолидированную информацию о контекстах текущего потока.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">Гарантирует, что ресурсы освобождены и выполнены другие операции очистки, когда сборщик мусора восстанавливает <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> объекта.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector calls Finalize when the current object is ready to be finalized.</source>
          <target state="translated">Сборщик мусора вызывает метод Finalize, когда текущий объект готов к завершению.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">Удаляет связь между названием и областью для всех потоков в процессе.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Для повышения производительности используйте поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибутом.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибут) и области данных.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании TLS см. в разделе <bpt id="p1">[</bpt>локальное хранилище потока: статические поля потока и области данных<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">После какой-либо поток вызывает <ph id="ph1">`FreeNamedDataSlot`</ph>, поток, который вызывает &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;с тем же именем приведет к выделению новую ячейку, связанный с именем.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">Последующие вызовы <ph id="ph1">`GetNamedDataSlot`</ph> любым потоком будут возвращать новую область.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, any thread that still has a &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt; returned by an earlier call to <ph id="ph1">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">Тем не менее, любой поток, по-прежнему содержит &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;возвращенные предыдущими вызовами метода <ph id="ph1">`GetNamedDataSlot`</ph> можно продолжать использовать старый слота.&lt;/xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">Область, связанный с именем, будет освобождена только тогда, когда каждый <ph id="ph1">`LocalDataStoreSlot`</ph> , полученные до вызова метода <ph id="ph2">`FreeNamedDataSlot`</ph> были освобождены и сбора мусора.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Потоки используют механизм локального хранилища памяти для хранения данных определенного потока.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Области данных являются уникальными для каждого потока.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ни один поток (даже дочерний поток) можно получить эти данные.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">Имя освобождаемой области данных.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value indicating the apartment state.</source>
          <target state="translated">Возвращает <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> значение, показывающее состояние апартамента.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method, along with the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">Этот метод вместе с &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;метод и &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;заменяет метод, &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;свойство.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the apartment state of the managed thread.</source>
          <target state="translated">Один из <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> значения, указывающие состояние подразделения управляемого потока.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Значение по умолчанию — <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">Возвращает <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> объекта, который может использоваться для записи стека текущего потока.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">Этот метод больше не поддерживается.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">Отсутствует.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">Во всех случаях.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">Получает значение из заданной области текущего потока, внутри текущей области текущего потока.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Для повышения производительности используйте поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибутом.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибут) и области данных.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании TLS см. в разделе <bpt id="p1">[</bpt>локальное хранилище потока: статические поля потока и области данных<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Потоки используют механизм локального хранилища памяти для хранения данных определенного потока.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Области данных являются уникальными для каждого потока.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ни один поток (даже дочерний поток) можно получить эти данные.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  GetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек GetData — <ph id="ph2">`Shared`</ph> метод, который всегда применяется к потоку выполняться в данный момент, даже при вызове с помощью переменной, которая ссылается на другой поток.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">Чтобы избежать путаницы, используйте имя класса при вызове <ph id="ph1">`Shared`</ph> методы: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to get the value.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> Из которого необходимо получить значение.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The retrieved value.</source>
          <target state="translated">Извлекаемое значение.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">Возвращает текущую область, в которой выполняется текущий поток.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current application domain of the running thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> Представляющий собой текущий домен приложения выполняющегося потока.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">Возвращает уникальный идентификатор домена приложения.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">32-разрядное знаковое целое число, однозначно определяющее домен приложения.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">Возвращает хэш-код для текущего потока.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">Хэш-код не гарантированно уникален.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property if you need a unique identifier for a managed thread.</source>
          <target state="translated">Используйте &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;свойство, если требуется уникальный идентификатор управляемого потока.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>An integer hash code value.</source>
          <target state="translated">Целочисленное значение хэш-кода.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Looks up a named data slot.</source>
          <target state="translated">Ищет именованную область данных.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Для повышения производительности используйте поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибутом.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибут) и области данных.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании TLS см. в разделе <bpt id="p1">[</bpt>локальное хранилище потока: статические поля потока и области данных<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Потоки используют механизм локального хранилища памяти для хранения данных определенного потока.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Области данных являются уникальными для каждого потока.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ни один поток (даже дочерний поток) можно получить эти данные.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">Если Именованная область не существует, выделяется новая область.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">Именованные области данных являются открытыми и может использоваться кем.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The name of the local data slot.</source>
          <target state="translated">Имя локальной области данных.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> allocated for this thread.</source>
          <target state="translated">Объект <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> выделенный для данного потока.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Interrupts a thread that is in the <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> thread state.</source>
          <target state="translated">Прерывает работу потока, находящегося в <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> состоянии.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">Если этот поток не заблокирован в настоящее время ожидания, спящего режима или состояние соединения, он будет прервана, когда он начнет блокироваться.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ThreadInterruptedException&gt; is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadInterruptedException&gt;возникает в прерванного потока, но только поток блокируется.&lt;/xref:System.Threading.ThreadInterruptedException&gt;</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">Если поток никогда не блокируется, исключение никогда не создается, и таким образом, поток может завершить не будучи прерванным.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Вызывающий объект не имеет соответствующего <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">Возвращает значение, показывающее статус выполнения текущего потока.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread has been started and has not terminated normally or aborted; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Если этот поток был запущен и не был завершен обычным образом или прерван; в противном случае <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">Возвращает или задает значение, указывающее, является ли поток фоновым потоком.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">Поток находится в фоновом потоке или основной поток.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">Фоновые потоки идентичны основные потоки, за исключением того, что фоновые потоки не предотвращают завершение процесса.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">Когда все основные потоки, принадлежащие процессу, завершились, общеязыковая среда выполнения завершает процесс.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">Все оставшиеся фоновые потоки останавливаются и не завершаются.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground (that is, their IsBackground property returns <ph id="ph1">`false`</ph>):      -   The primary thread (or main application thread).</source>
          <target state="translated">По умолчанию, перечисленных ниже потоков выполняются на переднем плане (то есть их IsBackground возвращает <ph id="ph1">`false`</ph>):-основного потока (или основного потока приложения).</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a &lt;xref:System.Threading.Thread&gt; class constructor.</source>
          <target state="translated">-Все потоки, созданные путем вызова &lt;xref:System.Threading.Thread&gt;конструктора класса.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the background  (that is, their IsBackground property returns <ph id="ph1">`true`</ph>):      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">По умолчанию, перечисленных ниже потоков выполняются в фоновом режиме (то есть их IsBackground возвращает <ph id="ph1">`true`</ph>):-потоков из пула потоков, которые являются пула рабочих потоков, которые поддерживаются средой выполнения.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">Работа потоков пула и расписание можно настроить в потоках из пула потоков с помощью &lt;xref:System.Threading.ThreadPool&gt;класса.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек автоматическое выполнение асинхронной операции на основе задачи в потоках из пула потоков.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-Все потоки, которые входят в управляемую среду выполнения из неуправляемого кода.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread is or is to become a background thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Если этот поток является или станет фоновым потоком; в противном случае <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The thread is dead.</source>
          <target state="translated">Поток не существует.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">Возвращает значение, указывающее, является ли поток принадлежит группе управляемых потоков.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. <bpt id="p1">[</bpt>управляемых потоков пула<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread belongs to the managed thread pool; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Если этот поток принадлежит группе управляемых потоков; в противном случае <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> pumping.</source>
          <target state="translated">Блокирует вызывающий поток до завершения потока, представленный этим экземпляром, продолжая отправлять стандартные сообщения COM и <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> сообщения.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose Join method is called has completed.</source>
          <target state="translated">Соединение является метод синхронизации, который блокирует вызывающий поток (поток, вызывающий метод), до которого соединения, вызывается метод завершения потока.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">Используйте этот метод, чтобы убедиться, что поток завершен.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">Вызывающий объект будет выполняться бесконечно, если поток не завершился.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the Join method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block until <ph id="ph4">`Thread2`</ph> has completed.</source>
          <target state="translated">В следующем примере <ph id="ph1">`Thread1`</ph> поток вызывает метод Join <ph id="ph2">`Thread2`</ph>, чего <ph id="ph3">`Thread1`</ph> блок до <ph id="ph4">`Thread2`</ph> завершена.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept><ept id="p3">]</ept>       If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept> <ept id="p3">]</ept> Если поток завершился уже при &lt;xref:System.Threading.Thread.Join%2A&gt;вызывается метод возвращается немедленно.&lt;/xref:System.Threading.Thread.Join%2A&gt;  </target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!WARNING]</ph> &gt;  You should never call the Join method of the &lt;xref:System.Threading.Thread&gt; object that represents the current thread from the current thread.</source>
          <target state="translated">Настроек <ph id="ph1">[!WARNING]</ph> настроек никогда не должен вызывать метод Join &lt;xref:System.Threading.Thread&gt;объект, представляющий текущий поток из текущего потока.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,       This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">В результате приложение зависает, так как текущий поток до появления сообщения от самой себя, этот метод изменяет состояние вызывающего потока для включения &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Невозможно вызвать <ph id="ph1">`Join`</ph> в потоке, который находится в &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;состояние.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">Вызывающий объект пытается присоединиться к потоку, который находится в <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> состояния.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">Выполнение потока прервано во время ожидания.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Блокирует вызывающий поток до завершения потока, представленный этим экземпляром или указанный истечения времени, продолжая отправлять стандартные сообщения COM и SendMessage.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">Соединение — это метод синхронизации, который блокирует вызывающий поток (поток, вызывающий метод) до любой поток которого &lt;xref:System.Threading.Thread.Join%2A&gt;вызывается метод завершения или истечения заданного интервала времени ожидания.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">В следующем примере <ph id="ph1">`Thread1`</ph> поток вызывает метод &lt;xref:System.Threading.Thread.Join&gt;метод <ph id="ph2">`Thread2`</ph>, чего <ph id="ph3">`Thread1`</ph> тех пор, пока блокировка <ph id="ph4">`Thread2`</ph> завершения или по истечении 2 секунды.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for the <ph id="ph1">`millisecondsTimeout`</ph> parameter, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept> <ept id="p3">]</ept> Если &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;указан для <ph id="ph1">`millisecondsTimeout`</ph> параметра, этот метод работает идентично &lt;xref:System.Threading.Thread.Join&gt;перегрузка метода, за исключением возвращаемого значения.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">Если поток завершился уже при &lt;xref:System.Threading.Thread.Join%2A&gt;вызывается метод возвращается немедленно.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">Этот метод изменяет состояние вызывающего потока для включения &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Невозможно вызвать <ph id="ph1">`Join`</ph> в потоке, который находится в &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;состояние.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">Количество миллисекунд для ожидания завершения потока.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread has terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Если поток завершился; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> Если поток не завершился по истечении количества времени, заданного параметром <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p3">&lt;/code&gt;</ept> параметре.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds.</source>
          <target state="translated">Значение <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p1">&lt;/code&gt;</ept> является отрицательным и не равно <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> в миллисекундах.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The thread has not been started.</source>
          <target state="translated">Поток не запущен.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Блокирует вызывающий поток до завершения потока, представленный этим экземпляром или указанный истечения времени, продолжая отправлять стандартные сообщения COM и SendMessage.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">Соединение — это метод синхронизации, который блокирует вызывающий поток (поток, вызывающий метод) до любой поток которого &lt;xref:System.Threading.Thread.Join%2A&gt;вызывается метод завершения или истечения заданного интервала времени ожидания.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">В следующем примере <ph id="ph1">`Thread1`</ph> поток вызывает метод &lt;xref:System.Threading.Thread.Join&gt;метод <ph id="ph2">`Thread2`</ph>, чего <ph id="ph3">`Thread1`</ph> тех пор, пока блокировка <ph id="ph4">`Thread2`</ph> завершения или по истечении 2 секунды.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for <ph id="ph1">`timeout`</ph>, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept> <ept id="p3">]</ept> Если &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;указан для <ph id="ph1">`timeout`</ph>, этот метод работает идентично &lt;xref:System.Threading.Thread.Join&gt;перегрузка метода, за исключением возвращаемого значения.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">Если поток завершился уже при &lt;xref:System.Threading.Thread.Join%2A&gt;вызывается метод возвращается немедленно.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the current thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Этот метод изменяет состояние текущего потока для включения &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Невозможно вызвать <ph id="ph1">`Join`</ph> в потоке, который находится в &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;состояние.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated">Объект &lt;xref:System.TimeSpan&gt;задано время ожидания для завершения процесса.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Если поток завершился; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> Если поток не завершился по истечении количества времени, заданного параметром <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p3">&lt;/code&gt;</ept> параметре.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">Значение <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> является отрицательным и не равно <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> в миллисекундах, или больше, чем <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> миллисекунд.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">Вызывающий объект пытается присоединиться к потоку, который находится в <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> состояния.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">Возвращает уникальный идентификатор текущего управляемого потока.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread's ManagedThreadId property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">Значение свойства ManagedThreadId потока служит для уникальной идентификации этого потока, внутри своего процесса.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the ManagedThreadId property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">Значение свойства ManagedThreadId не меняется со временем, даже если неуправляемый код, на котором размещается общеязыковая среда выполнения реализует поток как волокно.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">Целое число, представляющее уникальный идентификатор для этого управляемого потока.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</source>
          <target state="translated">Синхронизирует доступ к памяти следующим образом: процессор, выполняющий текущий поток не способен упорядочить инструкции таким способом, который обращается к памяти до вызова MemoryBarrier выполнялись после обращений к памяти, выполните вызов MemoryBarrier.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>MemoryBarrier is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated">MemoryBarrier требуется только на мультипроцессорных системах со слабой организацией памяти (например, система, использующая несколько процессоров Intel Itanium).</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the &lt;xref:System.Threading.Monitor&gt; class provide easier ways to synchronize data.</source>
          <target state="translated">Для большинства целей, C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции или &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые способы синхронизации данных.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">Возвращает или задает имя потока.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is write-once.</source>
          <target state="translated">Это свойство доступно для записи — после.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the default value of a thread's Name property is <ph id="ph1">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Так как значение по умолчанию, имя свойства потока <ph id="ph1">`null`</ph>, можно определить, является ли имя уже явно присвоен в поток, сравнивая его с <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string assigned to the Name property can include any Unicode character.</source>
          <target state="translated">Строка, назначается свойству имя может содержать любой символ Юникода.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>A string containing the name of the thread, or <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if no name was set.</source>
          <target state="translated">Строка, содержащая имя потока или <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> Если имя не задано.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>A set operation was requested, but the <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> property has already been set.</source>
          <target state="translated">Запрошена операция задания, но <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> свойство уже задано.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">Возвращает или задает значение, указывающее на планируемый приоритет потока.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can be assigned any one of the following priority &lt;xref:System.Threading.ThreadPriority&gt; values:      -   <ph id="ph1">`Highest`</ph><ph id="ph2">      -   </ph><ph id="ph3">`AboveNormal`</ph><ph id="ph4">      -   </ph><ph id="ph5">`Normal`</ph><ph id="ph6">      -   </ph><ph id="ph7">`BelowNormal`</ph><ph id="ph8">      -   </ph><ph id="ph9">`Lowest`</ph>       Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">Поток можно назначить один из следующих приоритет &lt;xref:System.Threading.ThreadPriority&gt;значения:- <ph id="ph1">`Highest`</ph> <ph id="ph2">      -   </ph> <ph id="ph3">`AboveNormal`</ph> <ph id="ph4">      -   </ph> <ph id="ph5">`Normal`</ph> <ph id="ph6">      -   </ph> <ph id="ph7">`BelowNormal`</ph> <ph id="ph8">      -   </ph> <ph id="ph9">`Lowest`</ph> операционные системы не требуются для предоставления приоритета потока.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">Один из <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> значения.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Значение по умолчанию — <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The thread has reached a final state, such as <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Поток достиг конечного состояния, такие как <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is not a valid <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">Значение, указанное для операции задания не является допустимым <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> значение.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Cancels an &lt;xref:System.Threading.Thread.Abort*&gt; requested for the current thread.</source>
          <target state="translated">Отменяет &lt;xref:System.Threading.Thread.Abort*&gt;запрошенный для текущего потока.&lt;/xref:System.Threading.Thread.Abort*&gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">Этот метод может вызываться только кодом с соответствующими разрешениями.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt;.</source>
          <target state="translated">Когда выполняется вызов для <ph id="ph1">`Abort`</ph> завершить поток, система создает &lt;xref:System.Threading.ThreadAbortException&gt;.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>— специальное исключение, которое может быть зафиксировано кодом приложения, но повторно в конце блока catch, если <ph id="ph2">`ResetAbort`</ph> вызывается.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Отменяет запрос на аварийное завершение и предотвращает <ph id="ph2">`ThreadAbortException`</ph> от завершения потока.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>See &lt;xref:System.Threading.ThreadAbortException&gt; for an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method.</source>
          <target state="translated">В разделе &lt;xref:System.Threading.ThreadAbortException&gt;пример, демонстрирующий вызов <ph id="ph1">`ResetAbort`</ph> метод.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> was not invoked on the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>не был вызван для текущего потока.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">Вызывающий не имеет требуемого разрешения безопасности для текущего потока.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">Возобновляет приостановленную потока.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">Поток не был запущен, бездействует или не находится в приостановленном состоянии.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Вызывающий объект не имеет соответствующего <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Задает состояние апартамента потока до его запуска.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">Новые потоки инициализируются как &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;Если их состояние подразделения не задано до их запуска.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Необходимо задать состояние подразделения, до начала потока.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек основного потока приложения инициализируется &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;по умолчанию.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">Единственный способ задать состояние подразделения потока основного приложения для &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;заключается в применении &lt;xref:System.STAThreadAttribute&gt;атрибут к методу точки входа.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">Метод SetApartmentState вместе с &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;метод и &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;заменяет метод, &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;свойство.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">Новое состояние апартамента.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>не является допустимым состоянием подразделения.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">Поток уже запущен.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">Состояние подразделения уже инициализировано.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Applies a captured <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the current thread.</source>
          <target state="translated">Применяет записанное <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> к текущему потоку.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">Этот метод больше не поддерживается.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to be applied to the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> Объекта для применения к текущему потоку.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">Во всех случаях.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">Задает данные в указанной области, на данный момент поток, для текущего домена этого потока.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>For better performance, use fields marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Для повышения производительности используйте поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибутом.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные &lt;xref:System.ThreadStaticAttribute&gt;атрибут) и области данных.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании TLS см. в разделе <bpt id="p1">[</bpt>локальное хранилище потока: статические поля потока и области данных<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Потоки используют механизм локального хранилища памяти для хранения данных определенного потока.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the &lt;xref:System.Threading.Thread&gt; object has been reclaimed by garbage collection.</source>
          <target state="translated">Поток может выделить область данных в хранилище данных, хранилище и получения данных значения в слоте и освободить эту область для повторного использования после завершения процедуры потока и &lt;xref:System.Threading.Thread&gt;удален сборщиком мусора объект.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Области данных являются уникальными для каждого потока.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ни один поток (даже дочерний поток) можно получить эти данные.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  SetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек SetData является <ph id="ph2">`Shared`</ph> метод, который всегда применяется к потоку выполняться в данный момент, даже при вызове с помощью переменной, которая ссылается на другой поток.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">Чтобы избежать путаницы, используйте имя класса при вызове <ph id="ph1">`Shared`</ph> методы: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in which to set the value.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> Которого задается значение.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The value to be set.</source>
          <target state="translated">Задаваемое значение.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">Приостанавливает текущий поток для указанного числа миллисекунд.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">Поток не планируется для выполнения в операционной системе на указанный период времени.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Этот метод изменяет состояние потока для включения &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; for the <ph id="ph1">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Можно указать &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;для <ph id="ph1">`millisecondsTimeout`</ph> параметра на приостановку потока бесконечно.&lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">Тем не менее, рекомендуется использовать другие &lt;xref:System.Threading?displayProperty=fullName&gt;классы, такие как &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, или &lt;xref:System.Threading.Semaphore&gt;вместо синхронизировать потоков или управление ресурсами.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">Тактов системы с определенной скоростью вызывается разрешение часов.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">Фактическое время ожидания может быть точно заданное время ожидания, поскольку заданное время ожидания будет впоследствии скорректирована совпадают с тактов.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">Дополнительные сведения о времени разрешения и время ожидания см. в разделе <bpt id="p1">[</bpt>спящий режим функция<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> раздела.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">Этот метод вызывает метод <bpt id="p1">[</bpt>спящий режим функция<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> из API системы Windows.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Этот метод не выполняет стандартные COM и SendMessage.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек необходимо в спящий режим в потоке, который имеет &lt;xref:System.STAThreadAttribute&gt;, но вы хотите выполнять стандартные COM и SendMessage, используйте одну из перегрузок &lt;xref:System.Threading.Thread.Join%2A&gt;метод, который задает интервал времени ожидания.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">Число миллисекунд, на которое приостанавливается поток.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Если значение <ph id="ph1">`millisecondsTimeout`</ph> аргумент равен нулю, поток освобождает оставшуюся часть своего интервала времени для любого потока с таким же приоритетом, готовым к выполнению.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Если нет других потоков с таким же приоритетом, готовым к выполнению, выполнение текущего потока не приостанавливается.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The time-out value is negative and is not equal to &lt;xref:System.Threading.Timeout.Infinite&gt;.</source>
          <target state="translated">Значение тайм-аута отрицательно и не равно &lt;xref:System.Threading.Timeout.Infinite&gt;.&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Приостанавливает текущий поток в течение заданного времени.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">Поток не планируется для выполнения в операционной системе на указанный период времени.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Этот метод изменяет состояние потока для включения &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt; for the <ph id="ph1">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Можно указать &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;для <ph id="ph1">`timeout`</ph> параметра на приостановку потока бесконечно.&lt;/xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">Тем не менее, рекомендуется использовать другие &lt;xref:System.Threading?displayProperty=fullName&gt;классы, такие как &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, или &lt;xref:System.Threading.Semaphore&gt;вместо синхронизировать потоков или управление ресурсами.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload of &lt;xref:System.Threading.Thread.Sleep%2A&gt; uses the total number of whole milliseconds in <ph id="ph1">`timeout`</ph>.</source>
          <target state="translated">Эта перегрузка &lt;xref:System.Threading.Thread.Sleep%2A&gt;использует общее количество миллисекунд в <ph id="ph1">`timeout`</ph>.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">Дробное количество миллисекунд, отбрасываются.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Этот метод не выполняет стандартные COM и SendMessage.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек необходимо в спящий режим в потоке, который имеет &lt;xref:System.STAThreadAttribute&gt;, но вы хотите выполнять стандартные COM и SendMessage, используйте одну из перегрузок &lt;xref:System.Threading.Thread.Join%2A&gt;метод, который задает интервал времени ожидания.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">Количество времени, на которое приостанавливается поток.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Если значение <ph id="ph1">`millisecondsTimeout`</ph> аргумент <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, поток освобождает оставшуюся часть своего интервала времени для любого потока с таким же приоритетом, готовым к выполнению.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Если нет других потоков с таким же приоритетом, готовым к выполнению, выполнение текущего потока не приостанавливается.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">Значение <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> является отрицательным и не равно <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> в миллисекундах, или больше, чем <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> миллисекунд.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Causes a thread to wait the number of times defined by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">iterations</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">Вынуждает поток ожидать количество времени, определенное параметром <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">iterations</ph> <ept id="p1">&lt;/code&gt;</ept> параметра.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SpinWait method is useful for implementing locks.</source>
          <target state="translated">Метод SpinWait полезна для реализации блокировки.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes in the .NET Framework, such as &lt;xref:System.Threading.Monitor&gt; and &lt;xref:System.Threading.ReaderWriterLock&gt;, use this method internally.</source>
          <target state="translated">Классы в .NET Framework, такие как &lt;xref:System.Threading.Monitor&gt;и &lt;xref:System.Threading.ReaderWriterLock&gt;, этот метод используется внутренне.&lt;/xref:System.Threading.ReaderWriterLock&gt; &lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph1">`iterations`</ph> parameter.</source>
          <target state="translated">SpinWait фактически переводит процессор в очень непрерывном цикле со счетчика цикла, заданные <ph id="ph1">`iterations`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">Таким образом, длительность ожидания зависит от скорости процессора.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contrast this with the &lt;xref:System.Threading.Thread.Sleep%2A&gt; method.</source>
          <target state="translated">Сравните это с &lt;xref:System.Threading.Thread.Sleep%2A&gt;метод.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that calls &lt;xref:System.Threading.Thread.Sleep%2A&gt; yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">Поток, который вызывает &lt;xref:System.Threading.Thread.Sleep%2A&gt;дает остальная часть своего текущего интервала времени процессора, даже если за определенный интервал времени равна нулю.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying a non-zero interval for &lt;xref:System.Threading.Thread.Sleep%2A&gt; removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">Указание ненулевой интервал &lt;xref:System.Threading.Thread.Sleep%2A&gt;удаляет поток из рассмотрения планировщиком потоков до истечения интервала времени.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait is not generally useful for ordinary applications.</source>
          <target state="translated">SpinWait обычно не имеет смысла для обычных приложений.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; or a statement that wraps &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; (<ph id="ph1">`lock`</ph> in C# or <ph id="ph2">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">В большинстве случаев следует использовать классы синхронизации, предоставляемые платформой .NET Framework; Например, вызов &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;или инструкцию, которая служит оболочкой для &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;(<ph id="ph1">`lock`</ph> в C# или <ph id="ph2">`SyncLock`</ph> в Visual Basic).&lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; &lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the SpinWait method in your loop.</source>
          <target state="translated">Настроек <ph id="ph1">[!CAUTION]</ph> настроек в тех редких случаях, где предпочтительнее избежать переключение контекста, например, если известно, что изменение состояния является неизбежной, вызвать метод SpinWait в цикле.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code SpinWait executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">Код, который выполняет SpinWait предназначен для предотвращения проблем, возникающих на компьютерах с несколькими процессорами.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, SpinWait prevents processor starvation in certain situations.</source>
          <target state="translated">Например на компьютерах с несколькими процессорами Intel с применением технологии Hyper-Threading SpinWait предотвращает нехватку ресурсов процессора в определенных ситуациях.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">32-разрядное знаковое целое число, определяющий, как долго поток — ожидание.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Заставляет операционную систему изменить состояние текущего экземпляра на <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">Когда поток находится в &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;состояние операционной системы можно запланировать его выполнение.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">Поток начинает выполнение на первой строке метода, представленного &lt;xref:System.Threading.ThreadStart&gt;или &lt;xref:System.Threading.ParameterizedThreadStart&gt;делегат, переданное в конструктор потока.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">Обратите внимание, что вызов метода Start не блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If this overload is used with a thread created using a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек Если эта перегрузка используется с потоком, созданные с помощью &lt;xref:System.Threading.ParameterizedThreadStart&gt;делегировать, <ph id="ph2">`null`</ph> передается в метод, выполняемый потоком.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Если поток завершился, его невозможно перезапустить другим вызовом <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">Поток уже запущен.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Не хватает памяти для запуска этого потока.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">Заставляет операционную систему изменить состояние текущего экземпляра на <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>и (необязательно) передает объект, содержащий данные для использования с помощью метода, который выполняется потоком.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">Когда поток находится в &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;состояние операционной системы можно запланировать его выполнение.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">Поток начинает выполнение на первой строке метода, представленного &lt;xref:System.Threading.ThreadStart&gt;или &lt;xref:System.Threading.ParameterizedThreadStart&gt;делегат, переданное в конструктор потока.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">Обратите внимание, что вызов метода Start не блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Если поток завершился, его невозможно перезапустить другим вызовом <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload and the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">Эта перегрузка и &lt;xref:System.Threading.ParameterizedThreadStart&gt;делегат позволяют легко передать процедуре потока данных, но метод не является типобезопасным, потому что эта перегрузка может передаваться все объекты.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">Для размещения процедуры потока и полей данных в рабочий объект является более надежным способом передачи данных в процедуре потока.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>создание потоков и передача данных во время запуска<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">Объект, содержащий данные для использования с помощью метода, который выполняется потоком.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">Поток уже запущен.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Не хватает памяти для запуска этого потока.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>This thread was created using a <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate instead of a <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> delegate.</source>
          <target state="translated">Этот поток был создан с помощью <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> делегировать вместо <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> делегата.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">Приостанавливает работу потока, либо если работа потока уже приостановлена, не оказывает влияния.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">Если работа потока уже приостановлена, этот метод не оказывает влияния.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Do not use the Suspend and &lt;xref:System.Threading.Thread.Resume%2A&gt; methods to synchronize the activities of threads.</source>
          <target state="translated">Настроек <ph id="ph1">[!CAUTION]</ph> настроек не используйте Suspend и &lt;xref:System.Threading.Thread.Resume%2A&gt;методы для синхронизации действий потоков.&lt;/xref:System.Threading.Thread.Resume%2A&gt;</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">У вас нет возможности узнать, какой код поток выполняется в том случае, когда он приостановлен.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the &lt;xref:System.AppDomain&gt; might be blocked.</source>
          <target state="translated">Если поток приостановлен во время удержания блокировок во время оценки разрешений безопасности, другие потоки в &lt;xref:System.AppDomain&gt;может быть заблокирован.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the &lt;xref:System.AppDomain&gt; that attempt to use that class are blocked.</source>
          <target state="translated">Если приостановить поток при выполнении конструктора класса, другие потоки в &lt;xref:System.AppDomain&gt;, попытка использовать, что класс заблокированы.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Очень легко может вызвать взаимоблокировку.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">Поток не запущен или не существует.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Вызывающий объект не имеет соответствующего <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для использования в будущем.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Переданный массив имен для сопоставления.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Количество сопоставляемых имен.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Контекст языкового стандарта для интерпретации имен.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Доступ поздним связыванием при помощи COM- <ph id="ph1">`IDispatch`</ph> интерфейс не поддерживается.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Извлекает сведения о типе для объекта, которые можно использовать для получения сведений о типе интерфейса.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
          <target state="translated">Возвращаемые сведения о типе.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Идентификатор языкового стандарта для сведений о типе.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Получает указатель на объект сведений о запрошенного типа.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Доступ поздним связыванием при помощи COM- <ph id="ph1">`IDispatch`</ph> интерфейс не поддерживается.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Возвращает число интерфейсов сведения о типе, предоставляемых объектом (0 или 1).</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Указывает, к которому записывается число предоставляемых объектом интерфейсов сведения о типе.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Доступ поздним связыванием при помощи COM- <ph id="ph1">`IDispatch`</ph> интерфейс не поддерживается.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Предоставляет доступ к свойствам и методам, предоставляемым объекта.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::Invoke`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
          <target state="translated">Идентифицирует член.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для использования в будущем.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Флаги, описывающие контекст вызова.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Указатель на расположение, где будет храниться результат.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Указатель на структуру, содержащую сведения об исключении.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Индекс первого аргумента, вызвавшего ошибку.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Доступ поздним связыванием при помощи COM- <ph id="ph1">`IDispatch`</ph> интерфейс не поддерживается.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">Получает значение, содержащее состояния текущего потока.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ThreadState property provides more specific information than the &lt;xref:System.Threading.Thread.IsAlive%2A&gt; property.</source>
          <target state="translated">Свойство ThreadState предоставляет более подробные сведения, чем &lt;xref:System.Threading.Thread.IsAlive%2A&gt;свойство.&lt;/xref:System.Threading.Thread.IsAlive%2A&gt;</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">Настроек <ph id="ph1">[!IMPORTANT]</ph> настроек состояние потока используется только в сценариях отладки.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">Никогда не используйте в коде состояния потоков для синхронизации действий потоков.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the state of the current thread.</source>
          <target state="translated">Один из <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> значения, указывающие состояние текущего потока.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Начальное значение — <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Задает состояние апартамента потока до его запуска.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">Новые потоки инициализируются как &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;Если их состояние подразделения не задано до их запуска.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Необходимо задать состояние подразделения, до начала потока.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек основного потока приложения инициализируется &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;по умолчанию.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">Единственный способ задать состояние подразделения потока основного приложения для &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;заключается в применении &lt;xref:System.STAThreadAttribute&gt;атрибут к методу точки входа.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The TrySetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">Метод TrySetApartmentState вместе с &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;метод и &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;заменяет метод, &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;свойство.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">Новое состояние апартамента.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the apartment state is set; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Если задано состояние подразделения; в противном случае <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>не является допустимым состоянием подразделения.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">Поток уже запущен.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">VolatileRead и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileRead obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе VolatileRead Получает самое последнее значение, записанное в ячейку памяти любым процессором.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный VolatileRead и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю, VolatileRead или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует VolatileRead или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Считывает значение поля.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;Получает самое последнее значение, записанное в ячейку памяти любым процессором.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Поле для чтения.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Последнее значение, записанное в поле любым процессором.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и VolatileWrite предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileWrite ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе VolatileWrite обеспечивает значение, записанное в ячейку памяти немедленно видимым для всех процессоров.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и VolatileWrite убедитесь, что значение чтение или записываются в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;предназначены для особых случаев синхронизации.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">В обычных условиях C# <ph id="ph1">`lock`</ph> оператор, Visual Basic <ph id="ph2">`SyncLock`</ph> инструкции и &lt;xref:System.Threading.Monitor&gt;класса предоставляют более простые альтернативы.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">В многопроцессорной системе &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Для этого может потребоваться сброс кэша процессора.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Даже в системе однопроцессорный &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;и &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Вызов этого метода влияет только однократный доступ к памяти.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Настроек <ph id="ph1">[!NOTE]</ph> настроек в C# с помощью <ph id="ph2">`volatile`</ph> модификатор поля гарантирует, что весь доступ к этому полю использует &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;или &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Поле, к которому должны быть записаны значения.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Записываемое значение.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">Позволяет вызвавшему потоку передать выполнение другому потоку, готовому к использованию на текущем процессоре.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">Операционная система выбирает потоку передается выполнение.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">Если этот метод завершается успешно, получением остальная часть потока текущего интервала времени.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">Операционная система планирует вызывающий поток для другого среза времени в соответствии с его приоритетом и состоянием других потоков, доступных для выполнения.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">Выдача ограничена процессором, который выполняет вызывающий поток.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">Операционная система не переключит выполнение на другой процессор даже в том случае, если процессор простаивает или выполняется поток с более низким приоритетом.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Если нет других потоков, которые готовы к выполнению на текущем процессоре, операционная система не дает выполнения, и этот метод возвращает <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">Этот метод эквивалентен методу вызове неуправляемого кода для вызова собственного Win32 <ph id="ph1">`SwitchToThread`</ph> функции.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should call the Yield method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">Следует вызывать Yield, вызвать метод вместо использования платформы, так как неуправляемого кода обходит любое пользовательское потоковое поведение запрошенным узла.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the operating system switched execution to another thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Если операционная система переключила выполнение на другой поток; в противном случае <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>