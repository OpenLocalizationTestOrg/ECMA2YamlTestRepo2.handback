<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa8d9be9bd8a6e579a04c9a6e75191b7d59e2792</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.PropertyMetadata.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e549028ed296d03d13f33fd463370a904a5b4b8a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb79b96cb966a9c981d9c339abc43bdee740d9d8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</source>
          <target state="translated">Define determinados aspectos do comportamento de uma propriedade de dependência conforme ela é aplicada a um tipo específico, incluindo condições com que foi registrada.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property metadata can be defined and used during dependency property registration when calling the &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; method.</source>
          <target state="translated">Metadados de propriedade podem ser definidos e usados durante o registro de propriedade de dependência ao chamar o &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;método (ou variações para propriedades anexadas ou propriedades de dependência somente leitura), ou após o registro de proprietário original ao chamar o &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;método.&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt; also takes property metadata.</source>
          <target state="translated">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;também usa os metadados de propriedade.&lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>This class is a concrete base class that can be used in each of these calls.</source>
          <target state="translated">Essa classe é uma classe base concreta que pode ser usada em cada uma dessas chamadas.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is very common to specify metadata using one of the derived classes such as &lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.</source>
          <target state="translated">No entanto, é muito comum para especificar metadados usando uma das classes derivadas como &lt;xref:System.Windows.FrameworkPropertyMetadata&gt;.&lt;/xref:System.Windows.FrameworkPropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> framework level.</source>
          <target state="translated">Mais detalhados de metadados executado como valores de propriedade booliana, que são úteis para detectar ou habilitar alguns comportamentos de layout e de sistema de propriedade que só são implementados no suportam a essas classes derivadas de <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> nível de framework.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as &lt;xref:System.Windows.DependencyProperty.Register%2A&gt; or &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.</source>
          <target state="translated">Várias propriedades dessa classe são leitura / gravação para o modelo de objeto, mas só pode ser gravado antes da instância que está sendo usada em uma operação de sistema de propriedade como &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;ou &lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;.&lt;/xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each of these properties could also have been set by the constructor but are exposed so that &lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt; method implementations can set them.</source>
          <target state="translated">Cada uma dessas propriedades também poderia ter sido definido por construtor, mas são expostos para que &lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;implementações de método podem defini-las.&lt;/xref:System.Windows.PropertyMetadata.Merge%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    This type, and members of this type, are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # Uso de texto XAML esse tipo e os membros desse tipo, não são usados normalmente em <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with a specified default value for the dependency property that this metadata will be applied to.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe com um valor padrão especificado para a propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem corresponder ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação (incompatibilidade gerará uma exceção de tempo de execução).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">Embora seja o padrão de acordo com o construtor sem parâmetros, uma <ph id="ph1">`defaultValue`</ph> de &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;não pode ser especificado.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Tentar fazer isso gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The default value to specify for a dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">O valor padrão para especificar para uma propriedade de dependência, geralmente é fornecida como um valor de um tipo específico.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>não é possível definir o valor <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; consulte comentários.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe com especificado <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> referência de implementação.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Referência a uma implementação do manipulador que deve ser chamado pelo sistema de propriedades sempre que o valor efetivo da propriedade é alterado.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe com o valor padrão especificado e <bpt id="p2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> referência de implementação.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido <ph id="ph1">`defaultValue`</ph> devem corresponder ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação (incompatibilidade gerará uma exceção de tempo de execução).</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">Embora seja o padrão de acordo com o construtor sem parâmetros, uma <ph id="ph1">`defaultValue`</ph> de &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;não pode ser especificado.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Tentar fazer isso gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente é fornecido como um valor de um tipo específico.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Referência a uma implementação do manipulador que deve ser chamado pelo sistema de propriedades sempre que o valor efetivo da propriedade é alterado.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>não é possível definir o valor <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; consulte comentários.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class with the specified default value and callbacks.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe com o valor padrão especificado e retornos de chamada.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a &lt;xref:System.Windows.CoerceValueCallback&gt; but not a &lt;xref:System.Windows.PropertyChangedCallback&gt;, you can pass <ph id="ph1">`null`</ph> for the <ph id="ph2">`propertyChangedCallback`</ph> parameter.</source>
          <target state="translated">Se você quiser especificar um &lt;xref:System.Windows.CoerceValueCallback&gt;, mas não um &lt;xref:System.Windows.PropertyChangedCallback&gt;, você pode passar <ph id="ph1">`null`</ph> para o <ph id="ph2">`propertyChangedCallback`</ph> parâmetro.&lt;/xref:System.Windows.PropertyChangedCallback&gt; &lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem corresponder ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação (incompatibilidade gerará uma exceção de tempo de execução).</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be specified.</source>
          <target state="translated">Embora seja o padrão de acordo com o construtor sem parâmetros, uma <ph id="ph1">`defaultValue`</ph> de &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;não pode ser especificado.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Tentar fazer isso gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente é fornecido como um valor de um tipo específico.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Referência a uma implementação do manipulador que deve ser chamado pelo sistema de propriedades sempre que o valor efetivo da propriedade é alterado.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called whenever the property system calls &lt;xref:System.Windows.DependencyObject.CoerceValue*&gt; against this property.</source>
          <target state="translated">Referência a uma implementação do manipulador que deve ser chamado sempre que o sistema de propriedade chama &lt;xref:System.Windows.DependencyObject.CoerceValue*&gt;em relação a essa propriedade.&lt;/xref:System.Windows.DependencyObject.CoerceValue*&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph>não é possível definir o valor <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>; consulte comentários.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">Obtém ou define uma referência para um <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> implementação especificada nos metadados.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">Os retornos de chamada nos metadados de propriedade não são normalmente públicos membros no tipo de conteúdo, o valor dessa propriedade não é importante para a maioria dos cenários que consomem apenas os metadados da propriedade de dependência existente.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.CoerceValueCallback&gt;.</source>
          <target state="translated">Um motivo para que essa propriedade é exposta é para que as subclasses de metadados podem executar sua lógica de mesclagem desejado se metadados de base e substituindo/adicionar metadados especificam &lt;xref:System.Windows.CoerceValueCallback&gt;.&lt;/xref:System.Windows.CoerceValueCallback&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the default merge logic for a CoerceValueCallback is to replace the previous one.</source>
          <target state="translated">No entanto, a lógica de mesclagem padrão para um CoerceValueCallback é substituir a anterior.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>CoerceValueCallback is defined in the object model as read-write.</source>
          <target state="translated">CoerceValueCallback é definido no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so CoerceValueCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">Isso é para CoerceValueCallback pode ser ajustada após a inicialização do &lt;xref:System.Windows.PropertyMetadata&gt;objeto propriamente dito.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">No entanto, quando os metadados são consumidos como parte de uma chamada para &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, ou &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, o sistema de propriedade será lacrar essa instância de metadados e as propriedades são consideradas imutáveis.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set CoerceValueCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir CoerceValueCallback uma vez &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;é <ph id="ph1">`true`</ph> nesses metadados instância gerará uma exceção.&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> referência de implementação.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Não é possível definir uma propriedade de metadados depois que ela é aplicada a uma operação de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Gets or sets the default value of the dependency property.</source>
          <target state="translated">Obtém ou define o valor padrão da propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>DefaultValue is defined in the object model as read-write.</source>
          <target state="translated">Valor padrão é definido no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so DefaultValue can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">Isso é para o valor padrão pode ser ajustado após a inicialização do &lt;xref:System.Windows.PropertyMetadata&gt;objeto propriamente dito.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">No entanto, quando os metadados são consumidos como parte de uma chamada para &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, ou &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, o sistema de propriedade será lacrar essa instância de metadados e as propriedades são consideradas imutáveis.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set DefaultValue once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir DefaultValue uma vez &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;é <ph id="ph1">`true`</ph> nesses metadados instância gerará uma exceção.&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt; cannot be set using either DefaultValue or the constructor.</source>
          <target state="translated">Embora seja o padrão de acordo com o construtor sem parâmetros, uma <ph id="ph1">`defaultValue`</ph> de &lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;não pode ser definida usando o valor padrão ou o construtor.&lt;/xref:System.Windows.DependencyProperty.UnsetValue&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Tentar fazer isso gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage    Members of this type are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # XAML texto uso membros desse tipo não são usados normalmente em <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The default value of the property.</source>
          <target state="translated">O valor padrão da propriedade.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The default value on a <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> instance created with the parameterless constructor will be <bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>; see Remarks.</source>
          <target state="translated">O valor padrão em um <bpt id="p1">&lt;xref href="System.Windows.PropertyMetadata"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> instância criada com o construtor sem parâmetro será <bpt id="p2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>; consulte comentários.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Cannot be set to the value <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> once created; see Remarks.</source>
          <target state="translated">Não é possível definir o valor <bpt id="p1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> depois de criado; consulte comentários.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Não é possível definir uma propriedade de metadados depois que ela é aplicada a uma operação de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</source>
          <target state="translated">Obtém um valor que determina se os metadados foi aplicado a uma propriedade de alguma forma, resultando em um estado imutável dessa instância de metadados.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Various properties of &lt;xref:System.Windows.PropertyMetadata&gt;, such as &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;, are defined in the object model as read-write.</source>
          <target state="translated">Várias propriedades de &lt;xref:System.Windows.PropertyMetadata&gt;, como &lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;, são definidos no modelo de objeto como leitura-gravação.&lt;/xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt; &lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so those properties can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">Isso é para essas propriedades podem ser ajustadas após a inicialização do &lt;xref:System.Windows.PropertyMetadata&gt;objeto propriamente dito.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is applied to a dependency property as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">No entanto, uma vez que os metadados é aplicado a uma propriedade de dependência como parte de uma chamada para &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, ou &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, o sistema de propriedade será lacrar essa instância de metadados e as propriedades são consideradas imutáveis.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>At the time of one of these calls, &lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt; is called, and the value of this property is set to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">No momento de uma dessas chamadas, &lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;é chamado, e o valor dessa propriedade é definido como <ph id="ph1">`true`</ph>.&lt;/xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the metadata instance is immutable; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se a instância de metadados é imutável; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Merges this metadata with the base metadata.</source>
          <target state="translated">Mescla esses metadados com os metadados de base.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used internally when metadata is being overridden (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; method).</source>
          <target state="translated">Esse método é usado internamente quando metadados está sendo substituído (&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; método).&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The base metadata to merge with this instance's values.</source>
          <target state="translated">Os metadados de base para mesclar com valores dessa instância.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The dependency property to which this metadata is being applied.</source>
          <target state="translated">A propriedade de dependência para que esses metadados está sendo aplicado.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">Chamado quando esses metadados foi aplicado a uma propriedade, que indica se os metadados está sendo lacrado.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subclasses should assure that any mutability of the data structure of a &lt;xref:System.Windows.PropertyMetadata&gt; subclass should be marked as immutable once OnApply is called.</source>
          <target state="translated">As subclasses devem garantir que qualquer Mutabilidade da estrutura de dados de um &lt;xref:System.Windows.PropertyMetadata&gt;subclasse deve ser marcada como imutável depois que é chamado de OnApply.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</source>
          <target state="translated">Isso será chamado depois que os metadados é aplicado a uma operação de sistema de propriedade (registrar, proprietário de adicionar, substituir os metadados).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">A propriedade de dependência para a qual os metadados foi aplicado.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">O tipo associado com esses metadados quando se trata de um tipo específico metadados.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If this is default metadata, this value is a null reference.</source>
          <target state="translated">Quando se trata de metadados padrão, esse valor é uma referência nula.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation specified in this metadata.</source>
          <target state="translated">Obtém ou define uma referência para um <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> implementação especificada nos metadados.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">Os retornos de chamada nos metadados de propriedade não são membros públicos normalmente na definição de tipo, o valor dessa propriedade não é importante para a maioria dos cenários que consomem apenas os metadados da propriedade de dependência existente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a &lt;xref:System.Windows.PropertyChangedCallback&gt;.</source>
          <target state="translated">Um motivo para que essa propriedade é exposta é para que as classes de metadados podem executar sua lógica de mesclagem desejado se metadados de base e substituindo/adicionar metadados especificam &lt;xref:System.Windows.PropertyChangedCallback&gt;.&lt;/xref:System.Windows.PropertyChangedCallback&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default merge logic for is to maintain all PropertyChangedCallback implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</source>
          <target state="translated">É a lógica de mesclagem padrão para manter todas as implementações de PropertyChangedCallback em uma tabela e chamar cada um deles, com retornos de chamada estabelecidos pela classe mais profundo na hierarquia que executa o primeiro.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>PropertyChangedCallback is defined in the object model as read-write.</source>
          <target state="translated">PropertyChangedCallback é definido no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so PropertyChangedCallback can be adjusted after initialization of the &lt;xref:System.Windows.PropertyMetadata&gt; object itself.</source>
          <target state="translated">Isso é para PropertyChangedCallback pode ser ajustada após a inicialização do &lt;xref:System.Windows.PropertyMetadata&gt;objeto propriamente dito.&lt;/xref:System.Windows.PropertyMetadata&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, or &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">No entanto, quando os metadados são consumidos como parte de uma chamada para &lt;xref:System.Windows.DependencyProperty.Register%2A&gt;, &lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;, ou &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;, o sistema de propriedade será lacrar essa instância de metadados e as propriedades são consideradas imutáveis.&lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; &lt;/xref:System.Windows.DependencyProperty.AddOwner%2A&gt; &lt;/xref:System.Windows.DependencyProperty.Register%2A&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set PropertyChangedCallback once &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt; is <ph id="ph1">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir PropertyChangedCallback uma vez &lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;é <ph id="ph1">`true`</ph> nesses metadados instância gerará uma exceção.&lt;/xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> implementation reference.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> referência de implementação.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Não é possível definir uma propriedade de metadados depois que ela é aplicada a uma operação de propriedade de dependência.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>