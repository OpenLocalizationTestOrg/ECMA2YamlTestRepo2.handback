<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">93899f77dbe9a89a757dd2011e2fe034a73757a3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Security.CodeAccessPermission.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a6c7b2b7e90fd68ad6a457daa1122eac8c49b1e5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">620f466bc0c7923a43efc9b1250f57dc037351b1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines the underlying structure of all code access permissions.</source>
          <target state="translated">Define a estrutura subjacente de todas as permissões de acesso do código.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</source>
          <target state="translated">Permissões de acesso de código usam um exame da pilha para garantir que todos os chamadores do código receberam uma permissão.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a permission object is <ph id="ph1">`null`</ph>, it is handled the same as a permission object with the state &lt;xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;.</source>
          <target state="translated">Se for um objeto de permissão <ph id="ph1">`null`</ph>, ela será manipulada o mesmo que um objeto de permissão com o estado &lt;xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;.&lt;/xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Inheritors of the CodeAccessPermission class must be granted full trust to function correctly as permissions extending the security infrastructure.</source>
          <target state="translated">Herdeiros da classe CodeAccessPermission devem ser concedidos confiança total para funcionar corretamente, estendendo a infraestrutura de segurança de permissões.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine that the inheritors are fully trusted, CodeAccessPermission issues an &lt;xref:System.Security.Permissions.SecurityAction&gt; for &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt; = <ph id="ph1">`true`</ph> and &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt; = <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Para determinar se os herdeiros estão totalmente confiáveis, CodeAccessPermission emite um &lt;xref:System.Security.Permissions.SecurityAction&gt;para &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt;= <ph id="ph1">`true`</ph> e &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt;= <ph id="ph2">`true`</ph>.&lt;/xref:System.Security.Permissions.SecurityPermissionFlag&gt; &lt;/xref:System.Security.Permissions.SecurityPermissionFlag&gt; &lt;/xref:System.Security.Permissions.SecurityAction&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is called to initialize state in the type whenever an instance of the derived class is created.</source>
          <target state="translated">Este construtor é chamado para inicializar o estado no tipo sempre que uma instância da classe derivada é criada.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</source>
          <target state="translated">Embora você pode chamar explicitamente esse construtor na declaração de construtor do construtor de classe derivada, isso geralmente não é necessário; a maioria dos compiladores gerará automaticamente a chamada para você.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">Declara que o código de chamada pode acessar o recurso protegido por uma demanda de permissão por meio do código que chama esse método, mesmo que os chamadores mais acima na pilha não recebeu permissão para acessar o recurso.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Using Assert can create security issues.</source>
          <target state="translated">Usar Assert pode criar problemas de segurança.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling Assert prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</source>
          <target state="translated">Chamar Assert impede que um exame da pilha inferior na pilha de chamadas de continuar a pilha de chamadas além do código que chama esse método de origem.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</source>
          <target state="translated">Portanto, mesmo que os chamadores superior na pilha de chamadas não tem as permissões necessárias para acessar um recurso, eles ainda podem acessá-lo por meio do código que chama esse método em que a permissão necessária.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>An assertion is effective only if the code that calls Assert passes the security check for the permission that it is asserting.</source>
          <target state="translated">Uma asserção é eficaz somente se o código que chama Assert passa na verificação de segurança para a permissão que está declarando.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call to Assert is effective until the calling code returns to its caller.</source>
          <target state="translated">A chamada ao Assert é eficaz até que o código de chamada retorna ao chamador.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one Assert can be active on a frame.</source>
          <target state="translated">Somente uma declaração pode estar ativa em um quadro.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to call Assert when an active Assert exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.</source>
          <target state="translated">Uma tentativa de chamar Assert quando existe uma declaração ativa no quadro resulta em &lt;xref:System.Security.SecurityException&gt;.&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active Assert.</source>
          <target state="translated">Chamar &lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;ou &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;para remover uma declaração active.&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assert is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">Assert é ignorado para uma permissão concedida não porque uma solicitação de permissão não terá êxito.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if code lower on the call stack calls &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call Assert.</source>
          <target state="translated">No entanto, se inferior na pilha de chamadas de código chama &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;para essa permissão, um &lt;xref:System.Security.SecurityException&gt;é gerada quando a movimentação da pilha atinge o código que tentou chamar Assert.&lt;/xref:System.Security.SecurityException&gt; &lt;/xref:System.Security.CodeAccessPermission.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>This happens because the code that called Assert has not been granted the permission, even though it tried to Assert it.</source>
          <target state="translated">Isso acontece porque o código que chamou Assert não foi concedido a permissão, mesmo que tentou Assert-lo.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Because calling Assert removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; Como chamar Assert remove o requisito de que todo o código da cadeia de chamada deve ter permissão para acessar o recurso especificado, ele poderá abrir problemas de segurança se usado incorretamente ou inadequadamente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">Portanto, ele deve ser usado com cuidado.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The calling code does not have <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermissionFlag"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O código de chamada não tem <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermissionFlag"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>-or-       There is already an active Assert for the current frame.</source>
          <target state="translated">- ou - já existe uma declaração ativa para o quadro atual.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>When implemented by a derived class, creates and returns an identical copy of the current permission object.</source>
          <target state="translated">Quando implementado por uma classe derivada, cria e retorna uma cópia idêntica do objeto de permissão atual.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>A copy of a permission object represents the same access to resources as the original permission object.</source>
          <target state="translated">Uma cópia de um objeto de permissão representa o mesmo acesso a recursos como o objeto de permissão original.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A copy of the current permission object.</source>
          <target state="translated">Uma cópia do objeto de permissão atual.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Forces a &lt;xref:System.Security.SecurityException&gt; at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</source>
          <target state="translated">Força uma &lt;xref:System.Security.SecurityException&gt;em tempo de execução se todos os chamadores mais acima na pilha de chamadas não receberam a permissão especificada na instância atual.&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">Normalmente, esse método é usado pelas bibliotecas seguras para garantir que os chamadores tem permissão para acessar um recurso.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a file class in a secure class library calls Demand for the necessary &lt;xref:System.Security.Permissions.FileIOPermission&gt; before performing a file operation requested by the caller.</source>
          <target state="translated">Por exemplo, uma classe de arquivo em uma biblioteca de classe seguro chama procura necessários &lt;xref:System.Security.Permissions.FileIOPermission&gt;antes de executar uma operação de arquivo solicitada pelo chamador.&lt;/xref:System.Security.Permissions.FileIOPermission&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">As permissões do código que chama esse método não são examinadas; a seleção começa o chamador imediato do código e continua na pilha.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>Demand succeeds only if no &lt;xref:System.Security.SecurityException&gt; is raised.</source>
          <target state="translated">Demanda é realizada somente se nenhuma &lt;xref:System.Security.SecurityException&gt;é gerado.&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have the permission specified by the current instance.</source>
          <target state="translated">Um chamador superior na pilha de chamadas não tem a permissão especificada na instância atual.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>-or-       A caller higher in the call stack has called &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; on the current permission object.</source>
          <target state="translated">- ou - um superior na pilha de chamadas do chamador chamou &lt;xref:System.Security.CodeAccessPermission.Deny*&gt;no objeto da permissão atual.&lt;/xref:System.Security.CodeAccessPermission.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</source>
          <target state="translated">Impede que os chamadores mais acima na pilha de chamadas usando o código que chama esse método para acessar o recurso especificado pela instância atual.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The Deny method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O método Deny deve ser usado apenas para proteger os recursos do access acidental por código totalmente confiável.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">Ele não deve ser usado para proteger recursos contra uso inadequado intencional por código não confiável.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a Deny for a permission and then calls method <ph id="ph2">`B`</ph>, method <ph id="ph3">`B`</ph> can overtly override the Deny by issuing an &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.</source>
          <target state="translated">Por exemplo, se método <ph id="ph1">`A`</ph> emite uma negação de permissão e, em seguida, chama o método <ph id="ph2">`B`</ph>, método <ph id="ph3">`B`</ph> evidentemente pode substituir o Deny emitindo um &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">O método chamado é sempre superior na pilha.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no Deny or &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; lower in the stack.</source>
          <target state="translated">Portanto, se método <ph id="ph1">`B`</ph> tenta acessar um recurso protegido, o sistema de segurança começa a verificação de permissões com ele como método <ph id="ph2">`B`</ph> é o chamador imediato e aborda abaixo a pilha para confirmar que não há nenhum Deny ou &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;inferior na pilha.&lt;/xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; method.</source>
          <target state="translated">Método <ph id="ph1">`B`</ph>, que está tentando acessar o recurso, pode parar a movimentação da pilha imediatamente usando o &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;método.&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, the Deny placed on the stack by method <ph id="ph1">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">Nesse caso, o Deny colocado na pilha pelo método <ph id="ph1">`A`</ph> (o método de chamada) nunca é descoberto.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">Esse método impede que os chamadores mais acima na pilha de chamadas acessando o recurso protegido por meio do código que chama esse método, mesmo que os chamadores tiverem permissão para acessá-lo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deny can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls Deny from being used to access the resource protected by the denied permission.</source>
          <target state="translated">Deny pode limitar a responsabilidade do programador ou ajudar a evitar problemas de segurança acidental, pois ajuda a impedir que o método que chama Deny sejam usados para acessar o recurso protegido pela permissão negada.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a method calls Deny on a permission, and if a &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the Deny.</source>
          <target state="translated">Se um método chama negar uma permissão e se um &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;para essa permissão é invocado por um chamador inferior na pilha de chamadas, essa verificação de segurança falharão quando atingir a negar.&lt;/xref:System.Security.CodeAccessPermission.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call to Deny is effective until the calling code returns to its caller.</source>
          <target state="translated">A chamada para negar é eficaz até que o código de chamada retorna ao chamador.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one Deny can be active on a frame.</source>
          <target state="translated">Negar apenas uma pode estar ativa em um quadro.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to call Deny when an active Deny exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.</source>
          <target state="translated">Uma tentativa de chamar Deny quando existe um Deny ativa no quadro resulta em &lt;xref:System.Security.SecurityException&gt;.&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active Deny.</source>
          <target state="translated">Chamar &lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;ou &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;para remover um Deny active.&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deny is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">Negar é ignorado para uma permissão concedida não porque uma solicitação de permissão não terá êxito.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>There is already an active Deny for the current frame.</source>
          <target state="translated">Já existe um Deny ativo para o quadro atual.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Determines whether the specified <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is equal to the current <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Determina se o especificado <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objeto é igual ao atual <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see &lt;xref:System.Object.Equals%2A&gt;.</source>
          <target state="translated">Para obter mais informações, consulte &lt;xref:System.Object.Equals%2A&gt;.&lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to compare with the current <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objeto a ser comparado com o atual <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the specified <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object is equal to the current <bpt id="p3">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>; otherwise, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se especificado <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> objeto é igual ao atual <bpt id="p3">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>; caso contrário, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</source>
          <target state="translated">Quando substituído em uma classe derivada, reconstrói um objeto de segurança com um estado especificado de uma codificação de XML.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom code that extends security objects needs to implement the &lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt; and FromXml methods to make the objects security-encodable.</source>
          <target state="translated">Código personalizado que estende os objetos de segurança necessário para implementar o &lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;e FromXml métodos para tornar os objetos de segurança-pode ser codificada.&lt;/xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The XML encoding to use to reconstruct the security object.</source>
          <target state="translated">O XML de codificação a ser usada para reconstruir o objeto de segurança.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter does not contain the XML encoding for an instance of the same type as the current instance.</source>
          <target state="translated">O <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">elem</ph> <ept id="p1">&lt;/code&gt;</ept> parâmetro não contém a codificação XML para uma instância do mesmo tipo que a instância atual.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>-or-       The version number of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not supported.</source>
          <target state="translated">- ou - o número de versão de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">elem</ph> <ept id="p1">&lt;/code&gt;</ept> não há suporte para o parâmetro.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Gets a hash code for the <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that is suitable for use in hashing algorithms and data structures such as a hash table.</source>
          <target state="translated">Obtém um código hash para o <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objeto que é adequado para uso em algoritmos e estruturas de dados como uma tabela de hash de hash.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two &lt;xref:System.Security.CodeAccessPermission&gt; objects.</source>
          <target state="translated">O código hash para duas instâncias da mesma permissão pode ser diferente, portanto, um código de hash não deve ser usado para comparar dois &lt;xref:System.Security.CodeAccessPermission&gt;objetos.&lt;/xref:System.Security.CodeAccessPermission&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A hash code for the current <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">Um código hash para a atual <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objeto.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</source>
          <target state="translated">Quando implementado por uma classe derivada, cria e retorna uma permissão que é a interseção de permissão atual e a permissão especificada.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>The intersection of two permissions is a permission that describes the set of operations they both describe in common.</source>
          <target state="translated">A interseção de duas permissões é uma permissão que descreve o conjunto de operações que ambas descrevem em comum.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only a demand that passes both original permissions will pass the intersection.</source>
          <target state="translated">Somente uma demanda que passa as permissões originais passará a interseção.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>A permission to intersect with the current permission.</source>
          <target state="translated">Uma permissão a interseção com a permissão atual.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Ele deve ser o mesmo tipo da permissão atual.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A new permission that represents the intersection of the current permission and the specified permission.</source>
          <target state="translated">Uma nova permissão que representa a interseção de permissão atual e a permissão especificada.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This new permission is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the intersection is empty.</source>
          <target state="translated">Essa nova permissão é <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> se a interseção está vazia.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">target</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> and is not an instance of the same class as the current permission.</source>
          <target state="translated">O <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">target</ph> <ept id="p1">&lt;/code&gt;</ept> parâmetro não é <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> e não é uma instância da classe mesmo como a permissão atual.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</source>
          <target state="translated">Quando implementado por uma classe derivada, determina se a permissão atual é um subconjunto de permissão especificada.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>A permission that is to be tested for the subset relationship.</source>
          <target state="translated">Uma permissão a ser testado para a relação de subconjunto.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This permission must be of the same type as the current permission.</source>
          <target state="translated">Essa permissão deve ser o mesmo tipo da permissão atual.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current permission is a subset of the specified permission; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se a permissão atual é um subconjunto da permissão especificada; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">target</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> and is not of the same type as the current permission.</source>
          <target state="translated">O <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">target</ph> <ept id="p1">&lt;/code&gt;</ept> parâmetro não é <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> e não é do mesmo tipo que a permissão atual.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</source>
          <target state="translated">Impede que os chamadores mais acima na pilha de chamadas usando o código que chama esse método para acessar todos os recursos, exceto o recurso especificado pela instância atual.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The PermitOnly method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O método PermitOnly deve ser usado apenas para proteger os recursos do access acidental por código totalmente confiável.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">Ele não deve ser usado para proteger recursos contra uso inadequado intencional por código não confiável.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a PermitOnly for a permission and then calls method <ph id="ph2">`B`</ph>, method <ph id="ph3">`B`</ph> can overtly override the PermitOnly by issuing an &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.</source>
          <target state="translated">Por exemplo, se método <ph id="ph1">`A`</ph> emite um PermitOnly para uma permissão e, em seguida, chama o método <ph id="ph2">`B`</ph>, método <ph id="ph3">`B`</ph> evidentemente pode substituir o PermitOnly emitindo um &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">O método chamado é sempre superior na pilha.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; or PermitOnly lower in the stack.</source>
          <target state="translated">Portanto, se método <ph id="ph1">`B`</ph> tenta acessar um recurso protegido, o sistema de segurança começa a verificação de permissões com ele como método <ph id="ph2">`B`</ph> é o chamador imediato e aborda abaixo da pilha para confirmar se há nenhum &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;ou PermitOnly inferior na pilha.&lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; method.</source>
          <target state="translated">Método <ph id="ph1">`B`</ph>, que está tentando acessar o recurso, pode parar a movimentação da pilha imediatamente usando o &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;método.&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, the PermitOnly placed on the stack by method <ph id="ph1">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">Nesse caso, o PermitOnly colocado na pilha pelo método <ph id="ph1">`A`</ph> (o método de chamada) nunca é descoberto.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>PermitOnly is similar to &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated">PermitOnly é semelhante ao &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, ambos causam movimentações de pilha falha em caso contrário, eles conseguirão.&lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>The difference is that &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; specifies permissions that will cause the stack walk to fail, but PermitOnly specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">A diferença é que &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;Especifica permissões que fará com que a pilha de percorrer falha, mas PermitOnly Especifica as permissões somente que fazem com que a movimentação da pilha falha.&lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">Chame este método para garantir que seu código pode ser usado para acessar somente os recursos especificados.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call to PermitOnly is effective until the calling code returns to its caller.</source>
          <target state="translated">A chamada à PermitOnly é eficaz até que o código de chamada retorna ao chamador.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one PermitOnly can be active on a frame.</source>
          <target state="translated">Somente um PermitOnly pode estar ativa em um quadro.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to call PermitOnly when an active PermitOnly exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.</source>
          <target state="translated">Uma tentativa de chamar PermitOnly quando existe um PermitOnly ativa no quadro resulta em &lt;xref:System.Security.SecurityException&gt;.&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active PermitOnly.</source>
          <target state="translated">Chamar &lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;ou &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;para remover um ativo PermitOnly.&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>PermitOnly is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">PermitOnly é ignorado para uma permissão concedida não porque uma solicitação de permissão não terá êxito.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if code lower on the call stack later calls &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call PermitOnly.</source>
          <target state="translated">No entanto, se o código inferior na chamada de pilha mais tarde chamadas &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;para essa permissão, um &lt;xref:System.Security.SecurityException&gt;é gerada quando a movimentação da pilha atinge o código que tentou chamar PermitOnly.&lt;/xref:System.Security.SecurityException&gt; &lt;/xref:System.Security.CodeAccessPermission.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the code that called PermitOnly has not been granted the permission, even though it called PermitOnly for that permission.</source>
          <target state="translated">Isso ocorre porque o código que chamou PermitOnly não recebeu a permissão, mesmo que ela chamou PermitOnly para essa permissão.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>There is already an active PermitOnly for the current frame.</source>
          <target state="translated">Já existe um PermitOnly ativo para o quadro atual.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Causes all previous overrides for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Faz com que todas as substituições anteriores para o quadro atual a ser removido e não mais em vigor.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no overrides (&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;, &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, or &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;) for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">Se não houver nenhum substituições (&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;, &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, ou &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;) para o quadro atual, um &lt;xref:System.ExecutionEngineException&gt;é gerada.&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.Assert<bpt id="p1">*</bpt>&gt;, &lt;xref:System.Security.CodeAccessPermission.Deny<ept id="p1">*</ept>&gt;, or &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame.</source>
          <target state="translated">Não há anterior não &lt;&gt; &lt;/&gt; <bpt id="p1">*</bpt>&gt;, &lt;&gt; &lt;/&gt; <ept id="p1">*</ept>&gt;, ou &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt;para o quadro atual.&lt;/xref:System.Security.CodeAccessPermission.PermitOnly*&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Causes any previous &lt;xref:System.Security.CodeAccessPermission.Assert*&gt; for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Faz com que qualquer anterior &lt;xref:System.Security.CodeAccessPermission.Assert*&gt;para o quadro atual a ser removido e não mais em vigor.&lt;/xref:System.Security.CodeAccessPermission.Assert*&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there is no &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">Se não houver nenhum &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;para o quadro atual, um &lt;xref:System.ExecutionEngineException&gt;é gerada.&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.Assert*&gt; for the current frame.</source>
          <target state="translated">Não há anterior não &lt;xref:System.Security.CodeAccessPermission.Assert*&gt;para o quadro atual.&lt;/xref:System.Security.CodeAccessPermission.Assert*&gt;</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Causes any previous &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Faz com que qualquer anterior &lt;xref:System.Security.CodeAccessPermission.Deny*&gt;para o quadro atual a ser removido e não mais em vigor.&lt;/xref:System.Security.CodeAccessPermission.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there is no &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">Se não houver nenhum &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;para o quadro atual, um &lt;xref:System.ExecutionEngineException&gt;é gerada.&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; for the current frame.</source>
          <target state="translated">Não há anterior não &lt;xref:System.Security.CodeAccessPermission.Deny*&gt;para o quadro atual.&lt;/xref:System.Security.CodeAccessPermission.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Causes any previous &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Faz com que qualquer anterior &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt;para o quadro atual a ser removido e não mais em vigor.&lt;/xref:System.Security.CodeAccessPermission.PermitOnly*&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there is no &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">Se não houver nenhum &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;para o quadro atual, um &lt;xref:System.ExecutionEngineException&gt;é gerada.&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame.</source>
          <target state="translated">Não há anterior não &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt;para o quadro atual.&lt;/xref:System.Security.CodeAccessPermission.PermitOnly*&gt;</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Creates and returns a string representation of the current permission object.</source>
          <target state="translated">Cria e retorna uma representação de cadeia de caracteres do objeto de permissão atual.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is useful in debugging when you need to display the permission as a string.</source>
          <target state="translated">Esse método é útil para depuração quando você precisa de permissão são exibidas como uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>A string representation of the current permission object.</source>
          <target state="translated">Uma representação de cadeia de caracteres do objeto de permissão atual.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, creates an XML encoding of the security object and its current state.</source>
          <target state="translated">Quando substituído em uma classe derivada, cria uma codificação de XML do objeto de segurança e seu estado atual.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom code that extends security objects needs to implement the ToXml and &lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt; methods to make the objects security-encodable.</source>
          <target state="translated">Código personalizado que estende os objetos de segurança necessário para implementar o ToXml e &lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;métodos para tornar os objetos de segurança-pode ser codificada.&lt;/xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>An XML encoding of the security object, including any state information.</source>
          <target state="translated">Uma codificação de XML do objeto de segurança, incluindo quaisquer informações de estado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</source>
          <target state="translated">Quando substituído em uma classe derivada, cria uma permissão que é a união de permissão atual e a permissão especificada.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result of a call to Union is a permission that represents all the operations represented by both the current permission and the specified permission.</source>
          <target state="translated">O resultado de uma chamada a união é uma permissão que representa todas as operações representadas pela permissão atual e a permissão especificada.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any demand that passes either permission passes their union.</source>
          <target state="translated">Qualquer solicitação que passa a ter a permissão passa seu union.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>A permission to combine with the current permission.</source>
          <target state="translated">Uma permissão para combinar com a permissão atual.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Ele deve ser o mesmo tipo da permissão atual.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A new permission that represents the union of the current permission and the specified permission.</source>
          <target state="translated">Uma nova permissão que representa a união de permissão atual e a permissão especificada.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This method is only supported at this level when passed <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Esse método só tem suporte nesse nível passadas <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>