<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ec4eb6abc1cdf4de3aec918a6749eb637feb389</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.ReaderWriterLock.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9e2c24c218a229c81059e01f388a03a2f20ba07c</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc33aa4e80118dfe4cd1a4cad4ba16b2cf1248f7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines a lock that supports single writers and multiple readers.</source>
          <target state="translated">Define um bloqueio que dá suporte a gravadores único e vários leitores.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The <ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph> has two reader-writer locks, &lt;xref:System.Threading.ReaderWriterLockSlim&gt; and ReaderWriterLock.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; De <ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph> tem dois bloqueios de leitor-gravador, &lt;xref:System.Threading.ReaderWriterLockSlim&gt;e ReaderWriterLock.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is recommended for all new development.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;é recomendado para todos os novos desenvolvimentos.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;é semelhante ao ReaderWriterLock, mas ele simplificou regras de recursão e para atualizar e fazer o downgrade de estado de bloqueio.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; avoids many cases of potential deadlock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;evita muitos casos de potencial deadlock.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, the performance of &lt;xref:System.Threading.ReaderWriterLockSlim&gt; is significantly better than ReaderWriterLock.</source>
          <target state="translated">Além disso, o desempenho de &lt;xref:System.Threading.ReaderWriterLockSlim&gt;é significativamente melhor que ReaderWriterLock.&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>ReaderWriterLock is used to synchronize access to a resource.</source>
          <target state="translated">ReaderWriterLock é usado para sincronizar o acesso a um recurso.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</source>
          <target state="translated">A qualquer momento determinado, ele permite que o acesso simultâneo de leitura para vários threads, ou acesso de gravação para um único thread.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a situation where a resource is changed infrequently, a <ph id="ph1">`ReaderWriterLock`</ph> provides better throughput than a simple one-at-a-time lock, such as &lt;xref:System.Threading.Monitor&gt;.</source>
          <target state="translated">Em uma situação em que um recurso é alterado com frequência, um <ph id="ph1">`ReaderWriterLock`</ph> fornece melhor taxa de transferência que um bloqueio de um em vez de simple, como &lt;xref:System.Threading.Monitor&gt;.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ReaderWriterLock`</ph> works best where most accesses are reads, while writes are infrequent and of short duration.</source>
          <target state="translated"><ph id="ph1">`ReaderWriterLock`</ph>funciona melhor em que acessa a maioria das leituras, enquanto as gravações são incomuns e de curta duração.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</source>
          <target state="translated">Vários leitores alternam com gravadores único, para que nem leitores nem gravadores estão bloqueados por longos períodos.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Holding reader locks or writer locks for long periods will starve other threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Mantendo bloqueios de leitor ou bloqueios de gravação por longos períodos enfraquecer o outro thread.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>For best performance, consider restructuring your application to minimize the duration of writes.</source>
          <target state="translated">Para melhor desempenho, considere a reestruturação de seu aplicativo para minimizar a duração de gravações.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can hold a reader lock or a writer lock, but not both at the same time.</source>
          <target state="translated">Um thread pode manter um leitor de bloqueio ou um bloqueio de gravador, mas não ambos ao mesmo tempo.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead of releasing a reader lock in order to acquire the writer lock, you can use &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;.</source>
          <target state="translated">Em vez de liberar um bloqueio de leitor para adquirir o bloqueio de gravador, você pode usar &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;e &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests increase the lock count on a lock.</source>
          <target state="translated">Solicitações de bloqueio recursiva aumentam a contagem de bloqueio em um bloqueio.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>Readers and writers are queued separately.</source>
          <target state="translated">Os leitores e gravadores são enfileirados separadamente.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</source>
          <target state="translated">Quando um thread libera o bloqueio de gravador, todos os threads aguardando na fila de leitor no momento são concedidos bloqueios de leitor; Quando todos os bloqueios de leitor foram lançados, a próxima espera de thread no gravador de fila, se houver, é concedido o bloqueio de gravador e assim por diante.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other words, <ph id="ph1">`ReaderWriterLock`</ph> alternates between a collection of readers, and one writer.</source>
          <target state="translated">Em outras palavras, <ph id="ph1">`ReaderWriterLock`</ph> alterna entre uma coleção de leitores e um gravador.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</source>
          <target state="translated">Enquanto aguarda um thread na fila do gravador de bloqueios de leitor ativo a ser liberado, threads, solicitando novos bloqueios de leitor acumulam na fila leitor.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</source>
          <target state="translated">As solicitações não são concedidas, mesmo que eles podem compartilhar acesso simultâneo com detentores de bloqueio de leitor existente; Isso ajuda a proteger gravadores em bloqueio indefinido por leitores.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most methods for acquiring locks on a <ph id="ph1">`ReaderWriterLock`</ph> accept time-out values.</source>
          <target state="translated">A maioria dos métodos para adquirir bloqueios em uma <ph id="ph1">`ReaderWriterLock`</ph> aceitar valores de tempo limite.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use time-outs to avoid deadlocks in your application.</source>
          <target state="translated">Use tempos limite para evitar deadlocks em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</source>
          <target state="translated">Por exemplo, um thread pode adquirir o bloqueio de gravador em um recurso e, em seguida, solicitam um bloqueio de leitor em um segundo recurso; Enquanto isso, outro thread pode adquirir o bloqueio de gravador no segundo recurso e solicitam um bloqueio de leitor no primeiro.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unless time-outs are used, the threads deadlock.</source>
          <target state="translated">A menos que tempos limite é usado, o bloqueio de threads.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">Se o intervalo de tempo limite expira e não foi concedida a solicitação de bloqueio, o método retorna o controle para o thread de chamada, lançando um &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can catch this exception and determine what action to take next.</source>
          <target state="translated">Um thread pode tratar essa exceção e determinar qual ação realizar em seguida.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Time-outs are expressed in milliseconds.</source>
          <target state="translated">Tempos limite é expressos em milissegundos.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use a &lt;xref:System.TimeSpan?displayProperty=fullName&gt; to specify the time-out, the value used is the total number of whole milliseconds represented by the &lt;xref:System.TimeSpan&gt;.</source>
          <target state="translated">Se você usar uma &lt;xref:System.TimeSpan?displayProperty=fullName&gt;para especificar o tempo limite, o valor usado é o número total de milissegundos representado pelo &lt;xref:System.TimeSpan&gt;.&lt;/xref:System.TimeSpan&gt; &lt;/xref:System.TimeSpan?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows the valid time-out values in milliseconds.</source>
          <target state="translated">A tabela a seguir mostra os valores de tempo limite válido em milissegundos.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>|Value|Description|   |-----------|-----------------|   |-1|The thread waits until the lock is acquired, regardless of how long it takes.</source>
          <target state="translated">| Valor | Descrição |   |-----------|-----------------|   | -1 | O thread aguarda até que o bloqueio é adquirido, independentemente de quanto tempo demora.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>For methods that specify integer time-outs, the constant &lt;xref:System.Threading.Timeout.Infinite&gt; can be used.|   |0|The thread does not wait to acquire the lock.</source>
          <target state="translated">Para métodos que especificar tempos limite de número inteiro, a constante &lt;xref:System.Threading.Timeout.Infinite&gt;pode ser usada. |   |&amp;0; | O thread não espera para adquirir o bloqueio.&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the lock cannot be acquired immediately, the method returns.|   |&gt;0|The number of milliseconds to wait.|       With the exception of -1, negative time-out values are not allowed.</source>
          <target state="translated">Se o bloqueio não é possível adquirir imediatamente, o método retorna. |   | &gt;&amp;0; | O número de milissegundos de espera. |       Com exceção de -1, não são permitidos valores de tempo limite negativo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a negative integer other than -1, a time-out value of zero is used instead.</source>
          <target state="translated">Se você especificar um inteiro negativo que não seja -1, um valor de tempo limite de zero será usado.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a &lt;xref:System.TimeSpan&gt; that represents a negative number of milliseconds other than -1, &lt;xref:System.ArgumentOutOfRangeException&gt; is thrown.</source>
          <target state="translated">(Ou seja, o método retorna sem esperar, se o bloqueio não é possível adquirir imediatamente.) Se você especificar um &lt;xref:System.TimeSpan&gt;que representa um número negativo de milissegundos que não seja -1, &lt;xref:System.ArgumentOutOfRangeException&gt;é gerada.&lt;/xref:System.ArgumentOutOfRangeException&gt; &lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">Obtém um leitor de bloqueio, usando um &lt;xref:System.Int32&gt;valor para o tempo limite.&lt;/xref:System.Int32&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>AcquireReaderLock blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">AcquireReaderLock blocos se um thread diferente tiver o bloqueio de gravador, ou se pelo menos um thread está aguardando o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se o thread atual já tem o bloqueio de gravador, nenhum bloqueio de leitor é adquirido.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">Em vez disso, a contagem de bloqueio no bloqueio de gravador é incrementada.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">Isso impede que um thread de bloqueio em seu próprio bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">O resultado é exatamente o mesmo que chamar &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;e uma chamada adicional para &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;é necessária ao liberar o bloqueio de gravador.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>oferece suporte a solicitações de bloqueio de leitor de recursiva.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">Isto é, um thread pode chamar AcquireReaderLock várias vezes, que incrementa a contagem de bloqueio cada vez.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">Você deve chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;uma vez para cada vez que você chamar <ph id="ph1">`AcquireReaderLock`</ph>.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">Como alternativa, você pode chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;para reduzir a contagem de bloqueio como zero imediatamente.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">Solicitações de bloqueio recursiva sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila de leitor.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">Use bloqueios de recursiva com cuidado, para evitar o bloqueio de solicitações de bloqueio de gravador por longos períodos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">Para obter valores de tempo limite válido, consulte &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">O tempo limite em milissegundos.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>expirar antes que a solicitação de bloqueio é concedida.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">Obtém um leitor de bloqueio, usando um &lt;xref:System.TimeSpan&gt;valor para o tempo limite.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt; blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;Bloquear se um thread diferente tiver o bloqueio de gravador, ou se pelo menos um thread está aguardando o bloqueio de gravador.&lt;/xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se o thread atual já tem o bloqueio de gravador, nenhum bloqueio de leitor é adquirido.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">Em vez disso, a contagem de bloqueio no bloqueio de gravador é incrementada.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">Isso impede que um thread de bloqueio em seu próprio bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">O resultado é exatamente o mesmo que chamar &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;e uma chamada adicional para &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;é necessária ao liberar o bloqueio de gravador.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>oferece suporte a solicitações de bloqueio de leitor de recursiva.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">Isto é, um thread pode chamar AcquireReaderLock várias vezes, que incrementa a contagem de bloqueio cada vez.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">Você deve chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;uma vez para cada vez que você chamar <ph id="ph1">`AcquireReaderLock`</ph>.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">Como alternativa, você pode chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;para reduzir a contagem de bloqueio como zero imediatamente.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">Solicitações de bloqueio recursiva sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila de leitor.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">Use bloqueios de recursiva com cuidado, para evitar o bloqueio de solicitações de bloqueio de gravador por longos períodos.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">Para obter valores de tempo limite válido, consulte &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> especificando o período de tempo limite.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>expirar antes que a solicitação de bloqueio é concedida.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>Especifica um valor negativo diferente de-1 milissegundos.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">Obtém o gravador de bloqueio, usando um &lt;xref:System.Int32&gt;valor para o tempo limite.&lt;/xref:System.Int32&gt;</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">Esse método blocos se outro thread tiver um bloqueio de leitor ou gravador.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">Para obter uma descrição do modo como as alternativas de bloqueio de gravador com vários bloqueios de leitor simultâneas, consulte a &lt;xref:System.Threading.ReaderWriterLock&gt;classe.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">Um thread que já tem um bloqueio de leitor pode adquirir o bloqueio de gravador de duas maneiras: por liberar o bloqueio de leitor antes de chamar AcquireWriterLock ou chamando &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; Se um thread chama <ph id="ph2">`AcquireWriterLock`</ph> enquanto ele ainda possui um bloqueio de leitor, ela impedirá que seu próprio bloqueio de leitor; se for especificado um tempo limite infinito, o thread de deadlock.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">Para evitar tais deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;para determinar se o thread atual já tem um bloqueio de leitor.&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>dá suporte a solicitações de bloqueio de gravador recursiva.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">Isto é, um thread pode chamar <ph id="ph1">`AcquireWriterLock`</ph> várias vezes, que incrementa a contagem de bloqueio cada vez.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">Você deve chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;uma vez para cada vez que você chamar <ph id="ph1">`AcquireWriterLock`</ph>.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">Como alternativa, você pode chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;para reduzir a contagem de bloqueio como zero imediatamente.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">Solicitações de bloqueio recursiva sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila do gravador.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">Para obter valores de tempo limite válido, consulte &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">O tempo limite em milissegundos.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>expirar antes que a solicitação de bloqueio é concedida.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">Obtém o gravador de bloqueio, usando um &lt;xref:System.TimeSpan&gt;valor para o tempo limite.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">Esse método blocos se outro thread tiver um bloqueio de leitor ou gravador.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">Para obter uma descrição do modo como as alternativas de bloqueio de gravador com vários bloqueios de leitor simultâneas, consulte a &lt;xref:System.Threading.ReaderWriterLock&gt;classe.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">Um thread que já tem um bloqueio de leitor pode adquirir o bloqueio de gravador de duas maneiras: por liberar o bloqueio de leitor antes de chamar &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, ou chamando &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; Se um thread chama <ph id="ph2">`AcquireWriterLock`</ph> enquanto ele ainda possui um bloqueio de leitor, ela impedirá que seu próprio bloqueio de leitor; se for especificado um tempo limite infinito, o thread de deadlock.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">Para evitar tais deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;para determinar se o thread atual já tem um bloqueio de leitor.&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>dá suporte a solicitações de bloqueio de gravador recursiva.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">Isto é, um thread pode chamar <ph id="ph1">`AcquireWriterLock`</ph> várias vezes, que incrementa a contagem de bloqueio cada vez.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">Você deve chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;uma vez para cada vez que você chamar <ph id="ph1">`AcquireWriterLock`</ph>.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">Como alternativa, você pode chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;para reduzir a contagem de bloqueio como zero imediatamente.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">Solicitações de bloqueio recursiva sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila do gravador.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">Para obter valores de tempo limite válido, consulte &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated">O <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> especificando o período de tempo limite.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>expirar antes que a solicitação de bloqueio é concedida.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>Especifica um valor negativo diferente de-1 milissegundos.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</source>
          <target state="translated">Indica se o bloqueio de gravador foi concedido para qualquer thread desde que o número de sequência foi obtido.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use &lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt; and <ph id="ph1">`AnyWritersSince`</ph> to improve application performance.</source>
          <target state="translated">Você pode usar &lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;e <ph id="ph1">`AnyWritersSince`</ph> para melhorar o desempenho do aplicativo.&lt;/xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">Por exemplo, um thread pode armazenar em cache as informações que ele obtém mantendo um bloqueio de leitor.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>After releasing and later reacquiring the lock, the thread can use <ph id="ph1">`AnyWritersSince`</ph> to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</source>
          <target state="translated">Depois de liberar e posteriormente readquirir o bloqueio, o thread pode usar <ph id="ph1">`AnyWritersSince`</ph> para determinar se outros threads foram gravadas para o recurso nesse ínterim; caso contrário, as informações em cache podem ser usadas.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">Essa técnica é útil onde a leitura das informações protegidas pelo bloqueio é caro; Por exemplo, executando uma consulta de banco de dados.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">O chamador deve ser mantendo um bloqueio de leitor ou um bloqueio de gravador para que o número de sequência para serem úteis.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The sequence number.</source>
          <target state="translated">O número de sequência.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o bloqueio de gravador recebeu qualquer thread desde que foi obtido o número de sequência; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt; was called.</source>
          <target state="translated">Restaura o status de bloqueio do thread em que estavam antes &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;foi chamado.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>DowngradeFromWriterLock releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</source>
          <target state="translated">DowngradeFromWriterLock libera o bloqueio de gravador, independentemente da contagem de bloqueio recursiva e restaura o bloqueio de leitor foi mantido pelo thread antes de atualizar para o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>The lock count on the reader lock is restored.</source>
          <target state="translated">A contagem de bloqueio no bloqueio de leitor é restaurada.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph><ph id="ph2"> &gt;  </ph><ph id="ph3">`DowngradeFromWriterLock`</ph> accepts a &lt;xref:System.Threading.LockCookie&gt; obtained by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> <ph id="ph2"> &gt;  </ph> <ph id="ph3">`DowngradeFromWriterLock`</ph> aceita um &lt;xref:System.Threading.LockCookie&gt;obtida chamando &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; &lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use a <ph id="ph1">`LockCookie`</ph> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">Não use um <ph id="ph1">`LockCookie`</ph> retornado por &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</source>
          <target state="translated">Um thread não bloqueia ao fazer o downgrade do bloqueio de gravador, mesmo se outros threads estão aguardando o bloqueio de gravador, porque todas as solicitações de bloqueio de leitor são concedidas quando o bloqueio de gravador é liberado.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> retornado por &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">O thread não tem o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">O endereço do <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept> é um ponteiro nulo.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">Garante que os recursos são liberados e outras operações de limpeza são realizadas quando o coletor de lixo recupera o <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objeto.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector calls Finalize when the current &lt;xref:System.Threading.ReaderWriterLock&gt; object is ready to be finalized.</source>
          <target state="translated">O coletor de lixo chamadas finalizar quando atual &lt;xref:System.Threading.ReaderWriterLock&gt;objeto está pronto para ser finalizada.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds a reader lock.</source>
          <target state="translated">Obtém um valor que indica se o thread atual mantém um bloqueio de leitor.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds a reader lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o thread atual mantém um bloqueio de leitor; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds the writer lock.</source>
          <target state="translated">Obtém um valor que indica se o thread atual mantém o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds the writer lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o thread atual retém o bloqueio de gravador; Caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Releases the lock, regardless of the number of times the thread acquired the lock.</source>
          <target state="translated">Libera o bloqueio, independentemente do número de vezes que o thread adquiriu o bloqueio.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count.</source>
          <target state="translated">ReleaseLock libera o bloqueio de leitor ou gravador, independentemente da contagem de bloqueio recursiva.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>To restore the state of the lock, including the lock count, pass the &lt;xref:System.Threading.LockCookie&gt; to &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">Para restaurar o estado do bloqueio, incluindo a contagem de bloqueio, passar o &lt;xref:System.Threading.LockCookie&gt; &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt; &lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value representing the released lock.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valor que representa o bloqueio liberado.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Decrements the lock count.</source>
          <target state="translated">Diminui a contagem de bloqueio.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>ReleaseReaderLock decrements the lock count.</source>
          <target state="translated">ReleaseReaderLock diminui a contagem de bloqueio.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the count reaches zero, the lock is released.</source>
          <target state="translated">Quando a contagem chega a zero, o bloqueio seja liberado.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has the writer lock, calling <ph id="ph2">`ReleaseReaderLock`</ph> has the same effect as calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se um thread tem o bloqueio de gravador, chamando <ph id="ph2">`ReleaseReaderLock`</ph> tem o mesmo efeito que chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has no locks, calling <ph id="ph1">`ReleaseReaderLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">Se um thread não tem nenhum bloqueio, chamando <ph id="ph1">`ReleaseReaderLock`</ph> lança um &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The thread does not have any reader or writer locks.</source>
          <target state="translated">O thread não tem nenhum bloqueio de leitor ou gravador.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Decrements the lock count on the writer lock.</source>
          <target state="translated">Diminui a contagem de bloqueio no bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>ReleaseWriterLock decrements the writer lock count.</source>
          <target state="translated">Contagem de bloqueio de gravador ReleaseWriterLock diminui.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the count reaches zero, the writer lock is released.</source>
          <target state="translated">Quando a contagem chega a zero, o bloqueio de gravador é liberado.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has a reader lock, or no locks, calling <ph id="ph2">`ReleaseWriterLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se um thread tem um bloqueio de leitor ou nenhum bloqueio, chamando <ph id="ph2">`ReleaseWriterLock`</ph> lança um &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">O thread não tem o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">Restaura o status de bloqueio do thread ao que era antes de chamar &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>The state restored by <ph id="ph1">`RestoreLock`</ph> includes the recursive lock count.</source>
          <target state="translated">O estado restaurado por <ph id="ph1">`RestoreLock`</ph> inclui a contagem de bloqueio recursiva.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</source>
          <target state="translated">Blocos de thread se tentar restaurar um bloqueio de leitor depois de outro thread tenha adquirido o bloqueio de gravador, ou se tentar restaurar o bloqueio de gravador depois de outro thread adquiriu um bloqueio de leitor ou gravador.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">`RestoreLock`</ph> does not accept a time-out, you should take care to avoid possible deadlocks.</source>
          <target state="translated">Porque <ph id="ph1">`RestoreLock`</ph> não aceita um tempo limite, você deve ter cuidado para evitar deadlocks possíveis.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Before calling <ph id="ph2">`RestoreLock`</ph>, make sure you have released all locks acquired since the call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; Antes de chamar <ph id="ph2">`RestoreLock`</ph>, certifique-se de ter lançado todos os bloqueios adquiridos desde a chamada para &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</source>
          <target state="translated">Por exemplo, um thread deadlocks se adquire um bloqueio de leitor e, em seguida, tenta restaurar um bloqueio de gravador anterior.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; to detect such additional locks.</source>
          <target state="translated">Use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;e &lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt;para detectar esses bloqueios adicionais.&lt;/xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use a &lt;xref:System.Threading.LockCookie&gt; returned from &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">Não use um &lt;xref:System.Threading.LockCookie&gt;retornados de &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; &lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> retornado por &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">O endereço do <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept> é um ponteiro nulo.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using an <bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">Bloqueio de um bloqueio de leitor para o gravador de atualizações, usando um <bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valor para o tempo limite.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">Quando um thread chama <ph id="ph1">`UpgradeToWriterLock`</ph> o bloqueio de leitor é liberado, independentemente da contagem de bloqueio, e o thread vai para o final da fila para o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">Portanto, outros threads podem gravar o recurso antes do thread que solicitou que a atualização é concedida o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; A exceção de tempo limite não é lançada até que o thread que chamou o método UpgradeToWriterLock pode readquirir o bloqueio de leitor.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">Se não houver nenhum outro thread aguarda o bloqueio de gravador, isso ocorre imediatamente.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if another thread is queued for the writer lock, the thread that called the UpgradeToWriterLock method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">No entanto, se outro thread estiver na fila para o bloqueio de gravador, o thread que chamou o método UpgradeToWriterLock não é possível readquirir o bloqueio de leitor até que todos os leitores atuais lançou seus bloqueios e um thread tem adquiridos e liberados o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the UpgradeToWriterLock method.</source>
          <target state="translated">Isso é verdadeiro mesmo se outro thread que solicitou o bloqueio de gravador solicitou depois que o thread atual chamado o método UpgradeToWriterLock.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">Para restaurar o estado de bloqueio, chame &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;usando o &lt;xref:System.Threading.LockCookie&gt;retornado por <ph id="ph1">`UpgradeToWriterLock`</ph>.&lt;/xref:System.Threading.LockCookie&gt; &lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">Não use isso <ph id="ph1">`LockCookie`</ph> com &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">Quando um thread não tem nenhum bloqueio de leitor, não use <ph id="ph1">`UpgradeToWriterLock`</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;em vez disso.&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">Para obter valores de tempo limite válido, consulte &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">O tempo limite em milissegundos.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>expirar antes que a solicitação de bloqueio é concedida.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using a <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">Bloqueio de um bloqueio de leitor para o gravador de atualizações, usando um <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valor para o tempo limite.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">Quando um thread chama <ph id="ph1">`UpgradeToWriterLock`</ph> o bloqueio de leitor é liberado, independentemente da contagem de bloqueio, e o thread vai para o final da fila para o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">Portanto, outros threads podem gravar o recurso antes do thread que solicitou que a atualização é concedida o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method can reacquire the reader lock.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; A exceção de tempo limite não é lançada até que o thread que chamou o &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;método pode readquirir o bloqueio de leitor.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">Se não houver nenhum outro thread aguarda o bloqueio de gravador, isso ocorre imediatamente.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if another thread is queued for the writer lock, the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">No entanto, se outro thread estiver na fila para o bloqueio de gravador, o thread que chamaram a &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;método não é possível readquirir o bloqueio de leitor até que todos os leitores atuais lançou seus bloqueios e um thread tem adquiridos e liberados o bloqueio de gravador.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method.</source>
          <target state="translated">Isso é verdadeiro mesmo se outro thread que solicitou o bloqueio de gravador solicitou depois que o segmento atual é chamado de &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;método.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">Para restaurar o estado de bloqueio, chame &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;usando o &lt;xref:System.Threading.LockCookie&gt;retornado por <ph id="ph1">`UpgradeToWriterLock`</ph>.&lt;/xref:System.Threading.LockCookie&gt; &lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">Não use isso <ph id="ph1">`LockCookie`</ph> com &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">Quando um thread não tem nenhum bloqueio de leitor, não use <ph id="ph1">`UpgradeToWriterLock`</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;em vez disso.&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">Para obter valores de tempo limite válido, consulte &lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated">O <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> especificando o período de tempo limite.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>expirar antes que a solicitação de bloqueio é concedida.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>Especifica um valor negativo diferente de-1 milissegundos.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Gets the current sequence number.</source>
          <target state="translated">Obtém o número de sequência atual.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sequence number increases whenever a thread acquires the writer lock.</source>
          <target state="translated">A sequência número aumenta sempre que um thread adquire o bloqueio de gravador.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can save the sequence number and pass it to &lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt; at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</source>
          <target state="translated">Você pode salvar o número de sequência e passá-lo para &lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;em um momento posterior, se você quiser determinar se outros threads tem adquirido o bloqueio de gravador nesse meio tempo.&lt;/xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">`WriterSeqNum`</ph> to improve application performance.</source>
          <target state="translated">Você pode usar <ph id="ph1">`WriterSeqNum`</ph> para melhorar o desempenho do aplicativo.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">Por exemplo, um thread pode armazenar em cache as informações que ele obtém mantendo um bloqueio de leitor.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling <ph id="ph1">`AnyWritersSince`</ph>; if not, the cached information can be used.</source>
          <target state="translated">Depois de liberar e posteriormente readquirir o bloqueio, o thread pode determinar se outros threads foram gravadas para o recurso chamando <ph id="ph1">`AnyWritersSince`</ph>; se não, as informações em cache podem ser usadas.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">Essa técnica é útil quando as informações protegidas pelo bloqueio de leitura é caro; Por exemplo, executando uma consulta de banco de dados.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">O chamador deve ser mantendo um bloqueio de leitor ou um bloqueio de gravador para que o número de sequência para serem úteis.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The current sequence number.</source>
          <target state="translated">O número de sequência atual.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>