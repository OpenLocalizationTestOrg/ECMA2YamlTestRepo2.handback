<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="sv-se">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e5df80f20fb8f8e9d58d7fd51e841a9b301b1bb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.Thread.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">836a4a28ca4635685ece20dbbe7b56da6a73e287</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d53c4cef63a323cfe675bb4658023858adff4b10</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">Skapar och kontrollerar en tråd, anger prioritet och hämtar dess status.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">När en process startas skapar common language runtime automatiskt en enda förgrunden tråd för att köra programkod.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">En process kan skapa en eller flera trådar för att köra en del av den programkod som är associerade med processen tillsammans med den här huvudsakliga förgrunds-tråden.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">Dessa trådar kan köras i förgrunden eller i bakgrunden.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, you can use the &lt;xref:System.Threading.ThreadPool&gt; class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">Du kan dessutom använda den &lt;xref:System.Threading.ThreadPool&gt;klassen för att köra kod i trådar som hanteras av CLR.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section       <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept>     <bpt id="p2">[</bpt>Retrieving Thread objects<ept id="p2">](#Retrieving)</ept>     <bpt id="p3">[</bpt>Foreground and background threads<ept id="p3">](#Foreground)</ept>     <bpt id="p4">[</bpt>Culture and threads<ept id="p4">](#Culture)</ept>     <bpt id="p5">[</bpt>Getting information about and controlling threads<ept id="p5">](#Properties)</ept>     <bpt id="p6">[</bpt>Accessing the source code for the Thread class<ept id="p6">](#Source)</ept>      <bpt id="p7">&lt;a name="Starting"&gt;</bpt><ept id="p7">&lt;/a&gt;</ept>    ## Starting a thread    You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">I det här avsnittet <bpt id="p1">[</bpt>starta en tråd<ept id="p1">](#Starting)</ept><bpt id="p2">[</bpt>hämtar trådobjekt<ept id="p2">](#Retrieving)</ept><bpt id="p3">[</bpt>i förgrunden och bakgrunden trådar<ept id="p3">](#Foreground)</ept><bpt id="p4">[</bpt>kultur och trådar<ept id="p4">](#Culture)</ept><bpt id="p5">[</bpt>och hämta information om och kontrollera trådar<ept id="p5">](#Properties)</ept><bpt id="p6">[</bpt>att öppna källkoden för klassen tråd<ept id="p6">](#Source)</ept> <bpt id="p7">&lt;a name="Starting"&gt;</bpt> <ept id="p7">&lt;/a&gt;</ept> ## från en tråd starta en tråd genom att tillhandahålla en delegat som representerar tråden är i sin klasskonstruktor för att köra metoden.                               </target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>You then call the &lt;xref:System.Threading.Thread.Start%2A&gt; method to begin execution.</source>
          <target state="translated">Sedan anropar den &lt;xref:System.Threading.Thread.Start%2A&gt;metod för att starta körningen.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Thread constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:      -   If the method has no arguments, you pass a &lt;xref:System.Threading.ThreadStart&gt; delegate to  the constructor.</source>
          <target state="translated">Tråd-konstruktorer kan ha två delegattyper, beroende på om du kan överföra argument till metoden för att köra:-om metoden inte har något argument du skickar en &lt;xref:System.Threading.ThreadStart&gt;Delegera till konstruktorn.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph>           The following example creates and starts a thread that executes the <ph id="ph3">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">Det har signatur: <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph> i följande exempel skapar och startar en tråd som kör den <ph id="ph3">`ExecuteInForeground`</ph> metoden.          </target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">Metoden visar information om vissa tråd egenskaper och sedan kör en loop pausar för en halv sekund och visar det förflutna antalet sekunder.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">Avslutar körning när tråden har körts minst fem sekunder loopen avslutas och tråden.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept><ept id="p3">]</ept>      -   If the method has an argument, you pass a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate to the constructor.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept> <ept id="p3">]</ept> -om metoden har ett argument kan du skicka en &lt;xref:System.Threading.ParameterizedThreadStart&gt;Delegera till konstruktorn.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;      </target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph>           The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">Det har signatur: <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph> metoden körs av delegaten kan omvandla (i C#) eller (i Visual Basic) konvertera parametern till lämplig.          </target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example is identical to the previous one, except that it calls the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor.</source>
          <target state="translated">Följande exempel är identiskt med det tidigare förutom att den anropar den &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;konstruktor.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">Den här versionen av den <ph id="ph1">`ExecuteInForeground`</ph> metoden har en parameter som representerar det ungefärliga antalet millisekunder som slingan är att köra.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept><ept id="p3">]</ept>       It is not necessary to retain a reference to a Thread object once you have started the thread.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept> <ept id="p3">]</ept> det är inte nödvändigt att behålla en referens till en trådobjektet när du har startat tråden.      </target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">Fortsätter att köra tills tråd proceduren har slutförts.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Retrieving Thread objects    You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## Hämtar tråd objekt du kan använda statiskhet (<ph id="ph1">`Shared`</ph> i Visual Basic) &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;egenskapen att hämta en referens till tråden körs från den kod som körs i tråden.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">I följande exempel används den &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;egenskapen för att visa information om programmets tråd, en annan tråd i förgrunden, en bakgrundstråd och en tråd pooltråd.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Foreground"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Foreground and background threads    Instances of the Thread class represent either foreground threads or background threads.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Foreground"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> ## förgrunden och bakgrunden trådar instanser av klassen tråd representerar trådar i förgrunden eller bakgrundstrådar.        </target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">Bakgrundstrådar är identiska med förgrunden trådar med ett undantag: en bakgrundstråd inte hålla en process som körs om alla trådar i förgrunden har avslutats.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">När alla trådar i förgrunden har stoppats, stoppar alla bakgrundstrådar körningsmiljön och stängs av.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground:      -   The main application thread.</source>
          <target state="translated">Som standard följande trådarna körs i förgrunden:-programmets tråd.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a Thread class constructor.</source>
          <target state="translated">-Alla trådar som skapas genom att anropa en tråd klasskonstruktor.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following threads execute in the background by default:      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Följande trådarna köras i bakgrunden som standard:-tråd pool trådar, som är en pool av trådar som underhålls av körningsmiljön.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">Du kan konfigurera tråd pool och schema arbete på tråd pool trådar med hjälp av &lt;xref:System.Threading.ThreadPool&gt;klassen.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Uppgiftsbaserade asynkrona åtgärder kör automatiskt på tråd pool trådar.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Task-based asynchronous operations use the &lt;xref:System.Threading.Tasks.Task&gt; and &lt;xref:System.Threading.Tasks.Task%601&gt; classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Uppgiftsbaserade asynkrona åtgärder använder den &lt;xref:System.Threading.Tasks.Task&gt;och &lt;xref:System.Threading.Tasks.Task%601&gt;klasser för att implementera den <bpt id="p1">[</bpt>uppgiftsbaserade asynkront mönster<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.&lt;/xref:System.Threading.Tasks.Task%601&gt; &lt;/xref:System.Threading.Tasks.Task&gt;</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-Alla trådar som anger den hantera körningsmiljön från ohanterad kod.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can change a thread to execute in the background by setting the &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property at any time.</source>
          <target state="translated">Du kan ändra en tråd som ska köras i bakgrunden genom att ange den &lt;xref:System.Threading.Thread.IsBackground%2A&gt;egenskapen när som helst.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">Bakgrundstrådar är användbara för någon åtgärd fortsätter så länge som ett program körs men bör inte hindra att programmet avslutas, till exempel övervaka filändringar system eller inkommande socketanslutningar.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">I följande exempel visas skillnaden mellan trådar i förgrunden och bakgrunden.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">Det är det första exemplet i den <bpt id="p1">[</bpt>starta en tråd<ept id="p1">](#Starting)</ept> avsnitt, förutom att det anger tråden som ska köras i bakgrunden innan du startar den.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">Som utdata visar avbryts slingan innan utförs för fem sekunder.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Culture"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Culture and threads    Each thread has a culture, represented by the &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt; property, and a UI culture, represented by the &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt; property.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Culture"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> ## kultur och trådar varje tråd har en kultur som representeras av den &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;egenskapen och en kultur för Användargränssnittet som representeras av den &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;egenskapen.&lt;/xref:System.Threading.Thread.CurrentUICulture%2A&gt; &lt;/xref:System.Threading.Thread.CurrentCulture%2A&gt;        </target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">Den aktuella kulturen stöder kulturen känslig åtgärder som parsning och formatering, strängjämförelse och sortering och kontrollerar även skrivning system och kalender som används av en tråd.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">Aktuell kultur för Användargränssnittet innehåller för kulturen känslig hämtning av resurser i Resursfiler.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">När en ny tråd instansieras dess kultur och kultur för Användargränssnittet definieras av den aktuella systemkulturen och kultur för Användargränssnittet och inte av kultur och kultur för Användargränssnittet för tråden som den nya tråden skapades från.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">Detta innebär till exempel, som om den aktuella systemkulturen är engelska (USA) och den aktuella kulturen för primära tråden är franska (Frankrike), kultur för en ny tråd som skapats genom att anropa den &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;konstruktorn från den primära tråden är engelska (USA) och inte franska (Frankrike).&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Mer information finns i avsnittet "Kultur och trådar" i den &lt;xref:System.Globalization.CultureInfo&gt;klassen avsnittet.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Detta gäller inte för trådar som kör asynkrona åtgärder för appar som mål i <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> och senare i det här fallet, kultur och kultur för Användargränssnittet är en del av en asynkrona åtgärder kontexten; tråd där en asynkron åtgärd körs som standard ärver kultur och kultur för Användargränssnittet för tråden som den asynkrona åtgärden har startats.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Mer information finns i avsnittet "Kultur och uppgiftsbaserade asynkrona åtgärder" i den &lt;xref:System.Globalization.CultureInfo&gt;klassen avsnittet.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:      -   You can pass a &lt;xref:System.Globalization.CultureInfo&gt; object that represents that culture to the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate or the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; method.</source>
          <target state="translated">Du kan göra något av följande för att se till att alla trådar körs i ett program delar samma kultur och kultur för Användargränssnittet:-du kan skicka en &lt;xref:System.Globalization.CultureInfo&gt;objekt som representerar den kulturen så att den &lt;xref:System.Threading.ParameterizedThreadStart&gt;Delegera eller &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt;metod.&lt;/xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; &lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt; and &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; properties.</source>
          <target state="translated">-För appar som körs på den <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> och senare versioner kan du definiera kultur och kultur för Användargränssnittet som ska tilldelas alla trådar som skapats i en tillämpningsdomän genom att ange värdet för den &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;och &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;Egenskaper.&lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; &lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">Observera att detta är en inställning per programdomän.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information and examples, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Mer information och exempel finns i avsnittet "Kultur och trådar" för den &lt;xref:System.Globalization.CultureInfo&gt;klassen avsnittet.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Getting information about and controlling threads    You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## Du kan hämta ett antal egenskapsvärden som innehåller information om en tråd få information om och styra trådar.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">I vissa fall kan ange du också egenskapsvärdena kontroll för tråden.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>These thread properties include:      -   A name.</source>
          <target state="translated">Egenskaperna tråd innehåller:-namnet.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.Name%2A&gt; is a write-once property that you can use to identify a thread.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Name%2A&gt;är en skrivning-när egenskapen som du kan använda för att identifiera en tråd.&lt;/xref:System.Threading.Thread.Name%2A&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Standardvärdet är <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A hash code, which you can retrieve by calling the &lt;xref:System.Threading.Thread.GetHashCode%2A&gt; method.</source>
          <target state="translated">-En Hashkod som du kan hämta genom att anropa den &lt;xref:System.Threading.Thread.GetHashCode%2A&gt;metoden.&lt;/xref:System.Threading.Thread.GetHashCode%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">Hash-koden kan användas för att unikt identifiera en tråd. dess hash-kod kommer inte krockar med värdet från tråden, oavsett den domän där du hämtar värdet för livslängden för en tråd.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A thread ID.</source>
          <target state="translated">-En tråd-ID.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the read-only &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">Värdet för den skrivskyddade &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;egenskapen tilldelas av körningen och som unikt identifierar en tråd i dess process.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; En operativsystemet <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> har ingen fast koppling till en hanterad tråd eftersom en ohanterad värd kan styra relationen mellan hanterade och ohanterade trådar.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">Mer specifikt en avancerad värd kan använda den <bpt id="p1">[</bpt>CLR värd API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> att schemalägga många trådar mot operativsystemet samma tråd som hanterade eller för att flytta en hanterad tråd mellan olika operativsystem trådar.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The thread's current state.</source>
          <target state="translated">-Trådens aktuella tillstånd.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the &lt;xref:System.Threading.ThreadState&gt; property.</source>
          <target state="translated">Under hela sin existens, en tråd är alltid i en eller flera av de tillstånd som definieras av den &lt;xref:System.Threading.ThreadState&gt;egenskapen.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A scheduling priority level, which is defined by the &lt;xref:System.Threading.ThreadPriority&gt; property.</source>
          <target state="translated">-En schemaläggning prioritetsnivå som definieras av den &lt;xref:System.Threading.ThreadPriority&gt;egenskapen.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">Även om du kan ange ett värde att begära en trådprioritet, är det inte säkert att användas av operativsystemet.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The read-only &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt; property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">-Den skrivskyddade &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;-egenskap som anger om en tråd är en tråd pooltråd.&lt;/xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property.</source>
          <target state="translated">- &lt;xref:System.Threading.Thread.IsBackground%2A&gt;Egenskap.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">Mer information finns i <bpt id="p1">[</bpt>i förgrunden och bakgrunden trådar<ept id="p1">](#Foreground)</ept> avsnitt.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Accessing the source code for the Thread class    To view the .NET Framework source code for the Thread class, see the <bpt id="p2">[</bpt>Reference Source<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>## Att öppna källkoden för tråden klassen om du vill visa källkoden för .NET Framework för klassen tråden finns i <bpt id="p2">[</bpt>referenskälla<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
          <target state="translated">Du kan bläddra igenom källkoden online, hämta referens för visning offline och gå igenom källor (inklusive korrigeringarna och programvaruuppdateringarna) vid felsökning. Se <bpt id="p1">[</bpt>instruktioner<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">Initierar en ny instans av den <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> klassen som anger en delegat som gör att ett objekt som ska skickas till tråden när tråden startades.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">En tråd börjar inte körs när den skapas.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">Om du vill schemalägga tråden för körning av anropa den &lt;xref:System.Threading.Thread.Start%2A&gt;metoden.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>To pass a data object to the thread, use the &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt; method overload.</source>
          <target state="translated">Om du vill lägga till ett dataobjekt i tråden, använda på &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;metodöverlagringen.&lt;/xref:System.Threading.Thread.Start%28System.Object%29&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Visual Basic-användare kan utelämna den &lt;xref:System.Threading.ThreadStart&gt;konstruktor när du skapar en tråd.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Använd den <ph id="ph1">`AddressOf`</ph> operatorn när metoden, till exempel <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic automatiskt anropar den &lt;xref:System.Threading.ThreadStart&gt;konstruktor.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">En delegat som representerar metoderna som anropas när denna tråd påbörjas.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">Initierar en ny instans av den <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> klass.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">En tråd börjar inte körs när den skapas.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">Om du vill schemalägga tråden för körning av anropa den &lt;xref:System.Threading.Thread.Start%2A&gt;metoden.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Visual Basic-användare kan utelämna den &lt;xref:System.Threading.ThreadStart&gt;konstruktor när du skapar en tråd.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Använd den <ph id="ph1">`AddressOf`</ph> operatorn när metoden till exempel <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic automatiskt anropar den &lt;xref:System.Threading.ThreadStart&gt;konstruktor.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">En <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegat som representerar metoderna som anropas när denna tråd påbörjas.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">Initierar en ny instans av den <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> klass, anger ett ombud som gör att ett objekt som ska skickas till tråden när tråden startades och anger den maximala storleken för tråden.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Undvik att använda den här konstruktorn överlagring.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">Standardstorleken för stacken som används av den &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;konstruktorn överlagring är den rekommenderade storleken för trådar.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Om en tråd har minnesproblem, är den mest troliga orsaken programmera fel, till exempel oändlig rekursion.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Från och med den <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, enbart fullständigt betrodd kod kan du ange <ph id="ph3">`maxStackSize`</ph> till ett värde som är större än standardstorleken stack (1 megabyte).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Om ett större värde har angetts för <ph id="ph1">`maxStackSize`</ph> när koden körs med partiellt förtroende <ph id="ph2">`maxStackSize`</ph> ignoreras och används för stacken standardstorleken.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">Inget undantag genereras.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Kod på någon förtroendenivån kan du ange <ph id="ph1">`maxStackSize`</ph> till ett värde som är mindre än standardstorleken för stacken.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Om du utvecklar ett fullständigt betrodd bibliotek som ska användas av delvis betrodd kod och måste du starta en tråd som kräver en stor stack, måste du assert fullständigt förtroende innan du skapar tråden eller stacken standardstorleken kommer att användas.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Gör inte detta om inte helt styra den kod som körs på tråden.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Om <ph id="ph1">`maxStackSize`</ph> är mindre än den minsta storleken, används den minsta storleken.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Om <ph id="ph1">`maxStackSize`</ph> är inte en multipel av storleken på sidan den avrundas till nästa större multipel av storleken på sidan.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Till exempel om du använder .NET Framework version 2.0 i Windows Vista, 256KB (262 144 byte) är den minsta storleken och sidstorleken är 64KB (65 536 byte).</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; På versioner av Microsoft Windows innan Windows XP och Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> ignoreras och stackstorleken som angetts i rubriken körbara används.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Om du anger en liten storlek kan behöva du inaktivera avsökning av stackspill.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">När stacken är mycket begränsad, kan den sökning själva orsaka stackspill.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Om du vill inaktivera avsökning av stack spill, lägger du till följande i programmets konfigurationsfil.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">En <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegat som representerar metoderna som anropas när denna tråd påbörjas.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Maximal stack storlek i byte som ska användas av tråden, eller 0 för att använda standard maximala stackstorleken angetts i rubriken för den körbara filen.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Viktigt för delvis betrodd kod, <ph id="ph1">`maxStackSize`</ph> ignoreras om den är större än standardstorleken för stacken.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">Inget undantag genereras.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>är mindre än noll.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">Initierar en ny instans av den <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> klassen som anger den maximala storleken för tråden.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Undvik att använda den här konstruktorn överlagring.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">Standardstorleken för stacken som används av den &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;konstruktorn överlagring är den rekommenderade storleken för trådar.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Om en tråd har minnesproblem, är den mest troliga orsaken programmera fel, till exempel oändlig rekursion.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Från och med den <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, enbart fullständigt betrodd kod kan du ange <ph id="ph3">`maxStackSize`</ph> till ett värde som är större än standardstorleken stack (1 megabyte).</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Om ett större värde har angetts för <ph id="ph1">`maxStackSize`</ph> när koden körs med partiellt förtroende <ph id="ph2">`maxStackSize`</ph> ignoreras och används för stacken standardstorleken.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">Inget undantag genereras.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Kod på någon förtroendenivån kan du ange <ph id="ph1">`maxStackSize`</ph> till ett värde som är mindre än standardstorleken för stacken.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Om du utvecklar ett fullständigt betrodd bibliotek som ska användas av delvis betrodd kod och måste du starta en tråd som kräver en stor stack, måste du assert fullständigt förtroende innan du skapar tråden eller stacken standardstorleken kommer att användas.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Gör inte detta om inte helt styra den kod som körs på tråden.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Om <ph id="ph1">`maxStackSize`</ph> är mindre än den minsta storleken, används den minsta storleken.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Om <ph id="ph1">`maxStackSize`</ph> är inte en multipel av storleken på sidan den avrundas till nästa större multipel av storleken på sidan.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Till exempel om du använder .NET Framework version 2.0 i Windows Vista, 256KB (262 144 byte) är den minsta storleken och sidstorleken är 64KB (65 536 byte).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; På versioner av Microsoft Windows innan Windows XP och Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> ignoreras och stackstorleken som angetts i rubriken körbara används.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Om du anger en liten storlek kan behöva du inaktivera avsökning av stackspill.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">När stacken är mycket begränsad, kan den sökning själva orsaka stackspill.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Om du vill inaktivera avsökning av stack spill, lägger du till följande i programmets konfigurationsfil.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">En <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegat som representerar metoderna som anropas när denna tråd påbörjas.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Maximal stack storlek i byte som ska användas av tråden, eller 0 för att använda standard maximala stackstorleken angetts i rubriken för den körbara filen.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Viktigt för delvis betrodd kod, <ph id="ph1">`maxStackSize`</ph> ignoreras om den är större än standardstorleken för stacken.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">Inget undantag genereras.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>är mindre än noll.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Genererar en <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> i tråden som metoden anropas, om du vill påbörja avslutar tråden.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Den här metoden anropas vanligtvis avbryter tråden.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">När den här metoden anropas på en tråd utlöser systemet en &lt;xref:System.Threading.ThreadAbortException&gt;i tråden att avbryta det.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>ett undantag som kan fångas upp av programkod, men är nytt utlöses i slutet av den <ph id="ph2">`catch`</ph> blockera om &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;kallas.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Avbryter begäran om att avbryta, och förhindrar att den <ph id="ph2">`ThreadAbortException`</ph> avbryter tråden.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Ångra <ph id="ph1">`finally`</ph> block körs innan Tråden avbröts.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; När en tråd anropar <ph id="ph2">`Abort`</ph> på själva effekten liknar genererar ett undantag, den &lt;xref:System.Threading.ThreadAbortException&gt;sker omedelbart, och resultatet är förutsägbara.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Men om en tråd anropar <ph id="ph1">`Abort`</ph> på en annan tråd avbrottet avbryter oavsett koden körs.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">Det finns också en risk att en statisk konstruktor kan avbrytas.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">I sällsynta fall kan detta förhindra instanser av klassen skapas i den domänen.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">I .NET Framework-versioner 1.0- och 1.1 ökar risken för tråden kan avbryta när en <ph id="ph1">`finally`</ph> block körs då den <ph id="ph2">`finally`</ph> block har avbrutits.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">Tråden är inte säkert att avbryta direkt eller alls.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Den här situationen kan inträffa om en tråd har ett obegränsat antal beräkningar i den <ph id="ph1">`finally`</ph> block som kallas som en del av proceduren avbrott, vilket på obestämd tid fördröja avbrottet.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee the wait will end.</source>
          <target state="translated">Om du vill vänta tills en tråd har avbrutits, kan du anropa den &lt;xref:System.Threading.Thread.Join%2A&gt;metoden tråd när du anropar Abort-metoden, men det är inte säkert väntetiden avslutas.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls Abort might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Tråden som anropar Avbryt kan blockera om tråden som är avbryts är i ett skyddat område i koden, som en <ph id="ph2">`catch`</ph> block <ph id="ph3">`finally`</ph> block eller begränsat körningsområde.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls Abort holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Om tråden som anropar Avbryt har ett lås som den avbrutna tråden kräver, kan det uppstå ett dödläge.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">Om <ph id="ph1">`Abort`</ph> anropas på en tråd som inte har startats tråden avbryts när &lt;xref:System.Threading.Thread.Start%2A&gt;anropas.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Om <ph id="ph1">`Abort`</ph> anropas på en tråd som är blockerad eller är i viloläge tråden avbryts och sedan avbryts.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">Om <ph id="ph1">`Abort`</ph> anropas på en tråd som har pausats kan en &lt;xref:System.Threading.ThreadStateException&gt;genereras i tråden som kallas &lt;xref:System.Threading.Thread.Abort%2A&gt;, och &lt;xref:System.Threading.ThreadState&gt;läggs till i &lt;xref:System.Threading.Thread.ThreadState%2A&gt;-egenskapen för tråden som avslutades.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">En &lt;xref:System.Threading.ThreadAbortException&gt;inte genereras i avbrutna tråden tills &lt;xref:System.Threading.Thread.Resume%2A&gt;kallas.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Om <ph id="ph1">`Abort`</ph> anropas på en hanterad tråd medan det körs ohanterad kod en <ph id="ph2">`ThreadAbortException`</ph> genereras inte förrän tråden returnerar till förvaltad kod.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Om två anrop till <ph id="ph1">`Abort`</ph> kommer samtidigt, är det möjligt för ett anrop för att ange tillståndsinformationen och andra anropet för att köra den <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Ett program kan emellertid identifiera denna situation.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Efter <ph id="ph1">`Abort`</ph> anropas på en tråd Trådens tillstånd inkluderar &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">När tråden har avslutats på grund av en lyckade anrop till <ph id="ph1">`Abort`</ph>, Trådens tillstånd ändras till &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Med tillräcklig behörighet, en tråd som är mål för en <ph id="ph1">`Abort`</ph> kan avbryta Avbryt med hjälp av den <ph id="ph2">`ResetAbort`</ph> metoden.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Ett exempel som visar anropar den <ph id="ph1">`ResetAbort`</ph> -metoden finns i <ph id="ph2">`ThreadAbortException`</ph> klass.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Anroparen har inte behörigheten som krävs.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">Tråden är avbryts är tillfälligt avbruten.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">Genererar en <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> i tråden som metoden anropas, om du vill påbörja avslutar tråden samtidigt som undantagsinformation om tråden avbröts.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Den här metoden anropas vanligtvis avbryter tråden.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">När den här metoden anropas på en tråd utlöser systemet en &lt;xref:System.Threading.ThreadAbortException&gt;i tråden att avbryta det.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>ett undantag som kan fångas upp av programkod, men är nytt utlöses i slutet av den <ph id="ph2">`catch`</ph> blockera om &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;kallas.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Avbryter begäran om att avbryta, och förhindrar att den <ph id="ph2">`ThreadAbortException`</ph> avbryter tråden.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Ångra <ph id="ph1">`finally`</ph> block körs innan Tråden avbröts.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; När en tråd anropar <ph id="ph2">`Abort`</ph> på själva effekten liknar genererar ett undantag, den &lt;xref:System.Threading.ThreadAbortException&gt;sker omedelbart, och resultatet är förutsägbara.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Men om en tråd anropar <ph id="ph1">`Abort`</ph> på en annan tråd avbrottet avbryter oavsett koden körs.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">Det finns en risk att en statisk konstruktor kan avbrytas.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">I sällsynta fall kan detta förhindra instanser av klassen skapas i den domänen.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">I .NET Framework-versioner 1.0- och 1.1 ökar risken för tråden kan avbryta när en <ph id="ph1">`finally`</ph> block körs då den <ph id="ph2">`finally`</ph> block har avbrutits.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">Tråden är inte säkert att avbryta direkt eller alls.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Den här situationen kan inträffa om en tråd har ett obegränsat antal beräkningar i den <ph id="ph1">`finally`</ph> block som kallas som en del av proceduren avbrott, vilket på obestämd tid fördröja avbrottet.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee that the wait will end.</source>
          <target state="translated">Om du vill vänta tills en tråd har avbrutits, kan du anropa den &lt;xref:System.Threading.Thread.Join%2A&gt;metoden tråd när du anropar Abort-metoden, men det finns ingen garanti för att vänta avslutas.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Tråden som anropar &lt;xref:System.Threading.Thread.Abort%2A&gt;kan blockera om tråden som är avbryts är i ett skyddat område i koden, som en <ph id="ph2">`catch`</ph> block <ph id="ph3">`finally`</ph> block eller begränsat körningsområde.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Om tråden som anropar &lt;xref:System.Threading.Thread.Abort%2A&gt;har ett lås som krävs för den avbrutna tråden, kan uppstå ett dödläge.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">Om <ph id="ph1">`Abort`</ph> anropas på en tråd som inte har startats tråden avbryts när &lt;xref:System.Threading.Thread.Start%2A&gt;anropas.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Om <ph id="ph1">`Abort`</ph> anropas på en tråd som är blockerad eller är i viloläge tråden avbryts och sedan avbryts.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">Om <ph id="ph1">`Abort`</ph> anropas på en tråd som har pausats kan en &lt;xref:System.Threading.ThreadStateException&gt;genereras i tråden som kallas &lt;xref:System.Threading.Thread.Abort%2A&gt;, och &lt;xref:System.Threading.ThreadState&gt;läggs till i &lt;xref:System.Threading.Thread.ThreadState%2A&gt;-egenskapen för tråden som avslutades.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">En &lt;xref:System.Threading.ThreadAbortException&gt;inte genereras i avbrutna tråden tills &lt;xref:System.Threading.Thread.Resume%2A&gt;kallas.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Om <ph id="ph1">`Abort`</ph> anropas på en hanterad tråd medan det körs ohanterad kod en <ph id="ph2">`ThreadAbortException`</ph> genereras inte förrän tråden returnerar till förvaltad kod.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Om två anrop till <ph id="ph1">`Abort`</ph> kommer samtidigt, är det möjligt för ett anrop för att ange tillståndsinformationen och andra anropet för att köra den <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Ett program kan emellertid identifiera denna situation.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Efter <ph id="ph1">`Abort`</ph> anropas på en tråd Trådens tillstånd inkluderar &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">När tråden har avslutats på grund av en lyckade anrop till <ph id="ph1">`Abort`</ph>, Trådens tillstånd ändras till &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Med tillräcklig behörighet, en tråd som är mål för en <ph id="ph1">`Abort`</ph> kan avbryta Avbryt med hjälp av den <ph id="ph2">`ResetAbort`</ph> metoden.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Ett exempel som visar anropar den <ph id="ph1">`ResetAbort`</ph> -metoden finns i <ph id="ph2">`ThreadAbortException`</ph> klass.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">Ett objekt som innehåller programspecifik information, till exempel tillstånd, som kan användas av tråden som avslutades.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Anroparen har inte behörigheten som krävs.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">Tråden är avbryts är tillfälligt avbruten.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">Allokerar en namnlösa datautrymmet på alla trådar.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">För bättre prestanda använder fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut i stället.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut) och data kortplatser.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Mer information om hur du använder TLS finns <bpt id="p1">[</bpt>tråd lokal lagring: tråden relativt statiska fält och Data fack<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">Platsen är allokerat på alla trådar.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime allokerar en matris med flera fack data store på varje process när den skapas.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Data platser är unikt för varje tråd.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Den allokerade namngivna datautrymmet på alla trådar.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">Allokerar en namngiven datautrymmet på alla trådar.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">För bättre prestanda använder fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut i stället.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut) och data kortplatser.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Mer information om hur du använder TLS finns <bpt id="p1">[</bpt>tråd lokal lagring: tråden relativt statiska fält och Data fack<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime allokerar en matris med flera fack data store på varje process när den skapas.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Data platser är unikt för varje tråd.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not necessary to use the AllocateNamedDataSlot method to allocate a named data slot, because the &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; method allocates the slot if it has not already been allocated.</source>
          <target state="translated">Det är inte nödvändigt att använda metoden AllocateNamedDataSlot för att allokera en namngiven datautrymmet eftersom den &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;metoden allokerar facket om den inte redan är tilldelad.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Om metoden AllocateNamedDataSlot används den ska anropas i huvudtråden vid programstart, eftersom den genererar ett undantag om en plats med det angivna namnet har redan allokerats.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">Det går inte att kontrollera om en plats har redan allokerats.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Slots allocated with this method must be freed with &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.</source>
          <target state="translated">Med den här metoden har allokerats måste frigöras med &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.&lt;/xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">Namnet på datautrymmet allokeras.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Den allokerade namngivna datautrymmet på alla trådar.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">En namngiven datautrymmet med det angivna namnet finns redan.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">Hämtar eller anger inneslutningstillståndet för tråden.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>The ApartmentState property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Egenskapen försöka är föråldrad.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>The non-obsolete alternatives are the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method to retrieve the apartment state and the   &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method to set the apartment state.</source>
          <target state="translated">Ej föråldrade alternativen är den &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;metod för att hämta inneslutningstillståndet och &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;metod för att ställa in inneslutningstillståndet.&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">I .NET Framework-version 1.0 och 1.1, den <ph id="ph1">`ApartmentState`</ph> egenskapen markerar en tråd för att ange att den körs i en enkeltrådad eller flertrådade inneslutning.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">Den här egenskapen kan anges när tråden är i den <ph id="ph1">`Unstarted`</ph> eller <ph id="ph2">`Running`</ph> tråd tillstånd, men den kan bara anges en gång för en tråd.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">Om egenskapen inte har angetts, returnerar <ph id="ph1">`Unknown`</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to use the ApartmentState property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">Ett försök att använda egenskapen försöka att ställa in en tråd har redan ställts in vars inneslutningstillståndet-inneslutningstillståndet ignoreras.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method throws a &lt;xref:System.InvalidOperationException&gt; in this case.</source>
          <target state="translated">Men den &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;metoden returnerar en &lt;xref:System.InvalidOperationException&gt;i det här fallet.&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  In the .NET Framework version 2.0, new threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; In the .NET Framework version 2.0, nya trådar har initierats som &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;om deras inneslutningstillståndet inte har angetts innan de startas.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">Programmets tråden har initierats till &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;som standard.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can no longer set the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by setting the &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; property on the first line of code.</source>
          <target state="translated">Du kan inte längre ange programmets tråd och &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;genom att ange den &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;egenskapen på den första raden i koden.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.STAThreadAttribute&gt; instead.</source>
          <target state="translated">Använd den &lt;xref:System.STAThreadAttribute&gt;i stället.&lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> linker option.</source>
          <target state="translated">Du kan ange COM trådad modell för att använda en C++ program i .NET Framework version 2.0 av <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Ange CLR-tråden attribut)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> länkaralternativet.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">En av de <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> värden.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Det första värdet är <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) or multithreaded apartment (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</source>
          <target state="translated">Ett försök görs att ange egenskapen till ett tillstånd som inte är en giltig inneslutningstillståndet (ett annat tillstånd än enkeltrådad inneslutning (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) eller flertrådade innesluten (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">Meddelar en värd att körningen håller på att ange en region i koden där effekterna av att en tråd Avbryt eller undantag kan äventyra andra aktiviteter i programdomänen.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Värdar för CLR (CLR), till exempel Microsoft SQL Server 2005 kan upprätta olika principer för fel i kritiska och icke-kritiska områden i koden.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">En kritisk region är ett där effekterna av att en tråd Avbryt eller ett ohanterat undantag inte kanske är begränsad till den aktuella aktiviteten.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Däremot påverkar ett avbrott eller fel i en icke-kritiska region i koden endast aktiviteten där felet inträffar.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Anta till exempel att en uppgift som försöker att allokera minne Håll ett lås.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Om det inte går att allokera minne, avbryter den aktuella åtgärden är inte tillräcklig för stabilitet i &lt;xref:System.AppDomain&gt;, eftersom det kan finnas andra uppgifter i den domän som väntar på samma låset.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Om den aktuella aktiviteten avslutas kan du ett dödläge andra aktiviteter.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">När ett fel uppstår i en kritisk region, värden kan besluta att ta bort hela &lt;xref:System.AppDomain&gt;i stället för att ta risken för fortsätter körningen i ett potentiellt instabilt tillstånd.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call BeginCriticalRegion.</source>
          <target state="translated">För att informera värden att koden är att ange en kritisk region, anropa BeginCriticalRegion.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt; when execution returns to a non-critical region of code.</source>
          <target state="translated">Anropa &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;när körningen returnerar till en icke-kritiska region i koden.&lt;/xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Med den här metoden i kod som körs i SQL Server 2005 kräver koden som ska köras vid den högsta skyddsnivån för värden.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Meddelar en värd som förvaltad kod håller på att köra instruktioner som är beroende av identiteten för den aktuella tråden fysiska operativsystem.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Vissa värdar i CLR, till exempel Microsoft SQL Server 2005, tillhandahålla sina egna tråd-hantering.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">En värd som tillhandahåller egna tråd hantering kan du flytta en aktivitet som körs från en fysisk operativsystemstråden till en annan när som helst.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">De flesta uppgifter påverkas inte av den här växlar.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Dock vissa aktiviteter har trådtilldelning - som är de beroende av identiteten för en fysisk operativsystemet tråd.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Dessa uppgifter måste informera värden när de kör kod som inte bör stängas.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call BeginThreadAffinity before acquiring the lock, and &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt; after releasing the lock.</source>
          <target state="translated">Till exempel om programmet anropar system API för att låsa ett operativsystem som har trådtilldelning, till exempel en Win32-CRITICAL_SECTION måste du anropa BeginThreadAffinity innan låshämtning, och &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;efter bort låset.&lt;/xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Med den här metoden i kod som körs i SQL Server 2005 kräver koden som ska köras vid den högsta skyddsnivån för värden.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Anroparen har inte behörigheten som krävs.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">Hämtar den aktuella kontexten där tråden körs.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current thread context.</source>
          <target state="translated">En <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> som representerar den aktuella tråd-kontexten.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Anroparen har inte behörigheten som krävs.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">Hämtar eller anger kulturen för den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Globalization.CultureInfo&gt; object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">Den &lt;xref:System.Globalization.CultureInfo&gt;objekt som returneras av den här egenskapen tillsammans med alla associerade objekt avgöra standardformatet för datum, tider, siffror, valuta, sorteringsordning för text, versaler och gemener konventioner, och de jämförelser.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo&gt; class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">Finns det &lt;xref:System.Globalization.CultureInfo&gt;klassen om du vill lära kultur namn och identifierare, skillnaderna mellan invariant neutral och specifika kulturer och hur kultur informationen påverkar trådar och programdomäner.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt; property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">Finns det &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;egenskapen vill lära dig hur en tråd standardkulturen bestäms och hur användare ange information om kultur för sina datorer.&lt;/xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, you can set the CurrentCulture property to a neutral culture.</source>
          <target state="translated">Från och med den <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, kan du ange egenskapen CurrentCulture till en neutral kultur.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the behavior of the &lt;xref:System.Globalization.CultureInfo&gt; class has changed: When it represents a neutral culture, its property values (in particular, the &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, and &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt; properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">Detta beror på att beteendet för den &lt;xref:System.Globalization.CultureInfo&gt;klass har ändrats: när den representerar en neutral kultur egenskapsvärdena (särskilt den &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, och &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;Egenskaper) nu återspeglar specifik kultur som är associerad med neutral kultur.&lt;/xref:System.Globalization.CultureInfo.TextInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.NumberFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.CompareInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.Calendar%2A&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>In earlier versions of the .NET Framework, the CurrentCulture property threw a &lt;xref:System.NotSupportedException&gt; exception when a neutral culture was assigned.</source>
          <target state="translated">I tidigare versioner av .NET Framework egenskapen CurrentCulture utlöste ett &lt;xref:System.NotSupportedException&gt;undantag när en neutral kultur tilldelades.&lt;/xref:System.NotSupportedException&gt;</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">Ett objekt som representerar kultur för den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Egenskapen anges till <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">Hämtar eller anger trådens aktuella huvudnamn (för rollbaserad säkerhet).</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Security.Principal.IPrincipal&gt; value representing the security context.</source>
          <target state="translated">En &lt;xref:System.Security.Principal.IPrincipal&gt;-värde som representerar säkerhetskontexten.&lt;/xref:System.Security.Principal.IPrincipal&gt;</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">Anroparen har inte den behörighet som krävs för att ange huvudnamn.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Gets the currently running thread.</source>
          <target state="translated">Hämtar tråden som för närvarande körs.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is the representation of the currently running thread.</source>
          <target state="translated">En <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> som är en representation av tråden som för närvarande körs.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">Hämtar eller anger den aktuella kulturen som används av Resource Manager för att leta upp kultur-specifika resurser vid körning.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>An object that represents the current culture.</source>
          <target state="translated">Ett objekt som representerar den aktuella kulturen.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Egenskapen anges till <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">Egenskapen anges till ett kulturnamn som inte kan användas för att hitta en resursfil.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">Resursfilnamn måste innehålla endast bokstäver, siffror, bindestreck och understreck.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">Stänger av automatisk rensning av körningsmiljön callable omslutningar (RCW) för den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">Som standard rensar common language runtime (CLR) runtime callable omslutningar automatiskt.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:      -   The application does its own message pumping.</source>
          <target state="translated">CLR pumpar meddelanden under rensning, vilket kan orsaka problem återinträde för några program som uppfyller följande kriterier för ovanliga:-programmet har ett eget meddelande pumpa.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">-Programmet måste kontrollera exakt när meddelandet pumpa inträffar.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such applications can use the DisableComObjectEagerCleanup method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">Sådana program kan använda metoden DisableComObjectEagerCleanup för att förhindra att CLR automatisk makulering av körningsmiljön callable omslutningar.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">När den här metoden har anropats på en tråd, kan inte automatisk rensning aktiveras igen för tråden.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application is ready to clean up runtime callable wrappers, use the &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt; method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">När programmet är redo att rensa runtime callable omslutningar använder den &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;metod för att instruera runtime att rensa alla runtime callable omslutningar i den aktuella kontexten.&lt;/xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">Meddelandet pumpa inträffar när metoden körs.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">Meddelar en värd att körningen håller på att ange en del av kod som effekterna av att en tråd Avbryt eller undantag är begränsad till den aktuella aktiviteten.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Värdar för CLR (CLR), till exempel Microsoft SQL Server 2005 kan upprätta olika principer för fel i kritiska och icke-kritiska områden i koden.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">En kritisk region är ett där effekterna av att en tråd Avbryt eller ett ohanterat undantag inte kanske är begränsad till den aktuella aktiviteten.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Däremot påverkar ett avbrott eller fel i en icke-kritiska region i koden endast aktiviteten där felet inträffar.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Anta till exempel att en uppgift som försöker att allokera minne Håll ett lås.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Om det inte går att allokera minne, avbryter den aktuella åtgärden är inte tillräcklig för stabilitet i &lt;xref:System.AppDomain&gt;, eftersom det kan finnas andra uppgifter i den domän som väntar på samma låset.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Om den aktuella aktiviteten avslutas kan du ett dödläge andra aktiviteter.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">När ett fel uppstår i en kritisk region, värden kan besluta att ta bort hela &lt;xref:System.AppDomain&gt;i stället för att ta risken för fortsätter körningen i ett potentiellt instabilt tillstånd.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.</source>
          <target state="translated">För att informera värden att koden är att ange en kritisk region, anropa &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.&lt;/xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call EndCriticalRegion when execution returns to a non-critical region of code.</source>
          <target state="translated">Anropa EndCriticalRegion när körningen återgår till en icke-kritiska region i koden.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Med den här metoden i kod som körs i SQL Server 2005 kräver koden som ska köras vid den högsta skyddsnivån för värden.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Meddelar en värd som förvaltad kod har avslutats instruktioner som är beroende av identiteten för den aktuella tråden fysiska operativsystem.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Vissa värdar i CLR, till exempel Microsoft SQL Server 2005, tillhandahålla sina egna tråd-hantering.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">En värd som tillhandahåller egna tråd hantering kan du flytta en aktivitet som körs från en fysisk operativsystemstråden till en annan när som helst.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">De flesta uppgifter påverkas inte av den här växlar.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Dock vissa aktiviteter har trådtilldelning - som är de beroende av identiteten för en fysisk operativsystemet tråd.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Dessa uppgifter måste informera värden när de kör kod som inte bör stängas.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt; before acquiring the lock, and EndThreadAffinity after releasing the lock.</source>
          <target state="translated">Om exempelvis låsa dina program anrop en system-API att erhålla ett operativsystem som har trådtilldelning, till exempel en Win32-CRITICAL_SECTION måste du anropa &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;innan införskaffa lock och EndThreadAffinity efter bort låset.&lt;/xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Med den här metoden i kod som körs i SQL Server 2005 kräver koden som ska köras vid den högsta skyddsnivån för värden.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Anroparen har inte behörigheten som krävs.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Gets an &lt;xref:System.Threading.ExecutionContext&gt; object that contains information about the various contexts of the current thread.</source>
          <target state="translated">Hämtar en &lt;xref:System.Threading.ExecutionContext&gt;objekt som innehåller information om olika kontexter för den aktuella tråden.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Threading.ExecutionContext&gt; class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">Den &lt;xref:System.Threading.ExecutionContext&gt;klassen innehåller en enskild behållare för all information som är relevanta för en logisk tråd av körningen.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">Detta inkluderar säkerhetskontext, anrop kontext, synkroniseringskontext, lokalisering kontext och transaktionskontext.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Threading.ExecutionContext&gt; object that consolidates context information for the current thread.</source>
          <target state="translated">En &lt;xref:System.Threading.ExecutionContext&gt;objekt som konsoliderar omständighetsinformation för den aktuella tråden.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">Säkerställer att frigörs resurser och andra rensningsåtgärder utförs när skräpinsamlingen återtar den <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objekt.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector calls Finalize when the current object is ready to be finalized.</source>
          <target state="translated">Skräpinsamlingen anropar Finalize när det aktuella objektet är redo att slutföras.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">Tar bort associationen mellan ett namn och en plats för alla trådar i processen.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">För bättre prestanda använder fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut i stället.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut) och data kortplatser.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Mer information om hur du använder TLS finns <bpt id="p1">[</bpt>tråd lokal lagring: tråden relativt statiska fält och Data fack<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">När någon tråd anrop <ph id="ph1">`FreeNamedDataSlot`</ph>, en tråd som anropar &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;med samma namn kommer att allokera en ny plats som är associerade med namnet.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">Efterföljande anrop till <ph id="ph1">`GetNamedDataSlot`</ph> av en tråd returneras den nya platsen.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, any thread that still has a &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt; returned by an earlier call to <ph id="ph1">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">En tråd som fortfarande har dock en &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;returnerades av ett tidigare anrop till <ph id="ph1">`GetNamedDataSlot`</ph> kan fortsätta att använda den gamla platsen.&lt;/xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">En plats som har associerats med ett namn som släpps endast när alla <ph id="ph1">`LocalDataStoreSlot`</ph> som har hämtats innan anropet till <ph id="ph2">`FreeNamedDataSlot`</ph> har släppts och skräpinsamlats.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime allokerar en matris med flera fack data store på varje process när den skapas.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Data platser är unikt för varje tråd.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">Namnet på datautrymmet att frigöras.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value indicating the apartment state.</source>
          <target state="translated">Returnerar en <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> värde som anger läget inneslutning.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method, along with the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">Den här metoden tillsammans med den &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;metoden och &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;metod, ersätter den &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;egenskapen.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the apartment state of the managed thread.</source>
          <target state="translated">En av de <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> värden som anger inneslutningstillståndet för hanterade tråden.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Standardvärdet är <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">Returnerar en <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objekt som kan användas för att avbilda stacken för den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">Den här metoden stöds inte längre.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">Ingen.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">I samtliga fall.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">Hämtar värdet från den angivna platsen på den aktuella tråden i den aktuella trådens aktuella domänen.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">För bättre prestanda använder fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut i stället.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut) och data kortplatser.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Mer information om hur du använder TLS finns <bpt id="p1">[</bpt>tråd lokal lagring: tråden relativt statiska fält och Data fack<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime allokerar en matris med flera fack data store på varje process när den skapas.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Data platser är unikt för varje tråd.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  GetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; GetData är en <ph id="ph2">`Shared`</ph> metod som gäller för tråden körs alltid även om du anropar den med hjälp av en variabel som refererar till en annan tråd.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">För att undvika förvirring använder klassnamnet vid anrop av <ph id="ph1">`Shared`</ph> metoder: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to get the value.</source>
          <target state="translated">Den <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> som du vill hämta värdet från.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The retrieved value.</source>
          <target state="translated">Det hämtade värdet.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">Returnerar den aktuella domänen som den aktuella tråden körs.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current application domain of the running thread.</source>
          <target state="translated">En <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> som representerar den aktuella programdomänen för tråden körs.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">Returnerar en unik identifierare för domänen.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">En 32-bitars heltal unikt identifierar programdomänen.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">Returnerar ett hash-koden för den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">Hash-koden är inte säkert att vara unika.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property if you need a unique identifier for a managed thread.</source>
          <target state="translated">Använd den &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;egenskapen om du behöver en unik identifierare för en hanterad tråd.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>An integer hash code value.</source>
          <target state="translated">Ett hash-kod heltal.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Looks up a named data slot.</source>
          <target state="translated">Slår upp en namngiven datautrymmet.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">För bättre prestanda använder fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut i stället.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut) och data kortplatser.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Mer information om hur du använder TLS finns <bpt id="p1">[</bpt>tråd lokal lagring: tråden relativt statiska fält och Data fack<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime allokerar en matris med flera fack data store på varje process när den skapas.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Data platser är unikt för varje tråd.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">Om den namngivna platsen inte finns, allokeras en ny plats.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">Namngivna data fack är offentlig och kan ändras av någon.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The name of the local data slot.</source>
          <target state="translated">Namnet på den lokala datautrymmet.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> allocated for this thread.</source>
          <target state="translated">En <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> allokerats för den här tråden.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Interrupts a thread that is in the <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> thread state.</source>
          <target state="translated">Avbryter en tråd som den <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> tråd tillstånd.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">Om den här tråden inte är blockerad i vänta, viloläge och anslutningstillståndet, avbryts den när den börjar nästa blockera.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ThreadInterruptedException&gt; is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadInterruptedException&gt;genereras i den avbrutna tråden, men inte förrän tråd-block.&lt;/xref:System.Threading.ThreadInterruptedException&gt;</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">Om tråden blockerar aldrig, den undantag aldrig och därmed tråden kan slutföras utan att någonsin avbryts.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Anroparen har inte rätt <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">Hämtar ett värde som anger status för körningen av den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread has been started and has not terminated normally or aborted; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Om den här tråden har startat och har inte avslutats normalt eller avbrutits; Annars <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">Hämtar eller anger ett värde som anger huruvida en tråd är en bakgrundstråd.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">En tråd är en bakgrundstråd eller en tråd i förgrunden.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">Bakgrundstrådar är identiska med förgrunden trådar, förutom att bakgrundstrådar inte förhindrar att en process avslutas.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">När alla förgrunden trådar som hör till en process har avslutats, avslutas CLR processen.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">Alla återstående bakgrundstrådar har stoppats och att slutföra inte.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground (that is, their IsBackground property returns <ph id="ph1">`false`</ph>):      -   The primary thread (or main application thread).</source>
          <target state="translated">Som standard följande trådarna körs i förgrunden (det vill säga deras IsBackground egenskapen returnerar <ph id="ph1">`false`</ph>):-primära tråden (eller programmets tråd).</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a &lt;xref:System.Threading.Thread&gt; class constructor.</source>
          <target state="translated">-Alla trådar som skapas genom att anropa en &lt;xref:System.Threading.Thread&gt;klasskonstruktor.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the background  (that is, their IsBackground property returns <ph id="ph1">`true`</ph>):      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Som standard följande trådar som körs i bakgrunden (det vill säga deras IsBackground egenskapen returnerar <ph id="ph1">`true`</ph>):-tråd pool trådar, som är en pool av trådar som underhålls av körningsmiljön.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">Du kan konfigurera tråd pool och schema arbete på tråd pool trådar med hjälp av &lt;xref:System.Threading.ThreadPool&gt;klassen.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Uppgiftsbaserade asynkrona åtgärder kör automatiskt på tråd pool trådar.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-Alla trådar som anger den hantera körningsmiljön från ohanterad kod.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread is or is to become a background thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Om den här tråden är eller ska bli en bakgrundstråd; Annars <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The thread is dead.</source>
          <target state="translated">Tråden är död.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">Hämtar ett värde som anger huruvida en tråd som tillhör hanterade trådpoolen.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Mer information finns i <bpt id="p1">[</bpt>i hanterad tråd grupp<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread belongs to the managed thread pool; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Om den här tråden som tillhör hanterade trådpoolen; Annars <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> pumping.</source>
          <target state="translated">Blockerar den anropande tråden tills den tråd som representeras av den här instansen avslutas, medan du utför vanliga COM och <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> pumpa.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose Join method is called has completed.</source>
          <target state="translated">Koppling är en synkroniseringsmetod som blockerar den anropande tråden (det vill säga tråden som anropar metoden) tills tråden vars koppling anropas metoden har slutförts.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">Använd den här metoden för att säkerställa att en tråd har avslutats.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">Anroparen blockeras utan tidsbegränsning om tråden inte avslutas.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the Join method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block until <ph id="ph4">`Thread2`</ph> has completed.</source>
          <target state="translated">I följande exempel visas den <ph id="ph1">`Thread1`</ph> tråden som anropar metoden Join i <ph id="ph2">`Thread2`</ph>, som orsakar <ph id="ph3">`Thread1`</ph> att blockera tills <ph id="ph4">`Thread2`</ph> har slutförts.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept><ept id="p3">]</ept>       If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept> <ept id="p3">]</ept> om tråden har redan avslutats när &lt;xref:System.Threading.Thread.Join%2A&gt;anropas metoden returnerar omedelbart.&lt;/xref:System.Threading.Thread.Join%2A&gt;  </target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!WARNING]</ph> &gt;  You should never call the Join method of the &lt;xref:System.Threading.Thread&gt; object that represents the current thread from the current thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!WARNING]</ph> &gt; Du bör aldrig anropa metoden koppling för den &lt;xref:System.Threading.Thread&gt;objekt som representerar den aktuella tråden från den aktuella tråden.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,       This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">Detta gör att din app låser sig eftersom den aktuella tråden väntar på själva på obestämd tid den här metoden ändras tillståndet för den anropande tråden att inkludera &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Du kan inte anropa <ph id="ph1">`Join`</ph> på en tråd som finns i den &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;tillstånd.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">Anroparen försökte ansluta till en tråd som den <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> tillstånd.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">Tråden avbryts väntan.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Den anropande tråden tills den tråd som representeras av den här instansen slutar eller den angivna tiden går ut medan du utför vanliga COM och SendMessage pumpa block.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">Anslutning till är en synkroniseringsmetod som blockerar den anropande tråden (det vill säga tråden som anropar metoden) tills antingen tråden vars &lt;xref:System.Threading.Thread.Join%2A&gt;anropas metoden har slutförts eller timeout-intervall har förflutit.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">I följande exempel visas den <ph id="ph1">`Thread1`</ph> tråd anrop i &lt;xref:System.Threading.Thread.Join&gt;metod för <ph id="ph2">`Thread2`</ph>, som orsakar <ph id="ph3">`Thread1`</ph> att blockera antingen tills <ph id="ph4">`Thread2`</ph> har slutförts eller 2 sekunder har förflutit.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for the <ph id="ph1">`millisecondsTimeout`</ph> parameter, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept> <ept id="p3">]</ept> om &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;har angetts för den <ph id="ph1">`millisecondsTimeout`</ph> parameter för den här metoden fungerar identiskt till det &lt;xref:System.Threading.Thread.Join&gt;metodöverlagringen förutom returvärdet.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">Om tråden har redan avslutats när &lt;xref:System.Threading.Thread.Join%2A&gt;anropas metoden returnerar omedelbart.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">Den här metoden ändrar status för den anropande tråden att inkludera &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Du kan inte anropa <ph id="ph1">`Join`</ph> på en tråd som finns i den &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;tillstånd.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">Antal millisekunder att vänta på att avsluta tråden.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread has terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>om tråden har avslutats; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> om tråden inte har avslutats efter den tid som anges av den <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p3">&lt;/code&gt;</ept> parametern har gått ut.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds.</source>
          <target state="translated">Värdet för <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p1">&lt;/code&gt;</ept> är negativt och är inte lika med <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> i millisekunder.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The thread has not been started.</source>
          <target state="translated">Tråden har inte startats.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Den anropande tråden tills den tråd som representeras av den här instansen slutar eller den angivna tiden går ut medan du utför vanliga COM och SendMessage pumpa block.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">Anslutning till är en synkroniseringsmetod som blockerar den anropande tråden (det vill säga tråden som anropar metoden) tills antingen tråden vars &lt;xref:System.Threading.Thread.Join%2A&gt;anropas metoden har slutförts eller timeout-intervall har förflutit.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">I följande exempel visas den <ph id="ph1">`Thread1`</ph> tråd anrop i &lt;xref:System.Threading.Thread.Join&gt;metod för <ph id="ph2">`Thread2`</ph>, som orsakar <ph id="ph3">`Thread1`</ph> att blockera antingen tills <ph id="ph4">`Thread2`</ph> har slutförts eller 2 sekunder har förflutit.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for <ph id="ph1">`timeout`</ph>, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept> <ept id="p3">]</ept> om &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;har angetts för <ph id="ph1">`timeout`</ph>, den här metoden fungerar identiskt till det &lt;xref:System.Threading.Thread.Join&gt;metodöverlagringen förutom returvärdet.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">Om tråden har redan avslutats när &lt;xref:System.Threading.Thread.Join%2A&gt;anropas metoden returnerar omedelbart.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the current thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Den här metoden ändrar status för den aktuella tråden kan inkludera &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Du kan inte anropa <ph id="ph1">`Join`</ph> på en tråd som finns i den &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;tillstånd.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated">En &lt;xref:System.TimeSpan&gt;är inställda som hur lång tid att vänta på att tråden ska upphöra.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>om tråden som avslutades; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> om tråden inte har avslutats efter den tid som anges av den <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p3">&lt;/code&gt;</ept> parametern har gått ut.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">Värdet för <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> är negativt och är inte lika med <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> i millisekunder, eller är större än <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> millisekunder.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">Anroparen försökte ansluta till en tråd som den <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> tillstånd.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">Hämtar en unik identifierare för den aktuella hantera tråden.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread's ManagedThreadId property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">En tråd ManagedThreadId egenskapens värde används för att unikt identifiera tråden i dess process.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the ManagedThreadId property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">Värdet på egenskapen ManagedThreadId varierar inte över tiden, även om ohanterad kod som är värd för common language runtime implementerar tråd som ett fiber.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">Ett heltal som representerar en unik identifierare för den här hanterade tråden.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</source>
          <target state="translated">Synkroniserar minnesåtkomst på följande sätt: processorn köra den aktuella tråden kan inte ändra ordning instruktioner i ett sådant sätt att minne kommer åt innan anropet till MemoryBarrier köra efter minne åtkomster som följer anropet till MemoryBarrier.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>MemoryBarrier is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated">MemoryBarrier krävs endast på datorer med flera processorer med svag minne ordning (till exempel ett system med flera processorer med Intel Itanium).</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the &lt;xref:System.Threading.Monitor&gt; class provide easier ways to synchronize data.</source>
          <target state="translated">För de flesta ändamål är C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen eller &lt;xref:System.Threading.Monitor&gt;klassen tillhandahåller enklare sätt att synkronisera data.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">Hämtar eller anger namnet på tråden.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is write-once.</source>
          <target state="translated">Den här egenskapen är write-när.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the default value of a thread's Name property is <ph id="ph1">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Eftersom standardvärdet för en tråd namnegenskapen är <ph id="ph1">`null`</ph>, kan du bestämma om ett namn har redan uttryckligen tilldelats tråden genom att jämföra med <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string assigned to the Name property can include any Unicode character.</source>
          <target state="translated">Strängen som tilldelats egenskapen namn kan innehålla valfritt Unicode-tecken.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>A string containing the name of the thread, or <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if no name was set.</source>
          <target state="translated">En sträng som innehåller namnet på tråden eller <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> om inget namn angavs.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>A set operation was requested, but the <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> property has already been set.</source>
          <target state="translated">En set-åtgärd begärdes men <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> egenskapen har redan angetts.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">Hämtar eller anger ett värde som anger schemaläggning prioriteten för en tråd.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can be assigned any one of the following priority &lt;xref:System.Threading.ThreadPriority&gt; values:      -   <ph id="ph1">`Highest`</ph><ph id="ph2">      -   </ph><ph id="ph3">`AboveNormal`</ph><ph id="ph4">      -   </ph><ph id="ph5">`Normal`</ph><ph id="ph6">      -   </ph><ph id="ph7">`BelowNormal`</ph><ph id="ph8">      -   </ph><ph id="ph9">`Lowest`</ph>       Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">En tråd kan tilldelas någon av följande prioritet &lt;xref:System.Threading.ThreadPriority&gt;värden:- <ph id="ph1">`Highest`</ph> <ph id="ph2">      -   </ph> <ph id="ph3">`AboveNormal`</ph> <ph id="ph4">      -   </ph> <ph id="ph5">`Normal`</ph> <ph id="ph6">      -   </ph> <ph id="ph7">`BelowNormal`</ph> <ph id="ph8">      -   </ph> <ph id="ph9">`Lowest`</ph> operativsystem krävs inte för att respektera prioriteten för en tråd.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">En av de <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> värden.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Standardvärdet är <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The thread has reached a final state, such as <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Tråden har uppnått ett sluttillstånd som <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is not a valid <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">Det angivna värdet för en set-åtgärd inte är ett giltigt <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> värde.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Cancels an &lt;xref:System.Threading.Thread.Abort*&gt; requested for the current thread.</source>
          <target state="translated">Avbryter en &lt;xref:System.Threading.Thread.Abort*&gt;krävs för den aktuella tråden.&lt;/xref:System.Threading.Thread.Abort*&gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">Den här metoden kan endast anropas av kod med rätt behörighet.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt;.</source>
          <target state="translated">När ett anrop görs till <ph id="ph1">`Abort`</ph> för att avsluta en tråd, genererar systemet &lt;xref:System.Threading.ThreadAbortException&gt;.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>är ett undantag som kan fångas upp av programkod men igen i slutet av catch-blocket om <ph id="ph2">`ResetAbort`</ph> anropas.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Avbryter begäran om att avbryta, och förhindrar att den <ph id="ph2">`ThreadAbortException`</ph> avbryter tråden.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>See &lt;xref:System.Threading.ThreadAbortException&gt; for an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method.</source>
          <target state="translated">Se &lt;xref:System.Threading.ThreadAbortException&gt;ett exempel som visar anropar den <ph id="ph1">`ResetAbort`</ph> metoden.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> was not invoked on the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>anropades inte i den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">Anroparen har inte behörighet för den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">Återupptar en tråd som har pausats.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">Tråden har inte startats, svarar inte eller är inte i inaktiverat tillstånd.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Anroparen har inte rätt <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Anger en tråd-inneslutningstillståndet innan den startas.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">Nya trådar har initierats som &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;om deras inneslutningstillståndet inte har angetts innan de startas.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Inneslutningstillståndet måste anges innan en tråd har startats.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Programmets tråden har initierats till &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;som standard.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">Det enda sättet att ange inneslutningstillståndet för programmets tråden till &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;är att använda den &lt;xref:System.STAThreadAttribute&gt;attribut till metoden.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">Metoden SetApartmentState tillsammans med den &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;metoden och &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;metod, ersätter den &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;egenskapen.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">Läget inneslutning.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>är inte en giltig inneslutningstillståndet.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">Tråden har redan startats.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">Läget inneslutning har redan initierats.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Applies a captured <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the current thread.</source>
          <target state="translated">Tillämpar en avbildade <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> till den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">Den här metoden stöds inte längre.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to be applied to the current thread.</source>
          <target state="translated">Den <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objekt som ska tillämpas på den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">I samtliga fall.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">Anger data i den angivna platsen i den pågående tråden för trådens aktuella domänen.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>For better performance, use fields marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">För bättre prestanda använder fält som har markerats med den &lt;xref:System.ThreadStaticAttribute&gt;attribut i stället.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den &lt;xref:System.ThreadStaticAttribute&gt;attribut) och data kortplatser.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Mer information om hur du använder TLS finns <bpt id="p1">[</bpt>tråd lokal lagring: tråden relativt statiska fält och Data fack<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime allokerar en matris med flera fack data store på varje process när den skapas.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the &lt;xref:System.Threading.Thread&gt; object has been reclaimed by garbage collection.</source>
          <target state="translated">Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning efter tråd proceduren avslutas och &lt;xref:System.Threading.Thread&gt;objekt har återställts vid en skräpinsamling.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Data platser är unikt för varje tråd.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  SetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; SetData är en <ph id="ph2">`Shared`</ph> metod som gäller för tråden körs alltid även om du anropar den med hjälp av en variabel som refererar till en annan tråd.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">För att undvika förvirring använder klassnamnet vid anrop av <ph id="ph1">`Shared`</ph> metoder: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in which to set the value.</source>
          <target state="translated">Den <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> att ange värdet.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The value to be set.</source>
          <target state="translated">Värdet som anges.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">Stoppar den aktuella tråden för det angivna antalet millisekunder.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">Tråden kommer inte schemaläggas för körning av operativsystemet för den angivna tiden.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Den här metoden ändrar status för tråden att inkludera &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; for the <ph id="ph1">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Du kan ange &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;för den <ph id="ph1">`millisecondsTimeout`</ph> parametern pausa tråden under obestämd tid.&lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">Vi rekommenderar dock att du använder andra &lt;xref:System.Threading?displayProperty=fullName&gt;klasser som &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, eller &lt;xref:System.Threading.Semaphore&gt;i stället till sychronize trådar eller hantera resurser.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">Systemets klocka tick med ett specifikt intervall kallas klockan lösning.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">Den faktiska tidsgränsen kanske inte exakt den angivna tidsgränsen eftersom den angivna tidsgränsen ska justeras med att klockan skalstreck.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">Mer information om klockan upplösning och väntetiden finns i <bpt id="p1">[</bpt>vila funktionen<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> avsnittet.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">Den här metoden anropar den <bpt id="p1">[</bpt>vila funktionen<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> från Windows-systemet API: er.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Den här metoden utför inte standard COM och SendMessage pumpa.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Om du behöver vila på en tråd som har &lt;xref:System.STAThreadAttribute&gt;, men du vill utföra standard COM och SendMessage pumpa bör du överväga att använda någon av överlagringar av den &lt;xref:System.Threading.Thread.Join%2A&gt;metod som anger ett timeout-intervall.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">Antalet millisekunder som tråden har pausats.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Om värdet för den <ph id="ph1">`millisecondsTimeout`</ph> argumentet är noll, tråden avsäger resten av dess tidsintervallet till varje tråd i samma prioritet som är redo att köras.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Om det finns ingen annan tråd i samma prioritet som är redo att köras, körningen av den aktuella tråden inte har inaktiverats.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The time-out value is negative and is not equal to &lt;xref:System.Threading.Timeout.Infinite&gt;.</source>
          <target state="translated">Timeout-värdet är negativt och är inte lika med &lt;xref:System.Threading.Timeout.Infinite&gt;.&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Stoppar den aktuella tråden för angiven tidsperiod.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">Tråden kommer inte schemaläggas för körning av operativsystemet för den angivna tiden.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Den här metoden ändrar status för tråden att inkludera &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt; for the <ph id="ph1">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Du kan ange &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;för den <ph id="ph1">`timeout`</ph> parametern pausa tråden under obestämd tid.&lt;/xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">Vi rekommenderar dock att du använder andra &lt;xref:System.Threading?displayProperty=fullName&gt;klasser som &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, eller &lt;xref:System.Threading.Semaphore&gt;i stället till sychronize trådar eller hantera resurser.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload of &lt;xref:System.Threading.Thread.Sleep%2A&gt; uses the total number of whole milliseconds in <ph id="ph1">`timeout`</ph>.</source>
          <target state="translated">Den här överlagring för &lt;xref:System.Threading.Thread.Sleep%2A&gt;använder det totala antalet hela millisekunder i <ph id="ph1">`timeout`</ph>.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">Bråkdelar millisekunder ignoreras.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Den här metoden utför inte standard COM och SendMessage pumpa.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Om du behöver vila på en tråd som har &lt;xref:System.STAThreadAttribute&gt;, men du vill utföra standard COM och SendMessage pumpa bör du överväga att använda någon av överlagringar av den &lt;xref:System.Threading.Thread.Join%2A&gt;metod som anger ett timeout-intervall.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">Hur lång tid som tråden har pausats.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Om värdet för den <ph id="ph1">`millisecondsTimeout`</ph> argumentet är <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, tråden avsäger resten av dess tidsintervallet till varje tråd i samma prioritet som är redo att köras.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Om det finns ingen annan tråd i samma prioritet som är redo att köras, körningen av den aktuella tråden inte har inaktiverats.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">Värdet för <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> är negativt och är inte lika med <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> i millisekunder, eller är större än <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> millisekunder.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Causes a thread to wait the number of times defined by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">iterations</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">Gör att en tråd vänta antalet gånger som definieras av den <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">iterations</ph> <ept id="p1">&lt;/code&gt;</ept> parameter.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SpinWait method is useful for implementing locks.</source>
          <target state="translated">SpinWait-metoden är användbar för att implementera Lås.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes in the .NET Framework, such as &lt;xref:System.Threading.Monitor&gt; and &lt;xref:System.Threading.ReaderWriterLock&gt;, use this method internally.</source>
          <target state="translated">Klasser i .NET Framework, som &lt;xref:System.Threading.Monitor&gt;och &lt;xref:System.Threading.ReaderWriterLock&gt;, använder den här metoden internt.&lt;/xref:System.Threading.ReaderWriterLock&gt; &lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph1">`iterations`</ph> parameter.</source>
          <target state="translated">SpinWait i stort sett placerar processorn i en mycket tät loop med antalet loop som anges av den <ph id="ph1">`iterations`</ph> parameter.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">Varaktighet för väntetid därför beror på processorns hastighet.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contrast this with the &lt;xref:System.Threading.Thread.Sleep%2A&gt; method.</source>
          <target state="translated">Jämför detta med den &lt;xref:System.Threading.Thread.Sleep%2A&gt;metoden.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that calls &lt;xref:System.Threading.Thread.Sleep%2A&gt; yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">En tråd som anropar &lt;xref:System.Threading.Thread.Sleep%2A&gt;ger resten av dess aktuellt segment processortid, även om det angivna intervallet är noll.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying a non-zero interval for &lt;xref:System.Threading.Thread.Sleep%2A&gt; removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">Ange ett noll-intervall för &lt;xref:System.Threading.Thread.Sleep%2A&gt;tar bort tråden från behandling med Schemaläggaren i tråden tills intervall har förflutit.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait is not generally useful for ordinary applications.</source>
          <target state="translated">SpinWait är inte brukar vara användbara för vanliga program.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; or a statement that wraps &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; (<ph id="ph1">`lock`</ph> in C# or <ph id="ph2">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">I de flesta fall bör du använda synkronisering-klasser som tillhandahålls av .NET Framework. till exempel anropa &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;eller en instruktion som omsluter &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;(<ph id="ph1">`lock`</ph> i C# eller <ph id="ph2">`SyncLock`</ph> i Visual Basic).&lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; &lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the SpinWait method in your loop.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; I de sällsynta fall där är det fördelaktigt för att undvika att en kontext växel, till exempel när du vet att en tillståndsändring är nära förestående, gör ett anrop till metoden SpinWait din loop.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code SpinWait executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">Koden SpinWait kör är utformat för att förhindra problem som kan uppstå på datorer med flera processorer.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, SpinWait prevents processor starvation in certain situations.</source>
          <target state="translated">På datorer med flera Intel-processorer med flertrådsteknik förhindrar till exempel SpinWait processor svält i vissa situationer.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">En 32-bitars heltal som anger hur länge en tråd är vänta.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Gör att ändra tillståndet för den aktuella instansen till <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">När en tråd är i den &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;tillstånd, operativsystemet kan schemalägga för körning.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">Tråden påbörjas vid den första raden i metoden som representeras av det &lt;xref:System.Threading.ThreadStart&gt;eller &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegat som skickades till konstruktorn tråd.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">Observera att anropet till Start inte blockerar den anropande tråden.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If this overload is used with a thread created using a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Om denna överlagring används med en tråd som skapats med en &lt;xref:System.Threading.ParameterizedThreadStart&gt;Delegera, <ph id="ph2">`null`</ph> har överförts till metoden körs tråden.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">När tråden avslutas, det går inte att starta om med ett annat anrop till <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">Tråden har redan startats.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Det finns inte tillräckligt med minne för att starta den här tråden.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">Gör att ändra tillståndet för den aktuella instansen till <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>, och du kan också tillhandahåller ett objekt som innehåller data som ska användas av metoden tråden körs.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">När en tråd är i den &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;tillstånd, operativsystemet kan schemalägga för körning.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">Tråden påbörjas vid den första raden i metoden som representeras av det &lt;xref:System.Threading.ThreadStart&gt;eller &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegat som skickades till konstruktorn tråd.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">Observera att anropet till Start inte blockerar den anropande tråden.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">När tråden avslutas, det går inte att starta om med ett annat anrop till <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload and the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">Den här överlagring och &lt;xref:System.Threading.ParameterizedThreadStart&gt;ombud gör det enkelt att skicka data till en tråd procedur, men tekniken är inte säker typ eftersom ett objekt kan skickas till den här överlagring.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">Stabilare sätt att skicka data till en tråd procedur är att placera datafälten och tråd-proceduren i en worker-objektet.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Mer information finns i <bpt id="p1">[</bpt>trådar för att skapa och skicka Data vid Start<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">Ett objekt som innehåller data som ska användas av metoden tråden körs.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">Tråden har redan startats.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Det finns inte tillräckligt med minne för att starta den här tråden.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>This thread was created using a <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate instead of a <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> delegate.</source>
          <target state="translated">Den här tråden skapades med en <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegera i stället för en <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> delegera.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">Pausar tråden, eller om tråden har redan pausats, har ingen effekt.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">Om tråden har redan pausats, har den här metoden ingen effekt.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Do not use the Suspend and &lt;xref:System.Threading.Thread.Resume%2A&gt; methods to synchronize the activities of threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; Inte använder inaktiverings och &lt;xref:System.Threading.Thread.Resume%2A&gt;metoder för att synkronisera aktiviteter trådar.&lt;/xref:System.Threading.Thread.Resume%2A&gt;</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">Det finns inget sätt att veta vilken kod en tråd körs när du avbryter den.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the &lt;xref:System.AppDomain&gt; might be blocked.</source>
          <target state="translated">Om du avbryter en tråd medan den innehåller Lås under en utvärdering av säkerhet behörighet, andra trådar i den &lt;xref:System.AppDomain&gt;blockeras.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the &lt;xref:System.AppDomain&gt; that attempt to use that class are blocked.</source>
          <target state="translated">Om du avbryter en tråd medan det körs en klasskonstruktor, andra trådar i den &lt;xref:System.AppDomain&gt;som försöker använda att klassen är blockerade.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Deadlocks kan uppstå väldigt enkelt.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">Tråden har inte startats eller svarar inte.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Anroparen har inte rätt <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Matchar en uppsättning namn med en motsvarande uppsättning dispatch-identifierare.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Mer information om <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, finns i MSDN Library.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">Reserverat för framtida användning.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Måste vara IID_NULL.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Skickades i matris med namn som ska mappas.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Antal namnen mappas.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Språkvariant-kontext att tolka namnen.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Anroparen allokerade matris som tar emot de ID: N som motsvarar namnen.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Sent bundna åtkomst med hjälp av COM <ph id="ph1">`IDispatch`</ph> gränssnittet stöds inte.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Hämtar typinformation för ett objekt som kan användas för att hämta typinformation för ett gränssnitt.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Mer information om <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, finns i MSDN Library.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
          <target state="translated">Informationen att returnera.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Språkvariant-ID för informationen.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Tar emot en pekare till informationsobjektet för den begärda typen.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Sent bundna åtkomst med hjälp av COM <ph id="ph1">`IDispatch`</ph> gränssnittet stöds inte.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Hämtar antalet typen information gränssnitt att ett objekt tillhandahåller (0 eller 1).</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Mer information om <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, finns i MSDN Library.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Pekar på en plats som tar emot antalet skriver information gränssnitt som tillhandahålls av objektet.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Sent bundna åtkomst med hjälp av COM <ph id="ph1">`IDispatch`</ph> gränssnittet stöds inte.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Tillhandahåller åtkomst till egenskaper och metoder som visas av ett objekt.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Mer information om <ph id="ph1">`IDispatch::Invoke`</ph>, finns i MSDN Library.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
          <target state="translated">Identifierar medlemmen.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">Reserverat för framtida användning.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Måste vara IID_NULL.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Språkvariant-kontext att tolka argument.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flaggor som beskriver kontexten för anropet.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Pekare till en struktur som innehåller en matris med argument, en matris med argumentet DISPID för namngivna argument och antal för antalet element i matriser.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Pekar till den plats där resultatet ska lagras.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Pekare till en struktur som innehåller undantagsinformation om.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Indexet för det första argumentet som har ett fel.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Sent bundna åtkomst med hjälp av COM <ph id="ph1">`IDispatch`</ph> gränssnittet stöds inte.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">Hämtar ett värde som innehåller tillstånd för den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ThreadState property provides more specific information than the &lt;xref:System.Threading.Thread.IsAlive%2A&gt; property.</source>
          <target state="translated">Egenskapen ThreadState ger mer specifik information än den &lt;xref:System.Threading.Thread.IsAlive%2A&gt;egenskapen.&lt;/xref:System.Threading.Thread.IsAlive%2A&gt;</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Trådtillstånd är av intresse för felsökning av scenarier.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">Koden ska aldrig använda Trådtillstånd för att synkronisera aktiviteter trådar.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the state of the current thread.</source>
          <target state="translated">En av de <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> värden som anger tillståndet för den aktuella tråden.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Det första värdet är <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Anger en tråd-inneslutningstillståndet innan den startas.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">Nya trådar har initierats som &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;om deras inneslutningstillståndet inte har angetts innan de startas.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Inneslutningstillståndet måste anges innan en tråd har startats.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Programmets tråden har initierats till &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;som standard.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">Det enda sättet att ange inneslutningstillståndet för programmets tråden till &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;är att använda den &lt;xref:System.STAThreadAttribute&gt;attribut till metoden.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The TrySetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">Metoden TrySetApartmentState tillsammans med den &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;metoden och &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;metod, ersätter den &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;egenskapen.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">Läget inneslutning.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the apartment state is set; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Om läget inneslutning anges; Annars <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>är inte en giltig inneslutningstillståndet.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">Tråden har redan startats.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">VolatileRead och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileRead obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer hämtar VolatileRead det senaste värdet skrivs till en minnesplats med en processor.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även om en processor datorn kan VolatileRead och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda VolatileRead eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder VolatileRead eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Läser värdet för ett fält.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;hämtar det senaste värdet skrivs till en minnesplats med en processor.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">Fältet som ska läsas.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Det senaste värdet som skrivs till fältet med en processor.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och VolatileWrite är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileWrite ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer garanterar VolatileWrite att ett värde som skrivs till en minnesplats omedelbart synliga för alla processorer.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och VolatileWrite Kontrollera att ett värde läsa eller skriva till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">För att ge effektiva synkronisering för ett fält måste all åtkomst till fältet måste använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;är specialfall av synkronisering.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Under normala omständigheter, C# <ph id="ph1">`lock`</ph> instruktionen, Visual Basic <ph id="ph2">`SyncLock`</ph> -instruktionen och &lt;xref:System.Threading.Monitor&gt;klass är enklare alternativ.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">På ett system med flera processorer, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Detta kan kräva lokaliseraren processor cacheminnen.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Även på ett system med en processor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;och &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Den här metoden anropas påverkar en enstaka minnesåtkomst.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; I C# med hjälp av den <ph id="ph2">`volatile`</ph> modifierare i ett fält som garanterar att all åtkomst till fältet använder &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;eller &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Det fält som är värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">Värdet som ska skrivas.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">Gör den anropande tråden kan ge körningen till en annan tråd är redo att köra på den aktuella processorn.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">Operativsystemet väljer tråd kan ge dig till.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">Om den här metoden lyckas gav resten av trådens aktuella tidsintervallet.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">Operativsystemet schemalägger den anropande tråden för en annan tidsintervallet enligt dess prioritet och status för andra trådar kan köras.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">Framställning är begränsad till processorn som den anropande tråden körs.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">Operativsystemet växlar inte körning till en annan processor, även om processorn är inaktiv eller kör en tråd av lägre prioritet.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Om det finns ingen annan tråd är redo att köras på den aktuella processorn operativsystemet ger inte körning och den här metoden returnerar <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">Den här metoden motsvarar med platform anropa för att anropa intern Win32 <ph id="ph1">`SwitchToThread`</ph> funktion.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should call the Yield method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">Du bör kontakta avkastningen metoden i stället för med platform anropa eftersom plattformen anropa kringgår eventuella anpassade trådade beteende som värden har begärt.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the operating system switched execution to another thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Om systemet växlade körningen till en annan tråd. Annars <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>