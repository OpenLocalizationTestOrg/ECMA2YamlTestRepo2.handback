<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6268fc94480a4936a59717d3dc614a6d4975ccec</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.Markup.XamlReader.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6671bf951825ac73db26ba52314b457f5c96dbd4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa63fc760c757e6f8ed203edf588d497bc9712ca</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</source>
          <target state="translated">讀取 XAML 輸入並建立使用 WPF 預設 XAML 讀取器和相關聯的 XAML 物件寫入器的物件圖形。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>The synchronous &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; methods are static, but the asynchronous &lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt; methods are not static and require an instance of the XamlReader class to use.</source>
          <target state="translated">同步&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;方法是靜態的但非同步&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;方法不是靜態的而且需要使用 XamlReader 類別的執行個體。&lt;/xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt; &lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The output of the <ph id="ph1">`Load`</ph> methods is a single object, which represents the root object of a created object tree or object graph.</source>
          <target state="translated">輸出<ph id="ph1">`Load`</ph>方法為單一物件，表示樹狀目錄中建立的物件或物件圖形的根物件。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Object graphs that are created by XamlReader are typically added to the existing object tree of a WPF application at run time.</source>
          <target state="translated">物件圖形建立的 XamlReader 通常會加入到現有的物件樹狀結構的 WPF 應用程式在執行階段。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</source>
          <target state="translated">否則新的物件圖形視為中斷連線的 WPF 應用程式模型的用途。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs &lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;, &lt;xref:System.Windows.LogicalTreeHelper&gt;, &lt;xref:System.Windows.Media.VisualTreeHelper&gt;).</source>
          <target state="translated">這表示不會呈現，而且無法存取使用任何的物件樹狀結構方法，以套用至 WPF 應用程式的主要物件樹狀結構 (例如，應用程式開發介面&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;， &lt;xref:System.Windows.LogicalTreeHelper&gt;， &lt;xref:System.Windows.Media.VisualTreeHelper&gt;)。&lt;/xref:System.Windows.Media.VisualTreeHelper&gt; &lt;/xref:System.Windows.LogicalTreeHelper&gt; &lt;/xref:System.Windows.FrameworkElement.FindName%2A&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For more information on object tree concepts, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需有關物件樹狀結構的概念的詳細資訊，請參閱<bpt id="p1">[</bpt>中 WPF 樹狀架構<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>XamlReader supports the following primary scenarios:      -   <bpt id="p1">**</bpt>Cloning/object factory<ept id="p1">**</ept>: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</source>
          <target state="translated">XamlReader 支援下列主要案例:-<bpt id="p1">**</bpt>複製/物件 factory<ept id="p1">**</ept>︰ 沒有其他的機制，參考類型通常不能包含在 WPF 物件樹狀結構中的多個位置。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on &lt;xref:System.Windows.Freezable&gt;, or support for commonly shareable objects such as &lt;xref:System.Windows.Media.Brush&gt; that are referenced as an item from a &lt;xref:System.Windows.ResourceDictionary&gt;.) One way to clone an object that is already in the object tree is to serialize the object using &lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">(其他的機制，提供共用的支援，或在 WPF 中重複使用的範例包括物件為基礎的&lt;xref:System.Windows.Freezable&gt;，或支援通常可共用的物件，例如&lt;xref:System.Windows.Media.Brush&gt;為從一個項目所參考之&lt;xref:System.Windows.ResourceDictionary&gt;。)&lt;/xref:System.Windows.ResourceDictionary&gt; &lt;/xref:System.Windows.Media.Brush&gt; &lt;/xref:System.Windows.Freezable&gt;若要複製的物件已經在物件樹狀結構中的一種方式為序列化使用&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName&gt;.&lt;/xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName&gt;物件</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You then use the serialized string as input for a call to &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;, with a stream or &lt;xref:System.Xml.XmlReader&gt; as an intermediary.</source>
          <target state="translated">用於序列化的字串做為輸入呼叫&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;，與資料流或&lt;xref:System.Xml.XmlReader&gt;做為媒介。&lt;/xref:System.Xml.XmlReader&gt; &lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>-   <bpt id="p1">**</bpt>Constructing objects based on just-in-time information<ept id="p1">**</ept>: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</source>
          <target state="translated">-<bpt id="p1">**</bpt>建構物件會根據在 just-in-time 資訊<ept id="p1">**</ept>︰ 通常是其他的方式有晚期繫結或使用者提供輸入變更現有物件的狀態。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For example you could use the same value to set more than one property, or use data binding.</source>
          <target state="translated">例如您無法使用相同的值來設定多個屬性，或使用資料繫結。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; input is often a useful technique.</source>
          <target state="translated">如果您有的案例，其中甚至建立物件的類型是僅判斷在執行階段或使用者互動，然後建立這類物件建置的字串，但是&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;輸入通常是一個實用的方法。&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>-   <bpt id="p1">**</bpt>Using existing resource techniques<ept id="p1">**</ept>: The &lt;xref:System.IO.Stream&gt; type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</source>
          <target state="translated">-<bpt id="p1">**</bpt>使用現有的資源技術<ept id="p1">**</ept>:&lt;xref:System.IO.Stream&gt;型別用於經常在於其他 framework 或技術傳送跨應用程式界限的資料或物件或類似的情況。&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can then use the &lt;xref:System.IO.Stream&gt; techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</source>
          <target state="translated">然後您可以使用&lt;xref:System.IO.Stream&gt;技術來儲存，或取得 XAML 格式的資料，最後使用建立的物件做為您的應用程式的一部分。&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>-   <bpt id="p1">**</bpt>Fixed documents:<ept id="p1">**</ept> Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</source>
          <target state="translated">-<bpt id="p1">**</bpt>固定文件︰<ept id="p1">**</ept>您的應用程式可能會載入包含在 WPF 應用程式物件樹狀結構和 UI 中的本機或下載 XPS 文件。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  This documentation sometimes describes an object graph, as opposed to an object tree.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 這份文件有時會描述物件圖形，而不是物件樹狀結構。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</source>
          <target state="translated">嚴格的父子式關聯性不一律存在於執行的階段物件關聯性的執行的階段 WPF 應用程式，因此物件圖形是更廣泛套用的術語。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>However, because WPF also includes two different tree conceptualization APIs (&lt;xref:System.Windows.LogicalTreeHelper&gt;, &lt;xref:System.Windows.Media.VisualTreeHelper&gt;) the tree metaphor still applies adequately to most real-world cases in WPF.</source>
          <target state="translated">不過，因為 WPF 還包含兩個不同的樹狀目錄概念化應用程式開發介面 (&lt;xref:System.Windows.LogicalTreeHelper&gt;， &lt;xref:System.Windows.Media.VisualTreeHelper&gt;) 樹狀目錄象徵仍適用於適當地在 WPF 中大部分的真實情況。&lt;/xref:System.Windows.Media.VisualTreeHelper&gt; &lt;/xref:System.Windows.LogicalTreeHelper&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</source>
          <target state="translated">從 XAML 語言的觀點來看，物件圖形其實通常思考如何從 XAML，會建立物件本身為 XAML 語言不一定會指定關聯性樹狀結構至多個再次顯示的 helper 類別方法的最佳方式。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Code Access Security, Loose XAML, and XamlReader    XAML is a markup language that directly represents object instantiation and execution.</source>
          <target state="translated">程式碼存取安全性、 鬆散的 XAML 和 XamlReader XAML 是直接代表物件具現化和執行的標記語言。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</source>
          <target state="translated">因此，在 XAML 中建立的項目就可以進行互動的系統資源 （例如，網路存取、 檔案系統的 IO，） 做為對等項目產生程式碼的功能。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> supports the <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/add/includes/tla2sharptla-net-md.md)]</ph> security framework <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/add/includes/tlasharptla-cas-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>支援<ph id="ph2">[!INCLUDE[TLA2#tla_net](~/add/includes/tla2sharptla-net-md.md)]</ph>安全性架構<ph id="ph3">[!INCLUDE[TLA#tla_cas](~/add/includes/tlasharptla-cas-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This means that <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> content running in the internet zone has reduced execution permissions.</source>
          <target state="translated">這表示<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph>網際網路區域中執行的內容已降低執行權限。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]</ph> are usually run in this internet zone and use the same permission set.</source>
          <target state="translated">「 鬆散的 XAML 」 （file XAML 頁面解譯 XAML 檢視器在載入時間） 和<ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]</ph>通常會執行這個網際網路區域中，並使用相同的權限集合。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</source>
          <target state="translated">不過，完全受信任的應用程式中載入的 XAML 一樣都裝載的應用程式具有相同存取權的系統資源。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>WPF Partial Trust Security<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>WPF 部分信任安全性<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The implications of these statements for XamlReader is that your application design must make trust decisions about the XAML you decide to load.</source>
          <target state="translated">這些陳述式造成的影響 XamlReader 是應用程式的設計必須讓您決定要載入的 XAML 相關的信任決策。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</source>
          <target state="translated">如果您載入未受信任的 XAML，請考慮實作您自己的沙箱技術的載入結果的物件圖形的方式。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>XamlReader can also be called by partial trust code.</source>
          <target state="translated">XamlReader 也可以呼叫由部分信任程式碼。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In this case, Internet security zone is applied for code access security.</source>
          <target state="translated">在此情況下，網際網路安全性區域就會套用程式碼存取安全性。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</source>
          <target state="translated">如果在載入的 XAML 中的任何項目無效網際網路安全性區域底下，XAML 剖析例外狀況會擲回。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Under XBAP and other cases that are partial trust at the platform level, where XamlReader is part of the execution, you get the same exception behavior as with explicit partial trust calls.</source>
          <target state="translated">XBAP 和其他平台層級，其中 XamlReader 是在執行期間，在部分信任的案例下，您會取得例外狀況與相同的行為與明確的部分信任的呼叫。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>WPF XAML, XAML Readers/Writers, and XAML Language Versioning    <ph id="ph1">[!INCLUDE[xaml2009](~/add/includes/xaml2009-md.md)]</ph> includes language features such as  and .</source>
          <target state="translated">WPF XAML、 XAML 讀取器/寫入器和 XAML 的語言版本控制<ph id="ph1">[!INCLUDE[xaml2009](~/add/includes/xaml2009-md.md)]</ph>包含語言功能，例如與。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can use signatures of <ph id="ph1">`Load`</ph> or <ph id="ph2">`Parse`</ph> to load XAML that uses these features.</source>
          <target state="translated">您可以使用的簽章<ph id="ph1">`Load`</ph>或<ph id="ph2">`Parse`</ph>載入會使用這些功能的 XAML。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the <bpt id="p1">**</bpt>Page<ept id="p1">**</ept> build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</source>
          <target state="translated">不過，這些語言功能不支援，需要進行標記編譯 xaml (例如 XAML<bpt id="p1">**</bpt>頁面<ept id="p1">**</ept>建置 WPF 應用程式或建置動作以標記編譯工作牽涉到任何 XAML 中的動作)。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</source>
          <target state="translated">WPF 型別和 WPF 技術通常支援依賴存取可 WPF 內部的概念。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</source>
          <target state="translated">比方說，WPF 會相依性屬性的實作依賴內部技術有效率的型別成員查閱。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Access to these internals is enabled by the XAML reading and writing APIs provided in &lt;xref:System.Windows.Markup.XamlWriter&gt; and XamlReader from the &lt;xref:System.Windows.Markup&gt; namespace and PresentationFramework assembly.</source>
          <target state="translated">存取這些內部項目會啟用讀取和寫入應用程式開發介面中提供的 XAML&lt;xref:System.Windows.Markup.XamlWriter&gt;和從 XamlReader&lt;xref:System.Windows.Markup&gt;命名空間和 PresentationFramework 組件。&lt;/xref:System.Windows.Markup&gt; &lt;/xref:System.Windows.Markup.XamlWriter&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on &lt;xref:System.Xaml.XamlReader?displayProperty=fullName&gt;, &lt;xref:System.Xaml.XamlWriter?displayProperty=fullName&gt;) do not have access to the WPF internals.</source>
          <target state="translated">不過，較低層級的 XAML 讀取器和 XAML 寫入器透過 System.Xaml 組件 (類別根據&lt;xref:System.Xaml.XamlReader?displayProperty=fullName&gt;， &lt;xref:System.Xaml.XamlWriter?displayProperty=fullName&gt;) 沒有 WPF 內部資訊的存取。&lt;/xref:System.Xaml.XamlWriter?displayProperty=fullName&gt; &lt;/xref:System.Xaml.XamlReader?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>There is no dependency from System.Xaml to any WPF-specific assembly.</source>
          <target state="translated">沒有任何特定的 WPF 組件從 System.Xaml 相依性。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</source>
          <target state="translated">如果沒有 WPF 內部存取，System.Xaml 讀取器和寫入器無法正確載入或儲存所有 WPF 類型根據 WPF 類型。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</source>
          <target state="translated">特別是，System.Xaml 讀取器和寫入器不了解概念，例如支援屬性存放區或所有的細節 WPF 會使用樣式、 資源字典和範本的 WPF 相依性屬性。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Therefore you have a choice to make:      -   If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</source>
          <target state="translated">因此，您必須選擇来讓:-如果您正在載入 WPF 類型，及/或您使用 XAML 中的任何方式 BAML 形式使用 PresentationFramework XAML 讀取器和 XAML 寫入器。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>-   If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</source>
          <target state="translated">-如果您不依賴任何 WPF 類型或 BAML 形式的 XAML，並不使用另一種特定技術的 XAML 讀取器或 XAML 寫入器實作專屬於該架構的原因，請使用 System.Xaml XAML 讀取器和 XAML 寫入器。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>System.Xaml Backing Implementation in .NET 4    XamlReader is the callable API surface for the WPF framework-level XAML parser.</source>
          <target state="translated">在.NET 4 XamlReader System.Xaml 備份實作是 WPF 架構層級 XAML 剖析器可呼叫的 API 介面。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target <ph id="ph1">[!INCLUDE[net_v30_short](~/add/includes/net-v30-short-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)]</ph>.</source>
          <target state="translated">相同的基礎 XAML 剖析器也會執行載入及剖析 WPF 應用程式為目標的執行階段 XAML<ph id="ph1">[!INCLUDE[net_v30_short](~/add/includes/net-v30-short-md.md)]</ph>和<ph id="ph2">[!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If you are targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>, the external API is the same, but parts of the implementation are built on the <ph id="ph2">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph> general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</source>
          <target state="translated">如果您的目標<ph id="ph1">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>，外部應用程式開發介面都相同，但實作的部分之上<ph id="ph2">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>System.Xaml 組件，可改善剖析 XAML 的技術和報告方面的許多一般 XAML 實作。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph> necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</source>
          <target state="translated">目標<ph id="ph1">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>一定需要包括 System.Xaml 的參考，以及實作的詳細資料，例如例外狀況的報告可能來自於 System.Xaml 中定義型別。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="xamlTextUsage_XamlReader"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## XAML Text Usage</source>
          <target state="translated"><bpt id="p1">&lt;a name="xamlTextUsage_XamlReader"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # XAML 文字用法</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</source>
          <target state="translated">中止目前非同步載入作業，如果有暫止的非同步載入作業。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>CancelAsync is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</source>
          <target state="translated">CancelAsync 是非同步作業;因此，在作業中止之前，可能會發生部分載入。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Xaml.XamlSchemaContext"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that represents the WPF schema context settings for a <bpt id="p2">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">傳回<bpt id="p1">&lt;xref href="System.Xaml.XamlSchemaContext"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>物件，代表 WPF 結構描述內容設定為<bpt id="p2">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Xaml.XamlSchemaContext"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that represents the WPF schema context settings for a <bpt id="p2">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Xaml.XamlSchemaContext"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>物件，代表 WPF 結構描述內容設定為<bpt id="p2">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns an &lt;xref:System.Object&gt; that is the root of the corresponding object tree.</source>
          <target state="translated">讀取指定的 XAML 輸入&lt;xref:System.IO.Stream&gt;並傳回&lt;xref:System.Object&gt;也就是對應的物件樹狀結構的根目錄。&lt;/xref:System.Object&gt; &lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The XAML to load, in stream form.</source>
          <target state="translated">若要載入，資料流的形式的 XAML。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The object at the root of the created object tree.</source>
          <target state="translated">在建立的物件樹狀結構的根物件。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Reads the XAML input through a provided <bpt id="p1">&lt;xref href="System.Xaml.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">讀取透過提供 XAML 輸入<bpt id="p1">&lt;xref href="System.Xaml.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>並傳回對應的物件樹狀結構根目錄的物件。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The input &lt;xref:System.Xaml.XamlReader&gt; can be &lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;.</source>
          <target state="translated">&lt;xref:System.Xaml.XamlReader&gt;可以是&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;.&lt;/xref:System.Windows.Baml2006.Baml2006Reader&gt;&lt;/xref:System.Xaml.XamlReader&gt;輸入</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This is how you can load BAML at run time, or for localization tool purposes.</source>
          <target state="translated">這是在執行階段，或當地語系化工具的目的而言，如何載入 BAML。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Xaml.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Xaml.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is expected to be initialized with input XAML.</source>
          <target state="translated">初始化具有輸入 XAML，這是預期行為。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">所建立的物件樹狀目錄的根目錄的物件。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.Xml.XmlReader&gt; and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">讀取指定的 XAML 輸入&lt;xref:System.Xml.XmlReader&gt;並傳回物件，對應的物件樹狀結構的根目錄。&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.XmlReader&gt; that has already loaded the XAML input to load in XML form.</source>
          <target state="translated">&lt;xref:System.Xml.XmlReader&gt;，已經載入輸入 XML 表單中載入的 XAML。&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">所建立的物件樹狀目錄的根目錄的物件。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">讀取指定的 XAML 輸入&lt;xref:System.IO.Stream&gt;並傳回物件，對應的物件樹狀結構的根目錄。&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The stream that contains the XAML input to load.</source>
          <target state="translated">包含 XAML 輸入載入的資料流。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Context information used by the parser.</source>
          <target state="translated">剖析器使用的內容資訊。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">所建立的物件樹狀目錄的根目錄的物件。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>-or-       <ph id="ph1">&lt;code&gt;parserContext&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">-or-       <ph id="ph1">&lt;code&gt;parserContext&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns the root of the corresponding object tree.</source>
          <target state="translated">讀取指定的 XAML 輸入&lt;xref:System.IO.Stream&gt;並傳回對應的物件樹狀結構的根目錄。&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">非同步的 XAML 載入作業一開始會傳回單純的根物件的物件。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">以非同步的方式，XAML 剖析然後仍繼續，和任何子物件會填入根目錄下。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">這是相較於一般的 WPF XAML 處理行為以及其與互動的物件存留期的 WPF 概念。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">一般 （非同步） 互動，包括所有子物件的所有屬性會傳回項目，並報告其在載入之前都填入。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">該行為等同於建立樹狀結構的根物件所在的最後一個物件變成可用的由下而上的方法。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">通常會將傳回的物件指派給 WPF 應用程式的物件樹狀結構中有些位置、 內容的知識可能仍然會填入，如果 UI 的一部分公開的整個內容可能會造成累加配置更新。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt; is handled.</source>
          <target state="translated">基於這個原因是隔離，或將虛擬化 xaml，任何以非同步方式載入的物件，並使用特定應用程式邏輯或應用程式狀態通知時，一般&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;處理。&lt;/xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In order for LoadAsync to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value <ph id="ph1">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">為了讓 LoadAsync 以非同步方式載入的 XAML 輸入 XAML 中的根項目輸入必須包含的屬性和值<ph id="ph1">`x:SynchronousMode="Async"`</ph>。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">此值視為區分大小寫。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If the XAML input root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see &lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;).</source>
          <target state="translated">如果不包含 XAML 輸入的根<ph id="ph1">`x:SynchronousMode="Async"`</ph>、 擲回任何例外狀況，以及同步負載處理呼叫 (請參閱&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;)。&lt;/xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Only one asynchronous load operation per instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class can be performed at a time.</source>
          <target state="translated">每個執行個體只有一個非同步載入作業&lt;xref:System.Windows.Markup.XamlReader&gt;類別可以執行一次。&lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If more than one asynchronous operation is attempted on the same instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class an &lt;xref:System.InvalidOperationException&gt; is thrown.</source>
          <target state="translated">如果多個非同步作業會嘗試在相同的執行個體上&lt;xref:System.Windows.Markup.XamlReader&gt;類別&lt;xref:System.InvalidOperationException&gt;就會擲回。&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The stream containing the XAML input to load.</source>
          <target state="translated">包含 XAML 輸入載入的資料流。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">所建立的物件樹狀目錄的根目錄的物件。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Multiple load operations are pending concurrently with the same <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">正在暫止多個負載作業與相同同時<bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.Xml.XmlReader&gt; and returns the root of the corresponding object tree.</source>
          <target state="translated">讀取指定的 XAML 輸入&lt;xref:System.Xml.XmlReader&gt;並傳回對應的物件樹狀結構的根目錄。&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">非同步的 XAML 載入作業一開始會傳回單純的根物件的物件。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">以非同步的方式，XAML 剖析然後仍繼續，和任何子物件會填入根目錄下。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">這是相較於一般的 WPF XAML 處理行為以及其與互動的物件存留期的 WPF 概念。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">一般 （非同步） 互動，包括所有子物件的所有屬性會傳回項目，並報告其在載入之前都填入。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">該行為等同於建立樹狀結構的根物件所在的最後一個物件變成可用的由下而上的方法。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You typically would assign the returned object from LoadAsync to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">通常會就會將從 LoadAsync 傳回的物件指派給您的應用程式物件樹狀結構中的某些位置、 內容的知識可能仍然會填入，如果 UI 的一部分公開的整個內容可能會造成累加配置更新。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt; is handled.</source>
          <target state="translated">基於這個原因是隔離，或將虛擬化 xaml，任何以非同步方式載入的物件，並使用特定應用程式邏輯或應用程式狀態通知時，一般&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;處理。&lt;/xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In order for LoadAsync to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph1">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">為了讓 LoadAsync 載入 XAML 輸入以非同步的方式，在 XAML 標記中的根項目必須包含的屬性和值<ph id="ph1">`x:SynchronousMode="Async"`</ph>。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">此值視為區分大小寫。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is instead processed as a synchronous load (see &lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;).</source>
          <target state="translated">如果不包含 XAML 標記根<ph id="ph1">`x:SynchronousMode="Async"`</ph>、 擲回任何例外狀況，以及同步負載改為處理的呼叫 (請參閱&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;)。&lt;/xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Only one asynchronous load operation per instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class can be performed at a time.</source>
          <target state="translated">每個執行個體只有一個非同步載入作業&lt;xref:System.Windows.Markup.XamlReader&gt;類別可以執行一次。&lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If more than one asynchronous operation is attempted on the same instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class an &lt;xref:System.InvalidOperationException&gt; is thrown.</source>
          <target state="translated">如果多個非同步作業會嘗試在相同的執行個體上&lt;xref:System.Windows.Markup.XamlReader&gt;類別&lt;xref:System.InvalidOperationException&gt;就會擲回。&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>An existing  &lt;xref:System.Xml.XmlReader&gt; that has already loaded/read the XAML input.</source>
          <target state="translated">現有&lt;xref:System.Xml.XmlReader&gt;，具有已載入/讀取 XAML 輸入。&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The root of the created object tree.</source>
          <target state="translated">建立的物件樹狀目錄的根目錄。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;reader&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Multiple load operations are performed concurrently with the same <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">多個載入作業將會與相同同時<bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns the root of the corresponding object tree.</source>
          <target state="translated">讀取指定的 XAML 輸入&lt;xref:System.IO.Stream&gt;並傳回對應的物件樹狀結構的根目錄。&lt;/xref:System.IO.Stream&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">非同步的 XAML 載入作業一開始會傳回單純的根物件的物件。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">以非同步的方式，XAML 剖析然後仍繼續，和任何子物件會填入根目錄下。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">這是相較於一般的 WPF XAML 處理行為以及其與互動的物件存留期的 WPF 概念。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">一般 （非同步） 互動，包括所有子物件的所有屬性會傳回項目，並報告其在載入之前都填入。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">該行為等同於建立樹狀結構的根物件所在的最後一個物件變成可用的由下而上的方法。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">通常會將傳回的物件指派給您的應用程式物件樹狀結構中有些位置、 內容的知識可能仍然會填入，如果 UI 的一部分公開的整個內容可能會造成累加配置更新。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt; is handled.</source>
          <target state="translated">基於這個原因是隔離，或將虛擬化 xaml，任何以非同步方式載入的物件，並使用特定應用程式邏輯或應用程式狀態通知時，一般&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;處理。&lt;/xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In order for LoadAsync to load markup asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph1">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">為了讓 LoadAsync 以非同步方式載入標記，在 XAML 標記中的根項目必須包含的屬性和值<ph id="ph1">`x:SynchronousMode="Async"`</ph>。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">此值視為區分大小寫。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see &lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;).</source>
          <target state="translated">如果不包含 XAML 標記根<ph id="ph1">`x:SynchronousMode="Async"`</ph>、 擲回任何例外狀況，以及同步負載處理呼叫 (請參閱&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;)。&lt;/xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Only one asynchronous load operation per instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class can be performed at a time.</source>
          <target state="translated">每個執行個體只有一個非同步載入作業&lt;xref:System.Windows.Markup.XamlReader&gt;類別可以執行一次。&lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If more than one asynchronous operation is attempted on the same instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class an &lt;xref:System.InvalidOperationException&gt; is thrown.</source>
          <target state="translated">如果多個非同步作業會嘗試在相同的執行個體上&lt;xref:System.Windows.Markup.XamlReader&gt;類別&lt;xref:System.InvalidOperationException&gt;就會擲回。&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Windows.Markup.XamlReader&gt;</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A stream containing the XAML input to load.</source>
          <target state="translated">包含 XAML 輸入載入的資料流。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Context information used by the parser.</source>
          <target state="translated">剖析器使用的內容資訊。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The root of the created object tree.</source>
          <target state="translated">建立的物件樹狀目錄的根目錄。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;stream&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Multiple load operations are performed concurrently with the same <bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">多個載入作業將會與相同同時<bpt id="p1">&lt;xref href="System.Windows.Markup.XamlReader"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Occurs when an asynchronous load operation completes.</source>
          <target state="translated">非同步載入作業完成時發生。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>LoadCompleted is also raised when an asynchronous load operation aborts.</source>
          <target state="translated">非同步載入作業中止時，也會引發 LoadCompleted。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>To be added.</source>
          <target state="translated">即將加入。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">讀取 XAML 輸入中指定的文字字串並傳回對應的物件，指定標記的根目錄。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The implementation calls &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; internally after creating a stream from the string.</source>
          <target state="translated">實作會呼叫&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;從字串建立的資料流之後，在內部。&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>See &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; for additional information such as possible exceptions.</source>
          <target state="translated">請參閱&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;如需詳細資訊，例如可能的例外狀況。&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">輸入 XAML 中，為單一文字字串。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The root of the created object tree.</source>
          <target state="translated">建立的物件樹狀目錄的根目錄。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Reads the XAML markup in the specified text string (using a specified <bpt id="p1">&lt;xref href="System.Windows.Markup.ParserContext"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">讀取 XAML 標記中指定的文字字串 (使用指定<bpt id="p1">&lt;xref href="System.Windows.Markup.ParserContext"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>)，並傳回對應的物件，指定標記的根目錄。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The implementation calls &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; internally after creating a stream from the string.</source>
          <target state="translated">實作會呼叫&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;從字串建立的資料流之後，在內部。&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>See &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; for additional information such as possible exceptions.</source>
          <target state="translated">請參閱&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;如需詳細資訊，例如可能的例外狀況。&lt;/xref:System.Windows.Markup.XamlReader.Load%2A&gt;</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">輸入 XAML 中，為單一文字字串。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Context information used by the parser.</source>
          <target state="translated">剖析器使用的內容資訊。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The root of the created object tree.</source>
          <target state="translated">建立的物件樹狀目錄的根目錄。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>