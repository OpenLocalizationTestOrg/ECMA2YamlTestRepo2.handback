<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">93899f77dbe9a89a757dd2011e2fe034a73757a3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Security.CodeAccessPermission.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">76e028dcf191768d6cde1ff987f2c0821484576b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">620f466bc0c7923a43efc9b1250f57dc037351b1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines the underlying structure of all code access permissions.</source>
          <target state="translated">定義所有程式碼存取權限的基礎結構。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</source>
          <target state="translated">程式碼存取權限會使用堆疊查核行程，確認所有呼叫端程式碼的已被授與權限。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>If a permission object is <ph id="ph1">`null`</ph>, it is handled the same as a permission object with the state &lt;xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;.</source>
          <target state="translated">權限物件是否<ph id="ph1">`null`</ph>，就會處理與&lt;xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;.&lt;/xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;狀態的權限物件與相同</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Inheritors of the CodeAccessPermission class must be granted full trust to function correctly as permissions extending the security infrastructure.</source>
          <target state="translated">CodeAccessPermission 類別繼承者必須授與完全信任才能正確運作，做為安全性基礎結構延伸權限。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>To determine that the inheritors are fully trusted, CodeAccessPermission issues an &lt;xref:System.Security.Permissions.SecurityAction&gt; for &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt; = <ph id="ph1">`true`</ph> and &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt; = <ph id="ph2">`true`</ph>.</source>
          <target state="translated">若要判斷，所以繼承者是完全受信任，CodeAccessPermission 發出&lt;xref:System.Security.Permissions.SecurityAction&gt;如&lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt;=<ph id="ph1">`true`</ph>和&lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt;= <ph id="ph2">`true`</ph>。&lt;/xref:System.Security.Permissions.SecurityPermissionFlag&gt; &lt;/xref:System.Security.Permissions.SecurityPermissionFlag&gt; &lt;/xref:System.Security.Permissions.SecurityAction&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This constructor is called to initialize state in the type whenever an instance of the derived class is created.</source>
          <target state="translated">這個建構函式會初始化型別中的狀態，每次建立衍生類別的執行個體時呼叫。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</source>
          <target state="translated">雖然您可以明確呼叫這個建構函式，在衍生的類別建構函式的建構函式宣告中，這通常不需要。大多數的編譯器會自動產生的呼叫。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">宣告呼叫程式碼可以存取權限要求執行程式碼會呼叫這個方法，即使堆疊中較高層的呼叫端未獲得存取資源的權限受保護的資源。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Using Assert can create security issues.</source>
          <target state="translated">使用判斷提示會造成安全性問題。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Calling Assert prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</source>
          <target state="translated">呼叫判斷提示，可避免來自之外的程式碼會呼叫這個方法的呼叫堆疊向上繼續進行的呼叫堆疊中較低堆疊查核行程。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</source>
          <target state="translated">因此，即使在呼叫堆疊中較高的呼叫端沒有必要的使用權限來存取資源，他們還是可以存取它透過呼叫這個方法所需的權限的程式碼。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>An assertion is effective only if the code that calls Assert passes the security check for the permission that it is asserting.</source>
          <target state="translated">判斷提示就會生效，只有當呼叫判斷提示的程式碼通過安全性檢查，它會判斷提示之權限。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The call to Assert is effective until the calling code returns to its caller.</source>
          <target state="translated">判斷提示的呼叫是有效，直到呼叫程式碼會傳回其呼叫端。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Only one Assert can be active on a frame.</source>
          <target state="translated">只有一個判斷提示可以是現用的框架。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>An attempt to call Assert when an active Assert exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.</source>
          <target state="translated">嘗試呼叫判斷提示，使用中的判斷提示上的框架會導致&lt;xref:System.Security.SecurityException&gt;.&lt;/xref:System.Security.SecurityException&gt;時</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Call &lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active Assert.</source>
          <target state="translated">呼叫&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;或&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;移除作用中的判斷提示。&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Assert is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">判斷提示該權限的要求將會失敗，因為未授與權限會被忽略。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>However, if code lower on the call stack calls &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call Assert.</source>
          <target state="translated">不過，如果在呼叫堆疊中較低的程式碼呼叫&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;該權限，&lt;xref:System.Security.SecurityException&gt;堆疊查核行程到達程式碼嘗試呼叫判斷提示時，會擲回。&lt;/xref:System.Security.SecurityException&gt; &lt;/xref:System.Security.CodeAccessPermission.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This happens because the code that called Assert has not been granted the permission, even though it tried to Assert it.</source>
          <target state="translated">這不會因為呼叫判斷提示的程式碼無法獲得的權限，即使它嘗試將它判斷提示。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Because calling Assert removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 呼叫 Assert 移除所有的程式碼呼叫鏈結中，必須授存取指定的資源的權限的需求，因為它可以開啟個安全性問題如果不正確或不當使用。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">因此，應該使用小心謹慎。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The calling code does not have <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermissionFlag"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">呼叫程式碼並沒有<bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermissionFlag"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>-or-       There is already an active Assert for the current frame.</source>
          <target state="translated">-或者-已經有使用中的判斷提示目前畫面格。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>When implemented by a derived class, creates and returns an identical copy of the current permission object.</source>
          <target state="translated">由衍生類別實作時，會建立並傳回目前權限物件的相同複本。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A copy of a permission object represents the same access to resources as the original permission object.</source>
          <target state="translated">權限物件的複本以原始的權限物件的資源表示相同的存取權。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A copy of the current permission object.</source>
          <target state="translated">目前的權限物件的複本。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Forces a &lt;xref:System.Security.SecurityException&gt; at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</source>
          <target state="translated">強制&lt;xref:System.Security.SecurityException&gt;所有呼叫堆疊中較高層的呼叫端未都獲得目前執行個體所指定的權限，如果在執行階段。&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">這個方法通常可由安全程式庫來確定呼叫端擁有存取資源的權限。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For example, a file class in a secure class library calls Demand for the necessary &lt;xref:System.Security.Permissions.FileIOPermission&gt; before performing a file operation requested by the caller.</source>
          <target state="translated">例如，檔案中的類別安全類別庫呼叫的必要需求&lt;xref:System.Security.Permissions.FileIOPermission&gt;之前執行檔案作業的呼叫端要求。&lt;/xref:System.Security.Permissions.FileIOPermission&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">不會檢查呼叫這個方法的程式碼的權限;檢查該程式碼的立即呼叫端從開始，然後進行堆疊。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Demand succeeds only if no &lt;xref:System.Security.SecurityException&gt; is raised.</source>
          <target state="translated">要求執行成功，只有當沒有&lt;xref:System.Security.SecurityException&gt;，就會引發。&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have the permission specified by the current instance.</source>
          <target state="translated">呼叫堆疊中較高層的呼叫端沒有目前的執行個體所指定的權限。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>-or-       A caller higher in the call stack has called &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; on the current permission object.</source>
          <target state="translated">-或-呼叫堆疊中較高層的呼叫端已呼叫&lt;xref:System.Security.CodeAccessPermission.Deny*&gt;上目前的權限物件。&lt;/xref:System.Security.CodeAccessPermission.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</source>
          <target state="translated">防止呼叫堆疊中較高層的呼叫端使用程式碼呼叫此方法來存取目前的執行個體所指定的資源。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The Deny method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; Deny 方法應只有要保護資源的意外存取完全信任的程式碼。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">它不應要保護資源的刻意誤用，而不受信任的程式碼。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a Deny for a permission and then calls method <ph id="ph2">`B`</ph>, method <ph id="ph3">`B`</ph> can overtly override the Deny by issuing an &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.</source>
          <target state="translated">例如，如果方法<ph id="ph1">`A`</ph>發出的 Deny 權限，然後再呼叫方法<ph id="ph2">`B`</ph>，方法<ph id="ph3">`B`</ph>overtly 覆寫，可以拒絕發行&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">所呼叫的方法一律是在堆疊中較高。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no Deny or &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; lower in the stack.</source>
          <target state="translated">因此，如果方法<ph id="ph1">`B`</ph>嘗試存取受保護的資源時，安全性系統會開始檢查它的權限，因為方法<ph id="ph2">`B`</ph>是立即呼叫端，上下然後查核行程來確認是否有任何的 Deny 堆疊或&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;堆疊中較低。&lt;/xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; method.</source>
          <target state="translated">方法<ph id="ph1">`B`</ph>，這嘗試存取資源，可以堆疊查核行程立即停止使用&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;方法。&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In that case, the Deny placed on the stack by method <ph id="ph1">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">在此情況下，Deny 放置在堆疊上方法<ph id="ph1">`A`</ph>永遠不會探索 （呼叫的方法）。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">這個方法會防止呼叫堆疊中較高層的呼叫端程式碼呼叫此方法，透過存取受保護的資源，即使這些呼叫端必須被授與存取權限。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Deny can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls Deny from being used to access the resource protected by the denied permission.</source>
          <target state="translated">拒絕可以限制程式設計人員的責任，或協助避免意外安全性問題，因為它可協助防止拒絕會從用來存取拒絕的權限所保護的資源呼叫的方法。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If a method calls Deny on a permission, and if a &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the Deny.</source>
          <target state="translated">如果方法呼叫拒絕權限，而且如果&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;到達拒絕時，安全性檢查的呼叫堆疊中較低的呼叫端所叫用該權限時，將會失敗。&lt;/xref:System.Security.CodeAccessPermission.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The call to Deny is effective until the calling code returns to its caller.</source>
          <target state="translated">拒絕的呼叫是有效，直到呼叫程式碼會傳回其呼叫端。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Only one Deny can be active on a frame.</source>
          <target state="translated">只有一個拒絕可以是現用的框架。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>An attempt to call Deny when an active Deny exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.</source>
          <target state="translated">嘗試在框架上的作用中的拒絕存在時，呼叫拒絕造成&lt;xref:System.Security.SecurityException&gt;.&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Call &lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active Deny.</source>
          <target state="translated">呼叫&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;或&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;若要移除的使用中的拒絕。&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Deny is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">拒絕權限未授與該權限的要求將會失敗，因為已忽略。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>There is already an active Deny for the current frame.</source>
          <target state="translated">已有作用中的拒絕，目前的框架。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Determines whether the specified <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object is equal to the current <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">決定是否指定<bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>物件是否等於目前<bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;xref:System.Object.Equals%2A&gt;.</source>
          <target state="translated">如需詳細資訊，請參閱&lt;xref:System.Object.Equals%2A&gt;.&lt;/xref:System.Object.Equals%2A&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to compare with the current <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>物件要與目前比較<bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the specified <bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> object is equal to the current <bpt id="p3">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>; otherwise, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果指定<bpt id="p2">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>物件是否等於目前<bpt id="p3">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>，否則<bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</source>
          <target state="translated">當在衍生類別中覆寫時，重新建構具有指定狀態的 XML 編碼方式的安全性物件。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Custom code that extends security objects needs to implement the &lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt; and FromXml methods to make the objects security-encodable.</source>
          <target state="translated">擴充安全性物件的自訂程式碼必須實作&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;和 FromXml 方法，使物件安全性 encodable。&lt;/xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The XML encoding to use to reconstruct the security object.</source>
          <target state="translated">XML 編碼用來重新建構安全性物件。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter does not contain the XML encoding for an instance of the same type as the current instance.</source>
          <target state="translated"><bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">elem</ph> <ept id="p1">&lt;/code&gt;</ept>參數不包含目前執行個體與相同類型的執行個體的 XML 編碼方式。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>-or-       The version number of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">elem</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not supported.</source>
          <target state="translated">-的版本號碼<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">elem</ph> <ept id="p1">&lt;/code&gt;</ept>不支援參數。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Gets a hash code for the <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that is suitable for use in hashing algorithms and data structures such as a hash table.</source>
          <target state="translated">取得的雜湊碼<bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>物件，其適合用於雜湊演算法和資料結構，例如雜湊表。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two &lt;xref:System.Security.CodeAccessPermission&gt; objects.</source>
          <target state="translated">相同的權限的兩個執行個體的雜湊程式碼可能會不同，因此雜湊程式碼不應比較兩個&lt;xref:System.Security.CodeAccessPermission&gt;物件。&lt;/xref:System.Security.CodeAccessPermission&gt;</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A hash code for the current <bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">目前的雜湊碼<bpt id="p1">&lt;xref href="System.Security.CodeAccessPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>物件。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</source>
          <target state="translated">由衍生類別實作時，會建立並傳回目前權限和指定的權限交集的權限。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The intersection of two permissions is a permission that describes the set of operations they both describe in common.</source>
          <target state="translated">兩個權限的交集會描述一組共同兩者描述的作業的權限。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Only a demand that passes both original permissions will pass the intersection.</source>
          <target state="translated">只有通過這兩個原始的使用權限的需求會通過交集。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>A permission to intersect with the current permission.</source>
          <target state="translated">要與目前權限產生交集的權限。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">它必須是類型的相同與目前權限。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A new permission that represents the intersection of the current permission and the specified permission.</source>
          <target state="translated">代表目前權限與指定權限交集的新權限。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This new permission is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the intersection is empty.</source>
          <target state="translated">這個新權限是<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果交集是空的。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">target</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> and is not an instance of the same class as the current permission.</source>
          <target state="translated"><bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">target</ph> <ept id="p1">&lt;/code&gt;</ept>參數不是<bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>並不是與目前權限具有相同類別的執行個體。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</source>
          <target state="translated">由衍生類別實作時，判斷目前權限是否為指定的權限的子集。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>A permission that is to be tested for the subset relationship.</source>
          <target state="translated">要測試子集關聯性的權限。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This permission must be of the same type as the current permission.</source>
          <target state="translated">此權限必須是類型的相同與目前權限。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current permission is a subset of the specified permission; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果目前權限是指定的權限的子集否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">target</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> and is not of the same type as the current permission.</source>
          <target state="translated"><bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">target</ph> <ept id="p1">&lt;/code&gt;</ept>參數不是<bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>而且不屬於相同的類型與目前權限。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</source>
          <target state="translated">防止呼叫堆疊中較高層的呼叫端使用程式碼呼叫此方法來存取目前的執行個體所指定之資源以外的所有資源。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The PermitOnly method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; PermitOnly 方法應只有要保護資源的意外存取完全信任的程式碼。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">它不應要保護資源的刻意誤用，而不受信任的程式碼。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a PermitOnly for a permission and then calls method <ph id="ph2">`B`</ph>, method <ph id="ph3">`B`</ph> can overtly override the PermitOnly by issuing an &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.</source>
          <target state="translated">例如，如果方法<ph id="ph1">`A`</ph>發出 PermitOnly 權限，然後再呼叫方法<ph id="ph2">`B`</ph>，方法<ph id="ph3">`B`</ph>可以 overtly 覆寫 PermitOnly 發出&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">所呼叫的方法一律是在堆疊中較高。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; or PermitOnly lower in the stack.</source>
          <target state="translated">因此，如果方法<ph id="ph1">`B`</ph>嘗試存取受保護的資源時，安全性系統會開始檢查它的權限，因為方法<ph id="ph2">`B`</ph>是立即呼叫端，上下然後查核行程的堆疊可以確認是否有任何&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;或 PermitOnly 堆疊中較低。&lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; method.</source>
          <target state="translated">方法<ph id="ph1">`B`</ph>，這嘗試存取資源，可以堆疊查核行程立即停止使用&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;方法。&lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In that case, the PermitOnly placed on the stack by method <ph id="ph1">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">在此情況下，PermitOnly 放置在堆疊上方法<ph id="ph1">`A`</ph>永遠不會探索 （呼叫的方法）。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>PermitOnly is similar to &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated">PermitOnly 是類似於&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;，在於兩者會導致堆疊查核行程符合則成功時失敗。&lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; specifies permissions that will cause the stack walk to fail, but PermitOnly specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">其差異在於，&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;指定權限，會導致堆疊查核行程失敗，但 PermitOnly 指定不會導致堆疊查核行程失敗的唯一權限。&lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">呼叫此方法，以確保您的程式碼，可用來存取指定的資源。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The call to PermitOnly is effective until the calling code returns to its caller.</source>
          <target state="translated">PermitOnly 的呼叫是有效的直到呼叫程式碼會傳回其呼叫端。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Only one PermitOnly can be active on a frame.</source>
          <target state="translated">只有一個 PermitOnly 可以是現用的框架。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>An attempt to call PermitOnly when an active PermitOnly exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.</source>
          <target state="translated">嘗試在框架上存在使用中的 PermitOnly 時呼叫 PermitOnly 造成&lt;xref:System.Security.SecurityException&gt;.&lt;/xref:System.Security.SecurityException&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Call &lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active PermitOnly.</source>
          <target state="translated">呼叫&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;或&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;移除作用中的 PermitOnly。&lt;/xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>PermitOnly is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated">PermitOnly 會忽略該權限的要求將會失敗，因為未授與的權限。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>However, if code lower on the call stack later calls &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call PermitOnly.</source>
          <target state="translated">不過，如果程式碼呼叫較低堆疊稍後呼叫&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;該權限，&lt;xref:System.Security.SecurityException&gt;堆疊查核行程到達程式碼嘗試呼叫 PermitOnly 時，會擲回。&lt;/xref:System.Security.SecurityException&gt; &lt;/xref:System.Security.CodeAccessPermission.Demand%2A&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This is because the code that called PermitOnly has not been granted the permission, even though it called PermitOnly for that permission.</source>
          <target state="translated">這是因為呼叫 PermitOnly 的程式碼無法獲得的權限，即使它針對該權限來呼叫 PermitOnly。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>There is already an active PermitOnly for the current frame.</source>
          <target state="translated">已針對目前的框架 active PermitOnly。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Causes all previous overrides for the current frame to be removed and no longer in effect.</source>
          <target state="translated">會導致所有先前覆寫會移除目前畫面且不再有作用。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If there are no overrides (&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;, &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, or &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;) for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">如果沒有任何覆寫 (&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;， &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;，或&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;) 目前的框架，&lt;xref:System.ExecutionEngineException&gt;就會擲回。&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt; &lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.Assert<bpt id="p1">*</bpt>&gt;, &lt;xref:System.Security.CodeAccessPermission.Deny<ept id="p1">*</ept>&gt;, or &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame.</source>
          <target state="translated">沒有先前&lt;&gt; <bpt id="p1">*</bpt>&gt;， &lt;&gt; &lt;/&gt; <ept id="p1">*</ept>&gt;，或&lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt;目前的框架。&lt;/xref:System.Security.CodeAccessPermission.PermitOnly*&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Causes any previous &lt;xref:System.Security.CodeAccessPermission.Assert*&gt; for the current frame to be removed and no longer in effect.</source>
          <target state="translated">格之任何先前&lt;xref:System.Security.CodeAccessPermission.Assert*&gt;要移除目前畫面格，且不再有作用。&lt;/xref:System.Security.CodeAccessPermission.Assert*&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If there is no &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">如果沒有任何&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;目前的框架，&lt;xref:System.ExecutionEngineException&gt;就會擲回。&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.Assert%2A&gt;</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.Assert*&gt; for the current frame.</source>
          <target state="translated">沒有先前&lt;xref:System.Security.CodeAccessPermission.Assert*&gt;目前的框架。&lt;/xref:System.Security.CodeAccessPermission.Assert*&gt;</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Causes any previous &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; for the current frame to be removed and no longer in effect.</source>
          <target state="translated">格之任何先前&lt;xref:System.Security.CodeAccessPermission.Deny*&gt;要移除目前畫面格，且不再有作用。&lt;/xref:System.Security.CodeAccessPermission.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If there is no &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">如果沒有任何&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;目前的框架，&lt;xref:System.ExecutionEngineException&gt;就會擲回。&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.Deny%2A&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; for the current frame.</source>
          <target state="translated">沒有先前&lt;xref:System.Security.CodeAccessPermission.Deny*&gt;目前的框架。&lt;/xref:System.Security.CodeAccessPermission.Deny*&gt;</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Causes any previous &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame to be removed and no longer in effect.</source>
          <target state="translated">格之任何先前&lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt;要移除目前畫面格，且不再有作用。&lt;/xref:System.Security.CodeAccessPermission.PermitOnly*&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If there is no &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.</source>
          <target state="translated">如果沒有任何&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;目前的框架，&lt;xref:System.ExecutionEngineException&gt;就會擲回。&lt;/xref:System.ExecutionEngineException&gt; &lt;/xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>There is no previous &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame.</source>
          <target state="translated">沒有先前&lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt;目前的框架。&lt;/xref:System.Security.CodeAccessPermission.PermitOnly*&gt;</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Creates and returns a string representation of the current permission object.</source>
          <target state="translated">建立並傳回目前權限物件的字串表示。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This method is useful in debugging when you need to display the permission as a string.</source>
          <target state="translated">這個方法是用於偵錯時您需要以字串形式顯示權限。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>A string representation of the current permission object.</source>
          <target state="translated">目前的權限物件的字串表示。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, creates an XML encoding of the security object and its current state.</source>
          <target state="translated">當在衍生類別中覆寫時，會建立安全性物件和其目前狀態的 XML 編碼方式。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Custom code that extends security objects needs to implement the ToXml and &lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt; methods to make the objects security-encodable.</source>
          <target state="translated">擴充安全性物件的自訂程式碼必須實作 ToXml 和&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;方法，以將物件變成安全性 encodable。&lt;/xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>An XML encoding of the security object, including any state information.</source>
          <target state="translated">安全性物件，包含所有狀態資訊的 XML 編碼方式。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</source>
          <target state="translated">當在衍生類別中覆寫時，會建立目前的權限與指定權限的聯集的權限。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The result of a call to Union is a permission that represents all the operations represented by both the current permission and the specified permission.</source>
          <target state="translated">要聯集呼叫的結果是權限，表示代表的所有作業目前的權限和指定的權限。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Any demand that passes either permission passes their union.</source>
          <target state="translated">傳遞其中一個權限的任何要求會傳遞它們的聯集。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>A permission to combine with the current permission.</source>
          <target state="translated">與目前權限結合的權限。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">它必須是類型的相同與目前權限。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A new permission that represents the union of the current permission and the specified permission.</source>
          <target state="translated">新的權限，表示目前的權限與指定權限的聯集。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This method is only supported at this level when passed <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">這個方法只支援在傳遞時，此層級<bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>