<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">090ebe53f727be99a100b9af773bb82108c2964a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.RequestBringIntoViewEventHandler.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">146702ede9be5f78d82f7591bf67735bc53b4f08</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bc516054c8f11ef86c766b5d8deb2ae53815760f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents the method that will handle the <bpt id="p1">&lt;xref href="System.Windows.FrameworkElement.RequestBringIntoView"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> routed event.</source>
          <target state="translated">代表將處理的方法<bpt id="p1">&lt;xref href="System.Windows.FrameworkElement.RequestBringIntoView"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>路由的事件。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</source>
          <target state="translated">處理此事件通常只是項目中，支援可捲動區域，或否則刻意將呈現大小為小於及其子系項目內容中，所需的組合大小，只由刻意處理事件之後，它有向上路由傳送項目樹狀結構中，而且已達到支援捲動區域的第一個父代。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is &lt;xref:System.Windows.Controls.ScrollViewer&gt;.</source>
          <target state="translated">現有的實作，處理方式，通常會需要使用者控制項的捲動區域為&lt;xref:System.Windows.Controls.ScrollViewer&gt;。&lt;/xref:System.Windows.Controls.ScrollViewer&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>If you derive from &lt;xref:System.Windows.Controls.ScrollViewer&gt;, you can register a class handler for &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; and supplement the base class handling of the event.</source>
          <target state="translated">如果您是衍生自&lt;xref:System.Windows.Controls.ScrollViewer&gt;，您可以註冊的類別處理常式&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;並補充基底類別處理事件。&lt;/xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; &lt;/xref:System.Windows.Controls.ScrollViewer&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You should also consider using or class-handling the class-defined &lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt; event instead of &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;.</source>
          <target state="translated">您也應該考慮使用或類別處理類別定義的&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;事件，而不是&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;.&lt;/xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; &lt;/xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Alternatively, if you create an entirely custom class that does not derive from &lt;xref:System.Windows.Controls.ScrollViewer&gt;, you can still add class handling by calling &lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=fullName&gt; in your class instantiation.</source>
          <target state="translated">或者，如果您建立完整的自訂類別，不是衍生自&lt;xref:System.Windows.Controls.ScrollViewer&gt;，您還是可以加入類別處理藉由呼叫&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=fullName&gt;您類別具現化。&lt;/xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=fullName&gt; &lt;/xref:System.Windows.Controls.ScrollViewer&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For details on class handling, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需類別處理的詳細資訊，請參閱<bpt id="p1">[</bpt>標示路由傳送事件中當做 Handled，和類別處理<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Content elements can cause the event to be raised by their content hosts (through calling &lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt; and raising &lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; from the content host).</source>
          <target state="translated">內容項目可能會導致引發的事件，由其內容主機 (透過呼叫&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;和引發&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt;內容主機)。&lt;/xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=fullName&gt; &lt;/xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Similarly, you can request logical tree elements to be brought into view with the helper method &lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">同樣地，您可以要求的 helper 方法&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=fullName&gt;.&lt;/xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=fullName&gt;帶入檢視的邏輯樹狀結構項目</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Windows.Controls.ListBox&gt; implements a related but different method &lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;.</source>
          <target state="translated">&lt;xref:System.Windows.Controls.ListBox&gt;實作&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;.&lt;/xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;相關但不同方法&lt;/xref:System.Windows.Controls.ListBox&gt;</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>