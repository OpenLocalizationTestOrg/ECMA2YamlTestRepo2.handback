<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ec4eb6abc1cdf4de3aec918a6749eb637feb389</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.ReaderWriterLock.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa260b1ec5f3c114c5ac5367d66c001eda77b1ee</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc33aa4e80118dfe4cd1a4cad4ba16b2cf1248f7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines a lock that supports single writers and multiple readers.</source>
          <target state="translated">定義支援單一寫入器和多個讀取器的鎖定。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The <ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph> has two reader-writer locks, &lt;xref:System.Threading.ReaderWriterLockSlim&gt; and ReaderWriterLock.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt;<ph id="ph2">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph>有兩個讀取器-寫入器鎖定，&lt;xref:System.Threading.ReaderWriterLockSlim&gt;和 ReaderWriterLock。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is recommended for all new development.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;建議所有新的開發。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;類似於 ReaderWriterLock，但它已簡化規則遞迴以及升級和降級鎖定狀態。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLockSlim&gt; avoids many cases of potential deadlock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;可避免可能發生死結的許多情況。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In addition, the performance of &lt;xref:System.Threading.ReaderWriterLockSlim&gt; is significantly better than ReaderWriterLock.</source>
          <target state="translated">此外，效能&lt;xref:System.Threading.ReaderWriterLockSlim&gt;明顯優於 ReaderWriterLock。&lt;/xref:System.Threading.ReaderWriterLockSlim&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ReaderWriterLock is used to synchronize access to a resource.</source>
          <target state="translated">ReaderWriterLock 用來同步處理資源的存取權。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</source>
          <target state="translated">在任何時候，它可讓多重執行緒的並行讀取權限，或是單一執行緒的寫入權限。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In a situation where a resource is changed infrequently, a <ph id="ph1">`ReaderWriterLock`</ph> provides better throughput than a simple one-at-a-time lock, such as &lt;xref:System.Threading.Monitor&gt;.</source>
          <target state="translated">資源不常變更的情況下<ph id="ph1">`ReaderWriterLock`</ph>提供更佳的輸送量，比簡單的其中一個-一次鎖定，例如&lt;xref:System.Threading.Monitor&gt;.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ReaderWriterLock`</ph> works best where most accesses are reads, while writes are infrequent and of short duration.</source>
          <target state="translated"><ph id="ph1">`ReaderWriterLock`</ph>其中大部分的存取，則讀取、 寫入不頻繁和短時間內，效果最好。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</source>
          <target state="translated">多個讀取器的替代與單一寫入器，因此會讀取器或寫入器會封鎖長時間。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Holding reader locks or writer locks for long periods will starve other threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 的長時間會影響其他執行緒持有讀取器鎖定或寫入器鎖定。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For best performance, consider restructuring your application to minimize the duration of writes.</source>
          <target state="translated">為了達到最佳效能，請考慮重建您的應用程式寫入的持續時間降至最低。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>A thread can hold a reader lock or a writer lock, but not both at the same time.</source>
          <target state="translated">執行緒可以保留讀取鎖定或寫入器鎖定，但不可同時在相同的時間。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Instead of releasing a reader lock in order to acquire the writer lock, you can use &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;.</source>
          <target state="translated">而不是為了取得寫入器鎖定釋放讀取器的鎖定，您可以使用&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;和&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Recursive lock requests increase the lock count on a lock.</source>
          <target state="translated">遞迴的鎖定要求增加上鎖定的鎖定計數。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Readers and writers are queued separately.</source>
          <target state="translated">是個別佇列讀取器和寫入器。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</source>
          <target state="translated">當執行緒釋放寫入器的鎖定時，那時讀取器佇列中等待的所有執行緒授都與讀取器鎖定。當這些讀取器鎖定的所有已發行下, 一個執行緒等候寫入器中排入佇列，如果任何，授與寫入器的鎖定，等等。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In other words, <ph id="ph1">`ReaderWriterLock`</ph> alternates between a collection of readers, and one writer.</source>
          <target state="translated">換句話說，<ph id="ph1">`ReaderWriterLock`</ph>交替讀取器，集合和一個寫入器。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</source>
          <target state="translated">當寫入器佇列中的執行緒正在等候讀取器鎖定釋出時，要求新的讀取器鎖定的執行緒會累積讀取器佇列中。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</source>
          <target state="translated">要求未獲授予，即使它們無法與現有的讀取器鎖定持有者; 共用的並行存取這有助於保護針對讀取者無限期發生封鎖情形等的寫入器。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Most methods for acquiring locks on a <ph id="ph1">`ReaderWriterLock`</ph> accept time-out values.</source>
          <target state="translated">大部分的方法上取得鎖定<ph id="ph1">`ReaderWriterLock`</ph>接受逾時值。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Use time-outs to avoid deadlocks in your application.</source>
          <target state="translated">若要避免死結，應用程式中的使用逾時。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</source>
          <target state="translated">比方說，執行緒可能會取得一個資源寫入器鎖定，而且然後要求第二個資源; 讀取器鎖定在此同時，另一個執行緒可能取得寫入器鎖定，第二個資源，並要求在第一個讀取器的鎖定。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Unless time-outs are used, the threads deadlock.</source>
          <target state="translated">除非使用逾時，執行緒會鎖死。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">如果逾時間隔到期且未被授與鎖定要求，方法會傳回控制項至呼叫的執行緒所擲回&lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A thread can catch this exception and determine what action to take next.</source>
          <target state="translated">執行緒可以捕捉此例外狀況，並判斷要採取的後續動作。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Time-outs are expressed in milliseconds.</source>
          <target state="translated">逾時值被以毫秒為單位。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you use a &lt;xref:System.TimeSpan?displayProperty=fullName&gt; to specify the time-out, the value used is the total number of whole milliseconds represented by the &lt;xref:System.TimeSpan&gt;.</source>
          <target state="translated">如果您使用&lt;xref:System.TimeSpan?displayProperty=fullName&gt;指定逾時，所使用的值是由&lt;xref:System.TimeSpan&gt;.&lt;/xref:System.TimeSpan&gt;表示整數毫秒總數&lt;/xref:System.TimeSpan?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following table shows the valid time-out values in milliseconds.</source>
          <target state="translated">下表顯示有效的逾時值以毫秒為單位。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>|Value|Description|   |-----------|-----------------|   |-1|The thread waits until the lock is acquired, regardless of how long it takes.</source>
          <target state="translated">|值 |描述 |  |-----------|-----------------|  |-1 |執行緒等候，直到鎖定，則不論花費的時間。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For methods that specify integer time-outs, the constant &lt;xref:System.Threading.Timeout.Infinite&gt; can be used.|   |0|The thread does not wait to acquire the lock.</source>
          <target state="translated">指定整數逾時的方法，您可以使用常數&lt;xref:System.Threading.Timeout.Infinite&gt;。 |  |&amp;0; |執行緒不會等候取得鎖定。&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If the lock cannot be acquired immediately, the method returns.|   |&gt;0|The number of milliseconds to wait.|       With the exception of -1, negative time-out values are not allowed.</source>
          <target state="translated">如果無法立即取得鎖定，則方法會傳回。 |  | &gt;&amp;0; |要等候的毫秒數。 |      -1，除了不允許負值。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you specify a negative integer other than -1, a time-out value of zero is used instead.</source>
          <target state="translated">如果您指定-1 以外的負數的整數，改為使用零的逾時值。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a &lt;xref:System.TimeSpan&gt; that represents a negative number of milliseconds other than -1, &lt;xref:System.ArgumentOutOfRangeException&gt; is thrown.</source>
          <target state="translated">（亦即，方法會傳回而不要等候，如果無法立即取得鎖定。）如果您指定&lt;xref:System.TimeSpan&gt;表示毫秒-1，以外的負數&lt;xref:System.ArgumentOutOfRangeException&gt;就會擲回。&lt;/xref:System.ArgumentOutOfRangeException&gt; &lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">初始化的新執行個體<bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>類別。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">取得讀取器鎖定，請使用&lt;xref:System.Int32&gt;逾時值。&lt;/xref:System.Int32&gt;</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>AcquireReaderLock blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">如果在不同的執行緒寫入器的鎖定，或至少一個執行緒正在等候寫入器的鎖定，就會封鎖 AcquireReaderLock。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 如果目前執行緒已寫入器的鎖定，沒有讀取器鎖定。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">相反地，寫入器的鎖定上的鎖定計數會遞增。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">這可防止在其本身的寫入器鎖定上封鎖執行緒。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">結果是完全呼叫相同&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;，以及額外的呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;釋放寫入器鎖定時，就需要。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>支援遞迴的讀取器鎖定要求。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">也就是說，執行緒可以呼叫 AcquireReaderLock 多次，這在每次增加的鎖定計數。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">您必須呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;一次針對每次呼叫<ph id="ph1">`AcquireReaderLock`</ph>。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">或者，您可以呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;減少鎖定計數為零立即。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">遞迴的鎖定要求會一律立即授與，而不會讓讀取器佇列中要求的執行緒。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">遞迴鎖定謹慎使用，以避免長時間封鎖寫入器鎖定要求。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有效的逾時值，請參閱&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">以毫秒為單位的逾時。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>到期之前授與鎖定要求。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Acquires a reader lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">取得讀取器鎖定，請使用&lt;xref:System.TimeSpan&gt;逾時值。&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt; blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated">&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;如果在不同的執行緒寫入器的鎖定，或至少一個執行緒正在等候寫入器的鎖定封鎖。&lt;/xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 如果目前執行緒已寫入器的鎖定，沒有讀取器鎖定。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">相反地，寫入器的鎖定上的鎖定計數會遞增。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">這可防止在其本身的寫入器鎖定上封鎖執行緒。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.</source>
          <target state="translated">結果是完全呼叫相同&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;，以及額外的呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;釋放寫入器鎖定時，就需要。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph>支援遞迴的讀取器鎖定要求。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">也就是說，執行緒可以呼叫 AcquireReaderLock 多次，這在每次增加的鎖定計數。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id="ph1">`AcquireReaderLock`</ph>.</source>
          <target state="translated">您必須呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;一次針對每次呼叫<ph id="ph1">`AcquireReaderLock`</ph>。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">或者，您可以呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;減少鎖定計數為零立即。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">遞迴的鎖定要求會一律立即授與，而不會讓讀取器佇列中要求的執行緒。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">遞迴鎖定謹慎使用，以避免長時間封鎖寫入器鎖定要求。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有效的逾時值，請參閱&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated">A <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>指定逾時期限。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>到期之前授與鎖定要求。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>指定-1 毫秒以外的負數的值。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using an &lt;xref:System.Int32&gt; value for the time-out.</source>
          <target state="translated">取得寫入器鎖定，請使用&lt;xref:System.Int32&gt;逾時值。&lt;/xref:System.Int32&gt;</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">這個方法會封鎖，如果另一個執行緒讀取器的鎖定或寫入器鎖定。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">如需說明的方式的寫入器鎖定替代項目與多個並行讀取器鎖定，請參閱&lt;xref:System.Threading.ReaderWriterLock&gt;類別。&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">已讀取器的鎖定的執行緒可以取得寫入器鎖定在兩種方式之一︰ 釋放讀取器鎖定，然後再呼叫 AcquireWriterLock，或呼叫&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 如果呼叫執行緒<ph id="ph2">`AcquireWriterLock`</ph>時仍有讀取器的鎖定，它會封鎖讀取器鎖定上; 如果指定無限逾時，就會鎖死的執行緒。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">若要避免這類死結，請使用&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;來判斷目前的執行緒是否已有讀取器的鎖定。&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>支援遞迴的寫入器鎖定要求。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">也就是說，執行緒可以呼叫<ph id="ph1">`AcquireWriterLock`</ph>許多次，其中的鎖定計數遞增每一次。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">您必須呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;一次針對每次呼叫<ph id="ph1">`AcquireWriterLock`</ph>。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">或者，您可以呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;減少鎖定計數為零立即。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">遞迴的鎖定要求會一律立即授與，而不會讓寫入器佇列中要求的執行緒。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有效的逾時值，請參閱&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">以毫秒為單位的逾時。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>到期之前授與鎖定要求。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Acquires the writer lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.</source>
          <target state="translated">取得寫入器鎖定，請使用&lt;xref:System.TimeSpan&gt;逾時值。&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">這個方法會封鎖，如果另一個執行緒讀取器的鎖定或寫入器鎖定。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.</source>
          <target state="translated">如需說明的方式的寫入器鎖定替代項目與多個並行讀取器鎖定，請參閱&lt;xref:System.Threading.ReaderWriterLock&gt;類別。&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">已讀取器的鎖定的執行緒可以取得寫入器鎖定在兩種方式之一︰ 釋放讀取鎖定，然後再呼叫&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;，或藉由呼叫&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  If a thread calls <ph id="ph2">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 如果呼叫執行緒<ph id="ph2">`AcquireWriterLock`</ph>時仍有讀取器的鎖定，它會封鎖讀取器鎖定上; 如果指定無限逾時，就會鎖死的執行緒。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.</source>
          <target state="translated">若要避免這類死結，請使用&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;來判斷目前的執行緒是否已有讀取器的鎖定。&lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph>支援遞迴的寫入器鎖定要求。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">也就是說，執行緒可以呼叫<ph id="ph1">`AcquireWriterLock`</ph>許多次，其中的鎖定計數遞增每一次。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id="ph1">`AcquireWriterLock`</ph>.</source>
          <target state="translated">您必須呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;一次針對每次呼叫<ph id="ph1">`AcquireWriterLock`</ph>。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.</source>
          <target state="translated">或者，您可以呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;減少鎖定計數為零立即。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">遞迴的鎖定要求會一律立即授與，而不會讓寫入器佇列中要求的執行緒。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有效的逾時值，請參閱&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>指定逾時期限。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>到期之前授與鎖定要求。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>指定-1 毫秒以外的負數的值。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</source>
          <target state="translated">指出是否將寫入器鎖定授與任何執行緒已取得序號之後。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You can use &lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt; and <ph id="ph1">`AnyWritersSince`</ph> to improve application performance.</source>
          <target state="translated">您可以使用&lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;和<ph id="ph1">`AnyWritersSince`</ph>改善應用程式效能。&lt;/xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">例如，執行緒可能會快取保留讀取鎖定時取得的資訊。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>After releasing and later reacquiring the lock, the thread can use <ph id="ph1">`AnyWritersSince`</ph> to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</source>
          <target state="translated">釋出和更新版本重新取得鎖定之後, 可以使用執行緒<ph id="ph1">`AnyWritersSince`</ph>來判斷是否其他執行緒的資源寫入暫時; 如果沒有，可以使用快取的資訊。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">這個技術非常有用是高度耗費資源; 讀取鎖定所保護的資訊例如，執行資料庫查詢。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">呼叫端必須寫入器鎖定或讀取器鎖定保留順序，序號才能發揮作用。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The sequence number.</source>
          <target state="translated">序號。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果寫入器鎖定已授與至任何執行緒因為取得序號。否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt; was called.</source>
          <target state="translated">將執行緒的鎖定狀態還原成之前&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;呼叫。&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>DowngradeFromWriterLock releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</source>
          <target state="translated">DowngradeFromWriterLock 釋放寫入器的鎖定，不論遞迴鎖定計數，並還原已由執行緒持有然後再升級至寫入器鎖定的讀取器鎖定。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The lock count on the reader lock is restored.</source>
          <target state="translated">在讀取器鎖定的鎖定計數就會還原。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph><ph id="ph2"> &gt;  </ph><ph id="ph3">`DowngradeFromWriterLock`</ph> accepts a &lt;xref:System.Threading.LockCookie&gt; obtained by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> <ph id="ph2"> &gt;  </ph> <ph id="ph3">`DowngradeFromWriterLock`</ph>接受&lt;xref:System.Threading.LockCookie&gt;藉由呼叫&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;取得&lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Do not use a <ph id="ph1">`LockCookie`</ph> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">請勿使用<ph id="ph1">`LockCookie`</ph>傳回&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</source>
          <target state="translated">執行緒不會封鎖寫入器的鎖定，從降級時，即使其他執行緒正在等候寫入器的鎖定，因為當使用者放開寫入器鎖定授與所有的讀取器鎖定要求。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>傳回&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">執行緒沒有寫入器的鎖定。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">位址<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept>為 null 指標。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">確認釋出資源，並在記憶體回收行程回收時執行其他清除作業<bpt id="p1">&lt;xref href="System.Threading.ReaderWriterLock"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>物件。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The garbage collector calls Finalize when the current &lt;xref:System.Threading.ReaderWriterLock&gt; object is ready to be finalized.</source>
          <target state="translated">記憶體回收行程呼叫完成時目前&lt;xref:System.Threading.ReaderWriterLock&gt;物件已經準備最終處理而。&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds a reader lock.</source>
          <target state="translated">取得值，指出目前的執行緒是否掌握讀取器的鎖定。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds a reader lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果目前的執行緒掌握讀取器的鎖定。否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current thread holds the writer lock.</source>
          <target state="translated">取得值，指出目前的執行緒是否掌握寫入器的鎖定。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the current thread holds the writer lock; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果目前的執行緒掌握寫入器的鎖定。否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Releases the lock, regardless of the number of times the thread acquired the lock.</source>
          <target state="translated">釋放鎖定，無論執行緒取得鎖定的次數。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count.</source>
          <target state="translated">讀取器鎖定或寫入器鎖定，不論遞迴鎖定計數為何，釋出之情況下呼叫。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>To restore the state of the lock, including the lock count, pass the &lt;xref:System.Threading.LockCookie&gt; to &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">若要還原狀態的鎖定，包括的鎖定計數，將傳遞&lt;xref:System.Threading.LockCookie&gt;至&lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt; &lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value representing the released lock.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>值，代表釋放的鎖定。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Decrements the lock count.</source>
          <target state="translated">減量鎖定計數。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>ReleaseReaderLock decrements the lock count.</source>
          <target state="translated">ReleaseReaderLock 減量鎖定計數。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>When the count reaches zero, the lock is released.</source>
          <target state="translated">當計數到達零時，會釋放鎖定。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has the writer lock, calling <ph id="ph2">`ReleaseReaderLock`</ph> has the same effect as calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 如果執行緒有將寫入器鎖定，則呼叫<ph id="ph2">`ReleaseReaderLock`</ph>已呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;相同的效果</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If a thread has no locks, calling <ph id="ph1">`ReleaseReaderLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">如果執行緒不有任何鎖定，則呼叫<ph id="ph1">`ReleaseReaderLock`</ph> &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;會擲回</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The thread does not have any reader or writer locks.</source>
          <target state="translated">執行緒沒有任何讀取器或寫入器鎖定。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Decrements the lock count on the writer lock.</source>
          <target state="translated">寫入器的鎖定的鎖定計數遞減。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>ReleaseWriterLock decrements the writer lock count.</source>
          <target state="translated">ReleaseWriterLock 減量寫入器的鎖定計數。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When the count reaches zero, the writer lock is released.</source>
          <target state="translated">當計數到達零時，就會寫入器鎖定釋放。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If a thread has a reader lock, or no locks, calling <ph id="ph2">`ReleaseWriterLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; 如果執行緒有讀取器的鎖定或沒有鎖定，則呼叫<ph id="ph2">`ReleaseWriterLock`</ph> &lt;xref:System.ApplicationException&gt;.&lt;/xref:System.ApplicationException&gt;會擲回</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">執行緒沒有寫入器的鎖定。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Restores the lock status of the thread to what it was before calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">將執行緒的鎖定狀態還原成之前呼叫&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The state restored by <ph id="ph1">`RestoreLock`</ph> includes the recursive lock count.</source>
          <target state="translated">還原狀態<ph id="ph1">`RestoreLock`</ph>包含遞迴鎖定計數。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</source>
          <target state="translated">如果它嘗試還原另一個執行緒取得寫入器鎖定之後，或如果它嘗試還原另一個執行緒取得讀取器鎖定或寫入器鎖定之後的寫入器鎖定的讀取器的鎖定的執行緒封鎖。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`RestoreLock`</ph> does not accept a time-out, you should take care to avoid possible deadlocks.</source>
          <target state="translated">因為<ph id="ph1">`RestoreLock`</ph>不接受逾時，您應謹慎避免可能的死結。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Before calling <ph id="ph2">`RestoreLock`</ph>, make sure you have released all locks acquired since the call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; 之前先呼叫<ph id="ph2">`RestoreLock`</ph>，請確定您已發行至&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;。&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;呼叫取得的所有鎖定</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</source>
          <target state="translated">例如，執行緒死結若取得讀取器的鎖定，然後再嘗試還原較早的寫入器鎖定。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; to detect such additional locks.</source>
          <target state="translated">使用&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;和&lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt;偵測這類額外的鎖定。&lt;/xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; &lt;/xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Do not use a &lt;xref:System.Threading.LockCookie&gt; returned from &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.</source>
          <target state="translated">請勿使用&lt;xref:System.Threading.LockCookie&gt;從&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;傳回&lt;/xref:System.Threading.LockCookie&gt;</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>傳回&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.&lt;/xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The address of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lockCookie</ph><ept id="p1">&lt;/code&gt;</ept> is a null pointer.</source>
          <target state="translated">位址<bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">lockCookie</ph> <ept id="p1">&lt;/code&gt;</ept>為 null 指標。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using an <bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">將讀取器鎖定升級至寫入器鎖定，使用<bpt id="p1">&lt;xref uid="langword_csharp_Int32" name="Int32" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>逾時值。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">當一個執行緒呼叫<ph id="ph1">`UpgradeToWriterLock`</ph>釋放讀取器鎖定，鎖定計數，不管和執行緒進行的寫入器鎖定的佇列結尾。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">因此，其他執行緒可能會寫入之前要求升級會授與寫入器鎖定的執行緒資源。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 之前呼叫 UpgradeToWriterLock 方法可以取得讀取器鎖定逾時例外狀況不擲回。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">如果沒有其他執行緒等候寫入器鎖定，此事件會立即發生。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>However, if another thread is queued for the writer lock, the thread that called the UpgradeToWriterLock method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">不過，如果另一個執行緒在佇列中等候寫入器的鎖定，呼叫 UpgradeToWriterLock 方法無法取得讀取器鎖定直到所有目前的讀取器已釋放其鎖定，以及一個執行緒具有取得和釋放寫入器的鎖定。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the UpgradeToWriterLock method.</source>
          <target state="translated">即使要求寫入器鎖定的執行緒在目前的執行緒呼叫 UpgradeToWriterLock 方法之後要求也是如此。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">若要還原的鎖定狀態，請呼叫&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;使用&lt;xref:System.Threading.LockCookie&gt;傳回<ph id="ph1">`UpgradeToWriterLock`</ph>。&lt;/xref:System.Threading.LockCookie&gt; &lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">不使用這個<ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;與</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">當執行緒必須沒有讀取器的鎖定時，請勿使用<ph id="ph1">`UpgradeToWriterLock`</ph>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">使用&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;改用。&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有效的逾時值，請參閱&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The time-out in milliseconds.</source>
          <target state="translated">以毫秒為單位的逾時。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph>到期之前授與鎖定要求。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Upgrades a reader lock to the writer lock, using a <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value for the time-out.</source>
          <target state="translated">將讀取器鎖定升級至寫入器鎖定，使用<bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>逾時值。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">當一個執行緒呼叫<ph id="ph1">`UpgradeToWriterLock`</ph>釋放讀取器鎖定，鎖定計數，不管和執行緒進行的寫入器鎖定的佇列結尾。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">因此，其他執行緒可能會寫入之前要求升級會授與寫入器鎖定的執行緒資源。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method can reacquire the reader lock.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; 逾時例外狀況不會擲回呼叫執行緒直到&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;方法可以取得讀取器鎖定。&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">如果沒有其他執行緒等候寫入器鎖定，此事件會立即發生。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>However, if another thread is queued for the writer lock, the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">不過，如果另一個執行緒在佇列中等候寫入器的鎖定，執行緒的呼叫&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;方法不能重新取得讀取器鎖定，直到所有目前的讀取器已釋放其鎖定，以及一個執行緒具有取得和釋放寫入器的鎖定。&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method.</source>
          <target state="translated">這是 true，即使要求寫入器鎖定的執行緒在目前的執行緒呼叫之後要求&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;方法。&lt;/xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">若要還原的鎖定狀態，請呼叫&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;使用&lt;xref:System.Threading.LockCookie&gt;傳回<ph id="ph1">`UpgradeToWriterLock`</ph>。&lt;/xref:System.Threading.LockCookie&gt; &lt;/xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.</source>
          <target state="translated">不使用這個<ph id="ph1">`LockCookie`</ph> &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.&lt;/xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;與</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">當執行緒必須沒有讀取器的鎖定時，請勿使用<ph id="ph1">`UpgradeToWriterLock`</ph>。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.</source>
          <target state="translated">使用&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;改用。&lt;/xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.</source>
          <target state="translated">有效的逾時值，請參閱&lt;xref:System.Threading.ReaderWriterLock&gt;.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> specifying the time-out period.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_TimeSpan" name="TimeSpan" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>指定逾時期限。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.LockCookie"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>到期之前授與鎖定要求。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;timeout&lt;/code&gt;</ph>指定-1 毫秒以外的負數的值。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Gets the current sequence number.</source>
          <target state="translated">取得目前的序號。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The sequence number increases whenever a thread acquires the writer lock.</source>
          <target state="translated">此順序數字會增加每當執行緒取得寫入器的鎖定。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>You can save the sequence number and pass it to &lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt; at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</source>
          <target state="translated">您可以儲存的序號，並將它傳遞給&lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;稍後，如果您想要判斷是否其他執行緒已取得寫入器鎖定 gotoreportmanager。&lt;/xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`WriterSeqNum`</ph> to improve application performance.</source>
          <target state="translated">您可以使用<ph id="ph1">`WriterSeqNum`</ph>改善應用程式效能。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">例如，執行緒可能會快取保留讀取鎖定時取得的資訊。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling <ph id="ph1">`AnyWritersSince`</ph>; if not, the cached information can be used.</source>
          <target state="translated">之後釋出和更新版本重新取得鎖定，執行緒可以判斷其他的執行緒是否已寫入至資源藉由呼叫<ph id="ph1">`AnyWritersSince`</ph>; 如果沒有，可以使用快取的資訊。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">讀取鎖定所保護的資訊是高度耗費資源; 時，這項技術非常有用例如，執行資料庫查詢。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">呼叫端必須寫入器鎖定或讀取器鎖定保留順序，序號才能發揮作用。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The current sequence number.</source>
          <target state="translated">目前的序號。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>