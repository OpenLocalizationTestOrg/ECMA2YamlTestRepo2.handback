<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4691a6e122ecbf5305faed03fb963be4f3007c7e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Windows.DependencyPropertyKey.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ca268bf0b8f34f96fc336bc5ef0b6e35ad9e9e0d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f8a436c8a112474f58b9bb1881a040508df4e8e6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides a dependency property identifier for limited write access to a read-only dependency property.</source>
          <target state="translated">提供有限的唯讀相依性屬性的寫入權限相依性屬性的識別項。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>DependencyPropertyKey instances are obtained as the return value of a dependency property registration call using the methods &lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt; or &lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;.</source>
          <target state="translated">取得做為傳回值的相依性屬性註冊呼叫使用方法&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;或&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;.&lt;/xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt; &lt;/xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt; DependencyPropertyKey 執行個體</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The types that register a dependency property can use the DependencyPropertyKey in calls to &lt;xref:System.Windows.DependencyObject.SetValue%2A&gt; and &lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt; that adjust the property's value as part of class logic.</source>
          <target state="translated">註冊相依性屬性的型別可用於呼叫的 DependencyPropertyKey&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;和&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;，調整屬性的值做為類別邏輯的一部分。&lt;/xref:System.Windows.DependencyObject.ClearValue%2A&gt; &lt;/xref:System.Windows.DependencyObject.SetValue%2A&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>If permitted by the access level of the key, related classes can use the key and the dependency property also.</source>
          <target state="translated">如果允許索引鍵的存取層級，相關的類別也可以使用索引鍵和相依性屬性。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</source>
          <target state="translated">比方說，您可以宣告為內部，索引鍵和相同的組件內的其他類型也可以設定該相依性屬性。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The DependencyPropertyKey returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</source>
          <target state="translated">傳回唯讀相依性屬性註冊 DependencyPropertyKey 應該不能為 public，因為公開索引鍵會讓此屬性可設定，因此擊敗登錄為唯讀相依性屬性的點。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Also, exposing the key causes a mismatch between the available dependency property behaviors and its <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]</ph> property wrapper implementations, which is bad class design.</source>
          <target state="translated">此外，公開索引鍵會導致不相符的可用的相依性屬性行為和其<ph id="ph1">[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]</ph>屬性的包裝函式實作，也就是不正確的類別設計。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Instead of exposing the key itself, you should instead expose the &lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt; value of the DependencyPropertyKey as a <ph id="ph1">`public static readonly`</ph>&lt;xref:System.Windows.DependencyProperty&gt; on your class.</source>
          <target state="translated">而不是公開本身的索引鍵，您應該改為公開&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;值做為 DependencyPropertyKey <ph id="ph1">`public static readonly`</ph> &lt;xref:System.Windows.DependencyProperty&gt;上您的類別。&lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</source>
          <target state="translated">這可讓屬性以傳回特定屬性系統作業，例如列舉本機設定值有效的相依性屬性的識別項。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>However, the identifier thus obtained does not have the full capabilities of a &lt;xref:System.Windows.DependencyProperty&gt; for many property system operations.</source>
          <target state="translated">但是，因此取得的識別項不需要的完整功能&lt;xref:System.Windows.DependencyProperty&gt;許多屬性系統作業。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</source>
          <target state="translated">取得與此特製化的唯讀相依性屬性的識別項相關聯的相依性屬性識別碼。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The DependencyProperty value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</source>
          <target state="translated">DependencyProperty 值可讓加入共同使用一些相同的介面所使用的讀寫相依性屬性的屬性系統作業的唯讀屬性的識別項。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In order to implement the get property accessor for a read-only dependency property, you should create and expose a &lt;xref:System.Windows.DependencyProperty&gt; identifier on your class.</source>
          <target state="translated">若要實作唯讀相依性屬性的 get 屬性存取子，您應該建立，並公開 （expose） 為&lt;xref:System.Windows.DependencyProperty&gt;您的類別識別項&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This serves two purposes:      -   Your own class needs the &lt;xref:System.Windows.DependencyProperty&gt; identifier in order to implement the get accessor for the property wrapper.</source>
          <target state="translated">這有兩種用途:-您擁有類別需要&lt;xref:System.Windows.DependencyProperty&gt;為了實作 get 存取子屬性的包裝函式的識別項。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You use the &lt;xref:System.Windows.DependencyProperty&gt; as a parameter for the &lt;xref:System.Windows.DependencyObject.GetValue%2A&gt; call that implements the get accessor.</source>
          <target state="translated">您使用&lt;xref:System.Windows.DependencyProperty&gt;做為參數的&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;實作 get 存取子的呼叫。&lt;/xref:System.Windows.DependencyObject.GetValue%2A&gt; &lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>-   &lt;xref:System.Windows.DependencyProperty&gt; identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</source>
          <target state="translated">-&lt;xref:System.Windows.DependencyProperty&gt;識別項會公開屬性系統相依性屬性，使依賴中繼資料的其他方法可以存取它之標準格式。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For instance, if you called &lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt; on some &lt;xref:System.Windows.DependencyObject&gt; and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your &lt;xref:System.Windows.DependencyProperty&gt; value rather than the key.</source>
          <target state="translated">比方說，如果您呼叫&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;上某些&lt;xref:System.Windows.DependencyObject&gt;，並且取得列舉型別在本機上設定屬性 （「 值 」 和 「 識別碼 」） 的識別碼傳回唯讀相依性屬性將會是您&lt;xref:System.Windows.DependencyProperty&gt;值而不是索引鍵。&lt;/xref:System.Windows.DependencyProperty&gt; &lt;/xref:System.Windows.DependencyObject&gt; &lt;/xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Not exposing a &lt;xref:System.Windows.DependencyProperty&gt; identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</source>
          <target state="translated">不會公開&lt;xref:System.Windows.DependencyProperty&gt;識別碼不會增加您以任何方式的唯讀相依性屬性的安全性，它只會牽涉到更造成不便同時用於後續的衍生的類別以及類別執行個體屬性的作業。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To expose the  &lt;xref:System.Windows.DependencyProperty&gt; identifier on your class, you call DependencyProperty directly on your key.</source>
          <target state="translated">若要公開&lt;xref:System.Windows.DependencyProperty&gt;類別上的識別項，您呼叫 DependencyProperty 直接在您的金鑰。&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Use this value to create a <ph id="ph1">`public static readonly`</ph>&lt;xref:System.Windows.DependencyProperty&gt; identifier on the class, which parallels the &lt;xref:System.Windows.DependencyPropertyKey&gt;.</source>
          <target state="translated">使用此值以建立<ph id="ph1">`public static readonly`</ph>&lt;xref:System.Windows.DependencyProperty&gt;類別，這與&lt;xref:System.Windows.DependencyPropertyKey&gt;.&lt;/xref:System.Windows.DependencyPropertyKey&gt;上的識別項&lt;/xref:System.Windows.DependencyProperty&gt;</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The relevant dependency property identifier.</source>
          <target state="translated">相關的相依性屬性的識別項。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</source>
          <target state="translated">覆寫此相依性屬性的識別項所表示之唯讀相依性屬性的中繼資料。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</source>
          <target state="translated">覆寫唯讀相依性屬性的中繼資料基於相似的原因與覆寫中繼資料讀寫相依性屬性，並僅限於使用索引鍵的層級的存取，因為指定的中繼資料中的行為可能會變更設定的行為 （預設值，執行個體）。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</source>
          <target state="translated">為具有讀寫相依性屬性，覆寫唯讀相依性屬性的中繼資料，才應該在屬性 （這相當於特定的執行個體的註冊屬性的物件具現化的時間） 的屬性系統放在使用之前。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Calls to OverrideMetadata should only be performed within the static constructors of the type that provides itself as the <ph id="ph1">`forType`</ph> parameter of this method, or equivalent initialization for that class.</source>
          <target state="translated">OverrideMetadata 呼叫執行應該只能在靜態建構函式的類型，提供本身為<ph id="ph1">`forType`</ph>這個方法或對等初始化時，該類別的參數。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This method effectively forwards to the &lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt; method, passing the &lt;xref:System.Windows.DependencyPropertyKey&gt; instance as the key parameter.</source>
          <target state="translated">這個方法實際上會轉送至&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;方法，傳遞&lt;xref:System.Windows.DependencyPropertyKey&gt;做為索引鍵參數的執行個體。&lt;/xref:System.Windows.DependencyPropertyKey&gt; &lt;/xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The type on which this dependency property exists and metadata should be overridden.</source>
          <target state="translated">在此相依性屬性存在，而且應該覆寫中繼資料型別。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Metadata supplied for this type.</source>
          <target state="translated">此類型提供的中繼資料。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Attempted metadata override on a read-write dependency property (cannot be done using this signature).</source>
          <target state="translated">嘗試的中繼資料覆寫讀寫相依性屬性 (無法完成使用此簽章)。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Metadata was already established for the property as it exists on the provided type.</source>
          <target state="translated">為存在於提供的型別中繼資料已建立的屬性。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>