<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a67d37a89ee4c73e68c5be9c05bf11c3ab7ca3c1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Runtime.Remoting.Messaging.AsyncResult.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b9cbecfb539fbbc747ae1543d08427742622d0b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">609e77d854a729b6553a17bd13fcc620819d300c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Encapsulates the results of an asynchronous operation on a delegate.</source>
          <target state="translated">封裝委派上非同步作業的結果。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>The AsyncResult class is used in conjunction with asynchronous method calls made using delegates.</source>
          <target state="translated">AsyncResult 類別是與搭配使用非同步方法呼叫使用委派。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.IAsyncResult&gt; returned from the delegate's <ph id="ph1">`BeginInvoke`</ph> method can be cast to an AsyncResult.</source>
          <target state="translated">&lt;xref:System.IAsyncResult&gt;從委派的傳回<ph id="ph1">`BeginInvoke`</ph>方法可以轉換成 AsyncResult。&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The AsyncResult has the &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A&gt; property that holds the delegate object on which the asynchronous call was invoked.</source>
          <target state="translated">AsyncResult 具有&lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A&gt;屬性可保存委派物件上叫用非同步呼叫。&lt;/xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A&gt;</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`BeginInvoke`</ph> and asynchronous calls using delegates, see <bpt id="p1">[</bpt>Asynchronous Programming Using Delegates<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需有關<ph id="ph1">`BeginInvoke`</ph>和非同步呼叫使用委派，請參閱<bpt id="p1">[</bpt>非同步程式設計使用委派<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Gets the delegate object on which the asynchronous call was invoked.</source>
          <target state="translated">取得非同步呼叫已叫用的委派物件。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The AsyncDelegate property can be cast to the actual class of the user-defined delegate.</source>
          <target state="translated">AsyncDelegate 屬性可以轉換成實際的使用者定義委派類別。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For example, if the delegate that was used to make the asynchronous call is of type <ph id="ph1">`MyDelegate`</ph>, the delegate that is returned by this property must be cast to <ph id="ph2">`MyDelegate`</ph>.</source>
          <target state="translated">例如，如果用來進行非同步呼叫的委派型別的<ph id="ph1">`MyDelegate`</ph>，這個屬性所傳回的委派必須轉換成<ph id="ph2">`MyDelegate`</ph>。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The callback method can then call the delegate's <ph id="ph1">`EndInvoke`</ph> method with the correct signature, in order to obtain the results of the asynchronous method call.</source>
          <target state="translated">回呼方法接著便可以呼叫的委派<ph id="ph1">`EndInvoke`</ph>具有正確的簽章，以取得結果的非同步方法呼叫的方法。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The delegate object on which the asynchronous call was invoked.</source>
          <target state="translated">非同步呼叫已叫用委派物件。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Implements the <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageSink"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> interface.</source>
          <target state="translated">實作<bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageSink"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>介面。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The AsyncProcessMessage method of the &lt;xref:System.Runtime.Remoting.Messaging.IMessageSink&gt; interface is not relevant to the &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult&gt; class.</source>
          <target state="translated">&lt;xref:System.Runtime.Remoting.Messaging.IMessageSink&gt;介面是不相關&lt;xref:System.Runtime.Remoting.Messaging.AsyncResult&gt;類別&lt;/xref:System.Runtime.Remoting.Messaging.AsyncResult&gt;&lt;/xref:System.Runtime.Remoting.Messaging.IMessageSink&gt;AsyncProcessMessage 方法</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Implementation by &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult&gt; throws a &lt;xref:System.NotSupportedException&gt;.</source>
          <target state="translated">實作&lt;xref:System.Runtime.Remoting.Messaging.AsyncResult&gt;會擲回&lt;xref:System.NotSupportedException&gt;.&lt;/xref:System.NotSupportedException&gt; &lt;/xref:System.Runtime.Remoting.Messaging.AsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Instead, obtain an &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult&gt; by casting the &lt;xref:System.IAsyncResult&gt; interface returned by an asynchronous call made using a delegate.</source>
          <target state="translated">相反地，取得&lt;xref:System.Runtime.Remoting.Messaging.AsyncResult&gt;透過將轉型&lt;xref:System.IAsyncResult&gt;發出使用委派非同步呼叫所傳回的介面。&lt;/xref:System.IAsyncResult&gt; &lt;/xref:System.Runtime.Remoting.Messaging.AsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The request <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessage"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> interface.</source>
          <target state="translated">要求<bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessage"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>介面。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The response <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageSink"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> interface.</source>
          <target state="translated">回應<bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageSink"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>介面。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>No value is returned.</source>
          <target state="translated">沒有傳回值。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Gets the object provided as the last parameter of a <bpt id="p1">&lt;xref uid="langword_csharp_BeginInvoke" name="BeginInvoke" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> method call.</source>
          <target state="translated">取得物件的最後一個參數當做提供<bpt id="p1">&lt;xref uid="langword_csharp_BeginInvoke" name="BeginInvoke" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>方法呼叫。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For more information about the <ph id="ph1">`BeginInvoke`</ph> method, see <bpt id="p1">[</bpt>Asynchronous Programming Using Delegates<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">如需有關<ph id="ph1">`BeginInvoke`</ph>方法，請參閱<bpt id="p1">[</bpt>非同步程式設計使用委派<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The object provided as the last parameter of a <bpt id="p1">&lt;xref uid="langword_csharp_BeginInvoke" name="BeginInvoke" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> method call.</source>
          <target state="translated">提供的最後一個參數為物件<bpt id="p1">&lt;xref uid="langword_csharp_BeginInvoke" name="BeginInvoke" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>方法呼叫。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Gets a &lt;xref:System.Threading.WaitHandle&gt; that encapsulates Win32 synchronization handles, and allows the implementation of various synchronization schemes.</source>
          <target state="translated">取得&lt;xref:System.Threading.WaitHandle&gt;封裝 Win32 同步控制代碼，而且可讓各種同步處理的配置的實作。&lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Threading.WaitHandle&gt; returned by this method is automatically signaled when the asynchronous operation has completed.</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle&gt;傳回此方法的非同步作業完成時自動收到信號。&lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The wait handle is not closed automatically when you call <ph id="ph1">`EndInvoke`</ph> on the delegate that was used to make the asynchronous method call.</source>
          <target state="translated">等候控制代碼不會自動關閉當您呼叫<ph id="ph1">`EndInvoke`</ph>上用來進行非同步方法呼叫的委派。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If you release all references to the wait handle, system resources are freed when garbage collection reclaims the wait handle.</source>
          <target state="translated">如果您釋放所有等候控制代碼的參考，當記憶體回收收回等候控制代碼時，會釋放系統資源。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>To free the system resources as soon as you are finished using the wait handle, call the &lt;xref:System.Threading.WaitHandle.Close%2A?displayProperty=fullName&gt; method.</source>
          <target state="translated">若要釋放系統資源，當您使用完等候控制代碼，呼叫&lt;xref:System.Threading.WaitHandle.Close%2A?displayProperty=fullName&gt;方法。&lt;/xref:System.Threading.WaitHandle.Close%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Garbage collection works more efficiently when disposable objects are explicitly closed or disposed.</source>
          <target state="translated">明確地關閉或處置可處置的物件時，記憶體回收會更有效率。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  The &lt;xref:System.Threading.WaitHandle&gt; contained in the AsyncWaitHandle property can be used to block the current thread until the asynchronous call is complete.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; &lt;xref:System.Threading.WaitHandle&gt;AsyncWaitHandle 屬性可用來非同步呼叫完成之前會封鎖目前執行緒中所包含。&lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>However the &lt;xref:System.Threading.WaitHandle&gt; will ignore the &lt;xref:System.AsyncCallback&gt;, if one was specified during the <ph id="ph1">`BeginInvoke`</ph> call.</source>
          <target state="translated">不過，&lt;xref:System.Threading.WaitHandle&gt;將會忽略&lt;xref:System.AsyncCallback&gt;，如果有指定期間<ph id="ph1">`BeginInvoke`</ph>呼叫。&lt;/xref:System.AsyncCallback&gt; &lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Therefore, a situation can occur where the application shuts down before the &lt;xref:System.AsyncCallback&gt; has finished executing, even if a &lt;xref:System.Threading.WaitHandle&gt; is used to block until the asynchronous call completion.</source>
          <target state="translated">因此，情況會發生在應用程式關閉之前&lt;xref:System.AsyncCallback&gt;已完成執行，即使&lt;xref:System.Threading.WaitHandle&gt;用來非同步呼叫完成的區塊。&lt;/xref:System.Threading.WaitHandle&gt; &lt;/xref:System.AsyncCallback&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For an example of such a situation, see the example for the &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult&gt; class, and remove the &lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName&gt; statement.</source>
          <target state="translated">如需這種情況的範例，請參閱範例的&lt;xref:System.Runtime.Remoting.Messaging.AsyncResult&gt;類別，並移除&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName&gt;陳述式。&lt;/xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName&gt; &lt;/xref:System.Runtime.Remoting.Messaging.AsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.Threading.WaitHandle&gt; that encapsulates Win32 synchronization handles, and allows the implementation of various synchronization schemes.</source>
          <target state="translated">A&lt;xref:System.Threading.WaitHandle&gt;封裝 Win32 同步控制代碼，而且可讓各種同步處理的配置的實作。&lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <bpt id="p1">&lt;xref uid="langword_csharp_BeginInvoke" name="BeginInvoke" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> call completed synchronously.</source>
          <target state="translated">取得值，指出是否<bpt id="p1">&lt;xref uid="langword_csharp_BeginInvoke" name="BeginInvoke" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>呼叫已同步完成。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If it is detected that the <ph id="ph1">`BeginInvoke`</ph> call completed synchronously in the &lt;xref:System.AsyncCallback&gt; delegate, it is probable that the thread that called BeginInvoke is the current thread.</source>
          <target state="translated">如果它偵測到的<ph id="ph1">`BeginInvoke`</ph>呼叫已完成同步在&lt;xref:System.AsyncCallback&gt;委派，它是可能性呼叫 BeginInvoke 執行緒目前的執行緒。&lt;/xref:System.AsyncCallback&gt;</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Most providers of the &lt;xref:System.IAsyncResult&gt; interface will not use the capability and will return a default <ph id="ph1">`false`</ph>.</source>
          <target state="translated">大部分的提供者的&lt;xref:System.IAsyncResult&gt;介面不會使用的功能，而且會傳回預設值<ph id="ph1">`false`</ph>。&lt;/xref:System.IAsyncResult&gt;</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Current implementation of CompletedSynchronously always returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">目前實作的 CompletedSynchronously 一律會傳回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the <bpt id="p2">&lt;xref uid="langword_csharp_BeginInvoke" name="BeginInvoke" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> call completed synchronously; otherwise, <bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果<bpt id="p2">&lt;xref uid="langword_csharp_BeginInvoke" name="BeginInvoke" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>同步完成，否則呼叫<bpt id="p3">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether <bpt id="p1">&lt;xref uid="langword_csharp_EndInvoke" name="EndInvoke" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> has been called on the current <bpt id="p2">&lt;xref href="System.Runtime.Remoting.Messaging.AsyncResult"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">取得或設定值，指出是否<bpt id="p1">&lt;xref uid="langword_csharp_EndInvoke" name="EndInvoke" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>已經在目前呼叫<bpt id="p2">&lt;xref href="System.Runtime.Remoting.Messaging.AsyncResult"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if <bpt id="p2">&lt;xref uid="langword_csharp_EndInvoke" name="EndInvoke" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> has been called on the current <bpt id="p3">&lt;xref href="System.Runtime.Remoting.Messaging.AsyncResult"&gt;</bpt><ept id="p3">&lt;/xref&gt;</ept>; otherwise, <bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p4">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>如果<bpt id="p2">&lt;xref uid="langword_csharp_EndInvoke" name="EndInvoke" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>已經在目前呼叫<bpt id="p3">&lt;xref href="System.Runtime.Remoting.Messaging.AsyncResult"&gt;</bpt> <ept id="p3">&lt;/xref&gt;</ept>，否則<bpt id="p4">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p4">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Gets the response message for the asynchronous call.</source>
          <target state="translated">取得非同步呼叫的回應訊息。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The GetReplyMessage method can return an object after the &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A&gt; method is called.</source>
          <target state="translated">GetReplyMessage 方法可以傳回的物件之後&lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A&gt;方法呼叫。&lt;/xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Runtime.Remoting.Messaging.IMessage&gt; return value can be cast to an &lt;xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage&gt;.</source>
          <target state="translated">&lt;xref:System.Runtime.Remoting.Messaging.IMessage&gt;傳回值可以轉換成&lt;xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage&gt;.&lt;/xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage&gt; &lt;/xref:System.Runtime.Remoting.Messaging.IMessage&gt;</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>However, you do not need to call either of these methods directly.</source>
          <target state="translated">不過，您不需要直接呼叫其中一種方法。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>They are intended for use by the remoting infrastructure of the .NET Framework.</source>
          <target state="translated">它們適用於.NET Framework 的遠端執行功能基礎結構。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A remoting message that should represent a response to a method call on a remote object.</source>
          <target state="translated">遠端訊息應該代表遠端物件上的方法呼叫的回應。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the server has completed the call.</source>
          <target state="translated">取得值，指出伺服器是否已完成呼叫。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The server must not use any client supplied resources outside of the agreed upon sharing semantics after it sets the IsCompleted property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">伺服器必須使用任何用戶端提供以外的資源所同意時它將 IsCompleted 屬性設定之後，共用語意<ph id="ph1">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Thus, it is safe for the client to destroy the resources after the IsCompleted property returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">因此，它是安全的用戶端之後 IsCompleted 屬性會傳回終結資源<ph id="ph1">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> after the server has completed the call; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>伺服器完成呼叫; 之後否則， <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Gets the next message sink in the sink chain.</source>
          <target state="translated">取得接收鏈結中的下一個訊息接收。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The current implementation of NextSink returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">傳回目前的 NextSink 實作<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageSink"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> interface that represents the next message sink in the sink chain.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageSink"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>接收鏈結中接收的介面，表示下一個訊息。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Sets an <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageCtrl"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for the current remote method call, which provides a way to control asynchronous messages after they have been dispatched.</source>
          <target state="translated">設定<bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageCtrl"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>目前的遠端方法呼叫，這樣會提供方法來控制非同步訊息分派它們之後。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You do not need to call the SetMessageCtrl method.</source>
          <target state="translated">您不需要呼叫 SetMessageCtrl 方法。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageCtrl"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> for the current remote method call.</source>
          <target state="translated"><bpt id="p1">&lt;xref href="System.Runtime.Remoting.Messaging.IMessageCtrl"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>目前的遠端方法呼叫。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Synchronously processes a response message returned by a method call on a remote object.</source>
          <target state="translated">同步處理遠端物件上方法呼叫所傳回的回應訊息。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The SyncProcessMessage method implements the &lt;xref:System.Runtime.Remoting.Messaging.IMessageSink&gt; interface.</source>
          <target state="translated">SyncProcessMessage 方法會實作&lt;xref:System.Runtime.Remoting.Messaging.IMessageSink&gt;介面。&lt;/xref:System.Runtime.Remoting.Messaging.IMessageSink&gt;</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You do not need to call this method directly.</source>
          <target state="translated">您不需要直接呼叫這個方法。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>It is intended for use by the remoting infrastructure of the .NET Framework.</source>
          <target state="translated">它適用於.NET Framework 的遠端執行功能基礎結構。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>SyncProcessMessage invokes the consumer code's &lt;xref:System.AsyncCallback&gt; delegate.</source>
          <target state="translated">SyncProcessMessage 叫用的消費者程式碼&lt;xref:System.AsyncCallback&gt;委派。&lt;/xref:System.AsyncCallback&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It also sets the &lt;xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage&gt; instance returned by the &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A&gt; method.</source>
          <target state="translated">它也會設定&lt;xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage&gt;所傳回的執行個體&lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A&gt;方法。&lt;/xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A&gt; &lt;/xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`msg`</ph> parameter is of type &lt;xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage&gt;, the same object is returned by &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A&gt;.</source>
          <target state="translated">如果<ph id="ph1">`msg`</ph>參數是型別&lt;xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage&gt;、 &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A&gt;.&lt;/xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A&gt;會傳回相同的物件&lt;/xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage&gt;</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Otherwise, a reply message that contains a remoting exception is returned.</source>
          <target state="translated">否則，會傳回回覆訊息，其中包含遠端處理的例外狀況。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>SyncProcessMessage also modifies the value returned by the &lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A&gt; property.</source>
          <target state="translated">SyncProcessMessage 也會修改所傳回的值&lt;xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A&gt;屬性。&lt;/xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>A response message to a method call on a remote object.</source>
          <target state="translated">遠端物件上呼叫方法的回應訊息。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Returns <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Returns <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>