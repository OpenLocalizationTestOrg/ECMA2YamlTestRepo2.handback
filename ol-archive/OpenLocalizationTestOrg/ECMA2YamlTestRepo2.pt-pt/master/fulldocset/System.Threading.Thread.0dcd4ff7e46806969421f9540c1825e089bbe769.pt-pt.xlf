<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-pt">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-192e1fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e5df80f20fb8f8e9d58d7fd51e841a9b301b1bb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset\System.Threading.Thread.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fulldocset</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">836a4a28ca4635685ece20dbbe7b56da6a73e287</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d53c4cef63a323cfe675bb4658023858adff4b10</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">Cria e controla um thread, define a prioridade e obtém o respetivo estado.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">Quando um processo é iniciado, o tempo de execução de idioma comum cria automaticamente um thread único em primeiro plano para executar código da aplicação.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">Juntamente com este thread de primeiro plano principal, um processo pode criar um ou mais threads para executar uma parte do código do programa associado ao processo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">Estes threads podem ser executado em primeiro plano ou em segundo plano.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, you can use the &lt;xref:System.Threading.ThreadPool&gt; class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">Além disso, pode utilizar o &lt;xref:System.Threading.ThreadPool&gt;classe para executar código em threads de trabalho que são geridos pelo tempo de execução de idioma comum.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section       <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept>     <bpt id="p2">[</bpt>Retrieving Thread objects<ept id="p2">](#Retrieving)</ept>     <bpt id="p3">[</bpt>Foreground and background threads<ept id="p3">](#Foreground)</ept>     <bpt id="p4">[</bpt>Culture and threads<ept id="p4">](#Culture)</ept>     <bpt id="p5">[</bpt>Getting information about and controlling threads<ept id="p5">](#Properties)</ept>     <bpt id="p6">[</bpt>Accessing the source code for the Thread class<ept id="p6">](#Source)</ept>      <bpt id="p7">&lt;a name="Starting"&gt;</bpt><ept id="p7">&lt;/a&gt;</ept>    ## Starting a thread    You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">Nesta secção <bpt id="p1">[</bpt>iniciar um thread<ept id="p1">](#Starting)</ept><bpt id="p2">[</bpt>objectos de Thread obter<ept id="p2">](#Retrieving)</ept><bpt id="p3">[</bpt>threads de primeiro plano e fundo<ept id="p3">](#Foreground)</ept><bpt id="p4">[</bpt>cultura e threads<ept id="p4">](#Culture)</ept><bpt id="p5">[</bpt>obter informações sobre e controlar threads<ept id="p5">](#Properties)</ept><bpt id="p6">[</bpt>aceder ao código de origem para a classe de Thread<ept id="p6">](#Source)</ept> <bpt id="p7">&lt;a name="Starting"&gt;</bpt> <ept id="p7">&lt;/a&gt;</ept> # # iniciar um thread iniciar um thread, fornecendo um delegado que representa o método o thread está a executar o construtor de classe.                               </target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>You then call the &lt;xref:System.Threading.Thread.Start%2A&gt; method to begin execution.</source>
          <target state="translated">Em seguida, chame o &lt;xref:System.Threading.Thread.Start%2A&gt;método para iniciar a execução.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Thread constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:      -   If the method has no arguments, you pass a &lt;xref:System.Threading.ThreadStart&gt; delegate to  the constructor.</source>
          <target state="translated">Os construtores de Thread podem demorar um dos tipos de delegado dois, dependendo se pode transmitir um argumento para o método para ser executada:-se o método tem sem argumentos, transmita um &lt;xref:System.Threading.ThreadStart&gt;Delegar a este construtor.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph>           The following example creates and starts a thread that executes the <ph id="ph3">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">Tem a assinatura: <ph id="ph1">```c#       public delegate void ThreadStart()       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ThreadStart()       ```</ph> o exemplo seguinte cria e inicia um thread que executa o <ph id="ph3">`ExecuteInForeground`</ph> método.          </target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">O método apresenta informações sobre algumas propriedades de thread, em seguida, executa um ciclo na qual interrompe para meio segundo e apresenta o número de segundos decorrido.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">Quando o thread foi executada para, pelo menos, cinco segundos, as extremidades de ciclo e o thread de termina a execução.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept><ept id="p3">]</ept>      -   If the method has an argument, you pass a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate to the constructor.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb)</ept> <ept id="p3">]</ept> -se o método tem um argumento, transmita um &lt;xref:System.Threading.ParameterizedThreadStart&gt;Delegar a este construtor.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;      </target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:          <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph>          <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph>           The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">Tem a assinatura: <ph id="ph1">```c#       public delegate void ParameterizedThreadStart(object obj)       ```</ph> <ph id="ph2">```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```</ph> o método executado pelo delegado do, em seguida, pode converter (em c#) ou converta (em Visual Basic) o parâmetro do tipo adequado.          </target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example is identical to the previous one, except that it calls the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor.</source>
          <target state="translated">O exemplo seguinte é idêntico à anterior, exceto que chama o &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;construtor.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">Esta versão do <ph id="ph1">`ExecuteInForeground`</ph> método tem um único parâmetro que representa o número aproximado de milissegundos no ciclo de consiste em executar.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept>      <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept><ept id="p3">]</ept>       It is not necessary to retain a reference to a Thread object once you have started the thread.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb)</ept> <ept id="p3">]</ept> não é necessário manter uma referência a um objecto de Thread depois de iniciar o thread.      </target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">O thread continua a executar até o procedimento de thread está concluído.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Retrieving Thread objects    You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Retrieving"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # Obter Thread objetos que pode utilizar o estático (<ph id="ph1">`Shared`</ph> no Visual Basic) &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;propriedade para obter uma referência para o thread atualmente em execução a partir do código que está a executar o thread.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the &lt;xref:System.Threading.Thread.CurrentThread%2A&gt; property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">O exemplo seguinte utiliza o &lt;xref:System.Threading.Thread.CurrentThread%2A&gt;propriedade para apresentar informações sobre o thread de aplicação principal, outro thread de primeiro plano, um thread de segundo plano e um thread de conjunto de threads.&lt;/xref:System.Threading.Thread.CurrentThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Foreground"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Foreground and background threads    Instances of the Thread class represent either foreground threads or background threads.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Foreground"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> # # threads de primeiro plano e fundo instâncias da classe Thread representam os threads de primeiro plano ou threads em segundo plano.        </target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">Threads em segundo plano são idênticos aos threads de primeiro plano com uma exceção: um thread de segundo plano não manter a execução de um processo se todos os threads de primeiro plano foi terminado.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">Depois de todos os threads de primeiro plano foram parados, o tempo de execução deixa de todos os threads em segundo plano e será encerrado.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground:      -   The main application thread.</source>
          <target state="translated">Por predefinição, os threads seguintes executar em primeiro plano:-o thread principal da aplicação.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a Thread class constructor.</source>
          <target state="translated">-Todos os threads criados chamando um construtor de classe do Thread.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following threads execute in the background by default:      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Os seguintes threads executados em segundo plano, por predefinição:-threads de agrupamento, que são um conjunto de threads de trabalho mantida pelo tempo de execução do Thread.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">Pode configurar o trabalho de agrupamento e o agendamento de threads em threads de conjunto de threads, utilizando a &lt;xref:System.Threading.ThreadPool&gt;classe.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Baseado em tarefas operações assíncronas executar automaticamente em threads de conjunto de threads.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Task-based asynchronous operations use the &lt;xref:System.Threading.Tasks.Task&gt; and &lt;xref:System.Threading.Tasks.Task%601&gt; classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Utilizam operações assíncronas baseado em tarefas a &lt;xref:System.Threading.Tasks.Task&gt;e &lt;xref:System.Threading.Tasks.Task%601&gt;classes para implementar o <bpt id="p1">[</bpt>padrão assíncrono baseado em tarefas<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.&lt;/xref:System.Threading.Tasks.Task%601&gt; &lt;/xref:System.Threading.Tasks.Task&gt;</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-Todos os threads que introduzir o ambiente de execução gerido a partir do código não gerido.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can change a thread to execute in the background by setting the &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property at any time.</source>
          <target state="translated">Pode alterar um thread para executar em segundo plano, definindo o &lt;xref:System.Threading.Thread.IsBackground%2A&gt;propriedade em qualquer altura.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">Threads em segundo plano são úteis para todas as operações eventualmente devem continuar enquanto uma aplicação está em execução, mas não deve impedir que a aplicação de terminar, tais como a monitorização de alterações de sistema de ficheiros ou as ligações recebidas do socket.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">O exemplo seguinte ilustra a diferença entre threads primeiro e segundo plano.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">É semelhante ao exemplo no primeiro o <bpt id="p1">[</bpt>iniciar um thread<ept id="p1">](#Starting)</ept> secção, exceto que define o thread para ser executado em segundo plano antes de iniciá-lo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">Como mostra a saída, o ciclo for interrompido antes de ser executada para cinco segundos.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept><ept id="p3">]</ept>      <bpt id="p5">&lt;a name="Culture"&gt;</bpt><ept id="p5">&lt;/a&gt;</ept>    ## Culture and threads    Each thread has a culture, represented by the &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt; property, and a UI culture, represented by the &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt; property.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb)</ept> <ept id="p3">]</ept> <bpt id="p5">&lt;a name="Culture"&gt;</bpt> <ept id="p5">&lt;/a&gt;</ept> # # cultura e threads cada thread tem uma cultura, representada pelo &lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;propriedade e um idioma de IU, representado pelo &lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.CurrentUICulture%2A&gt; &lt;/xref:System.Threading.Thread.CurrentCulture%2A&gt;        </target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">A cultura atual suporta a cultura sensíveis operações como analisar e formatação, comparação de cadeias e ordenação e também controla o sistema de escrita e calendário utilizado por um thread.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">Fornece a cultura da IU atual para obtenção de cultura sensíveis dos recursos nos ficheiros de recursos.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">Quando um novo thread é instanciado, o idioma e cultura da IU são definidas pela cultura atual do sistema e cultura da IU e não pela cultura e cultura da IU do thread de que é criado novo thread.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">Isto significa que, por exemplo, que se o idioma atual do sistema é inglês (Estados Unidos) e o idioma atual do thread principal da aplicação é francês (França), o idioma de um novo thread criado chamando o &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;construtor do thread principal é inglês (Estados Unidos) e francês (França).&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Para obter mais informações, consulte a secção "Cultura e threads" o &lt;xref:System.Globalization.CultureInfo&gt;tópico de classe.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Isto não é verdade de threads que executar as operações assíncronas para aplicações que o destino de <ph id="ph2">[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]</ph> e versões posteriores, neste caso, o idioma e cultura da IU faz parte do contexto de um operações assíncronas; o thread em que uma operação assíncrona executa por predefinição herda a cultura e cultura da IU do thread de que a operação assíncrona foi iniciada.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Para obter mais informações, consulte a secção "Cultura e baseado em tarefas operações assíncronas" o &lt;xref:System.Globalization.CultureInfo&gt;tópico de classe.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:      -   You can pass a &lt;xref:System.Globalization.CultureInfo&gt; object that represents that culture to the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate or the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; method.</source>
          <target state="translated">Pode efetuar um dos seguintes procedimentos para se certificar de que todos os threads em execução numa aplicação partilhar o mesmo idioma e a cultura da IU:-pode passar um &lt;xref:System.Globalization.CultureInfo&gt;objeto que representa esse idioma para o &lt;xref:System.Threading.ParameterizedThreadStart&gt;Delegar ou &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt;método.&lt;/xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt; &lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt; and &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; properties.</source>
          <target state="translated">-Para aplicações em execução no <ph id="ph1">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> e versões posteriores, pode definir o idioma e cultura da IU que está a ser atribuído a todos os threads criados num domínio de aplicação, definindo o valor da &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;e &lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;Propriedades.&lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt; &lt;/xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">Tenha em atenção que se trata de uma definição de domínio por aplicação.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information and examples, see the "Culture and threads" section of the &lt;xref:System.Globalization.CultureInfo&gt; class topic.</source>
          <target state="translated">Para obter mais informações e exemplos, consulte a secção "Cultura e threads" o &lt;xref:System.Globalization.CultureInfo&gt;tópico de classe.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Getting information about and controlling threads    You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Properties"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # Obter informações e controlar threads pode obter um número de valores de propriedade que fornecem informações sobre um thread.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">Em alguns casos, também pode definir estes valores de propriedade para controlar a operação do thread.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>These thread properties include:      -   A name.</source>
          <target state="translated">Estas propriedades de thread incluem:-um nome.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.Name%2A&gt; is a write-once property that you can use to identify a thread.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Name%2A&gt;é uma operação de escrita-uma vez a propriedade que pode utilizar para identificar um thread.&lt;/xref:System.Threading.Thread.Name%2A&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">O valor predefinido é <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A hash code, which you can retrieve by calling the &lt;xref:System.Threading.Thread.GetHashCode%2A&gt; method.</source>
          <target state="translated">-Um código de hash, que pode obter chamando a &lt;xref:System.Threading.Thread.GetHashCode%2A&gt;método.&lt;/xref:System.Threading.Thread.GetHashCode%2A&gt;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">O código hash pode ser utilizado para identificar exclusivamente um thread; para a duração do seu thread, o código hash irá não entrar em conflito com o valor de outro thread, independentemente do domínio de aplicação a partir do qual obter o valor.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A thread ID.</source>
          <target state="translated">-Um ID de thread.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the read-only &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">O valor da só de leitura &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;propriedade é atribuída pelo runtime e identifica exclusivamente um thread dentro do respetivo processo.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Um sistema operativo <bpt id="p1">[</bpt>ID da thread<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> não tem qualquer relação fixa a um thread gerido, porque um anfitrião não gerido pode controlar a relação entre threads geridas e não geridas.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">Especificamente, pode utilizar um anfitrião sofisticado o <bpt id="p1">[</bpt>API de alojamento de CLR<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> agendar vários threads geridos contra o mesmo thread do sistema operativo ou para mover um thread gerido entre threads diferentes do sistema operativo.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The thread's current state.</source>
          <target state="translated">-Estado actual do thread o.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the &lt;xref:System.Threading.ThreadState&gt; property.</source>
          <target state="translated">Durante a respetiva existência, um thread é sempre num ou mais dos Estados definidos pelo &lt;xref:System.Threading.ThreadState&gt;propriedade.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   A scheduling priority level, which is defined by the &lt;xref:System.Threading.ThreadPriority&gt; property.</source>
          <target state="translated">-Um nível de prioridade agendamento, que é definido pelo &lt;xref:System.Threading.ThreadPriority&gt;propriedade.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">Embora o que pode definir este valor para pedir a prioridade de um thread, não é assegurada para ser cumpridas pelo sistema operativo.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The read-only &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt; property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">-O só de leitura &lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;propriedade, o que indica se um thread é um thread de conjunto de threads.&lt;/xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The &lt;xref:System.Threading.Thread.IsBackground%2A&gt; property.</source>
          <target state="translated">-O &lt;xref:System.Threading.Thread.IsBackground%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.IsBackground%2A&gt;</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">Para obter mais informações, consulte o <bpt id="p1">[</bpt>threads de primeiro plano e fundo<ept id="p1">](#Foreground)</ept> secção.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>    ## Accessing the source code for the Thread class    To view the .NET Framework source code for the Thread class, see the <bpt id="p2">[</bpt>Reference Source<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;a name="Source"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept># # Aceder ao código de origem para a classe de Thread para ver o código de origem do .NET Framework para a classe de Thread, consulte o <bpt id="p2">[</bpt>referência origem<ept id="p2">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
          <target state="translated">Pode percorrer o código de origem online, transfira a referência para visualização offline e siga os passos as origens (incluindo correções de erros e atualizações) durante a depuração; consulte <bpt id="p1">[</bpt>instruções<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe, especificando um delegado que permite que um objeto a ser transmitido para o thread quando o thread foi iniciado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Um thread não começa a executar quando é criado.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">Para agendar o thread de execução, chame o &lt;xref:System.Threading.Thread.Start%2A&gt;método.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>To pass a data object to the thread, use the &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt; method overload.</source>
          <target state="translated">Para transferir um objeto de dados para o thread, utilize o &lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;sobrecarga de método.&lt;/xref:System.Threading.Thread.Start%28System.Object%29&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Visual Basic utilizadores podem omitir o &lt;xref:System.Threading.ThreadStart&gt;construtor ao criar um thread.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Utilize o <ph id="ph1">`AddressOf`</ph> operador ao transmitir o seu método, por exemplo <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic automaticamente chama o &lt;xref:System.Threading.ThreadStart&gt;construtor.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Um delegado que representa os métodos para ser invocado quando este thread começa a executar.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Um thread não começa a executar quando é criado.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the &lt;xref:System.Threading.Thread.Start%2A&gt; method.</source>
          <target state="translated">Para agendar o thread de execução, chame o &lt;xref:System.Threading.Thread.Start%2A&gt;método.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.ThreadStart&gt; constructor when creating a thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Visual Basic utilizadores podem omitir o &lt;xref:System.Threading.ThreadStart&gt;construtor ao criar um thread.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Utilize o <ph id="ph1">`AddressOf`</ph> operador ao transmitir o seu método por exemplo <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the &lt;xref:System.Threading.ThreadStart&gt; constructor.</source>
          <target state="translated">Visual Basic automaticamente chama o &lt;xref:System.Threading.ThreadStart&gt;construtor.&lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegado que representa os métodos para ser invocado quando este thread começa a executar.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated">The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <bpt id="p2">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe, especificando um delegado que permite que um objeto a ser transmitido para o thread quando o thread está iniciado e especificar o tamanho da pilha máximo para o thread.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Evite utilizar esta sobrecarga de construtor.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">O tamanho da pilha de predefinido utilizado pelo &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;sobrecarga de construtor é o tamanho da pilha recomendada para threads.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Começando com o <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, só pode definir o código de confiança totalmente <ph id="ph3">`maxStackSize`</ph> para um valor que é maior do que o tamanho da pilha predefinida (1 megabyte).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Se for especificado um valor maior para <ph id="ph1">`maxStackSize`</ph> quando o código está em execução com fidedignidade parcial, <ph id="ph2">`maxStackSize`</ph> é ignorada e o tamanho da pilha predefinida é utilizado.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">Sem exceção é emitida.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Pode definir o código em qualquer nível de fidedignidade <ph id="ph1">`maxStackSize`</ph> para um valor que é menor que o tamanho predefinido da pilha.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se estiver a desenvolver uma biblioteca totalmente fidedigna que será utilizada pelo código parcialmente fidedigno e terá de iniciar um thread que requer uma pilha de grandes dimensões, tem assert fidedignidade total antes de criar o thread ou será utilizado o tamanho predefinido da pilha.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Não efetuar este procedimento, a menos que controlar totalmente o código que é executado no thread.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Se <ph id="ph1">`maxStackSize`</ph> é inferior ao tamanho mínimo da pilha, é utilizado o tamanho da pilha mínimo.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Se <ph id="ph1">`maxStackSize`</ph> não é um múltiplo do tamanho da página, é arredondado ao múltiplo maior seguinte do tamanho da página.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Por exemplo, se estiver a utilizar o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha mínima e o tamanho de página é 64KB (65,536 bytes).</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em versões do Microsoft Windows antes do Windows XP e Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> é ignorada e o tamanho da pilha especificado no cabeçalho de executável é utilizado.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Se especificar um tamanho da pilha muito pequenos, poderá ter de desativar a pesquisa de capacidade excedida da pilha.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Quando a pilha gravemente é restrita, a pesquisa pode próprio causar uma capacidade excedida da pilha.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Para desativar a pesquisa de capacidade excedida de pilha, adicione o seguinte ao ficheiro de configuração de aplicação.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegado que representa os métodos para ser invocado quando este thread começa a executar.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">O tamanho da pilha máximo, em bytes, para ser utilizado pelo thread ou 0 para utilizar o tamanho da pilha máximo predefinido especificado no cabeçalho para o executável.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Importante para parcialmente fidedigna código, <ph id="ph1">`maxStackSize`</ph> é ignorada se for maior do que o tamanho predefinido da pilha.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">Sem exceção é emitida.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>é menor que zero.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">Inicializa uma nova instância do <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> classe, especificar o tamanho da pilha máximo para o thread.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Evite utilizar esta sobrecarga de construtor.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt; constructor overload is the recommended stack size for threads.</source>
          <target state="translated">O tamanho da pilha de predefinido utilizado pelo &lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;sobrecarga de construtor é o tamanho da pilha recomendada para threads.&lt;/xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Beginning with the <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph3">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Começando com o <ph id="ph2">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, só pode definir o código de confiança totalmente <ph id="ph3">`maxStackSize`</ph> para um valor que é maior do que o tamanho da pilha predefinida (1 megabyte).</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Se for especificado um valor maior para <ph id="ph1">`maxStackSize`</ph> quando o código está em execução com fidedignidade parcial, <ph id="ph2">`maxStackSize`</ph> é ignorada e o tamanho da pilha predefinida é utilizado.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
          <target state="translated">Sem exceção é emitida.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Pode definir o código em qualquer nível de fidedignidade <ph id="ph1">`maxStackSize`</ph> para um valor que é menor que o tamanho predefinido da pilha.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se estiver a desenvolver uma biblioteca totalmente fidedigna que será utilizada pelo código parcialmente fidedigno e terá de iniciar um thread que requer uma pilha de grandes dimensões, tem assert fidedignidade total antes de criar o thread ou será utilizado o tamanho predefinido da pilha.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Não efetuar este procedimento, a menos que controlar totalmente o código que é executado no thread.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Se <ph id="ph1">`maxStackSize`</ph> é inferior ao tamanho mínimo da pilha, é utilizado o tamanho da pilha mínimo.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Se <ph id="ph1">`maxStackSize`</ph> não é um múltiplo do tamanho da página, é arredondado ao múltiplo maior seguinte do tamanho da página.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Por exemplo, se estiver a utilizar o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha mínima e o tamanho de página é 64KB (65,536 bytes).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em versões do Microsoft Windows antes do Windows XP e Windows Server 2003, <ph id="ph2">`maxStackSize`</ph> é ignorada e o tamanho da pilha especificado no cabeçalho de executável é utilizado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Se especificar um tamanho da pilha muito pequenos, poderá ter de desativar a pesquisa de capacidade excedida da pilha.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Quando a pilha gravemente é restrita, a pesquisa pode próprio causar uma capacidade excedida da pilha.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Para desativar a pesquisa de capacidade excedida de pilha, adicione o seguinte ao ficheiro de configuração de aplicação.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegado que representa os métodos para ser invocado quando este thread começa a executar.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">O tamanho da pilha máximo, em bytes, para ser utilizado pelo thread ou 0 para utilizar o tamanho da pilha máximo predefinido especificado no cabeçalho para o executável.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <ph id="ph1">`maxStackSize`</ph> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Importante para parcialmente fidedigna código, <ph id="ph1">`maxStackSize`</ph> é ignorada se for maior do que o tamanho predefinido da pilha.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
          <target state="translated">Sem exceção é emitida.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph>is <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph>é menor que zero.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Gera um <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> num thread no qual é invocado, para iniciar o processo de terminar o thread.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Chamar este método normalmente termina o thread.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">Quando este método é invocado num thread, o sistema emite um &lt;xref:System.Threading.ThreadAbortException&gt;no thread para abortar o mesmo.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>é uma exceção especial que pode ser detetada pelo código da aplicação, mas é novamente iniciadas no fim do <ph id="ph2">`catch`</ph> bloquear, a menos que &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Cancela o pedido para abortar e impede o <ph id="ph2">`ThreadAbortException`</ph> de terminar o thread.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Unexecuted <ph id="ph1">`finally`</ph> blocos são executados antes do thread foi abortado.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Quando chama um thread <ph id="ph2">`Abort`</ph> em si próprio, o efeito é semelhante para accionar uma excepção; os &lt;xref:System.Threading.ThreadAbortException&gt;acontece imediatamente, e o resultado é previsível.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">No entanto, se chama um thread <ph id="ph1">`Abort`</ph> noutro thread, a abortar interrupções qualquer código está em execução.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">Também é provável que construtor estático foi abortado.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">Em casos raros, isto poderá impedir instâncias dessa classe que está a ser criado nesse domínio de aplicação.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">Nas versões do .NET Framework 1.0 e 1.1, há a possibilidade do thread foi abortar enquanto um <ph id="ph1">`finally`</ph> bloco está em execução, caso em que o <ph id="ph2">`finally`</ph> bloco foi abortado.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">O thread não é assegurado para abortar imediatamente ou de todo.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Esta situação pode ocorrer se um thread uma quantidade de computação no unbounded o <ph id="ph1">`finally`</ph> blocos que são denominados como parte do procedimento de abortar indefinidamente, deste modo, atrasando a abortar.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee the wait will end.</source>
          <target state="translated">Aguardar até o thread foi abortada, pode chamar o &lt;xref:System.Threading.Thread.Join%2A&gt;método no thread depois de chamar o método de abortar, mas não existe nenhuma garantia, a espera vai terminar.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls Abort might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; O thread que chama abortar poderão bloquear se o thread que está a ser abortado está numa região protegida de código, tais como um <ph id="ph2">`catch`</ph> bloco, <ph id="ph3">`finally`</ph> bloco ou região de execução restrita.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls Abort holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Se o thread que chama abortar deter um bloqueio que requer que o thread de abortada, pode ocorrer um impasse.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado num thread que não foi iniciado, o thread irá abortar quando &lt;xref:System.Threading.Thread.Start%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado num thread que está bloqueado ou é suspenso, o thread é interrompido e, em seguida, abortado.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado num thread que tiver sido suspenso, um &lt;xref:System.Threading.ThreadStateException&gt;é emitida no thread de chamada &lt;xref:System.Threading.Thread.Abort%2A&gt;, e &lt;xref:System.Threading.ThreadState&gt;é adicionado ao &lt;xref:System.Threading.Thread.ThreadState%2A&gt;propriedade do thread abortado.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">A &lt;xref:System.Threading.ThreadAbortException&gt;não está a ser emitida no thread suspenso até &lt;xref:System.Threading.Thread.Resume%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado num thread gerido enquanto está a executar código não gerido, um <ph id="ph2">`ThreadAbortException`</ph> não é emitida até que o thread devolve para código gerido.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Se dois chamadas para <ph id="ph1">`Abort`</ph> vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e a outra chamada para executar o <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">No entanto, uma aplicação não consegue detetar esta situação.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Depois de <ph id="ph1">`Abort`</ph> é invocado num thread, o estado do thread inclui &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Depois do thread foi terminada devido a uma chamada com êxito para <ph id="ph1">`Abort`</ph>, o estado do thread é alterado para &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Com permissões suficientes, um thread que é o destino de uma <ph id="ph1">`Abort`</ph> pode cancelar a abortar utilizando o <ph id="ph2">`ResetAbort`</ph> método.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Para obter um exemplo que demonstra a chamar o <ph id="ph1">`ResetAbort`</ph> método, consulte o <ph id="ph2">`ThreadAbortException`</ph> classe.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">O thread que está a ser abortado está atualmente suspensa.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Raises a <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">Gera um <bpt id="p1">&lt;xref href="System.Threading.ThreadAbortException"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> num thread no qual é invocado, para iniciar o processo de terminar o thread enquanto também fornecem informações sobre a terminação do thread da exceção.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Chamar este método normalmente termina o thread.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt; in the thread to abort it.</source>
          <target state="translated">Quando este método é invocado num thread, o sistema emite um &lt;xref:System.Threading.ThreadAbortException&gt;no thread para abortar o mesmo.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless &lt;xref:System.Threading.Thread.ResetAbort%2A&gt; is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>é uma exceção especial que pode ser detetada pelo código da aplicação, mas é novamente iniciadas no fim do <ph id="ph2">`catch`</ph> bloquear, a menos que &lt;xref:System.Threading.Thread.ResetAbort%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.ResetAbort%2A&gt;</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Cancela o pedido para abortar e impede o <ph id="ph2">`ThreadAbortException`</ph> de terminar o thread.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Unexecuted <ph id="ph1">`finally`</ph> blocos são executados antes do thread foi abortado.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  When a thread calls <ph id="ph2">`Abort`</ph> on itself, the effect is similar to throwing an exception; the &lt;xref:System.Threading.ThreadAbortException&gt; happens immediately, and the result is predictable.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Quando chama um thread <ph id="ph2">`Abort`</ph> em si próprio, o efeito é semelhante para accionar uma excepção; os &lt;xref:System.Threading.ThreadAbortException&gt;acontece imediatamente, e o resultado é previsível.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">No entanto, se chama um thread <ph id="ph1">`Abort`</ph> noutro thread, a abortar interrupções qualquer código está em execução.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">Há a possibilidade de que um construtor estático foi abortado.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">Em casos raros, isto poderá impedir instâncias dessa classe que está a ser criado nesse domínio de aplicação.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">Nas versões do .NET Framework 1.0 e 1.1, há a possibilidade do thread foi abortar enquanto um <ph id="ph1">`finally`</ph> bloco está em execução, caso em que o <ph id="ph2">`finally`</ph> bloco foi abortado.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">O thread não é assegurado para abortar imediatamente ou de todo.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Esta situação pode ocorrer se um thread uma quantidade de computação no unbounded o <ph id="ph1">`finally`</ph> blocos que são denominados como parte do procedimento de abortar indefinidamente, deste modo, atrasando a abortar.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the &lt;xref:System.Threading.Thread.Join%2A&gt; method on the thread after calling the Abort method, but there is no guarantee that the wait will end.</source>
          <target state="translated">Aguardar até o thread foi abortada, pode chamar o &lt;xref:System.Threading.Thread.Join%2A&gt;método no thread depois de chamar o método de abortar, mas não existe nenhuma garantia de que a espera vai terminar.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; O thread que chama &lt;xref:System.Threading.Thread.Abort%2A&gt;poderão bloquear se o thread que está a ser abortado está numa região protegida de código, tais como um <ph id="ph2">`catch`</ph> bloco, <ph id="ph3">`finally`</ph> bloco ou região de execução restrita.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls &lt;xref:System.Threading.Thread.Abort%2A&gt; holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Se o thread que chama &lt;xref:System.Threading.Thread.Abort%2A&gt;deter um bloqueio que requer que o thread de abortada, pode ocorrer um impasse.&lt;/xref:System.Threading.Thread.Abort%2A&gt;</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when &lt;xref:System.Threading.Thread.Start%2A&gt; is called.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado num thread que não foi iniciado, o thread irá abortar quando &lt;xref:System.Threading.Thread.Start%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado num thread que está bloqueado ou é suspenso, o thread é interrompido e, em seguida, abortado.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a &lt;xref:System.Threading.ThreadStateException&gt; is thrown in the thread that called &lt;xref:System.Threading.Thread.Abort%2A&gt;, and &lt;xref:System.Threading.ThreadState&gt; is added to the &lt;xref:System.Threading.Thread.ThreadState%2A&gt; property of the thread being aborted.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado num thread que tiver sido suspenso, um &lt;xref:System.Threading.ThreadStateException&gt;é emitida no thread de chamada &lt;xref:System.Threading.Thread.Abort%2A&gt;, e &lt;xref:System.Threading.ThreadState&gt;é adicionado ao &lt;xref:System.Threading.Thread.ThreadState%2A&gt;propriedade do thread abortado.&lt;/xref:System.Threading.Thread.ThreadState%2A&gt; &lt;/xref:System.Threading.ThreadState&gt; &lt;/xref:System.Threading.Thread.Abort%2A&gt; &lt;/xref:System.Threading.ThreadStateException&gt;</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>A &lt;xref:System.Threading.ThreadAbortException&gt; is not thrown in the suspended thread until &lt;xref:System.Threading.Thread.Resume%2A&gt; is called.</source>
          <target state="translated">A &lt;xref:System.Threading.ThreadAbortException&gt;não está a ser emitida no thread suspenso até &lt;xref:System.Threading.Thread.Resume%2A&gt;é chamado.&lt;/xref:System.Threading.Thread.Resume%2A&gt; &lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Se <ph id="ph1">`Abort`</ph> é chamado num thread gerido enquanto está a executar código não gerido, um <ph id="ph2">`ThreadAbortException`</ph> não é emitida até que o thread devolve para código gerido.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Se dois chamadas para <ph id="ph1">`Abort`</ph> vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e a outra chamada para executar o <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">No entanto, uma aplicação não consegue detetar esta situação.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Depois de <ph id="ph1">`Abort`</ph> é invocado num thread, o estado do thread inclui &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Depois do thread foi terminada devido a uma chamada com êxito para <ph id="ph1">`Abort`</ph>, o estado do thread é alterado para &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Com permissões suficientes, um thread que é o destino de uma <ph id="ph1">`Abort`</ph> pode cancelar a abortar utilizando o <ph id="ph2">`ResetAbort`</ph> método.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Para obter um exemplo que demonstra a chamar o <ph id="ph1">`ResetAbort`</ph> método, consulte o <ph id="ph2">`ThreadAbortException`</ph> classe.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">Um objeto que contém informações específicas de aplicações, tais como Estado, o que pode ser utilizado pelo thread abortado.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">O thread que está a ser abortado está atualmente suspensa.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">Atribui um bloco de dados sem nome em todos os threads.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para um melhor desempenho, utilize os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e blocos de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a utilização de TLS, consulte <bpt id="p1">[</bpt>Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">O espaço é alocado tendo em todos os threads.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Ranhuras de dados são exclusivas por thread.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">O alocado com o nome bloco de dados em todos os threads.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">Atribui um bloco de dados com nome em todos os threads.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para um melhor desempenho, utilize os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e blocos de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a utilização de TLS, consulte <bpt id="p1">[</bpt>Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Ranhuras de dados são exclusivas por thread.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not necessary to use the AllocateNamedDataSlot method to allocate a named data slot, because the &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; method allocates the slot if it has not already been allocated.</source>
          <target state="translated">Não é necessário utilizar o método de AllocateNamedDataSlot alocar um bloco de dados com nome, porque o &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;método aloca a ranhura se já não foi atribuído.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se for utilizado o método AllocateNamedDataSlot, deve ser invocado no thread principal durante o arranque do programa, porque emite uma exceção, se uma ranhura com o nome especificado já foi atribuída.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">Não há nenhuma forma de testar se uma ranhura já foi atribuída.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Slots allocated with this method must be freed with &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.</source>
          <target state="translated">As ranhuras alocadas com este método tem de ser libertadas com &lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;.&lt;/xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">O nome da ranhura de dados a ser alocados.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">O alocado com o nome bloco de dados em todos os threads.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">Um bloco de dados denominado com o nome especificado já existe.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">Obtém ou define o estado de apartamento deste thread.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>The ApartmentState property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>A propriedade ApartmentState está obsoleta.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>The non-obsolete alternatives are the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method to retrieve the apartment state and the   &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method to set the apartment state.</source>
          <target state="translated">As alternativas não obsoletos são o &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;método ao obter o estado de apartamento e &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;método para definir o estado de apartamento.&lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">Nas versões do .NET Framework 1.0 e 1.1, o <ph id="ph1">`ApartmentState`</ph> propriedade marca um thread para indicar que são executados no apartamento de um único thread ou multithread.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">Esta propriedade pode ser definida quando o thread está no <ph id="ph1">`Unstarted`</ph> ou <ph id="ph2">`Running`</ph> thread Estado; no entanto, este pode ser definido apenas uma vez para um thread.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">Se a propriedade não foi definida, devolve <ph id="ph1">`Unknown`</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to use the ApartmentState property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">Uma tentativa para utilizar a propriedade ApartmentState para definir o estado de apartamento de thread cujo estado apartment já foi definido é ignorada.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method throws a &lt;xref:System.InvalidOperationException&gt; in this case.</source>
          <target state="translated">No entanto, o &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;método gera um &lt;xref:System.InvalidOperationException&gt;neste caso.&lt;/xref:System.InvalidOperationException&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  In the .NET Framework version 2.0, new threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; No .NET Framework versão 2.0, threads novo são inicializados como &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;se respetivo estado de apartamento não foi definido antes de serem iniciadas.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">O thread de aplicação principal é inicializado &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;por predefinição.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can no longer set the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by setting the &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; property on the first line of code.</source>
          <target state="translated">Já não pode definir o thread de aplicação principal &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;definindo a &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;propriedade na primeira linha de código.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.STAThreadAttribute&gt; instead.</source>
          <target state="translated">Utilize o &lt;xref:System.STAThreadAttribute&gt;em vez disso.&lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> linker option.</source>
          <target state="translated">No .NET Framework versão 2.0, pode especificar o COM o modelo para uma aplicação de C++ através de thread do <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (definir o atributo de Thread CLR)<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept> opção do linker.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">Um do <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valores.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O valor inicial é <bpt id="p1">&lt;xref uid="langword_csharp_Unknown" name="Unknown" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) or multithreaded apartment (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</source>
          <target state="translated">É efetuada uma tentativa de definir esta propriedade para um Estado que não é um estado apartment válido (estado diferente de apartamento de thread único (<bpt id="p1">&lt;xref uid="langword_csharp_STA" name="STA" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>) ou apartment multithread (<bpt id="p2">&lt;xref uid="langword_csharp_MTA" name="MTA" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>)).</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">Notifica um anfitrião que execução está prestes a introduzir uma região do código em que os efeitos de um thread abortar ou uma exceção não processada possam comprometer a outras tarefas no domínio de aplicação.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Anfitriões do language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer diferentes políticas para falhas em regiões críticas e não críticas do código.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Uma região crítica é um em que os efeitos de um aborto de threads ou uma exceção não processada não poderão ser limitados para a tarefa atual.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Por outro lado, um abort ou falha numa região não críticos de código afeta apenas a tarefa no qual ocorre o erro.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Por exemplo, considere uma tarefa que tenta alocar memória ao que contém um bloqueio.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Se falhar a alocação de memória, abortar a tarefa atual não é suficiente para garantir a estabilidade do &lt;xref:System.AppDomain&gt;, porque podem existir outras tarefas no domínio a aguardar que o mesmo bloqueio.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Se a tarefa atual foi terminada, outras tarefas podem ser estão bloqueadas.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Quando ocorre uma falha numa região crítico, o anfitrião poderá decidir ao descarregar a toda a &lt;xref:System.AppDomain&gt;em vez de aceitar o risco de continuar a execução num estado potencialmente instável.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call BeginCriticalRegion.</source>
          <target state="translated">Para informar o anfitrião que o código é introduzir uma região crítico, chame BeginCriticalRegion.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt; when execution returns to a non-critical region of code.</source>
          <target state="translated">Chamar &lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;Quando execução devolve para uma região não críticas do código.&lt;/xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Ao utilizar este método no código que é executada no SQL Server 2005 requer o código para ser executado ao nível de proteção do anfitrião mais elevado.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Notifica um anfitrião que código gerido está prestes a executar as instruções que dependem a identidade do sistema operativo físico thread atual.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Alguns anfitriões do tempo de execução de idioma comuns, tais como o Microsoft SQL Server 2005, fornecem as suas próprias gestão thread.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Um anfitrião que fornece a gestão do seu próprio thread pode mover uma tarefa em execução de um thread de sistema de operativo físico para outro em qualquer altura.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">A maioria das tarefas não são afetados por este mudar.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">No entanto, algumas tarefas têm afinidade de threads - ou seja, dependem a identidade de um thread de sistema de operativo físico.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Estas tarefas devem informar o anfitrião quando são executados código que não deve ser mudado.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call BeginThreadAffinity before acquiring the lock, and &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt; after releasing the lock.</source>
          <target state="translated">Por exemplo, se a sua aplicação chama uma API para adquirir um bloqueio de sistema operativo que tenha a afinidade de threads, como um CRITICAL_SECTION Win32, do sistema tem de chamar BeginThreadAffinity antes de adquirir o bloqueio e &lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;após a libertação do bloqueio.&lt;/xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Ao utilizar este método no código que é executada no SQL Server 2005 requer o código para ser executado ao nível de proteção do anfitrião mais elevado.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">Obtém o contexto atual no qual o thread está a executar.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current thread context.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> que representa o contexto do thread actual.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">Obtém ou define o idioma para o thread actual.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Globalization.CultureInfo&gt; object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">O &lt;xref:System.Globalization.CultureInfo&gt;objeto é devolvido por esta propriedade, juntamente com os objetos associados, determinar o formato predefinido para as datas, vezes, números, valores de moeda, a ordenação a ordem de texto, as maiúsculas e minúsculas convenções e comparações de cadeia.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo&gt; class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">Consulte o &lt;xref:System.Globalization.CultureInfo&gt;de classe para saber mais sobre os nomes de cultura e identificadores, as diferenças entre as culturas invariável, independentes e específicas, e as informações de cultura da forma como afeta threads e domínios de aplicação.&lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt; property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">Consulte o &lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;propriedade para saber como o idioma predefinido de um thread é determinado e como os utilizadores definir informações de cultura para os respetivos computadores.&lt;/xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, you can set the CurrentCulture property to a neutral culture.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, pode definir a propriedade CurrentCulture para um idioma neutro.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the behavior of the &lt;xref:System.Globalization.CultureInfo&gt; class has changed: When it represents a neutral culture, its property values (in particular, the &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, and &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt; properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">Isto acontece porque o comportamento do &lt;xref:System.Globalization.CultureInfo&gt;classe foi alterada: quando representa uma cultura neutra, os respetivos valores de propriedade (em particular, a &lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;, &lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;, &lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;, &lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;, e &lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;Propriedades) agora refletir o idioma específico que está associado ao idioma neutro.&lt;/xref:System.Globalization.CultureInfo.TextInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.NumberFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt; &lt;/xref:System.Globalization.CultureInfo.CompareInfo%2A&gt; &lt;/xref:System.Globalization.CultureInfo.Calendar%2A&gt; &lt;/xref:System.Globalization.CultureInfo&gt;</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>In earlier versions of the .NET Framework, the CurrentCulture property threw a &lt;xref:System.NotSupportedException&gt; exception when a neutral culture was assigned.</source>
          <target state="translated">Nas versões anteriores do .NET Framework, a propriedade CurrentCulture emitiu um &lt;xref:System.NotSupportedException&gt;exceção quando foi atribuída uma cultura neutra.&lt;/xref:System.NotSupportedException&gt;</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">Um objeto que representa o idioma para o thread actual.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A propriedade está definida como <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">Obtém ou define o principal atual do thread (para a segurança baseada em funções).</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Security.Principal.IPrincipal&gt; value representing the security context.</source>
          <target state="translated">Um &lt;xref:System.Security.Principal.IPrincipal&gt;representando o contexto de segurança.&lt;/xref:System.Security.Principal.IPrincipal&gt;</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">O chamador não tem a permissão necessária para definir o principal.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Gets the currently running thread.</source>
          <target state="translated">Obtém o thread actualmente em execução.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> that is the representation of the currently running thread.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> que é a representação do thread actualmente em execução.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">Obtém ou define a cultura atual utilizada pelo Gestor de recursos para consultar recursos do idioma específico no tempo de execução.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>An object that represents the current culture.</source>
          <target state="translated">Um objeto que representa a cultura atual.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The property is set to <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A propriedade está definida como <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">A propriedade está definida como um nome de cultura que não pode ser utilizado para localizar um ficheiro de recursos.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">Os nomes de ficheiro de recursos tem de incluir apenas letras, números, hífenes e carateres de sublinhado.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">Desativa a limpeza automática de tempo de execução possível chamar EndRead wrappers (RCW) para o thread actual.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">Por predefinição, o language runtime (CLR) limpa wrappers possível chamar EndRead do tempo de execução automaticamente.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:      -   The application does its own message pumping.</source>
          <target state="translated">O CLR bombas mensagens durante a limpeza, o que poderá causar problemas de reentrancy para algumas aplicações que cumprem os critérios de atividade invulgares seguintes:-a aplicação gerar sua própria mensagem.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">-A aplicação tem de controlar precisamente quando ocorre a gerar a mensagem.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such applications can use the DisableComObjectEagerCleanup method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">Essas aplicações podem utilizar o método DisableComObjectEagerCleanup para impedir o CLR de fazer a recuperação automática de wrappers possível chamar EndRead do tempo de execução.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">Quando este método foi chamado num thread, a limpeza automática não pode ser ativada novamente nesse thread.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application is ready to clean up runtime callable wrappers, use the &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt; method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">Quando a aplicação está pronta para limpar wrappers possível chamar EndRead do tempo de execução, utilize o &lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;método para instruir o tempo de execução para limpar todos os wrappers possível chamar EndRead de tempo de execução no contexto atual.&lt;/xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">Gerar mensagem ocorre durante o método executa.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">Notifica um anfitrião que execução está prestes a introduzir uma região do código em que os efeitos de um thread abortar ou uma exceção não processada estão limitados a tarefa atual.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Anfitriões do language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer diferentes políticas para falhas em regiões críticas e não críticas do código.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Uma região crítica é um em que os efeitos de um aborto de threads ou uma exceção não processada não poderão ser limitados para a tarefa atual.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Por outro lado, um abort ou falha numa região não críticos de código afeta apenas a tarefa no qual ocorre o erro.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Por exemplo, considere uma tarefa que tenta alocar memória ao que contém um bloqueio.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the &lt;xref:System.AppDomain&gt;, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Se falhar a alocação de memória, abortar a tarefa atual não é suficiente para garantir a estabilidade do &lt;xref:System.AppDomain&gt;, porque podem existir outras tarefas no domínio a aguardar que o mesmo bloqueio.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Se a tarefa atual foi terminada, outras tarefas podem ser estão bloqueadas.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire &lt;xref:System.AppDomain&gt; rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Quando ocorre uma falha numa região crítico, o anfitrião poderá decidir ao descarregar a toda a &lt;xref:System.AppDomain&gt;em vez de aceitar o risco de continuar a execução num estado potencialmente instável.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.</source>
          <target state="translated">Para informar o anfitrião que o código é introduzir uma região crítico, chame &lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;.&lt;/xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call EndCriticalRegion when execution returns to a non-critical region of code.</source>
          <target state="translated">Chame EndCriticalRegion quando execução regressar a uma região não críticas do código.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Ao utilizar este método no código que é executada no SQL Server 2005 requer o código para ser executado ao nível de proteção do anfitrião mais elevado.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Notifica um anfitrião que código gerido terminou a execução instruções que dependem a identidade do sistema operativo físico thread atual.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Alguns anfitriões do tempo de execução de idioma comuns, tais como o Microsoft SQL Server 2005, fornecem as suas próprias gestão thread.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Um anfitrião que fornece a gestão do seu próprio thread pode mover uma tarefa em execução de um thread de sistema de operativo físico para outro em qualquer altura.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">A maioria das tarefas não são afetados por este mudar.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">No entanto, algumas tarefas têm afinidade de threads - ou seja, dependem a identidade de um thread de sistema de operativo físico.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Estas tarefas devem informar o anfitrião quando são executados código que não deve ser mudado.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt; before acquiring the lock, and EndThreadAffinity after releasing the lock.</source>
          <target state="translated">Por exemplo, se bloquear as chamadas de aplicação de uma API de sistema para adquirir um sistema operativo que tenha a afinidade de threads, como um CRITICAL_SECTION Win32, tem de chamar &lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;antes de adquirir o bloqueio e EndThreadAffinity após a libertação do bloqueio.&lt;/xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Ao utilizar este método no código que é executada no SQL Server 2005 requer o código para ser executado ao nível de proteção do anfitrião mais elevado.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Gets an &lt;xref:System.Threading.ExecutionContext&gt; object that contains information about the various contexts of the current thread.</source>
          <target state="translated">Obtém um &lt;xref:System.Threading.ExecutionContext&gt;objeto que contém informações sobre os vários contextos de thread atual.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The &lt;xref:System.Threading.ExecutionContext&gt; class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">O &lt;xref:System.Threading.ExecutionContext&gt;classe fornece um único contentor para todas as informações relevantes para o thread lógico de execução.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">Isto inclui o contexto de segurança, contexto de chamada, contexto de sincronização, contexto de localização e o contexto de transação.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>An &lt;xref:System.Threading.ExecutionContext&gt; object that consolidates context information for the current thread.</source>
          <target state="translated">Um &lt;xref:System.Threading.ExecutionContext&gt;objeto que consolida as informações de contexto para o thread actual.&lt;/xref:System.Threading.ExecutionContext&gt;</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object.</source>
          <target state="translated">Garante que os recursos são libertados e outras operações de limpeza são efetuadas quando o recoletor de lixo da memória reclama o <bpt id="p1">&lt;xref href="System.Threading.Thread"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objeto.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector calls Finalize when the current object is ready to be finalized.</source>
          <target state="translated">As chamadas de recoletor de lixo Finalize quando o objeto atual está pronto para ser finalizada.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">Elimina a associação entre um nome e uma ranhura, para todos os threads no processo.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para um melhor desempenho, utilize os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e blocos de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a utilização de TLS, consulte <bpt id="p1">[</bpt>Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt; with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">Depois de qualquer thread chamadas <ph id="ph1">`FreeNamedDataSlot`</ph>, outro thread que chama &lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;com o mesmo nome irá alocar uma nova ranhura associada ao nome.&lt;/xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">As chamadas subsequentes para <ph id="ph1">`GetNamedDataSlot`</ph> por qualquer thread irá devolver a nova ranhura.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, any thread that still has a &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt; returned by an earlier call to <ph id="ph1">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">No entanto, qualquer thread que ainda tem um &lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;devolvido por uma chamada anterior para <ph id="ph1">`GetNamedDataSlot`</ph> pode continuar a utilizar o bloco de antigo.&lt;/xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">É lançada uma ranhura que foi associada com um nome de apenas quando cada <ph id="ph1">`LocalDataStoreSlot`</ph> que foi obtido antes da chamada para <ph id="ph2">`FreeNamedDataSlot`</ph> foi libertado e libertação da memória.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Ranhuras de dados são exclusivas por thread.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">O nome da ranhura de dados a ser libertado.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value indicating the apartment state.</source>
          <target state="translated">Devolve um <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valor que indica o estado de apartamento.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method, along with the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">Este método, juntamente com o &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;método e o &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;substitui o método, o &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the apartment state of the managed thread.</source>
          <target state="translated">Um do <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valores que indica o estado apartment do thread gerido.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The default is <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">A predefinição é <bpt id="p1">&lt;xref href="System.Threading.ApartmentState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">Devolve um <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objetos que podem ser utilizados para capturar a pilha de para o thread actual.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">Este método já não é suportado.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">Nenhum.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">Em todos os casos.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">Obtém o valor da ranhura especificada no thread atual, dentro do domínio atual do thread actual.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para um melhor desempenho, utilize os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e blocos de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a utilização de TLS, consulte <bpt id="p1">[</bpt>Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Ranhuras de dados são exclusivas por thread.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  GetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; GetData é um <ph id="ph2">`Shared`</ph> método sempre aplica-se a thread atualmente em execução, mesmo se chamá-la utilizando uma variável que se refira a outro thread.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">Para evitar confusões, utilize o nome de classe ao chamar <ph id="ph1">`Shared`</ph> métodos: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> from which to get the value.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> partir do qual pode obter o valor.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The retrieved value.</source>
          <target state="translated">O valor obtido.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">Devolve o domínio atual no qual está a executar o thread actual.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> representing the current application domain of the running thread.</source>
          <target state="translated">Um <bpt id="p1">&lt;xref href="System.AppDomain"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> que representa o domínio de aplicação atual do thread em execução.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">Devolve um identificador de domínio de aplicação único.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">Inteiro sinal de 32 bits identificar exclusivamente o domínio de aplicação.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">Devolve um código hash para o thread actual.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">O código hash não é garantido ser exclusivo.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt; property if you need a unique identifier for a managed thread.</source>
          <target state="translated">Utilize o &lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;propriedade se precisar de um identificador exclusivo de um thread gerido.&lt;/xref:System.Threading.Thread.ManagedThreadId%2A&gt;</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>An integer hash code value.</source>
          <target state="translated">Um valor de código de hash de número inteiro.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Looks up a named data slot.</source>
          <target state="translated">Procura um bloco de dados com nome.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para um melhor desempenho, utilize os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e blocos de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a utilização de TLS, consulte <bpt id="p1">[</bpt>Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Ranhuras de dados são exclusivas por thread.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">Se a ranhura com nome não existir, é atribuída a uma nova ranhura.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">Ranhuras de dados com nome são públicas e podem ser manipuladas a qualquer pessoa.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The name of the local data slot.</source>
          <target state="translated">O nome da ranhura de dados local.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> allocated for this thread.</source>
          <target state="translated">A <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> atribuído para este thread.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Interrupts a thread that is in the <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> thread state.</source>
          <target state="translated">Interrupções thread que está a ser o <bpt id="p1">&lt;xref uid="langword_csharp_WaitSleepJoin" name="WaitSleepJoin" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> estado do thread.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">Se este thread não está atualmente bloqueado num espera, modo de suspensão ou o estado de associação, irá ser interrompida quando começa junto a bloquear.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.ThreadInterruptedException&gt; is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated">&lt;xref:System.Threading.ThreadInterruptedException&gt;é emitida o thread interrompido, mas não até os blocos de thread.&lt;/xref:System.Threading.ThreadInterruptedException&gt;</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">Se o thread nunca bloqueia, a exceção é acionada nunca e, por conseguinte, o thread pode ser concluída sem alguma vez que está a ser interrompido.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O chamador não tem o adequado <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">Obtém um valor que indica o estado de execução do thread atual.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread has been started and has not terminated normally or aborted; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se este thread foi iniciado e não tiver normalmente terminada ou abortada; caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">Obtém ou define um valor que indica se é ou não um thread um thread de segundo plano.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">Um thread é o thread de segundo plano ou um thread de primeiro plano.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">Threads em segundo plano são idênticos aos threads de primeiro plano, à exceção de threads em segundo plano impede que um processo a terminar.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">Depois de todos os threads de primeiro plano que pertençam a um processo foi terminado, o tempo de execução de idioma comum termina o processo.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">Qualquer threads em segundo plano restantes são parados e não concluída.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground (that is, their IsBackground property returns <ph id="ph1">`false`</ph>):      -   The primary thread (or main application thread).</source>
          <target state="translated">Por predefinição, os threads seguintes executar em primeiro plano (ou seja, os respetivos devolve de propriedade IsBackground <ph id="ph1">`false`</ph>):-o thread principal (ou o thread de aplicação principal).</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads created by calling a &lt;xref:System.Threading.Thread&gt; class constructor.</source>
          <target state="translated">-Todos os threads criados chamando um &lt;xref:System.Threading.Thread&gt;Construtor de classe.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the background  (that is, their IsBackground property returns <ph id="ph1">`true`</ph>):      -   Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Por predefinição, os threads seguintes executar em segundo plano (ou seja, os respetivos devolve de propriedade IsBackground <ph id="ph1">`true`</ph>):-threads de agrupamento, que são um conjunto de threads de trabalho mantida pelo tempo de execução do Thread.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the &lt;xref:System.Threading.ThreadPool&gt; class.</source>
          <target state="translated">Pode configurar o trabalho de agrupamento e o agendamento de threads em threads de conjunto de threads, utilizando a &lt;xref:System.Threading.ThreadPool&gt;classe.&lt;/xref:System.Threading.ThreadPool&gt;</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph>     &gt;  Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Baseado em tarefas operações assíncronas executar automaticamente em threads de conjunto de threads.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>-   All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">-Todos os threads que introduzir o ambiente de execução gerido a partir do código não gerido.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread is or is to become a background thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se este thread ou está a tornar-se de um thread de segundo plano; caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The thread is dead.</source>
          <target state="translated">O thread está inactivo.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">Obtém um valor que indica se é ou não um thread pertence ao conjunto de threads gerido.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações consulte <bpt id="p1">[</bpt>agrupamento do Thread de gerido o<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if this thread belongs to the managed thread pool; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se este thread pertence ao conjunto de threads gerido; caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> pumping.</source>
          <target state="translated">Bloqueia o thread que efectua até que o thread representado por esta instância termina, ao continuar a executar COM padrão e <bpt id="p1">&lt;xref uid="langword_csharp_SendMessage" name="SendMessage" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> gerar.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose Join method is called has completed.</source>
          <target state="translated">A associação é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cuja associação método é denominado foi concluída.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">Utilize este método para se certificar de que o thread foi terminado.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">O chamador irá bloquear indefinidamente, caso o thread não terminar.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the Join method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block until <ph id="ph4">`Thread2`</ph> has completed.</source>
          <target state="translated">No exemplo seguinte, o <ph id="ph1">`Thread1`</ph> thread chama o método de associação de <ph id="ph2">`Thread2`</ph>, que faz com que <ph id="ph3">`Thread1`</ph> para bloco até <ph id="ph4">`Thread2`</ph> foi concluída.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept><ept id="p3">]</ept>       If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb)</ept> <ept id="p3">]</ept> se o thread já foi terminada quando &lt;xref:System.Threading.Thread.Join%2A&gt;é chamado o método devolve imediatamente.&lt;/xref:System.Threading.Thread.Join%2A&gt;  </target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!WARNING]</ph> &gt;  You should never call the Join method of the &lt;xref:System.Threading.Thread&gt; object that represents the current thread from the current thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!WARNING]</ph> &gt; Nunca deve chamar o método de associação do &lt;xref:System.Threading.Thread&gt;objeto que representa o thread actual do thread atual.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,       This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">Isto faz com que a aplicação fique suspensa porque o thread actual tem de aguardar após a próprio indefinidamente, alterações este método o estado do thread que efectua a incluir &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Não é possível invocar <ph id="ph1">`Join`</ph> num thread que está a ser o &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;Estado.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">O chamador tentou aderir a um thread que está a ser o <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> estado.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">O thread é interrompido ao aguardar a resposta.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Blocos de decorrido o thread que efectua até que o thread representado por esta instância termina ou o período de tempo especificado, ao continuar a executar COM padrão e SendMessage gerar.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">A associação é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread de qualquer um dos cujo &lt;xref:System.Threading.Thread.Join%2A&gt;método é denominado foi concluída ou o intervalo de tempo limite expirou.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">No exemplo seguinte, o <ph id="ph1">`Thread1`</ph> thread chamadas a &lt;xref:System.Threading.Thread.Join&gt;método de <ph id="ph2">`Thread2`</ph>, que faz com que <ph id="ph3">`Thread1`</ph> para bloquear o até <ph id="ph4">`Thread2`</ph> foi concluída ou 2 segundos decorridos.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for the <ph id="ph1">`millisecondsTimeout`</ph> parameter, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb)</ept> <ept id="p3">]</ept> se &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;especificado para o <ph id="ph1">`millisecondsTimeout`</ph> parâmetro, este método comporta-se de forma idêntica de &lt;xref:System.Threading.Thread.Join&gt;sobrecarga de método, exceto para o valor de retorno.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">Se o thread já foi terminada quando &lt;xref:System.Threading.Thread.Join%2A&gt;é chamado o método devolve imediatamente.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the calling thread to include &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.</source>
          <target state="translated">Este método altera o estado do thread que efectua a incluir &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Não é possível invocar <ph id="ph1">`Join`</ph> num thread que está a ser o &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;Estado.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">O número de milissegundos a aguardar para terminar o thread.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread has terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o thread foi terminada; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> se o thread não foi terminada após o período de tempo especificado pelo <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p3">&lt;/code&gt;</ept> parâmetro tiver decorrido.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds.</source>
          <target state="translated">O valor de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">millisecondsTimeout</ph> <ept id="p1">&lt;/code&gt;</ept> é negativo e não é igual ao <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> em milissegundos.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The thread has not been started.</source>
          <target state="translated">O thread não foi iniciado.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Blocos de decorrido o thread que efectua até que o thread representado por esta instância termina ou o período de tempo especificado, ao continuar a executar COM padrão e SendMessage gerar.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose &lt;xref:System.Threading.Thread.Join%2A&gt; method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated">A associação é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread de qualquer um dos cujo &lt;xref:System.Threading.Thread.Join%2A&gt;método é denominado foi concluída ou o intervalo de tempo limite expirou.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the &lt;xref:System.Threading.Thread.Join&gt; method of <ph id="ph2">`Thread2`</ph>, which causes <ph id="ph3">`Thread1`</ph> to block either until <ph id="ph4">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">No exemplo seguinte, o <ph id="ph1">`Thread1`</ph> thread chamadas a &lt;xref:System.Threading.Thread.Join&gt;método de <ph id="ph2">`Thread2`</ph>, que faz com que <ph id="ph3">`Thread1`</ph> para bloquear o até <ph id="ph4">`Thread2`</ph> foi concluída ou 2 segundos decorridos.&lt;/xref:System.Threading.Thread.Join&gt;</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept><ept id="p3">]</ept>       If &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; is specified for <ph id="ph1">`timeout`</ph>, this method behaves identically to the &lt;xref:System.Threading.Thread.Join&gt; method overload, except for the return value.</source>
          <target state="translated"><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)</ept><ept id="p1">]</ept><bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb)</ept> <ept id="p3">]</ept> se &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;especificado para <ph id="ph1">`timeout`</ph>, este método comporta-se de forma idêntica do &lt;xref:System.Threading.Thread.Join&gt;sobrecarga de método, exceto para o valor de retorno.&lt;/xref:System.Threading.Thread.Join&gt; &lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;  </target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when &lt;xref:System.Threading.Thread.Join%2A&gt; is called, the method returns immediately.</source>
          <target state="translated">Se o thread já foi terminada quando &lt;xref:System.Threading.Thread.Join%2A&gt;é chamado o método devolve imediatamente.&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the current thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Este método altera o estado do thread atual para incluir &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state.</source>
          <target state="translated">Não é possível invocar <ph id="ph1">`Join`</ph> num thread que está a ser o &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;Estado.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>A &lt;xref:System.TimeSpan&gt; set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated">A &lt;xref:System.TimeSpan&gt;definido como a quantidade de tempo ao aguardar por thread terminar.&lt;/xref:System.TimeSpan&gt;</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the thread terminated; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> if the thread has not terminated after the amount of time specified by the <bpt id="p3">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p3">&lt;/code&gt;</ept> parameter has elapsed.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o thread foi terminado; <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> se o thread não foi terminada após o período de tempo especificado pelo <bpt id="p3">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p3">&lt;/code&gt;</ept> parâmetro tiver decorrido.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">O valor de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> é negativo e não é igual ao <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> em milissegundos, ou é superior ao <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milissegundos.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> state.</source>
          <target state="translated">O chamador tentou aderir a um thread que está a ser o <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> estado.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">Obtém um identificador exclusivo para o thread actual gerido.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread's ManagedThreadId property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">O valor da propriedade ManagedThreadId um thread serve para identificar exclusivamente essa thread dentro do respetivo processo.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the ManagedThreadId property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">O valor da propriedade ManagedThreadId varia ao longo do tempo, mesmo que o thread como um fibra implementa o código não gerido que aloja o language runtime.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">Um número inteiro que representa um identificador exclusivo para este thread gerido.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</source>
          <target state="translated">Sincroniza o acesso à memória da seguinte forma: O processador de execução do thread atual não é possível reordenar as instruções em como executar de forma a que acede a memória antes da chamada para MemoryBarrier depois de acessos de memória que siga a chamada para MemoryBarrier.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>MemoryBarrier is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated">MemoryBarrier é necessário apenas em sistemas com multiprocessamento com memória fraca ordenar (por exemplo, um sistema empregar vários processadores Intel Itanium).</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the &lt;xref:System.Threading.Monitor&gt; class provide easier ways to synchronize data.</source>
          <target state="translated">Para fins, a maioria do c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração, ou o &lt;xref:System.Threading.Monitor&gt;classe fornecem formas mais fácil para sincronizar dados.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">Obtém ou define o nome do thread.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is write-once.</source>
          <target state="translated">Esta propriedade é escrita-uma vez.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the default value of a thread's Name property is <ph id="ph1">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Porque o valor predefinido da propriedade de nome de um thread é <ph id="ph1">`null`</ph>, pode determinar se um nome já foi explicitamente atribuído para o thread comparando-o com <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string assigned to the Name property can include any Unicode character.</source>
          <target state="translated">A cadeia atribuída à propriedade nome pode incluir qualquer caráter Unicode.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>A string containing the name of the thread, or <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if no name was set.</source>
          <target state="translated">Uma cadeia contendo o nome do thread, ou <bpt id="p1">&lt;xref uid="langword_csharp_null" name="null" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> não se foi definido nenhum nome.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>A set operation was requested, but the <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> property has already been set.</source>
          <target state="translated">Foi pedida uma operação de definição, mas o <bpt id="p1">&lt;xref uid="langword_csharp_Name" name="Name" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> propriedade já foi definida.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">Obtém ou define um valor que indica a prioridade de agendamento de um thread.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can be assigned any one of the following priority &lt;xref:System.Threading.ThreadPriority&gt; values:      -   <ph id="ph1">`Highest`</ph><ph id="ph2">      -   </ph><ph id="ph3">`AboveNormal`</ph><ph id="ph4">      -   </ph><ph id="ph5">`Normal`</ph><ph id="ph6">      -   </ph><ph id="ph7">`BelowNormal`</ph><ph id="ph8">      -   </ph><ph id="ph9">`Lowest`</ph>       Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">Um thread pode ser atribuído a qualquer um da seguinte prioridade &lt;xref:System.Threading.ThreadPriority&gt;valores:- <ph id="ph1">`Highest`</ph> <ph id="ph2">      -   </ph> <ph id="ph3">`AboveNormal`</ph> <ph id="ph4">      -   </ph> <ph id="ph5">`Normal`</ph> <ph id="ph6">      -   </ph> <ph id="ph7">`BelowNormal`</ph> <ph id="ph8">      -   </ph> <ph id="ph9">`Lowest`</ph> sistemas operativos não são necessários para honrar a prioridade de um thread.&lt;/xref:System.Threading.ThreadPriority&gt;</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values.</source>
          <target state="translated">Um do <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valores.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O valor predefinido é <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The thread has reached a final state, such as <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O thread atingiu um estado final, tais como <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is not a valid <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> value.</source>
          <target state="translated">O valor especificado para uma operação de definição não é um <bpt id="p1">&lt;xref href="System.Threading.ThreadPriority"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valor.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Cancels an &lt;xref:System.Threading.Thread.Abort*&gt; requested for the current thread.</source>
          <target state="translated">Cancela uma &lt;xref:System.Threading.Thread.Abort*&gt;pedida para o thread actual.&lt;/xref:System.Threading.Thread.Abort*&gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">Este método só pode ser chamado por código com as permissões adequadas.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a &lt;xref:System.Threading.ThreadAbortException&gt;.</source>
          <target state="translated">Quando é efetuada uma chamada para <ph id="ph1">`Abort`</ph> terminar um thread, o sistema emite &lt;xref:System.Threading.ThreadAbortException&gt;.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph>é uma exceção de especial que pode ser detetada pelo código da aplicação, mas é novamente iniciada no fim do bloco catch, a menos que <ph id="ph2">`ResetAbort`</ph> é chamado.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph>Cancela o pedido para abortar e impede o <ph id="ph2">`ThreadAbortException`</ph> de terminar o thread.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>See &lt;xref:System.Threading.ThreadAbortException&gt; for an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method.</source>
          <target state="translated">Consulte &lt;xref:System.Threading.ThreadAbortException&gt;para obter um exemplo que demonstra a chamar o <ph id="ph1">`ResetAbort`</ph> método.&lt;/xref:System.Threading.ThreadAbortException&gt;</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> was not invoked on the current thread.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_Abort" name="Abort" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Não foi invocada no thread atual.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">O chamador não tem a permissão de segurança necessárias para o thread actual.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">Retoma um thread que foi suspenso.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">O thread não foi iniciado, está inactivo ou não está no estado suspenso.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O chamador não tem o adequado <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Define o estado de apartamento de thread antes de que é iniciado.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">Novo threads são inicializados como &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;se respetivo estado de apartamento não foi definido antes de serem iniciadas.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Estado apartment tem de ser definido antes de um thread é iniciado.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; O thread de aplicação principal é inicializado &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;por predefinição.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">A única forma de definir o estado apartment do thread para aplicação principal &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;é para aplicar o &lt;xref:System.STAThreadAttribute&gt;atributo para o método de ponto de entrada.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">O método SetApartmentState, juntamente com o &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;método e o &lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;substitui o método, o &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.TrySetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">O estado apartment de novo.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>Não é um estado apartment válido.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">O thread já foi iniciado.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">O estado de apartamento já foram inicializado.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Applies a captured <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> to the current thread.</source>
          <target state="translated">Aplica-se um capturada <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> ao thread actual.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
          <target state="translated">Este método já não é suportado.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> object to be applied to the current thread.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.Threading.CompressedStack"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> objecto a aplicar ao thread actual.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
          <target state="translated">Em todos os casos.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">Define os dados na ranhura de especificado no thread em execução, para o domínio atual nesse thread.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>For better performance, use fields marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute instead.</source>
          <target state="translated">Para um melhor desempenho, utilize campos marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo em vez disso.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&gt; [!IMPORTANT]</ph> &gt;  The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute) and data slots.</source>
          <target state="translated"><ph id="ph1">&gt; [!IMPORTANT]</ph>&gt; O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o &lt;xref:System.ThreadStaticAttribute&gt;atributo) e blocos de dados.&lt;/xref:System.ThreadStaticAttribute&gt;</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a utilização de TLS, consulte <bpt id="p1">[</bpt>Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the &lt;xref:System.Threading.Thread&gt; object has been reclaimed by garbage collection.</source>
          <target state="translated">O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas após terminar o procedimento de thread e a &lt;xref:System.Threading.Thread&gt;objeto tem sido recuperado através da recolha de lixo.&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Ranhuras de dados são exclusivas por thread.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  SetData is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; SetData é um <ph id="ph2">`Shared`</ph> método sempre aplica-se a thread atualmente em execução, mesmo se chamá-la utilizando uma variável que se refira a outro thread.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">Para evitar confusões, utilize o nome de classe ao chamar <ph id="ph1">`Shared`</ph> métodos: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> in which to set the value.</source>
          <target state="translated">O <bpt id="p1">&lt;xref href="System.LocalDataStoreSlot"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> no qual pretende definir o valor.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The value to be set.</source>
          <target state="translated">O valor a ser definido.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">Suspende o thread atual para o número especificado de milissegundos.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">O thread não será agendado para execução pelo sistema operativo para a quantidade de tempo especificado.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Este método altera o estado do thread para incluir &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; for the <ph id="ph1">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Pode especificar &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;para o <ph id="ph1">`millisecondsTimeout`</ph> parâmetro para suspender o thread indefinidamente.&lt;/xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">No entanto, recomendamos que utilize outro &lt;xref:System.Threading?displayProperty=fullName&gt;classes, tal como &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, ou &lt;xref:System.Threading.Semaphore&gt;em vez disso, para sychronize threads ou gerir os recursos.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">Os batimentos serão relógio de sistema uma taxa específico chamado a resolução do relógio.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">O limite de tempo real pode não ser exatamente o tempo limite especificado, porque o tempo limite especificado será ajustado para a operação com batimentos de relógio.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">Para obter mais informações sobre resolução de relógio e o tempo de espera, consulte o <bpt id="p1">[</bpt>no modo de suspensão função<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> tópico.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">Este método chama o <bpt id="p1">[</bpt>no modo de suspensão função<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> do sistema Windows APIs.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Este método não efetua padrão COM e SendMessage gerar.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se precisa de suspensão num thread que tenha &lt;xref:System.STAThreadAttribute&gt;, mas que pretende efetuar padrão COM e SendMessage gerar, considere a utilização de uma das sobrecargas do &lt;xref:System.Threading.Thread.Join%2A&gt;método que especifica um intervalo de tempo limite.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">O número de milissegundos para o qual o thread está suspenso.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Se o valor da <ph id="ph1">`millisecondsTimeout`</ph> argumento for zero, o thread relinquishes o resto do respetivo intervalo de tempo para qualquer thread do igual prioridade que está pronta para ser executado.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Se existirem não existem outros threads igual prioridade que estão prontos para ser executada, a execução do thread atual não é suspenso.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The time-out value is negative and is not equal to &lt;xref:System.Threading.Timeout.Infinite&gt;.</source>
          <target state="translated">O valor de tempo limite é negativo e não é igual ao &lt;xref:System.Threading.Timeout.Infinite&gt;.&lt;/xref:System.Threading.Timeout.Infinite&gt;</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Suspende o thread atual para o período de tempo especificado.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">O thread não será agendado para execução pelo sistema operativo para a quantidade de tempo especificado.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include &lt;xref:System.Threading.ThreadState&gt;.</source>
          <target state="translated">Este método altera o estado do thread para incluir &lt;xref:System.Threading.ThreadState&gt;.&lt;/xref:System.Threading.ThreadState&gt;</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt; for the <ph id="ph1">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Pode especificar &lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;para o <ph id="ph1">`timeout`</ph> parâmetro para suspender o thread indefinidamente.&lt;/xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other &lt;xref:System.Threading?displayProperty=fullName&gt; classes such as &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, or &lt;xref:System.Threading.Semaphore&gt; instead to sychronize threads or manage resources.</source>
          <target state="translated">No entanto, recomendamos que utilize outro &lt;xref:System.Threading?displayProperty=fullName&gt;classes, tal como &lt;xref:System.Threading.Mutex&gt;, &lt;xref:System.Threading.Monitor&gt;, &lt;xref:System.Threading.EventWaitHandle&gt;, ou &lt;xref:System.Threading.Semaphore&gt;em vez disso, para sychronize threads ou gerir os recursos.&lt;/xref:System.Threading.Semaphore&gt; &lt;/xref:System.Threading.EventWaitHandle&gt; &lt;/xref:System.Threading.Monitor&gt; &lt;/xref:System.Threading.Mutex&gt; &lt;/xref:System.Threading?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload of &lt;xref:System.Threading.Thread.Sleep%2A&gt; uses the total number of whole milliseconds in <ph id="ph1">`timeout`</ph>.</source>
          <target state="translated">Esta sobrecarga de &lt;xref:System.Threading.Thread.Sleep%2A&gt;utiliza o número total de milissegundos inteiros no <ph id="ph1">`timeout`</ph>.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">Milissegundos fracional são eliminados.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Este método não efetua padrão COM e SendMessage gerar.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If you need to sleep on a thread that has &lt;xref:System.STAThreadAttribute&gt;, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the &lt;xref:System.Threading.Thread.Join%2A&gt; method that specifies a timeout interval.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se precisa de suspensão num thread que tenha &lt;xref:System.STAThreadAttribute&gt;, mas que pretende efetuar padrão COM e SendMessage gerar, considere a utilização de uma das sobrecargas do &lt;xref:System.Threading.Thread.Join%2A&gt;método que especifica um intervalo de tempo limite.&lt;/xref:System.Threading.Thread.Join%2A&gt; &lt;/xref:System.STAThreadAttribute&gt;</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">A quantidade de tempo para o qual o thread está suspenso.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>If the value of the <ph id="ph1">`millisecondsTimeout`</ph> argument is <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Se o valor da <ph id="ph1">`millisecondsTimeout`</ph> argumento é <ph id="ph2">&amp;lt;</ph>xref:System.TimeSpan?displayProperty=fullName<ph id="ph3">&amp;gt;</ph>, o thread relinquishes o resto do respetivo intervalo de tempo para qualquer thread do igual prioridade que está pronta para ser executado.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Se existirem não existem outros threads igual prioridade que estão prontos para ser executada, a execução do thread atual não é suspenso.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> in milliseconds, or is greater than <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milliseconds.</source>
          <target state="translated">O valor de <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">timeout</ph> <ept id="p1">&lt;/code&gt;</ept> é negativo e não é igual ao <ph id="ph2">&amp;lt;</ph>xref:System.Threading.Timeout.Infinite?displayProperty=fullName<ph id="ph3">&amp;gt;</ph> em milissegundos, ou é superior ao <ph id="ph4">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id="ph5">&amp;gt;</ph> milissegundos.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Causes a thread to wait the number of times defined by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">iterations</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
          <target state="translated">Faz com que um thread para aguardar o número de vezes definidos pelo <bpt id="p1">&lt;code&gt;</bpt> <ph id="ph1">iterations</ph> <ept id="p1">&lt;/code&gt;</ept> parâmetro.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SpinWait method is useful for implementing locks.</source>
          <target state="translated">O método SpinWait é útil para implementar as bloqueios.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes in the .NET Framework, such as &lt;xref:System.Threading.Monitor&gt; and &lt;xref:System.Threading.ReaderWriterLock&gt;, use this method internally.</source>
          <target state="translated">Classes no .NET Framework, tais como &lt;xref:System.Threading.Monitor&gt;e &lt;xref:System.Threading.ReaderWriterLock&gt;, utilize este método internamente.&lt;/xref:System.Threading.ReaderWriterLock&gt; &lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph1">`iterations`</ph> parameter.</source>
          <target state="translated">SpinWait coloca essencialmente o processador no ciclo muito sólido, com a contagem de ciclo especificada pelo <ph id="ph1">`iterations`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">Durante a espera depende, por conseguinte, a velocidade do processador.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contrast this with the &lt;xref:System.Threading.Thread.Sleep%2A&gt; method.</source>
          <target state="translated">Contraste isto com o &lt;xref:System.Threading.Thread.Sleep%2A&gt;método.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that calls &lt;xref:System.Threading.Thread.Sleep%2A&gt; yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">Um thread que chama &lt;xref:System.Threading.Thread.Sleep%2A&gt;gera o resto do respetivo setor atual de tempo do processador, mesmo que o intervalo especificado é zero.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying a non-zero interval for &lt;xref:System.Threading.Thread.Sleep%2A&gt; removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">Especificar um intervalo de diferente de zero para &lt;xref:System.Threading.Thread.Sleep%2A&gt;Remove o thread de consideração pelo programador thread até que o intervalo de tempo decorrido.&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>SpinWait is not generally useful for ordinary applications.</source>
          <target state="translated">SpinWait não é, geralmente, útil para aplicações comum.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; or a statement that wraps &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; (<ph id="ph1">`lock`</ph> in C# or <ph id="ph2">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">Na maioria dos casos, deve utilizar as classes de sincronização fornecidas pelo .NET Framework; Por exemplo, chamada &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;ou uma instrução que encapsula num wrapper &lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;(<ph id="ph1">`lock`</ph> em c# ou <ph id="ph2">`SyncLock`</ph> no Visual Basic).&lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt; &lt;/xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the SpinWait method in your loop.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; No caso de raro, onde é vantajoso para evitar um comutador de contexto, por exemplo, quando sabe que uma alteração de estado é imminent, efetuar uma chamada ao método SpinWait no seu ciclo.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code SpinWait executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">O código que spinwait executa foi concebido para impedir que os problemas que podem ocorrer em computadores com vários processadores.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, SpinWait prevents processor starvation in certain situations.</source>
          <target state="translated">Por exemplo, em computadores com vários processadores Intel a utilização de tecnologia Hyper-Threading, SpinWait impede a carência de processador em determinadas situações.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">Um 32-bit número inteiro com sinal que define quanto tempo um thread é de esperar.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">Faz com que o sistema operativo alterar o estado da instância atual <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">Depois de um thread é no &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;Estado, o sistema operativo pode agendá-la para execução.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">O thread começa a executar na primeira linha do método representado pelo &lt;xref:System.Threading.ThreadStart&gt;ou &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegado fornecido para o construtor de thread.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">Tenha em atenção que a chamada de início não bloqueia o thread de chamada.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  If this overload is used with a thread created using a &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Se esta sobrecarga é utilizada com um thread criado utilizando uma &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegar, <ph id="ph2">`null`</ph> é transmitido ao método executado pelo thread.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Assim que o thread termina, não podendo ser reiniciada com outra chamada <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">O thread já foi iniciado.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Não há memória disponível suficiente para iniciar este thread.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">Faz com que o sistema operativo alterar o estado da instância atual <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>e, opcionalmente, forneça um objeto que contém os dados a ser utilizado pelo método executa o thread.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt; state, the operating system can schedule it for execution.</source>
          <target state="translated">Depois de um thread é no &lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;Estado, o sistema operativo pode agendá-la para execução.&lt;/xref:System.Threading.ThreadState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the &lt;xref:System.Threading.ThreadStart&gt; or &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate supplied to the thread constructor.</source>
          <target state="translated">O thread começa a executar na primeira linha do método representado pelo &lt;xref:System.Threading.ThreadStart&gt;ou &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegado fornecido para o construtor de thread.&lt;/xref:System.Threading.ParameterizedThreadStart&gt; &lt;/xref:System.Threading.ThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to Start does not block the calling thread.</source>
          <target state="translated">Tenha em atenção que a chamada de início não bloqueia o thread de chamada.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Assim que o thread termina, não podendo ser reiniciada com outra chamada <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload and the &lt;xref:System.Threading.ParameterizedThreadStart&gt; delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">Esta sobrecarga e a &lt;xref:System.Threading.ParameterizedThreadStart&gt;delegado torna mais fácil transmitir dados para um procedimento de thread, mas a técnica não é seguro porque qualquer objeto possam ser transmitido para esta sobrecarga de.&lt;/xref:System.Threading.ParameterizedThreadStart&gt;</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">Uma forma mais robusta para transmitir dados para um procedimento de thread é colocar o procedimento de thread e os campos de dados para um objeto de trabalho.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>criar Threads e transmissão de dados na hora de início<ept id="p1">](~/add/includes/ajax-current-ext-md.md)</ept>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">Um objeto que contém dados para ser utilizado pelo método o thread de execução.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">O thread já foi iniciado.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">Não há memória disponível suficiente para iniciar este thread.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>This thread was created using a <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> delegate instead of a <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept> delegate.</source>
          <target state="translated">Este thread foi criado utilizando uma <bpt id="p1">&lt;xref href="System.Threading.ThreadStart"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> delegar em vez de um <bpt id="p2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept> delegar.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">Suspende o thread, ou se o thread já está suspenso, não tem qualquer efeito.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">Se o thread já está suspenso, este método não tem efeito.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!CAUTION]</ph> &gt;  Do not use the Suspend and &lt;xref:System.Threading.Thread.Resume%2A&gt; methods to synchronize the activities of threads.</source>
          <target state="translated">&gt; <ph id="ph1">[!CAUTION]</ph> &gt; Não utilize a suspender e &lt;xref:System.Threading.Thread.Resume%2A&gt;métodos para sincronizar as atividades de threads.&lt;/xref:System.Threading.Thread.Resume%2A&gt;</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">Não tem nenhuma forma de saber o código de um thread está a executar quando suspende-lo.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the &lt;xref:System.AppDomain&gt; might be blocked.</source>
          <target state="translated">Se suspender um thread enquanto realiza bloqueios durante uma avaliação de permissão de segurança, outros threads no &lt;xref:System.AppDomain&gt;poderá ser bloqueado.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the &lt;xref:System.AppDomain&gt; that attempt to use that class are blocked.</source>
          <target state="translated">Se suspender um thread enquanto está a executar um construtor de classe, outros threads no &lt;xref:System.AppDomain&gt;que tentam utilizar que classe estão bloqueadas.&lt;/xref:System.AppDomain&gt;</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Impasses podem ocorrer muito facilmente.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">O thread não foi iniciado ou está inactivo.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O chamador não tem o adequado <bpt id="p1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Mapeia um conjunto de nomes para um conjunto de identificadores de emissão correspondente.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consulte a biblioteca da MSDN.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para utilização futura.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Tem de ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">No passado a matriz de nomes deve ser mapeado.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Contagem dos nomes a ser mapeado.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">O contexto de região na qual a interpretar os nomes.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz alocado de autor da chamada que recebe os IDs correspondentes aos nomes.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Acesso de vinculação tardia utilizando o COM <ph id="ph1">`IDispatch`</ph> interface não é suportada.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Obtém as informações de tipo para um objeto, que, em seguida, pode ser utilizado para obter as informações de tipo para uma interface.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consulte a biblioteca da MSDN.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
          <target state="translated">As informações de tipo de retorno.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
          <target state="translated">O identificador de região para obter as informações de tipo.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recebe um ponteiro para o objeto de informações do tipo pedido.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Acesso de vinculação tardia utilizando o COM <ph id="ph1">`IDispatch`</ph> interface não é suportada.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Obtém o número de interfaces de informações de tipo que um objeto fornece (0 ou 1).</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consulte a biblioteca da MSDN.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Aponta para uma localização que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Acesso de vinculação tardia utilizando o COM <ph id="ph1">`IDispatch`</ph> interface não é suportada.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornece acesso às propriedades e métodos expostos por um objeto.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::Invoke`</ph>, consulte a biblioteca da MSDN.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
          <target state="translated">Identifica o membro.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para utilização futura.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
          <target state="translated">Tem de ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">O contexto de região na qual interpretar argumentos.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Sinalizadores que descrevem o contexto da chamada.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Apontador para uma estrutura que contém uma matriz de argumentos, uma matriz de argumento DISPID para os argumentos com nome e contagens para o número de elementos nas matrizes.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Apontador para a localização onde o resultado é que sejam armazenadas.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Apontador para uma estrutura que contém informações de exceção.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">O índice do primeiro argumento tem um erro.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <ph id="ph1">`IDispatch`</ph> interface is not supported.</source>
          <target state="translated">Acesso de vinculação tardia utilizando o COM <ph id="ph1">`IDispatch`</ph> interface não é suportada.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">Obtém um valor que contém os Estados do thread atual.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ThreadState property provides more specific information than the &lt;xref:System.Threading.Thread.IsAlive%2A&gt; property.</source>
          <target state="translated">A propriedade ThreadState fornece informações mais específicas que o &lt;xref:System.Threading.Thread.IsAlive%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.IsAlive%2A&gt;</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt;  Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">&gt; <ph id="ph1">[!IMPORTANT]</ph> &gt; Estado thread é apenas de interesse em cenários de depuração.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">O código nunca deve utilizar o estado de thread para sincronizar as atividades de threads.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>One of the <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> values indicating the state of the current thread.</source>
          <target state="translated">Um do <bpt id="p1">&lt;xref href="System.Threading.ThreadState"&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept> valores que indica o estado do thread atual.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The initial value is <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>.</source>
          <target state="translated">O valor inicial é <bpt id="p1">&lt;xref uid="langword_csharp_Unstarted" name="Unstarted" href=""&gt;</bpt> <ept id="p1">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Define o estado de apartamento de thread antes de que é iniciado.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; if their apartment state has not been set before they are started.</source>
          <target state="translated">Novo threads são inicializados como &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;se respetivo estado de apartamento não foi definido antes de serem iniciadas.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Estado apartment tem de ser definido antes de um thread é iniciado.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  The main application thread is initialized to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; by default.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; O thread de aplicação principal é inicializado &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;por predefinição.&lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt; is to apply the &lt;xref:System.STAThreadAttribute&gt; attribute to the entry point method.</source>
          <target state="translated">A única forma de definir o estado apartment do thread para aplicação principal &lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;é para aplicar o &lt;xref:System.STAThreadAttribute&gt;atributo para o método de ponto de entrada.&lt;/xref:System.STAThreadAttribute&gt; &lt;/xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The TrySetApartmentState method, along with the &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt; method and the &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt; method, replaces the &lt;xref:System.Threading.Thread.ApartmentState%2A&gt; property.</source>
          <target state="translated">O método TrySetApartmentState, juntamente com o &lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;método e o &lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;substitui o método, o &lt;xref:System.Threading.Thread.ApartmentState%2A&gt;propriedade.&lt;/xref:System.Threading.Thread.ApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.SetApartmentState%2A&gt; &lt;/xref:System.Threading.Thread.GetApartmentState%2A&gt;</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
          <target state="translated">O estado apartment de novo.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the apartment state is set; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se estiver definido o estado de apartamento; caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph>Não é um estado apartment válido.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
          <target state="translated">O thread já foi iniciado.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">VolatileRead e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileRead obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, VolatileRead obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, VolatileRead and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, VolatileRead e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar VolatileRead ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses VolatileRead or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza VolatileRead ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
          <target state="translated">Lê o valor de um campo.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
          <target state="translated">O campo de leitura.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">O valor mais recente escrito para o campo por qualquer processador.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e VolatileWrite para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, VolatileWrite ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, VolatileWrite garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and VolatileWrite ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e VolatileWrite Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or VolatileWrite.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou VolatileWrite.&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source>&lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; are for special cases of synchronization.</source>
          <target state="translated">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;são para casos especiais de sincronização.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;&lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the &lt;xref:System.Threading.Monitor&gt; class provide easier alternatives.</source>
          <target state="translated">Em circunstâncias normais, o c# <ph id="ph1">`lock`</ph> instrução, o Visual Basic <ph id="ph2">`SyncLock`</ph> declaração e o &lt;xref:System.Threading.Monitor&gt;classe fornecer alternativas mais fácil.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Num sistema com multiprocessamento, &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt;</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Isto pode requerer a Limpar caches do processador.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; and &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt; ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Mesmo num sistema uniprocessor, &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;e &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Chamar este método afeta apenas um único acesso à memória do.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source>&gt; <ph id="ph1">[!NOTE]</ph> &gt;  In C#, using the <ph id="ph2">`volatile`</ph> modifier on a field guarantees that all access to that field uses &lt;xref:System.Threading.Thread.VolatileRead%2A&gt; or &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.</source>
          <target state="translated">&gt; <ph id="ph1">[!NOTE]</ph> &gt; Em c#, utilizando o <ph id="ph2">`volatile`</ph> modificador num campo garante que todos os acessos a esse campo utiliza &lt;xref:System.Threading.Thread.VolatileRead%2A&gt;ou &lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;.&lt;/xref:System.Threading.Thread.VolatileWrite%2A&gt; &lt;/xref:System.Threading.Thread.VolatileRead%2A&gt;</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
          <target state="translated">O campo ao qual o valor está a ser escrito.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
          <target state="translated">O valor a ser escrito.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">Faz com que o thread de chamada produzir a execução de outro thread que está pronto para executar o processador atual.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">O sistema operativo seleciona o thread para produzir para.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">Se este método é concluída com êxito, é geraram o resto do setor de hora actual do thread.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">O sistema operativo agenda o thread de chamada de outro intervalo de tempo, em conformidade com a sua prioridade e o estado de outros threads que estão disponíveis para executar.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">Gerar resultados está limitada para o processador que está a executar o thread de chamada.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">O sistema operativo não muda execução a outro processador, mesmo que esse processador está inativo ou está a executar um thread de menor prioridade.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se não existem não existem outros threads que estão prontos para executar o processador atual, o sistema operativo não produzir execução e este método devolve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">Este método é equivalente ao utilizar plataforma invocar para chamar a Win32 nativo <ph id="ph1">`SwitchToThread`</ph> função.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should call the Yield method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">Deve chamar Yield de invocação do método em vez de utilizar a plataforma, porque a plataforma invocar omissões qualquer comportamento thread personalizado, que o anfitrião está a ser pedido.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept> if the operating system switched execution to another thread; otherwise, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt><ept id="p2">&lt;/xref&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;xref uid="langword_csharp_true" name="true" href=""&gt;</bpt><ept id="p1">&lt;/xref&gt;</ept>Se o sistema operativo execução de mudar para outro thread; caso contrário, <bpt id="p2">&lt;xref uid="langword_csharp_false" name="false" href=""&gt;</bpt> <ept id="p2">&lt;/xref&gt;</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>